[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "PubMed 마이너(pubmed-miner) 프로젝트\n\n\n\nPortfolio\n\nBioinformatics\n\n\n\n\n2025-10-02\n\n\n\n\n\n\n\n\n\n\n\n한국어 프로그래밍 폰트 만들기\n\n\n\nPortfolio\n\nfonts\n\n\n\n\n2025-08-12\n\n\n\n\n\n\n\n\n\n\n\nCertification wallpaper\n\n\n\nPortfolio\n\nCertificate\n\n\n\n\n2025-05-31\n\n\n\n\n\n\n\n\n\n\n\nProject kimchi-gold\n\n\n\nPortfolio\n\nInvestment\n\n\n\n\n2025-05-12\n\n\n\n\n\n\n\n\n\n\n\nBefore 2015\n\n\n\nPortfolio\n\n\n\n\n2025-03-04\n\n\n\n\n\n\n\n\n\n\n\nProject Idea\n\n\n\nPortfolio\n\n\n\n\n2023-10-07\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\n\n생명정보학 알고리즘\n\n\n\nNews\n\nBook\n\n\n\n\n2023-10-07\n\n\n\n\n\n\n\n\n\n\n\n파이썬을 활용한 생명정보학 2/e\n\n\n\nNews\n\nBook\n\n\n\n\n2023-10-07\n\n\n\n\n\n\n\n\n\n\n\n생명과학을 위한 딥러닝\n\n\n\nNews\n\nBook\n\n\n\n\n2023-10-07\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "portfolio/certificates.html",
    "href": "portfolio/certificates.html",
    "title": "Certification wallpaper",
    "section": "",
    "text": "여러 곳에서 주워온 수강증을 모아둔 페이지입니다. 그냥 재미삼아서 수강하고 있는 것들이 많습니다."
  },
  {
    "objectID": "portfolio/certificates.html#네이버-부스트코스",
    "href": "portfolio/certificates.html#네이버-부스트코스",
    "title": "Certification wallpaper",
    "section": "네이버 부스트코스",
    "text": "네이버 부스트코스"
  },
  {
    "objectID": "portfolio/certificates.html#허깅페이스",
    "href": "portfolio/certificates.html#허깅페이스",
    "title": "Certification wallpaper",
    "section": "허깅페이스",
    "text": "허깅페이스"
  },
  {
    "objectID": "portfolio/certificates.html#laidd",
    "href": "portfolio/certificates.html#laidd",
    "title": "Certification wallpaper",
    "section": "LAIDD",
    "text": "LAIDD"
  },
  {
    "objectID": "portfolio/certificates.html#codeacademy",
    "href": "portfolio/certificates.html#codeacademy",
    "title": "Certification wallpaper",
    "section": "CodeAcademy",
    "text": "CodeAcademy"
  },
  {
    "objectID": "portfolio/certificates.html#kaggle",
    "href": "portfolio/certificates.html#kaggle",
    "title": "Certification wallpaper",
    "section": "Kaggle",
    "text": "Kaggle"
  },
  {
    "objectID": "portfolio/before_2015.html",
    "href": "portfolio/before_2015.html",
    "title": "Before 2015",
    "section": "",
    "text": "2015년 이전의 작업물"
  },
  {
    "objectID": "portfolio/pubmed_miner.html",
    "href": "portfolio/pubmed_miner.html",
    "title": "PubMed 마이너(pubmed-miner) 프로젝트",
    "section": "",
    "text": "pubmed-miner는 PubMed에 등재된 논문들을 분석하기 위해 개발한 파이썬 기반의 사이드 프로젝트입니다. 곧바로 활용될 수 있습니다."
  },
  {
    "objectID": "portfolio/pubmed_miner.html#프로젝트의-활용법",
    "href": "portfolio/pubmed_miner.html#프로젝트의-활용법",
    "title": "PubMed 마이너(pubmed-miner) 프로젝트",
    "section": "프로젝트의 활용법",
    "text": "프로젝트의 활용법\npubmed-miner 프로젝트는 다음과 같은 상황에서 유용하게 활용될 수 있습니다.\n\n특정 주제 연구 동향 파악: 특정 질병이나 유전자에 대한 최신 연구 동향을 빠르게 파악하고 싶을 때, 관련 논문들에서 언급된 주요 생물학적 개체들을 한눈에 확인할 수 있습니다.\n대규모 문헌 스크리닝: 수백, 수천 편의 논문을 사람이 직접 읽지 않고도, 기계적인 방법을 통해 원하는 정보(예: 특정 단백질과 관련된 질병)를 빠르게 스크리닝할 수 있습니다."
  },
  {
    "objectID": "books/Deeplearning_Biology.html",
    "href": "books/Deeplearning_Biology.html",
    "title": "생명과학을 위한 딥러닝",
    "section": "",
    "text": "생물학, 유전체학, 신약 개발에 적용하는 실무 딥러닝\n\n분자 데이터에 머신러닝을 적용하는 방법\n딥러닝으로 유전학/유전체학 분석하기\n딥러닝으로 생물물리학 시스템 이해\nDeepChem 라이브러리 소개\n딥러닝을 사용한 현미경 이미지 분석\n딥러닝을 사용한 의료 이미지 분석\nVAE와 GAN 모델\n머신러닝 모델의 작동 원리 해석\n\n\n1 목차\n\n1장. 왜 생명과학인가?\n\n딥러닝은 왜 필요한가?\n현대 생명과학은 빅데이터를 다룬다\n무엇을 배우는가?\n\n2장. 딥러닝 소개\n\n선형 모델\n다층 퍼셉트론\n모델 학습하기\n검증하기\n정규화\n하이퍼파라미터 최적화\n다른 유형의 모델들\n\n합성곱 신경망\n순환 신경망\n\n\n3장. DeepChem을 이용한 머신러닝\n\nDeepChem의 기본 데이터셋\n독성 분자 예측 모델 만들기\nMNIST 데이터셋으로 필기 인식 모델 만들기\n\nMNIST 필기 인식 데이터셋\n합성곱 신경망으로 필기 인식하기\n\n소프트맥스와 소프트맥스 교차 엔트로피\n\n4장. 분자 수준 데이터 다루기\n\n분자란 무엇인가?\n\n분자 간 결합\n분자 그래프\n분자 구조\n분자 카이랄성\n\n분자 데이터 피처화\n\nSMILES 문자열과 RDKit\n확장 연결 지문\n분자 표현자\n\n그래프 합성곱\n용해도 예측 모델\nMoleculeNet\nSMARTS 문자열\n\n5장. 생물물리학과 머신러닝\n\n단백질의 구조\n\n단백질 서열\n\n단백질 3차원 구조를 예측할 수 있을까?\n\n단백질-리간드 결합\n\n생물물리학적 피처화\n\n그리드 피처화\n원자 피처화\n\n생물물리학 데이터 사례 연구\n\nPDBBind 데이터셋\nPDBBind 데이터셋 피처화\n\n\n6장. 유전학과 딥러닝\n\nDNA, RNA, 단백질\n실제 세포 내에서 일어나는 일\n전사인자의 결합\n\n전사인자의 결합을 예측하는 합성곱 모델\n\n염색질 접근성\nRNA 간섭\n\n7장. 현미경을 위한 딥러닝\n\n현미경에 대한 간략한 소개\n\n현대의 광학현미경\n\n회절 한계\n\n전자현미경과 원자현미경\n초고해상도 현미경\n딥러닝과 회절 한계\n\n현미경을 위한 시료 준비\n\n시료 염색하기\n시료 고정\n\n시료 절편 가공\n\n형광현미경\n시료 준비 과정의 영향\n\n딥러닝 활용법\n\n세포수 측정\n\n세포주란 무엇인가?\n\n세포 구별하기\n머신러닝과 실험\n\n\n8장. 의료 체계를 위한 딥러닝\n\n컴퓨터 지원 질병 진단\n베이즈 네트워크를 이용한 불확실성 예측\n전자 건강 기록\nICD-10 코드\n비지도 학습이란 무엇인가?\n\n거대 전자 건강 기록 데이터베이스의 위험성\n\n방사선학을 위한 딥러닝\n\nX선 촬영과 CT 촬영\n조직학\nMRI 촬영\n\n치료법으로서의 머신러닝\n당뇨망막병증\n\n9장. 생성 모델\n\nVAE\nGAN\n생명과학에 생성 모델 응용하기\n\n신약 후보 물질 찾기\n단백질 엔지니어링\n과학적 발견을 위한 도구\n\n생성 모델의 미래\n생성 모델 사용하기\n\n생성 모델 결과 분석\n\n\n10장. 딥러닝 모델의 해석\n\n예측값 설명하기\n입력값 최적화하기\n불확실성 예측하기\n해석 가능성, 설명 가능성, 실제 결과\n\n11장. 가상 선별검사\n\n예측 모델을 위한 데이터셋 준비\n머신러닝 모델 학습하기\n예측을 위한 데이터셋 준비하기\n예측 모델 적용하기\n\n12장. 딥러닝의 미래와 전망\n\n질병 진단\n맞춤 의학\n신약 개발\n생물학 연구\n\n\n\n\n2 구입처\n\n알라딘\nYES24\n교보문고\n인터파크\n반디앤루니스"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 짧은 소개\n안녕하세요. 이 블로그는 제가 생물학자이자 개발자로서 흥미롭고 유용하다고 생각되는 내용들을 공유하는 공간입니다. 저는 과학자의 삶이 흥미진진한 모험으로 가득해야 한다고 믿습니다. 그래서 이 블로그의 내용이 때로는 다소 산만해 보일 수 있지만, 사실 나름의 고민과 정리를 거친 결과물입니다.\n앙리 푸앵카레의 말처럼 “과학자는 연구의 유용성 때문이 아니라, 그 과정에서 느끼는 희열 때문에 연구합니다.” 이 말은 제 연구 철학과도 일맥상통합니다.\n사실 이 블로그를 시작하기까지 많은 고민이 있었습니다. 완벽주의 성향 때문에 글쓰기를 미뤄왔고, 제 글이 기대에 미치지 못할까 두려워했죠. 하지만 글쓰기 실력을 향상시키고 제 생각을 정리하는 좋은 기회라 생각해 이 블로그를 시작하게 되었습니다. 거창한 목표나 엄격한 계획 없이 그저 제가 알고 있고 관심 있는 분야에 대해 자유롭게 글을 쓰려고 합니다. 때로는 열심히 때로는 여유롭게 과학과 기술에 대한 제 생각과 경험을 나누고자 합니다. 부족한 점이 많겠지만 이 과정을 통해 조금씩 성장해 나가길 기대합니다.\n\n\n2 작업 환경\n제 작업 환경에 대해서 간략히 적어볼게요.\n\n\n코딩할 때는 Visual studio code 를 쓰고 파이펫팅 할 때는 Eppendorf 파이펫을 씁니다. 독일제 명품이거든요.\n주로 쓰는 프로그래밍 언어는 Python과 R이고 지금은 Rust 공부하고 있습니다.\n이 블로그는 Github 에서 무료 호스팅되고 Static site generator 인 Quarto 를 사용했습니다.\n\n\n\n\n3 내 블로그의 역사\n오래전부터 존재감 없는 블로그를 만들어왔습니다. 제가 기억하는 선에서 한번 나열하면 아래와 같죠.\n\n\nhttp://netsphere.codex.kr/ : 호스팅 업체가 망해버렸습니다.\nhttp://partrita.posterous.com/ : 서비스가 종료되었습니다.\nhttps://partrita.blogspot.kr/ : 구글검색어 노출에 유리했지만, 제약이 많아서 워드프레스로 이사\nhttps://partrita.wordpress.com/ : 처음에는 설치형을 사용하다. 무료호스팅을 제공하는 wordpress으로 이사했었습니다.\nhttps://partrita.github.io/ : 워드프레스는 너무 올드한 것 같아서 최신 유행인 깃헙으로 이전했습니다.\n\n\n\n\n4 저작권에 대해\n게시되는 글들은 대부분 제 개인적인 연구나 독창적인 내용보다는 다양한 출처(주로 인터넷)에서 얻은 정보를 제 나름대로 정리하고 해석한 것입니다. 이 과정에서 때로는 저작권이 있는 자료가 포함될 수 있음을 인지하고 있습니다. 만약 제 글에서 저작권 침해 사항을 발견하셨다면 partrita@gmail.com으로 연락 주시기 바랍니다. 관련 내용을 신속히 확인하고 필요한 조치를 취하겠습니다. 이 블로그는 지식 공유와 학습을 목적으로 운영되며 모든 분들의 지적 재산권을 존중합니다. 여러분의 이해에 감사드립니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html",
    "href": "posts/qmd/guide_seurat.html",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "",
    "text": "Seurat 은 scRNA-seq 분석에서 가장 널리 사용되는 R 패키지로, 다양한 기능을 통해 데이터를 처리하고 시각화합니다. 이 문서는 주요 명령어와 기능을 요약하여 사용자가 데이터를 효율적으로 다룰 수 있도록 지원합니다. 특히, 데이터 로드, 전처리, 클러스터링 및 시각화와 같은 일반적인 작업에 대한 예제를 제공합니다. Seurat v5.0.1 버전을 사용한 환경에서 테스트되었습니다. 다양한 명령어와 튜토리얼은 공식 페이지 에서 확인하세요."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#메타데이터에-새로운-열-추가",
    "href": "posts/qmd/guide_seurat.html#메타데이터에-새로운-열-추가",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "2.1 메타데이터에 새로운 열 추가",
    "text": "2.1 메타데이터에 새로운 열 추가\n새로운 열을 추가하려면 $ 기호를 사용하여 벡터를 메타데이터 열에 할당할 수 있습니다.\nSeuratObject$NEW_COLUMN_NAME &lt;- setNames(\n    colnames(SeuratObject),\n    vector_NEW_DATA\n)\n또는 AddMetaData 함수를 사용하여 열을 추가할 수 있습니다.\nSeuratObject &lt;- AddMetaData(\n    object   = SeuratObject,\n    metadata = vector_NEW_DATA,\n    col.name = \"NEW_COLUMN_NAME\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#seurat-객체-하위-집합-만들기",
    "href": "posts/qmd/guide_seurat.html#seurat-객체-하위-집합-만들기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "2.2 Seurat 객체 하위 집합 만들기",
    "text": "2.2 Seurat 객체 하위 집합 만들기\n일부 데이터를 따로 때어내는 방법은 R 의 데이터프레임 문법을 사용하는 방법과 Seurat 함수를 사용하는 방법이 있습니다. 먼저 데이터 프레임 문법은 아래와 같습니다.\n# Feature 하위 집합\nSeuratObject[vector_FEATURES_TO_USE, ]\n# 세포 하위 집합\nSeuratObject[, vector_CELLS_TO_USE]\nSeurat 에서 제공하는 함수는 아래와 같습니다.\n# Identity 클래스를 기반으로 Seurat 객체를 하위 집합으로 추출합니다. 자세한 내용은 ?SubsetData를 참조하세요.\nsubset(x = SeuratObject, idents = \"Bcell\")\nsubset(x = SeuratObject, idents = c(\"CD4T\", \"CD8T\"), invert = TRUE)\n\n# 유전자/특성의 발현 수준을 기준으로 하위 집합을 만듭니다.\nsubset(x = SeuratObject, subset = MS4A1 &gt; 3)\n\n# 기준의 조합에 따라 하위 집합을 만듭니다.\nsubset(x = SeuratObject, subset = MS4A1 &gt; 3 & PC1 &gt; 5)\nsubset(x = SeuratObject, subset = MS4A1 &gt; 3, idents = \"B 세포\")\n\n# 객체 메타 데이터의 값에 따라 하위 집합을 만듭니다.\nsubset(x = SeuratObject, subset = orig.ident == \"Replicate1\")\n\n# 각 identity 클래스당 세포 수를 다운샘플링합니다.\nsubset(x = SeuratObject, downsample = 100)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#시각화하기",
    "href": "posts/qmd/guide_seurat.html#시각화하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "2.3 시각화하기",
    "text": "2.3 시각화하기\n가장 일반적으로 사용되는 시각화 함수는 바이올린 플롯과 UMAP(차원 축소 후의 산점도) 입니다.\n\n\n\n\n\n\nWarning\n\n\n\nUMAP 을 그리기 전에 반드시 먼저 차원 축소를 계산해야 합니다.\n\n\n연속 변수에 대하여 바이올린 플롯 시각화하는 코드\nVlnPlot(\n    object = SeuratObject,\n    group.by = \"orig.ident\",\n    features = c(\"percent_mito\"),\n    pt.size = 0.1,\n    ncol = 4,\n    y.max = 100\n) + NoLegend()\n연속 변수에 대한 UMAP 을 그리는 방법 (예시: 유전자 발현량):\nFeaturePlot(\n    object = SeuratObject,\n    features = c(\"FEATURE_1\", \"FEATURE_2\", \"FEATURE_3\"),\n    reduction = \"umap\",\n    dims = c(1, 2),\n    order = TRUE,\n    pt.size = 0.1,\n    ncol = 3\n)\n범주형 변수에 대한 UMAP 을 그리는 방법 (예시: 세포 유형):\nDimPlot(\n    object = SeuratObject,\n    group.by = c(\"DATASET\"),\n    reduction = \"umap\",\n    dims = c(1, 2),\n    pt.size = 0.1,\n    label = TRUE,\n    ncol = 3\n)\n이것 말고도 다양한 시각화 함수가 있으니 자세한 것은 공식 문서 를 참고하세요."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#데이터-합치기",
    "href": "posts/qmd/guide_seurat.html#데이터-합치기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "2.4 데이터 합치기",
    "text": "2.4 데이터 합치기\n두 개이상의 데이터셋을 결합하려면:\nmerged_obj &lt;- merge(\n    x = SeuratObject1,\n    y = c(SeuratObject2, SeuratObject3, SeuratObject4),\n    add.cell.ids = c(\"Dataset1\", \"Dataset2\", \"Dataset3\", \"Dataset4\")\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#미토콘드리아-유전자-비율",
    "href": "posts/qmd/guide_seurat.html#미토콘드리아-유전자-비율",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "4.1 미토콘드리아 유전자 비율",
    "text": "4.1 미토콘드리아 유전자 비율\n높은 비율의 미토콘드리아 유전자는 일반적으로 손상된 세포를 의미합니다. 이는 세포질 속의 RNA 가 쉽게 소실되는 반면, 미토콘드리아 속의 RNA 는 비교적 덜 손실되기 때문입니다. 다음은 미토콘드리아 유전자 비율을 계산하고 메타데이터 테이블에 추가하는 예시입니다.\n# 미토콘드리아 유전자의 비율 계산\nSeuratObject &lt;- PercentageFeatureSet(\n    object = SeuratObject,\n    pattern = \"^MT\",\n    assay = \"RNA\",\n    col.name = \"percent_mito\"\n)\n\n\n\n\n\n\nNote\n\n\n\n유전자 관련 품질 관리에 대한 설명은 사람 (human) 에 해당하는 내용으로 다른 종의 데이터를 처리하는 경우에는 코드가 수정되어야 합니다. 예시로 생쥐 (mouse) 의 경우 미토콘드리아 (mt-), 리보소말 (Rpl) 입니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#리보솜-유전자-비율",
    "href": "posts/qmd/guide_seurat.html#리보솜-유전자-비율",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "4.2 리보솜 유전자 비율",
    "text": "4.2 리보솜 유전자 비율\n리보솜 유전자는 모든 세포에서 가장 많이 발현되는 유전자 중 하나이며, 미토콘드리아 유전자와는 반대로 미토콘드리아 수에 반비례하는 경향이 있습니다. 즉, 미토콘드리아의 수가 많을수록 리보솜 유전자의 감지 수준은 낮아집니다 (다만, 이 관계는 비선형적입니다). 리보솜 단백질에서 유래하는 유전자 발현 비율을 계산하는 방법은 미토콘드리아 유전자 비율을 계산하는 방법과 유사합니다.\n# 리보솜 유전자의 비율 계산\nSeuratObject &lt;- PercentageFeatureSet(\n    SeuratObject,\n    pattern  = \"^RP[SL]\",\n    col.name = \"percent_ribo\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#유전자-유형-및-염색체-위치-정보",
    "href": "posts/qmd/guide_seurat.html#유전자-유형-및-염색체-위치-정보",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "4.3 유전자 유형 및 염색체 위치 정보",
    "text": "4.3 유전자 유형 및 염색체 위치 정보\nRNA 시퀀싱에서 얻은 유전자는 여러 유형으로 구분할 수 있습니다. 이에는 단백질 발현 정보를 포함하는 Coding 유전자, 단백질 정보를 포함하지 않는 Non-coding 유전자, BCR 및 TCR 과 관련된 VDJ 영역 유전자 (세포 분화에 대한 정보를 포함), 그리고 siRNA 등이 포함됩니다. 이러한 정보를 활용하면 원하는 분석 유형에 따라 관심 없는 특정 유전자 범주를 필터링할 수 있습니다.\n특히, scRNA-seq 는 일반적으로 poly-A 를 사용하여 RNA 를 농축하기 때문에 데이터에 존재하는 유전자의 약 80-90% 가 단백질 코딩 유전자입니다. 또한, 유전자의 염색체 위치 정보를 수집하면 성 염색체에 의한 효과를 식별하는 데 유용할 수 있습니다.\n# 사람 유전자로 변경하기 위해 먼저 ENSEMBL에서 마우스 유전자 주석 검색\nlibrary(biomaRt)\n\n# ENSEMBL 마트 설정\nmart &lt;- biomaRt::useMart(\n    biomart = \"ensembl\",\n    dataset = \"hsapiens_gene_ensembl\",\n    host= \"www.ensembl.org\"\n)\n\n# 선택된 속성으로 마우스 유전자 주석 검색\nannot &lt;- biomaRt::getBM(\n    mart = mart,\n    attributes = c(\"external_gene_name\", \"gene_biotype\", \"chromosome_name\")\n)\n유전자 이름을 해당 생물 유형과 일치시킵니다.\n# 유전자 이름과 해당 염색체 위치 일치\nitem &lt;- annot[match(rownames(SeuratObject), annot[, 1]), \"chromosome_name\"]\n\n# NA 값을 \"unknown\"으로 대체\nitem[is.na(item)] &lt;- \"unknown\"\n\n# 유효하지 않은 염색체 값을 \"other\"로 대체\nitem[!item %in% as.character(c(1:23, \"X\", \"Y\", \"MT\"))] &lt;- \"other\"\n예를 들어 단백질 코딩 유전자에만 초점을 맞추려면 다음과 같이 수행 할 수 있습니다.\n# SeuratObject의 차원 확인\ndim(SeuratObject)\n\n# 유전자 주석에서 단백질 코딩 유전자 선택\nsel &lt;- annot[match(rownames(SeuratObject), annot[, 1]), 2] == \"protein_coding\"\n\n# 선택된 유전자 이름 가져오기\ngenes_use &lt;- rownames(SeuratObject)[sel]\ngenes_use &lt;- as.character(na.omit(genes_use))\n\n# SeuratObject에서 단백질 코딩 유전자만 필터링\nSeuratObject &lt;- SeuratObject[genes_use, ]\n\n# 필터링 후 SeuratObject의 차원 확인\ndim(SeuratObject)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#데이터-정규화",
    "href": "posts/qmd/guide_seurat.html#데이터-정규화",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "7.1 데이터 정규화",
    "text": "7.1 데이터 정규화\nscRNA-seq 에서 가장 일반적인 정규화 방법은 로그 정규화입니다. 이 방법은 각 유전자의 카운트를 모든 유전자 카운트의 합 (라이브러리 크기라고도 함) 으로 나누어 라이브러리 크기의 차이를 보상합니다. 그 후, 결과에 상수를 곱하여 모든 세포가 동일한 시퀀싱 깊이를 가지도록 합니다. 대부분의 bulk RNA-seq 에서는 상수가 보통 1e6 이며, 이로 인해 CPM(백만 단위 카운트) 이 생성됩니다. 그러나 단일 세포 라이브러리 크기는 그보다 훨씬 작기 때문에 1e3 에서 1e4(10,000 단위 카운트) 까지 사용됩니다.\n\\[ NormCounts = \\frac{(GeneCounts \\times 10000)}{LibrarySize} \\]\n라이브러리 크기에 대해 보정된 값은 로그 변환하여 로그 정규 분포로 만듭니다.\n\\[ logNormCounts = \\ln(NormCounts + 1) \\]\nSeurat에서는 NormalizeData 함수를 사용하여 이 과정을 수행할 수 있습니다.\n# 분산이 0인 유전자 제거\nSeuratObject &lt;- SeuratObject[Matrix::rowSums(SeuratObject) &gt; 0, ]\n\n# 데이터 정규화 (LogNormalize 사용)\nSeuratObject &lt;- NormalizeData(\n    object = SeuratObject,\n    scale.factor = 10000,\n    normalization.method = \"LogNormalize\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#데이터-회귀-regression",
    "href": "posts/qmd/guide_seurat.html#데이터-회귀-regression",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "7.2 데이터 회귀 (Regression)",
    "text": "7.2 데이터 회귀 (Regression)\n데이터에서 혼란 요인을 제거하기 위해 회귀 분석을 수행할 수 있습니다. 예를 들어, 세포 주기나 품질 지표 (예: 미토콘드리아 비율 또는 감지된 유전자 수) 와 같은 혼란 요인을 제거할 수 있습니다. Seurat에서는 ScaleData 함수를 사용하여 이러한 회귀를 수행할 수 있습니다.\nSeuratObject &lt;- ScaleData(\n    SeuratObject,\n    vars.to.regress = c(\"nFeature_RNA\", \"percent_mito\"),\n    verbose = FALSE\n)\n이렇게 하면 데이터에 회귀가 적용되며, 이제 데이터가 준비되었으므로 추가 분석을 진행할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#선형-스케일링-및-중심화",
    "href": "posts/qmd/guide_seurat.html#선형-스케일링-및-중심화",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "9.1 (선형) 스케일링 및 중심화",
    "text": "9.1 (선형) 스케일링 및 중심화\n각 유전자는 서로 다른 발현 수준을 가지므로, 높은 발현 값을 가진 유전자는 자연스럽게 더 높은 변동성을 보입니다. 이는 후속 분석에서 잘 포착될 수 있습니다. 따라서 각 유전자에 대해 유사한 가중치를 부여하는 것이 중요합니다. 일반적으로 PCA 를 수행하기 전에 각 유전자를 중심화하고 스케일링하는 것이 권장됩니다. 이러한 정밀한 스케일링 방법은 Z- 점수 정규화라고 하며, PCA, 클러스터링 및 히트맵 시각화에 매우 유용합니다.\n또한, 세포 주기, 시퀀싱 깊이, 미토콘드리아 비율 등과 같은 데이터셋에서 원하지 않는 변동 소스를 제거하기 위해 회귀 분석을 사용할 수 있습니다. 이는 이러한 매개변수를 모형의 공변량으로 사용하여 일반화된 선형 회귀 (GLM) 를 수행함으로써 달성됩니다. 이후 모델의 잔차는 “회귀된 데이터”로 간주됩니다.\nSeuratObject &lt;- ScaleData(\n    object = SeuratObject,\n    vars.to.regress = c(\"nCount_RNA\", \"percent_mito\", \"nFeatures_RNA\"),\n    model.use = \"linear\",\n    assay = \"RNA\",\n    do.scale = TRUE,\n    do.center = TRUE\n)\nSeurat 은 기본적으로 Seurat 객체에 있는 모든 변수 기능에 대해 스케일링을 실행합니다. 변수 기능이 있을 경우 이러한 스케일링 단계의 성능을 크게 향상시킬 수 있습니다. 그러나 결과는 변수 유전자 자체에 기반하여 PCA, 차원 축소 또는 클러스터링과 같은 후속 분석의 결과가 변경되지 않습니다. 전체 유전자 수에 대해 데이터를 스케일링하려는 경우 FindVariableFeatures 를 사용한 후 함수 호출에서 이를 지정할 수 있습니다.\nSeuratObject &lt;- ScaleData(\n    object = SeuratObject,\n    vars.to.regress = c(\"nCount_RNA\", \"percent_mito\", \"nFeatures_RNA\"),\n    model.use  = \"linear\",\n    assay = \"RNA\",\n    do.scale = TRUE,\n    do.center = TRUE,\n    features = rownames(SeuratObject)\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#포아송-스케일링-및-중심화",
    "href": "posts/qmd/guide_seurat.html#포아송-스케일링-및-중심화",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "9.2 (포아송) 스케일링 및 중심화",
    "text": "9.2 (포아송) 스케일링 및 중심화\n위의 선형 스케일링과 중심화는 로그 - 선형 데이터 분포를 가정하기 때문에, RNA-seq 데이터 (단일 세포 포함) 는 보다 음이항 분포에 가까울 수 있으며, 이로 인해 변이를 올바르게 회귀하지 못할 수 있습니다. 위의 절차의 대안으로 “포아송” 또는 “음이항” 분포를 사용하여 원시 UMI 카운트 데이터에 대해 실행할 수 있습니다. 이는 포아송 모델을 사용하여 유전자별 GLM 회귀를 수행하는 방법입니다. \nSeuratObject &lt;- ScaleData(\n    object = SeuratObject,\n    vars.to.regress = c(\"nCount_RNA\", \"mito.percent\", \"nFeatures_RNA\"),\n    model.use = \"poisson\",\n    assay = \"RNA\",\n    do.scale = TRUE,\n    do.center = TRUE\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#pca",
    "href": "posts/qmd/guide_seurat.html#pca",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "11.1 PCA",
    "text": "11.1 PCA\n주성분 분석 (PCA) 은 데이터를 새로운 좌표계로 변환하는 직교 선형 변환입니다. 이 과정에서 데이터의 가장 큰 분산이 첫 번째 주성분에 위치하고, 두 번째로 큰 분산은 두 번째 주성분에 위치하도록 합니다. 이러한 과정을 통해 데이터의 분산을 가장 잘 설명하는 방식으로 내부 구조를 드러냅니다. 일반적으로 이 동작은 데이터의 차원을 줄여 변환된 데이터의 차원을 축소하는 방식으로 이해될 수 있습니다.\n# 주성분 분석 실행\nSeuratObject &lt;- RunPCA(\n    object = SeuratObject,\n    assay = \"RNA\",\n    npcs = 100,\n    verbose = FALSE\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#t-sne",
    "href": "posts/qmd/guide_seurat.html#t-sne",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "11.2 t-SNE",
    "text": "11.2 t-SNE\nt- 분포 확률적 이웃 임베딩 (t-distributed stochastic neighbor embedding, t-SNE) 은 고차원 데이터를 저차원 공간으로 임베딩하여 시각화하는 데 적합한 비선형 차원 축소 기술입니다. 이 방법은 각 고차원 객체를 유사한 객체와 가까운 점으로 모델링하고, 서로 다른 객체는 먼 확률적 점으로 모델링하여 두 개 또는 세 개의 차원으로 표현합니다.2\n# tSNE 실행\nSeuratObject &lt;- RunTSNE(\n    object = SeuratObject,\n    reduction = \"pca\",\n    perplexity = 30,\n    max_iter = 1000,\n    theta = 0.5,\n    eta = 200,\n    exaggeration_factor = 12,\n    dims.use = 1:50,\n    verbose = FALSE,\n    num_threads = 0\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#umap",
    "href": "posts/qmd/guide_seurat.html#umap",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "11.3 UMAP",
    "text": "11.3 UMAP\nUMAP(Uniform Manifold Approximation and Projection) 은 t-SNE 와 유사하게 시각화를 위한 차원 축소에 사용할 수 있는 기술이며, 일반적인 비선형 차원 축소에도 활용될 수 있습니다.3\nUMAP 알고리즘은 실제 데이터에 적용할 수 있는 실용적이고 확장 가능한 방법입니다. 이 알고리즘은 시각화 품질에서 t-SNE 와 경쟁할 만큼 우수하며, 더 나은 실행 시간 성능을 바탕으로 전역 구조를 더 잘 보존한다고 알려져 있습니다. 또한 UMAP 은 임베딩 차원에 대한 계산 제한이 없어 머신러닝을 위한 일반적인 목적의 차원 축소 기술로 널리 사용될 수 있습니다.4\nSeuratObject &lt;- RunUMAP(\n    object = SeuratObject,\n    reduction = \"pca\",\n    dims = 1:50,\n    n.components = 2,\n    n.neighbors = 20,\n    repulsion.strength = 1,\n    verbose = FALSE,\n    n.epochs = 200,\n    metric = \"euclidean\",\n    seed.use = 42,\n    reduction.name = \"umap\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#확산-맵-diffusion-maps",
    "href": "posts/qmd/guide_seurat.html#확산-맵-diffusion-maps",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "11.4 확산 맵 (Diffusion Maps)",
    "text": "11.4 확산 맵 (Diffusion Maps)\n확산 맵 (Diffusion Maps, DM) 은 데이터 집합을 유클리드 공간 (일반적으로 저차원) 으로 임베딩하는 차원 축소 기법 중 하나입니다. 이 기법은 데이터에 대한 확산 연산자의 고유 벡터와 고유값을 기반으로 임베딩을 계산합니다. 임베딩된 공간에서의 점들 사이의 유클리드 거리는 해당 점들을 중심으로 하는 확률 분포 간의 “확산 거리”와 동일합니다. 이 방법은 주어진 데이터에서 랜덤 워크를 수행할 때, 인접한 데이터 포인트로 이동하는 것이 멀리 떨어진 데이터 포인트로 이동하는 것보다 더 자주 발생한다는 기본적인 관찰에 기반하여 작동합니다.확산 맵은 주로 데이터가 추출된 기저 매니폴드를 발견하는 데 중점을 두고 있으며, 이는 주성분 분석 (PCA) 이나 다차원 스케일링 (MDS) 과 같은 선형 차원 축소 방법과는 다른 접근 방식입니다.5\n# 추가 라이브러리 로드\nlibrary(destiny)\n\n# destiny 패키지를 사용하여 확산 맵 실행\ndm &lt;- DiffusionMap(\n    data = SeuratObject@reductions[[\"pca\"]]@cell.embeddings[, 1:50],\n    k = 20,\n    n_eigs = 20)\n\n# DM 임베딩에서 셀 이름 수정\nrownames(dm@eigenvectors) &lt;- colnames(SeuratObject)\n\n# SeuratObject에 DM 임베딩 추가\nSeuratObject@reductions[[\"dm\"]] &lt;- CreateDimReducObject(\n    embeddings = dm@eigenvectors,                                \n    key = \"DC_\",\n    assay = \"RNA\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#독립-성분-분석-ica",
    "href": "posts/qmd/guide_seurat.html#독립-성분-분석-ica",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "11.5 독립 성분 분석 (ICA)",
    "text": "11.5 독립 성분 분석 (ICA)\n독립 성분 분석 (Independent Component Analysis, ICA) 은 다변량 신호를 가산성 하위 구성 요소로 분리하는 계산 방법입니다. 이 기법은 하위 구성 요소가 가우시안이 아닌 신호이며 서로 통계적으로 독립적이라는 가정을 기반으로 합니다. ICA 는 블라인드 소스 분리 (blind source separation) 의 특별한 경우로 간주됩니다.6\nSeuratObject &lt;- RunICA(\n    object = SeuratObject,\n    assay = \"pca\",\n    nics = 20,\n    reduction.name = \"ica\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#knn",
    "href": "posts/qmd/guide_seurat.html#knn",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "12.1 KNN",
    "text": "12.1 KNN\nKNN 은 “K Nearest Neighbors”의 약자로, 데이터 마이닝 및 기계 학습 분야에서 기본적이고 인기 있는 주제입니다. KNN 그래프는 두 정점 p 와 q 가 연결되는 그래프로, 그 거리가 K 번째로 작은 거리 중 하나인 경우에만 연결됩니다. 이때 쌍별 거리 측정치는 해밍 거리, 코사인 거리, 유클리드 거리 등 다양한 방법을 사용할 수 있습니다. 본 논문에서는 벡터 간 유사성을 측정하기 위해 유클리드 거리를 사용합니다. KNN 그래프 데이터 구조는 데이터 마이닝에서 많은 이점을 제공합니다. 예를 들어, 수십억 개의 데이터 세트에서는 KNN 그래프를 오프라인으로 사전 구축하여 인덱스로 사용하는 것이 여러 번의 온라인 KNN 검색보다 훨씬 효율적입니다.\nSeuratObject &lt;- FindNeighbors(\n    SeuratObject,\n    assay = \"RNA\",\n    compute.SNN = FALSE, # FALSE로 설정하면 KNN 그래프만 계산됩니다.\n    reduction = \"pca\",\n    dims = 1:50,\n    graph.name = \"nn\",\n    prune.SNN = 1/15,\n    k.param = 20,\n    force.recalc = TRUE\n)\nKNN 그래프는 모든 셀 간의 연결이 1 로 표시된 행렬로 나타납니다. 이를 가중치가 없는 그래프라고 하며, Seurat 의 기본 설정입니다. 그러나 일부 셀 간의 연결은 다른 연결보다 더 중요할 수 있으며, 이 경우 그래프의 가중치는 0 에서 최대 거리까지 다양해집니다. 일반적으로 거리가 작을수록 두 점이 가까워지고, 그들의 연결이 강해집니다. 이러한 경우를 가중치가 있는 그래프라고 합니다.\n가중치가 있는 그래프와 가중치가 없는 그래프 모두 클러스터링에 적합하지만, 대규모 데이터 세트 (100,000 개 이상의 세포) 에서는 가중치가 없는 그래프에서 클러스터링하는 것이 더 빠릅니다.\nlibrary(pheatmap)\n\npheatmap(\n    SeuratObject@graphs$nn[1:100, 1:100],\n    col = c(\"white\", \"black\"),\n    border_color = \"grey90\",\n    legend = FALSE,\n    cluster_rows = FALSE,\n    cluster_cols = FALSE,\n    fontsize = 2\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#snn",
    "href": "posts/qmd/guide_seurat.html#snn",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "12.2 SNN",
    "text": "12.2 SNN\n추가로 KNN 그래프 외에도 모든 두 점 간에 공유된 최근접 이웃의 수를 계산합니다. 이를 통해 “공유된 최근접 이웃” 그래프를 형성합니다. 이 과정에서는 두 점 간의 각 링크의 가중치를 해당 점들이 공유하는 이웃의 수로 대체합니다. 다시 말해, 이는 최근접 이웃 그래프 내에서 모든 두 점 사이의 길이가 2 인 경로의 수를 나타냅니다.공유된 최근접 이웃 그래프가 생성되면 모든 점 쌍이 비교됩니다. 두 점이 T 이상의 이웃을 공유하는 경우, 즉 공유된 최근접 이웃 그래프에서 가중치가 임계값 T 보다 많은 링크를 가지면, 두 점과 그들이 속한 모든 클러스터가 병합됩니다. 다시 말해, 클러스터는 임계값을 사용하여 희소화한 후 공유된 최근접 이웃 그래프에서의 연결 요소입니다.\nSeuratObject &lt;- FindNeighbors(\n    SeuratObject,\n    assay = \"RNA\",\n    compute.SNN = TRUE, # KNN 그래프와 SNN 그래프 둘 다 계산합니다.\n    reduction = \"pca\",\n    dims = 1:50,\n    graph.name = \"SNN\",\n    prune.SNN = 1/15,\n    k.param = 20,\n    force.recalc = TRUE\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#scanorama-사용하기",
    "href": "posts/qmd/guide_seurat.html#scanorama-사용하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "13.1 Scanorama 사용하기",
    "text": "13.1 Scanorama 사용하기\n\n\n\n\n\n\nNote\n\n\n\n최근 여러 방법들이 데이터셋을 성공적으로 통합할 수 있다는 것을 보여주고 있습니다. 그러나 이러한 접근법들은 데이터셋에 적어도 하나의 공통 세포 유형이 존재한다고 가정하기 때문에, 세포 구성이 상당히 다른 데이터셋을 결합할 경우 과도한 보정이 발생할 수 있습니다.\n\n\nScanorama 의 접근 방식은 두 데이터 세트 간의 유사한 요소를 찾는 상호 최근접 이웃 일치 기술을 일반화하여 여러 데이터 세트 간에 유사한 요소를 탐색합니다. 이 방식은 휴대폰으로 파노라마 사진을 촬영하는 기술과 유사합니다. Scanorama 는 자동으로 유사한 전사 프로필을 가진 세포를 식별하고 이를 일괄 보정 및 통합에 활용합니다. 이 방법은 강력한 특징을 가지고 있으며, 데이터셋의 크기나 출처에 크게 영향을 받지 않으며, 모든 데이터셋이 적어도 하나의 공통 세포 모집단을 공유할 필요가 없습니다.9\nlibrary(reticulate)\nscanorama &lt;- import(\"scanorama\")\n\n# 오브젝트를 배치 별로 분할\nSeuratObject.list &lt;- SplitObject(\n    object   = SeuratObject,\n    split.by = \"BATCH\"\n)\n\n# 어레이 및 제네릭 데이터 만들기\nassaylist &lt;- list()\ngenelist  &lt;- list()\n\nfor (i in seq_along(SeuratObject.list)) {\n    assaylist[[i]] &lt;- t(\n        as.matrix(GetAssayData(SeuratObject.list[[i]], \"data\"))\n    )\n    genelist[[i]] &lt;- rownames(SeuratObject.list[[i]])\n}\n\n# 데이터 통합 및 보정\nintegrated.data &lt;- scanorama$integrate(assaylist, genelist)\ncorrected.data &lt;- scanorama$correct(\n    assaylist,\n    genelist,\n    return_dense = TRUE\n)\nintegrated.corrected.data &lt;- scanorama$correct(\n    assaylist,\n    genelist,\n    return_dimred = TRUE,\n    return_dense = TRUE\n)\n\n# 데이터 결합 및 이름 지정\nintdata &lt;- lapply(integrated.corrected.data[[2]], t)\npanorama &lt;- do.call(cbind, intdata)\nrownames(panorama) &lt;- as.character(integrated.corrected.data[[3]])\ncolnames(panorama) &lt;- unlist(sapply(assaylist, rownames))\n\n# 차원 축소 결과 결합\nintdimred &lt;- do.call(rbind, integrated.corrected.data[[1]])\ncolnames(intdimred) &lt;- paste0(\"PC_\", 1:100)\n\n# Seurat에서 Elbow Plot을 그리기 위해 표준 편차 추가\nstdevs &lt;- apply(intdimred, MARGIN = 2, FUN = sd)\n\n# 새로운 어레이 오브젝트 만들기\nSeuratObject@assays[[\"pano\"]] &lt;- CreateAssayObject(\n    data = panorama,\n    min.cells = 0,\n    min.features = 0\n)\n\n# PCA 결과 추가\nSeuratObject[[\"pca_scanorama\"]] &lt;- CreateDimReducObject(\n    embeddings = intdimred,\n    stdev = stdevs,\n    key = \"PC_\",\n    assay = \"pano\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#harmony-사용하기",
    "href": "posts/qmd/guide_seurat.html#harmony-사용하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "13.2 Harmony 사용하기",
    "text": "13.2 Harmony 사용하기\nHarmony 는 주어진 저차원 임베딩 (예: 주성분 분석) 을 기반으로 시작합니다. Harmony 는 먼저 이 임베딩을 사용하여 셀을 여러 데이터 세트 클러스터로 그룹화합니다. 부드러운 전이를 고려하기 위해 소프트 클러스터링을 사용하여 셀을 잠재적으로 여러 클러스터에 할당합니다. 이러한 클러스터는 이산적인 세포 유형을 식별하기 위한 것이 아니라, 세포 상태 간의 부드러운 전환을 반영하는 대리 변수로 기능합니다. 클러스터링이 완료되면 각 데이터셋에는 클러스터별 중심점이 생성됩니다. 이 중심점은 클러스터별 선형 보정 계수를 계산하는 데 사용됩니다. 클러스터가 세포 유형과 상태에 해당하므로, 클러스터별 보정 계수는 개별 세포 유형 및 세포 상태에 특정한 보정 계수로 작용합니다. 이를 통해 Harmony 는 미묘한 세포 표현형에 민감한 간단한 선형 조정 함수를 학습합니다. 마지막으로, 각 세포는 이러한 클러스터의 가중 평균을 할당받고, 세포별 선형 요소에 의해 보정됩니다. 각 세포가 여러 클러스터에 속할 수 있기 때문에, 각 세포에는 잠재적으로 고유한 보정 계수가 부여됩니다. Harmony 는 셀 클러스터 할당이 안정될 때까지 이 네 단계를 반복합니다. Harmony 는 대규모 데이터셋으로 확장 가능하며, 다양한 인구 집단과 세부적인 하위 집단을 동시에 식별할 수 있는 유연성을 갖추고 있습니다. 또한 복잡한 실험 설계를 수용할 수 있으며, 다양한 모드 간 통합이 가능한 강력한 알고리즘입니다.10\n# 추가 라이브러리 로드\nlibrary(harmony)\nlibrary(SeuratWrappers)\n\n# Harmony 실행\nSeuratObject &lt;- RunHarmony(\n  SeuratObject,\n  group.by.vars = \"batch\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#루브앵-louvain",
    "href": "posts/qmd/guide_seurat.html#루브앵-louvain",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "14.1 루브앵 (Louvain)",
    "text": "14.1 루브앵 (Louvain)\n루브앵 (Louvain) 방법은 Blondel 이 개발한 대규모 네트워크에서 커뮤니티를 추출하는 기법입니다.12 이 방법은 네트워크 노드 수에 대해 \\(O(n.log2n)\\) 의 시간 복잡도를 가지는 탐욕적 최적화 방법입니다. 최적화하는 값은 모듈러리티 (modularity) 로 이는 커뮤니티 내 링크 밀도를 커뮤니티 간 링크와 비교하여 측정하는 범위 내 값입니다. 이 값을 최적화하는 것은 이론적으로 주어진 네트워크의 노드를 가장 잘 그룹화하는 결과를 도출하지만 모든 노드를 그룹으로 나누는 모든 가능한 반복 과정을 거치는 것은 비실용적이므로 휴리스틱 알고리즘이 사용됩니다. \nSeuratObject &lt;- FindClusters(\n  object = SeuratObject,\n  graph.name = \"SNN\",\n  resolution = 0.8,\n  algorithm = 1 # 1로 설정하면 Louvain을 의미합니다.\n)\n클러스터 수는 resolution 매개변수를 사용하여 제어할 수 있으며 값이 높을수록 더 많은 (작은) 클러스터가 생성됩니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#라이든-leiden",
    "href": "posts/qmd/guide_seurat.html#라이든-leiden",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "14.2 라이든 (Leiden)",
    "text": "14.2 라이든 (Leiden)\n라이든 알고리즘은 반복적으로 적용되어 모든 커뮤니티의 하위 집합이 지역적으로 최적화된 분할로 수렴합니다.13 이 알고리즘은 빠른 로컬 이동 접근 방식을 기반으로 하여 루브앵 알고리즘보다 더 빠르게 실행됩니다. 라이든 알고리즘은 다음과 같은 세 단계로 구성됩니다:\n\n노드의 로컬 이동: 네트워크 내의 각 노드는 주변 노드와의 연결을 고려하여 위치를 조정합니다. 이 과정에서 각 노드는 자신의 이웃 중에서 가장 높은 모듈러리티를 제공하는 위치로 이동하게 됩니다. 이를 통해 각 노드가 속한 커뮤니티가 더욱 명확해집니다.\n분할의 정제: 초기 클러스터링 결과를 바탕으로, 각 커뮤니티 내에서 노드의 재배치를 통해 더 나은 분할을 찾습니다. 이 단계에서는 커뮤니티 간의 경계를 명확히 하고, 중복된 연결을 줄이는 과정이 포함됩니다.\n정제된 분할을 바탕으로 네트워크를 집계: 정제된 분할을 사용하여 새로운 집계 네트워크를 생성합니다. 이때, 정제되지 않은 분할을 기반으로 초기 집계 네트워크의 분할을 생성하여, 전체 네트워크 구조를 반영합니다.\n\n이러한 과정을 통해 라이든 알고리즘은 데이터의 구조를 효과적으로 파악하고, 커뮤니티 간의 관계를 명확히 하여 최적화된 결과를 도출합니다. 라이든 알고리즘은 대규모 네트워크에서도 효율적으로 작동하며, 다양한 분야에서 널리 사용되고 있습니다.\nSeuratObject &lt;- FindClusters(\n  object = SeuratObject,\n  graph.name = \"SNN\",\n  resolution = 0.8,\n  algorithm = 4 # 4로 설정하면 Leiden을 의미합니다.\n)\n클러스터 수는 resolution 매개변수를 사용하여 제어할 수 있으며 값이 높을수록 더 많은 (작은) 클러스터가 생성됩니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#계층적-클러스터링",
    "href": "posts/qmd/guide_seurat.html#계층적-클러스터링",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "14.3 계층적 클러스터링",
    "text": "14.3 계층적 클러스터링\n계층적 클러스터링 (Hierarchical Clustering, HC) 은 클러스터의 계층 구조를 구축하는 클러스터 분석 방법입니다. 이 방법은 일반적으로 두 가지 전략으로 나뉘며, 각각 합병적 (agglomerative) 또는 분할적 (divisive) 입니다. 병합과 분할은 보통 탐욕적인 방식으로 결정됩니다. 계층적 클러스터링의 결과는 일반적으로 덴드로그램 (dendrogram) 으로 시각화됩니다.\n계층적 병합 클러스터링 (Hierarchical Agglomerative Clustering, HAC) 의 표준 알고리즘은 \\(O(n^3)\\) 의 시간 복잡도를 가지며 \\(O(n^2)\\) 의 메모리를 필요로 하기 때문에, 중간 규모의 데이터 세트에서도 느릴 수 있습니다. 병합적인 경우에는 어떤 클러스터를 결합할 것인지, 분할적인 경우에는 어떤 클러스터를 분할할 것인지를 결정하기 위해 관측값 집합 간의 불일치 측정이 필요합니다. 대부분의 계층적 클러스터링 방법에서는 적절한 메트릭 (관측값 쌍 간의 거리 측정) 과 연결 기준을 사용하여 관측값 집합의 불일치를 관측값 쌍 간 거리의 함수로 정의합니다.\nR 의 기본 stats 패키지에는 모든 샘플 쌍 사이의 거리를 계산하는 dist() 함수가 포함되어 있습니다. dist() 에서 사용할 수 있는 거리 방법은 다음과 같습니다:\n\n유클리드 거리 (euclidean)\n최대 거리 (maximum)\n맨하탄 거리 (manhattan)\n캔버라 거리 (canberra)\n이진 거리 (binary)\n민코프스키 거리 (minkowski)\n\n또한, 이미 셀 간 거리 정보를 포함하는 그래프 (KNN 또는 SNN) 를 사용하여 직접 계층적 클러스터링을 수행할 수도 있습니다. 그러나 그래프의 거리는 반전되어 있으므로 (0 은 멀리 떨어져 있음을 나타내고 1 은 가깝다는 것을 나타냄), 그래프의 최대값 (인접 SNN 의 경우 1) 을 뺀 후 0 이 가까운 거리를 나타내고 1 이 먼 거리를 나타내도록 조정해야 합니다.\n샘플 간의 거리를 계산한 후에는 본격적인 계층적 클러스터링을 진행할 수 있습니다. 이를 위해 hclust() 함수를 사용하며, 위에서 생성한 거리 객체를 활용하여 간단히 실행할 수 있습니다. 사용 가능한 방법에 대한 자세한 내용은 HC for networks 에서 확인할 수 있습니다.\n# PCA에서 HC 실행\nh_pca &lt;- hclust(\n    d = dist(\n        SeuratObject@reductions[[\"pca\"]]@cell.embeddings[, 1:30],\n        method = \"euclidean\"\n    ),\n    method = \"ward.D2\"\n)\n\n# 그래프에서 HC 실행\nh_graph &lt;- hclust(\n    d = 1 - as.dist(SeuratObject@graphs$SNN),\n    method = \"ward.D2\"\n)\n클러스터 계층이 정의되면, 다음 단계는 특정 클러스터에 속하는 샘플을 식별하는 것입니다.\nplot(h, labels = FALSE)\n세포에 대한 덴드로그램을 확인한 후, 고정된 높이 (threshold) 에서 나무 (tree) 를 자를 수 있습니다. 이 작업은 cutree 함수를 사용하여 수행할 수 있습니다. 또한, 해상도에 따라 다른 수준에서 나무를 자르는 것도 가능합니다.\n# 덴드로그램 높이를 기반으로 나무 자르기\nSeuratObject$HC_res &lt;- cutree(\n    tree = h,\n    k = 18\n)\n\n# 클러스터 수를 기반으로 나무 자르기\nSeuratObject$HC_res &lt;- cutree(\n    tree = h,\n    h = 3\n)\n\n# 각 클러스터에 속하는 셀 수 확인\ntable(SeuratObject$HC_res)\n클러스터의 수는 높이 (h) 를 기준으로 하거나 직접 k 매개변수를 설정하여 조절할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#k--평균-클러스터링",
    "href": "posts/qmd/guide_seurat.html#k--평균-클러스터링",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "14.4 K- 평균 클러스터링",
    "text": "14.4 K- 평균 클러스터링\nK- 평균 클러스터링 (k-means clustering) 은 신호 처리에서 시작된 벡터 양자화 방법으로, n 개의 관측값을 k 개의 클러스터로 분할하여 각 관측값이 평균 (클러스터 중심) 과 가장 가까운 클러스터에 속하도록 하는 것을 목표로 합니다. 이 평균은 클러스터의 프로토타입 역할을 합니다. 그러나 알고리즘은 전역 최적값으로 수렴하는 것을 보장하지 않으며, 결과는 초기 클러스터 설정에 따라 달라질 수 있습니다. 일반적으로 알고리즘은 빠르게 실행되므로 서로 다른 초기 조건으로 여러 번 실행하는 것이 일반적입니다. K- 평균 클러스터링은 주로 비슷한 공간 범위의 클러스터 (모두 같은 크기) 를 찾지만, 기대값 최대화 메커니즘 덕분에 클러스터가 다양한 형태를 가질 수 있습니다.\nK- 평균은 많은 응용 분야에서 널리 사용되는 클러스터링 알고리즘입니다. R 에서는 kmeans 함수를 사용하여 쉽게 적용할 수 있습니다. 일반적으로 이 알고리즘은 표현 데이터의 축소된 차원 표현 (대부분 PCA 를 사용함) 에 적용되며, 이는 저차원 거리의 해석 가능성 덕분입니다. K- 평균 클러스터링을 수행할 때는 클러스터의 수를 미리 정의해야 하며, 결과는 클러스터 중심의 초기화에 따라 달라지므로 일반적으로 다양한 시작 구성으로 k-means 를 실행하는 것이 권장됩니다 (nstart 인수를 통해 설정 가능).\nset.seed(42)  # 재현성을 위해 설정합니다.\n\n# K-means 클러스터링 실행\nSeuratObject$kmeans_12 &lt;- kmeans(\n    x = SeuratObject@reductions[[\"pca\"]]@cell.embeddings[, 1:50],\n    centers = 12,\n    iter.max = 50,\n    nstart = 10\n)$cluster\n클러스터의 수는 centers 매개변수를 사용하여 설정할 수 있습니다. 그렇다면 어떤 클러스터링 해상도를 선택해야 할까요?클러스터링 해상도를 결정하는 것은 간단한 문제가 아니며, 여러 방법을 통해 접근할 수 있습니다. 합리적인 클러스터 수를 정하는 것은 복잡한 과정으로, 샘플에 대한 생물학적 지식과 조사가 필요합니다.차별적 유전자 발현 (Differential gene expression) 분석은 이 과정에 큰 도움이 될 수 있습니다. 만약 두 클러스터가 동일한 차별적 유전자 발현을 보이고 구별할 만한 유전자가 없다면, 이들을 개별 클러스터로 분리하는 것은 바람직하지 않을 수 있습니다. 또한, 품질 관리 지표 (QC metrics) 를 통해 생성된 클러스터를 검토하여, 일부 클러스터가 낮은 품질의 세포나 이중체로 구성되지 않았는지 확인하는 것이 중요합니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#클러스터링-결과-비교하기",
    "href": "posts/qmd/guide_seurat.html#클러스터링-결과-비교하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "14.5 클러스터링 결과 비교하기",
    "text": "14.5 클러스터링 결과 비교하기\n클러스터링 결과를 다른 클러스터링 기법과 비교하는 것은 매우 유용합니다. 이를 다음과 같은 방식으로 수행할 수 있습니다: 위 코드는 비교 대상 클래스에 속하는 세포 수에 대한 정보를 포함하는 테이블을 생성합니다. 이 데이터를 막대 그래프로 시각화하여 클러스터링 결과를 쉽게 비교할 수 있습니다.\n# 비교 테이블 생성\ncomparison_table &lt;- table(\n    list(\n        SeuratObject@meta.data[,\"METADATA_FACTOR_1\"],\n        SeuratObject@meta.data[,\"METADATA_FACTOR_2\"]\n    )\n)\n\n# 데이터를 백분율로 변환\ncomparison_table &lt;- t(t(comparison_table) / colSums(comparison_table)) * 100\n\n# 막대 그래프 그리기\nbarplot(\n    comparison_table,\n    col = 1:nrow(comparison_table),  # 색상 설정\n    border = NA,\n    las = 2                         # 축 라벨 방향 설정\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#degdifferential-expression-gene-찾기",
    "href": "posts/qmd/guide_seurat.html#degdifferential-expression-gene-찾기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "15.1 DEG(Differential expression gene) 찾기",
    "text": "15.1 DEG(Differential expression gene) 찾기\n차별적 발현 유전자 (DEG) 는 종종 “마커 유전자”로 언급되지만, 대부분의 DE 테스트는 한 그룹의 세포와 다른 그룹의 세포 간에 발현이 더 높은 유전자를 감지하도록 설계되었다는 점을 인식해야 합니다. DEG 가 자동으로 세포 유형을 위한 고유한 마커가 되지는 않습니다.Seurat 패키지에는 DE 분석을 위한 여러 가지 테스트가 구현되어 있으며, 일부는 scRNA-seq 에 특화되어 있고, 다른 일부는 벌크 RNA-seq 에서 사용됩니다.\n\nwilcox: Wilcoxon 순위 합 검정을 사용하여 두 그룹의 세포 간 차이가 있는 유전자 식별\nbimod: 단일 세포 유전자 발현에 대한 우도 비율 검정 15\nroc: ROC 분석을 사용하여 유전자 발현의 ’마커’를 식별합니다. 각 유전자에 대해 해당 유전자를 기반으로 구축된 분류기를 평가하여 두 그룹의 세포를 분류합니다. AUC 를 사용하여 각 유전자에 대한 분류기의 성능을 평가하며, AUC 값이 1 인 경우 해당 유전자의 발현 값만으로 두 그룹을 완벽하게 구분할 수 있음을 의미합니다. AUC 값이 0 인 경우 완벽한 분류가 이루어지지만 반대 방향입니다. AUC 값이 0.5 인 경우 해당 유전자가 두 그룹을 구분하는 데 예측력이 없음을 나타냅니다. 이 방법은 예상되는 차별적 발현 유전자의 순위를 지정된 예측력\\((abs(AUC-0.5) * 2)\\) 행렬로 반환합니다.\nt: 두 그룹의 세포 간 차이가 있는 유전자 식별을 위한 Student 의 t-test 사용\nnegbinom: 음이항 일반화 선형 모델을 사용하여 두 그룹의 세포 간 차이가 있는 유전자 식별 (UMI 기반 데이터 세트에만 사용)\npoisson: 포아송 일반화 선형 모델을 사용하여 두 그룹의 세포 간 차이가 있는 유전자 식별 (UMI 기반 데이터 세트에만 사용)\nLR: 로지스틱 회귀 모델을 사용하여 차이가 있는 유전자 식별. 각 기능을 개별적으로 사용하여 그룹 소속을 예측하는 로지스틱 회귀 모델을 구성하고 이를 가능도 비율 검정과 비교합니다.\nMAST: scRNA-seq 데이터에 특화된 허들 모델을 사용하여 두 그룹의 세포 간 차이가 있는 유전자 식별. DE 테스트를 실행하기 위해 MAST 패키지를 사용합니다.\nDESeq2: DESeq2 를 사용하여 두 그룹의 세포 간 차이가 있는 유전자 식별. DESeq2 는 음이항 분포를 사용하는 모델에 기초하며, 이 테스트는 세포 그룹 간 평균 차이 (또는 감지율의 백분율) 에 따른 유전자의 사전 필터링을 지원하지 않습니다. 그러나 유전자는 세포 그룹 모두에서 최소 감지율 (min.pct) 기준으로 사전 필터링될 수 있습니다. 이 방법을 사용하려면 DESeq2 를 설치하십시오.\n\nSeurat 객체의 모든 클러스터에 대해 각 클러스터와 모든 다른 세포 간의 DE 예측을 실행하려면 FindAllMarkers 함수를 사용하세요.\nmarkers &lt;- FindAllMarkers(\n    object = SeuratObject,\n    assay = \"RNA\",\n    logfc.threshold = 0.25,\n    test.use = \"wilcox\",\n    slot = \"data\",\n    min.pct = 0.1,\n    min.diff.pct = -Inf,\n    only.pos = FALSE,\n    max.cells.per.ident = Inf,\n    latent.vars = NULL,\n    min.cells.feature = 3,\n    min.cells.group = 3,\n    pseudocount.use = 1,\n    return.thresh = 0.01\n)\n아래에 나타낸 여러 가지 기준을 통해 특정 유전자를 포함하거나 출력을 필터링할 수 있습니다. 예를 들어, 상향 조절된 유전자만 테스트하면 분석 속도를 높일 수 있습니다:\n\nonly.pos = TRUE 를 사용하여 상향 조절된 유전자만 테스트\n유전자가 발현된 최소 세포 수를 설정하는 min.cells.feature\n유전자가 발현된 클러스터의 최소 세포 수를 나타내는 min.cells.group\n클러스터에서 min.pct 이상 발현된 유전자만 테스트\n두 그룹 간의 발현 비율 차이가 min.pct.diff 인 유전자만 테스트\np.value &lt; return.thresh 인 유전자만 반환\nlogFoldchange &gt; logfc.threshold 인 유전자만 반환\n\n또한 고려해야 할 몇 가지 중요한 사항이 있습니다:\n\n객체에 여러 분석이 포함된 경우, 올바른 분석 결과에서 차등발현 분석을 실행해야 합니다. 예를 들어, 데이터가 통합된 경우에는 Batch 를 고려해야 합니다.\n\ncell_selection &lt;- SeuratObject[, SeuratObject$seurat_clusters == 4]\ncell_selection &lt;- SetIdent(cell_selection, value = \"Batch\")\n\n# 차별적 발현 계산\nDGE_cell_selection &lt;- FindAllMarkers(\n    object = cell_selection,\n    logfc.threshold = 0.2,\n    test.use = \"wilcox\",\n    min.pct = 0.1,\n    min.diff.pct = -Inf,\n    only.pos = FALSE,\n    max.cells.per.ident = Inf,\n    latent.vars = NULL,\n    min.cells.feature = 3,\n    min.cells.group = 3,\n    pseudocount.use = 1,\n    return.thresh = 0.01\n)\n또한 FindMarkers 함수를 사용하여 두 세트의 세포 간의 차이를 테스트할 수 있으며, 각 그룹에 대한 셀 이름을 cells 및 cells 로 지정할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#deg-시각화하기",
    "href": "posts/qmd/guide_seurat.html#deg-시각화하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "15.2 DEG 시각화하기",
    "text": "15.2 DEG 시각화하기\nDE 테스트를 실행한 후, 다양한 방법으로 유전자를 시각화하고 싶을 수 있습니다. 그러나 먼저 각 클러스터에서 상위 DEG 를 추출해야 합니다. 각 클러스터별로 상위 5 개의 유전자를 선택하는 방법은 다음과 같습니다:\ntop5 &lt;- markers %&gt;% group_by(cluster) %&gt;% top_n(-5, p_val_adj)\n이를 히트맵으로 시각화할 수 있습니다:\nDoHeatmap(\n    object = SeuratObject,\n    features = as.character(unique(top5$gene)),\n    group.by = \"seurat_clusters\",\n    assay = \"RNA\"\n)\n또는 각 클러스터가 평균 발현으로 색상별로 나타내고, 해당 유전자를 발현하는 세포의 비율로 크기별로 나타내는 점 도플롯을 사용할 수 있습니다:\n# coord_flip() 함수를 위해 필요\nlibrary(ggplot2) \n\nDotPlot(\n    object = SeuratObject,\n    features = as.character(unique(top5$gene)),\n    group.by = \"seurat_clusters\",\n    assay = \"RNA\"\n) + coord_flip()\n또한 각 유전자에 대해 바이올린 플롯을 그릴 수 있습니다:\nVlnPlot(\n    object = SeuratObject,\n    features = as.character(unique(top5$gene)),\n    ncol = 3,\n    group.by = \"seurat_clusters\",\n    assay = \"RNA\"\n)\n바이올린 플롯을 배치별로 분할할 수도 있습니다. 이것은 감지된 DEG 가 단일 배치로 인해 주도되는 것이 아닌지 확인하는 데 매우 유용할 수 있습니다.\nVlnPlot(\n    object = SeuratObject,\n    features = as.character(unique(top5$gene)),\n    ncol = 3,\n    group.by = \"seurat_clusters\",\n    assay = \"RNA\",\n    split.by = \"Batch\"\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#slingshot-사용하기",
    "href": "posts/qmd/guide_seurat.html#slingshot-사용하기",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "17.1 Slingshot 사용하기",
    "text": "17.1 Slingshot 사용하기\n슬링샷 (Slingshot) 은 차원 축소, 클러스터링 및 주요 곡선 (Principal curves) 과 같은 다른 경로 분석 방법에서 발견되는 여러 인기 있는 구성 요소를 포함하고 있어 가장 전형적인 방법 중 하나입니다. 슬링샷은 특정 차원 축소 방법에 제한되지 않으며, 어떤 방법을 사용할지 결정할 때 고려해야 할 중요한 세 가지 사항이 있습니다:\n\n데이터의 전체 복잡성을 포착하기에 충분한 차원을 사용해야 합니다. 이는 특히 PCA 및 MDS 와 같은 선형 차원 축소에서 중요하며, 경로의 위상이 이분화보다 복잡할 경우 더욱 그렇습니다. 두 차원에서 경로가 명확하게 보이지 않을 때도 여전히 다차원에서 경로를 시각화할 수 있습니다.\n일부 차원 축소 방법은 고밀도 영역에서 거리를 확대할 수 있습니다. t-SNE 와 UMAP 은 이러한 문제를 겪을 수 있습니다. 우리가 사용하는 데이터셋에서는 이러한 문제가 발생하지 않지만, 생물학적 모집단을 무작위로 샘플링할 경우 문제가 발생할 수 있습니다.\n일부 차원 축소 방법은 셀의 그룹화를 강제하고 연속성을 제거하려고 합니다. t-SNE 와 UMAP 도 이러한 문제를 일부 가지고 있으며, 이로 인해 실제로는 그렇지 않은 셀들이 함께 묶일 수 있습니다.\n\n이러한 이유로 MDS 와 확산 맵이 종종 선호되는 선택지입니다. 그러나 샘플이 균형 잡힌 경우 t-SNE 와 UMAP 도 효과적으로 작동할 수 있습니다.\ndimred &lt;- SeuratObject@reductions[['pca']]@cell.embeddings  # 사용될 embedding 지정\n그 답은 간단합니다. 클러스터링은 문제를 단순화하며, 경로 상에서 거의 동일한 위치에 있는 세포 그룹을 찾아냅니다. 이러한 그룹은 이후 세포가 어떤 경로를 통해 이동하고 분기되는지를 파악하는 데 연결될 수 있습니다. 이상적으로 TI 를 위한 클러스터링 방법은 밀도를 기반으로 셀을 그룹화해서는 안 됩니다. 예를 들어 DBSCAN 과 같은 밀도 기반 클러스터링은 정의상 모든 세포가 고밀도 영역을 통해 연결되지만 유전자 발현에서는 차이가 발생할 수 있습니다. 여기서는 Seurat의 표준 클러스터링 방법인 라이든 (Leiden) 클러스터링을 사용할 것입니다.\nclustering &lt;- factor(\n    SeuratObject@meta.data[, \"seurat_clusters\"]\n) \n이제부터 이 클러스터링 결과를 경로 분석에 적용할 것입니다. 전체 프로세스는 단일 함수인 slingshot 을 사용하여 수행할 수 있으며, 이는 경로 분석을 위한 두 가지 주요 단계를 간단히 묶어 놓은 래퍼 (wrapper) 입니다. 프로세스의 첫 번째 단계는 세포 계통 (cell lineages) 을 정의하고, 그 다음 데이터를 통해 경로를 정의하는 곡선을 맞추는 것입니다. 이러한 단계들은 아래에서 설명합니다.\n\n17.1.1 Slingshot 으로 세포 계통 정의하기\n# 기본 설정으로 Slingshot 세포 계통 식별을 실행\nlibrary(slingshot)\n\nlineages &lt;- getLineages(\n     data = dimred,\n     clusterLabels = clustering\n)\n\n# Lineages를 시각화.\npar(mfrow = c(1,2))\nplot(\n     dimred[, 1:2],\n     col = clustering,\n     cex = ,\n     pch = 16\n)\n여기서 우리는 경로 분석의 한 가지 중요한 문제를 살펴볼 수 있습니다: 경로 분석이 어디에서 시작되는지를 알 수 없다는 점입니다. 추가 정보가 없이는 이를 파악하기가 거의 불가능합니다. 경로 분석의 시작점과 끝점을 정의하기 위해서는 사전 생물학적 정보가 필요합니다.\n# Cluster 5에서 Slingshot을 시작하기.\nlineages &lt;- getLineages(\n    data = dimred,\n    clusterLabels = clustering,\n    start.clus = \"5\"\n)\n\nlineages\n\n\n17.1.2 주요 경로 정의하기\n시작 클러스터를 정한 뒤에는 Slingshot 을 사용하여 경로 분석을 수행할 수 있습니다. Slingshot 의 알고리즘은 초기 경로를 반복적으로 수정하여 데이터 포인트와 더 잘 일치되도록 합니다. 구체적으로 Slingshot 은 두 가지 기능을 사용합니다.\n\n각 “계통”마다 주요 경로를 찾습니다: 여기서 “계통”이란 특정 시작 클러스터에서 특정 종단 클러스터로 이어지는 클러스터 집합을 의미합니다. 즉, 각 계통은 세포들이 어떤 경로를 따라 이동하는지를 나타내며, 이를 통해 세포의 발달 과정을 이해할 수 있습니다.\n동일한 클러스터 집합을 가진 계통은 주요 곡선이 겹치는 클러스터 주위에 묶이도록 제약됩니다: 이는 서로 연결된 세포 그룹이 같은 경로를 공유하도록 하여, 분석의 일관성을 높이는 역할을 합니다. 이렇게 하면 각 계통이 서로 다른 경로를 따라 이동하더라도, 동일한 클러스터 내에서의 관계를 유지할 수 있습니다.\n\nSlingshot 의 getCurves() 함수는 실행하는 데 시간이 오래 걸리므로 각 계통에서 사용할 셀의 수를 줄여 곡선 적합 프로세스의 속도를 높일 수 있습니다. 이상적으로는 모든 셀을 사용하는 것이 좋지만 여기서는 approx_points 를 300 으로 설정하여 속도를 높였습니다.\n# 곡선 데이터 가져오기\ncurves &lt;- getCurves(\n    lineages,\n    approx_points = 300,\n    thresh = 0.01,\n    stretch = NULL,  # stretch 인수에 NULL 설정 (예시)\n    allow.breaks = FALSE,\n    shrink = NULL    # shrink 인수에 NULL 설정 (예시)\n)\n\n# 곡선 데이터 확인\ncurves\n\n# 차원 축소 결과 플롯\nplot(\n    dimred,\n    col = clustering,\n    asp = 1,\n    pch = 16\n)\n\n# 곡선 추가\nlines(\n    curves,\n    lwd = 3,\n    col = 'black'\n)"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#경로-분석를-따라-변하는-유전자를-찾기-differential-expression-along-trajectories",
    "href": "posts/qmd/guide_seurat.html#경로-분석를-따라-변하는-유전자를-찾기-differential-expression-along-trajectories",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "17.2 경로 분석를 따라 변하는 유전자를 찾기 (Differential expression along trajectories)",
    "text": "17.2 경로 분석를 따라 변하는 유전자를 찾기 (Differential expression along trajectories)\n경로 분석을 해석하는 주요 방법 중 하나는 경로를 따라 변하는 유전자를 찾는 것입니다. 경로 분석에서 차별적 발현 (differential expression) 을 정의하는 방법은 여러 가지가 있습니다:\n\n특정 경로를 따라 발현 변화: 예를 들어, 세포가 유사한 시간에 따라 발현이 어떻게 변화하는지를 분석합니다.\n가지 사이의 발현 차이: 서로 다른 경로 (또는 가지) 간의 유전자 발현 차이를 비교합니다.\n분기점에서의 발현 변화: 세포가 분기점에 도달했을 때 발현이 어떻게 변화하는지를 살펴봅니다.\n경로 분석의 어느 지점에서든 발현 변화: 경로의 모든 지점에서 유전자 발현의 변화를 평가합니다.\n\ntradeSeq 는 경로 분석 결과에서 차별적 발현 유전자를 찾는 도구 중 하나입니다. 이 도구는 일반화된 가법 모형 (Generalized Additive Models, GAMs) 을 사용하여 경로를 따라 유전자 발현을 조정하고 경로의 여러 지점 사이에서 특정 계수가 통계적으로 다른지를 테스트합니다. GAM 모델을 적합시키는 과정은 시간이 많이 걸립니다. 따라서 여기에서는 매우 엄격한 필터링을 통해 많은 유전자를 제거하였습니다. 실제로는 모든 유전자 데이터를 사용하는 것이 좋습니다.\n# 추가 패키지 로드\nBiocParallel::register(BiocParallel::SerialParam())\nlibrary(tradeSeq)\n\n# 연산 속도를 높이기 위해 일부 유전자 제거\ncounts &lt;- as.matrix(SeuratObject[[\"RNA\"]]$counts)\ndim(counts)  # 원본 카운트 행렬 차원 확인\n\n# 필터링된 카운트 행렬 생성\nfilt_counts &lt;- counts[rowSums(counts &gt; 5) &gt; ncol(counts) / 100, ]\ndim(filt_counts)  # 필터링 후 카운트 행렬 차원 확인\n\n# 감마 분포 fitting\nsce &lt;- fitGAM(\n    counts = as.matrix(filt_counts),\n    sds = curves\n)\n\n# 결과 플롯\nplotGeneCount(\n    curve = curves,\n    counts = filt_counts,\n    clusters = clustering,\n    models = sce\n)\n\n17.2.1 두 시간점 사이에서 변하는 유전자\n원하는 경우 사용자 정의 유사 시간 (Pseudotime) 값을 설정하여 두 시간점 사이에서 변하는 유전자를 찾을 수 있습니다. 예를 들어, 전구 세포 표시자와 같은 특정 유전자를 분석할 수 있습니다. 기본적으로는 시작점과 끝점 사이의 차이를 살펴보는 방식으로 진행됩니다.\n# Pseudotime 시작과 끝 간의 연관성 테스트\npseudotime_start_end_association &lt;- startVsEndTest(\n    sce,\n    pseudotimeValues = c(0, 1)\n)\n\n# feature_id 추가\npseudotime_start_end_association$feature_id &lt;- rownames(pseudotime_start_end_association)\n\n# p-value가 0.05 미만인 feature_id 필터링 및 선택\nfeature_id &lt;- pseudotime_start_end_association %&gt;%\n    filter(pvalue &lt; 0.05) %&gt;%\n    top_n(1, waldStat) %&gt;%\n    pull(feature_id)\n\n# 차별 발현 플롯 그리기\nplot_differential_expression(feature_id)\n\n\n17.2.2 경로가 갈라지는 사이에서 변하는 유전자\n두 가지 사이에서 차별적으로 발현되는 유전자는 특히 흥미로운 연구 대상입니다. 이러한 유전자 중 일부는 이전의 두 시간점 사이에서 변하는 유전자 분석에서 이미 발견되었을 수 있습니다. “경로가 갈라지는 사이에서 변하는 유전자”를 정의하는 여러 가지 방법이 있으며 방법에 따라 함수가 다릅니다.17\n\ndiffEndTest: 각 가지의 끝점에서 발현 차이를 분석합니다.\nearlyDETest: 가지의 분기점에서 발현 차이를 평가합니다.\npatternTest: 경로 분석의 어느 지점에서든 발현 차이를 탐색합니다. 이 마지막 함수는 두 가지 간의 유사 시간이 정렬되어 있어야 함을 요구합니다.\n\n# 차별적 끝 연관성 테스트 수행\ndifferent_end_association &lt;- diffEndTest(sce)\ndifferent_end_association$feature_id &lt;- rownames(different_end_association)\n\n# p-value가 0.05 미만인 feature_id 필터링 및 정렬\nfeature_id &lt;- different_end_association %&gt;%\n    filter(pvalue &lt; 0.05) %&gt;%\n    arrange(desc(waldStat)) %&gt;%\n    dplyr::slice(1) %&gt;%\n    pull(feature_id)\n\n# 차별 발현 플롯 그리기\nplot_differential_expression(feature_id)\n\n# 가지점 연관성 테스트 수행\nbranch_point_association &lt;- earlyDETest(sce)\nbranch_point_association$feature_id &lt;- rownames(branch_point_association)\n\n# p-value가 0.05 미만인 feature_id 필터링 및 정렬\nfeature_id &lt;- branch_point_association %&gt;%\n    filter(pvalue &lt; 0.05) %&gt;%\n    arrange(desc(waldStat)) %&gt;%\n    dplyr::slice(1) %&gt;%\n    pull(feature_id)\n\n# 차별 발현 플롯 그리기\nplot_differential_expression(feature_id)\n더 자세한 것은 공식 문서 를 확인하십시오."
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#온라인-강의",
    "href": "posts/qmd/guide_seurat.html#온라인-강의",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "18.1 온라인 강의",
    "text": "18.1 온라인 강의\n\nExercises for the NBIS scRNA-seq course\nThe GitHub repository for the NBIS scRNA-seq course\nSingle cell RNA-seq course at from Hemberg lab\nSingle cell RNA-seq course in Python\nSingle cell RNA-seq course at Broad"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#프레젠테이션-및-강의",
    "href": "posts/qmd/guide_seurat.html#프레젠테이션-및-강의",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "18.2 프레젠테이션 및 강의",
    "text": "18.2 프레젠테이션 및 강의\n\nSingle-cell methodologies\nQuaility controls\nNormalisation\nDimensionality reduction\nBatch correction and data integration\nClustering techniques\nDifferential expression analysis\nTrajectory inference analyses\nAll of the above in a YouTube playlist"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#도구-및-파이프라인",
    "href": "posts/qmd/guide_seurat.html#도구-및-파이프라인",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "18.3 도구 및 파이프라인",
    "text": "18.3 도구 및 파이프라인\n\nRepository listing many scRNA-seq tools\nBitbucket repository for QC report scripts\nBitbucket repository for an NBIS scRNA-seq pipeline\nA catalogue of many scRNA-seq tools"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#웹사이트",
    "href": "posts/qmd/guide_seurat.html#웹사이트",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "18.4 웹사이트",
    "text": "18.4 웹사이트\n\nSingleCellExperiment objects for many datasets\nConquer datasets - many different datasets based on a salmon pipeline\nThe Human Cell Atlas project\nThe EBI Single-cell expression atlas"
  },
  {
    "objectID": "posts/qmd/guide_seurat.html#footnotes",
    "href": "posts/qmd/guide_seurat.html#footnotes",
    "title": "Seurat 라이브러리 치트시트(Cheatsheet)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.pnas.org/content/116/20/9775)↩︎\nhttps://distill.pub/2016/misread-tsne, http://jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf↩︎\nhttps://umap-learn.readthedocs.io/en/latest↩︎\nhttps://arxiv.org/abs/1802.03426↩︎\nhttps://projecteuclid.org/euclid.ajm/1253539864↩︎\nhttps://en.wikipedia.org/wiki/Independent_component_analysis↩︎\nhttps://www.nature.com/articles/nbt.4091↩︎\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1850-9↩︎\nhttps://www.nature.com/articles/s41587-019-0113-3↩︎\nhttps://www.nature.com/articles/s41592-019-0619-00↩︎\nhttps://f1000research.com/articles/7-1141↩︎\nhttps://iopscience.iop.org/article/10.1088/1742-5468/2008/10/P10008/pdf↩︎\nhttps://www.nature.com/articles/s41598-019-41695-z.pdf↩︎\nhttps://www.nature.com/articles/nmeth.4612↩︎\nMcDavid et al., Bioinformatics, 2013↩︎\nhttps://www.nature.com/articles/s41587-019-0071-9↩︎\nCannoodt, Robrecht, Wouter Saelens, and Yvan Saeys. 2016.”Computational Methods for Trajectory Inference from Single-Cell Transcriptomics.”European Journal of Immunology 46 (11): 2496–2506.↩︎"
  },
  {
    "objectID": "posts/qmd/tool_pymol.html",
    "href": "posts/qmd/tool_pymol.html",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "",
    "text": "PyMOL 은 생화학과 분자 생물학에서 자주 사용되는 분자 시각화 소프트웨어입니다. 단백질, 핵산, 소형 화합물 등의 3D 구조를 시각화하고 분석하고 그래픽 렌더링 기능을 통해 고품질의 이미지를 생성할 수 있습니다. PyMOL 에는 오픈 소스 버전과 PyMOL by Schrödinger(상업 라이센스) 가 존재하기 때문에 영리기관 (회사) 에서 일을 하시거나 라이센스 문제를 겪고 싶지 않다면 오픈 소스 버전을 컴파일해서 설치하는 것을 추천합니다."
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#미니콘다-설치",
    "href": "posts/qmd/tool_pymol.html#미니콘다-설치",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "1.1 미니콘다 설치",
    "text": "1.1 미니콘다 설치\n먼저 Windows 용 Miniconda 를 설치합니다. 자세한 설치 방법은 공식 홈페이지를 참고하세요. Anaconda 를 사용하시거나 다른 유사한 conda 배포판을 사용하셔도 상관은 없습니다."
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#pymol-환경-생성",
    "href": "posts/qmd/tool_pymol.html#pymol-환경-생성",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "1.2 PyMOL 환경 생성",
    "text": "1.2 PyMOL 환경 생성\nPyMOL 3.0.x 용 가상 환경을 생성합니다.\n$conda create -n pymol python=3.12\n그런 다음 가상 환경을 활성화하고 필요한 패키지를 설치합니다.\n$conda activate pymol\n\n# 필요한 패키지 설치\n(pymol-3.0)$conda install numpy pmw pyqt pip"
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#파일-다운로드-및-pymol-설치",
    "href": "posts/qmd/tool_pymol.html#파일-다운로드-및-pymol-설치",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "1.3 파일 다운로드 및 PyMOL 설치",
    "text": "1.3 파일 다운로드 및 PyMOL 설치\n파이썬의 wheel 파일은 파이썬 패키지를 배포하기 위한 표준 형식 중 하나입니다. .whl 확장자를 가지며, 설치 속도 빠르고 빌드가 불필요하다는 장점이 있습니다. 윈도우용 PyMOL wheel 파일은 GitHub 리포지토리 의 릴리즈 페이지 에서 다운로드할 수 있습니다.\nWindows 11 x64 의 경우, pymol-3.0.0-cp312-cp312-win_amd64.whl 을 다운로드합니다. 그런 다음 아래 명령어로 설치합니다. 아래 사용한 파일명은 예시로 다운로드한 파일의 이름으로 변경하셔야 합니다.\n(pymol)$python -m pip install pymol-3.0.0-cp312-cp312-win_amd64.whl\n\n\n\n\n\n\nNote\n\n\n\n예전 버전과는 달리 더 이상 pymol_launcher 가 필요하지 않습니다.\n\n\n만약 오류가 발생했다면 wheel 파일의 경로가 올바른지 확인하세요. 오류 메시지가 발생하지 않았다면 다음의 명령어로 PyMOL 을 실행할 수 있습니다:\n(pymol)$pymol"
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#기본-패키지-매니저-사용",
    "href": "posts/qmd/tool_pymol.html#기본-패키지-매니저-사용",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "2.1 기본 패키지 매니저 사용",
    "text": "2.1 기본 패키지 매니저 사용\nLinux 에서는 최신 버전을 제공하지 않는 경우가 많지만 오픈 소스 PyMOL을 위한 바이너리 패키지를 기본 제공하기 때문에 아주 편리하게 설치 할 수 있습니다. 아래는 일부 인기 있는 배포판에 대한 설치 명령어입니다. 참고로 모든 명령은 superuser 로 실행해야 합니다.\n# Debian/Ubuntu/Mint\napt-get install pymol\n\n# Fedora\ndnf install pymol\n\n# Arch/Manjaro\npacman -S pymol\n\n# CentOS with EPEL\nrpm -i http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-5.noarch.rpm\nyum --enablerepo=epel install pymol\n우분투를 NVIDIA 그래픽 카드 및 일반 드라이버와 함께 사용하는 경우 렌더링 불량, 검은색 픽셀화 및 기타 그래픽 이상이 발생할 수 있습니다. NVIDIA 전용 드라이버 설치 가이드는 Ubuntu 커뮤니티 Nvidia 드라이버 설치 방법 에서 확인할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#homebrew-사용",
    "href": "posts/qmd/tool_pymol.html#homebrew-사용",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "2.2 Homebrew 사용",
    "text": "2.2 Homebrew 사용\nHomebrew는 macOS 와 Linux 시스템을 위한 패키지 관리자입니다. Homebrew는 전용 디렉토리에 패키지를 설치하기 때문에 시스템의 다른 부분에 영향을 주지 않는 장점이 있습니다. 저는 가능하다면 이 방법을 가장 추천합니다.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nHomebrew 를 설치가 완료되면 다음 명령어로 간단하게 설치가 가능합니다.\nbrew install pymol"
  },
  {
    "objectID": "posts/qmd/tool_pymol.html#footnotes",
    "href": "posts/qmd/tool_pymol.html#footnotes",
    "title": "오픈 소스 PyMOL 설치하기",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://omicx.cc/posts/2024-04-13-install-open-source-pymol-3.0.x-in-windows-11/↩︎"
  },
  {
    "objectID": "posts/qmd/tip_PDB.html",
    "href": "posts/qmd/tip_PDB.html",
    "title": "PDB 데이터베이스에 숨겨진 5가지 진실",
    "section": "",
    "text": "생명과학 연구의 심장부에는 단백질 데이터 뱅크(Protein Data Bank, PDB)라는 거대한 데이터베이스가 있습니다. 1971년 단 7개의 구조로 시작된 이 데이터베이스는 이제 277,000개가 넘는 분자 구조 모델을 보유한 방대한 아카이브로 성장했습니다. PDB는 질병의 원리를 규명하고 새로운 치료제를 설계하는 등 과학 발전에 결정적인 역할을 해왔으며, 이제는 단백질 구조 예측 기술을 발전시키는 데에도 핵심적인 기반이 되고 있습니다.\n이처럼 엄청난 데이터의 가치는 아무리 강조해도 지나치지 않습니다. 연구자들은 PDB 덕분에 새로운 발견을 거대한 아카이브와 비교하고, 수천 개의 구조에서 나타나는 패턴을 분석하며 단일 구조만으로는 결코 알 수 없었을 통찰을 얻습니다. 하지만 이 놀라운 자원의 이면에는 종종 간과되는 복잡성과 미묘한 함정들이 존재합니다.\n단순히 데이터를 다운로드하여 사용하는 것만으로는 충분하지 않습니다. PDB 데이터를 제대로 활용하기 위해서는 그 안에 숨겨진 특성과 한계를 이해해야 합니다. 이 글에서는 단백질 구조 데이터 작업을 할 때 반드시 알아야 할 5가지를 알아 보고자 합니다.\n\n1 거대한 데이터 아카이브는 생각보다 편향되어 있습니다\nPDB가 자연에 존재하는 모든 단백질을 균일하게 담고 있다고 생각하기 쉽지만 사실 그렇지 않습니다. 데이터베이스는 특정 종류의 단백질에 심각하게 편향되어 있습니다. 많은 데이터들이 X선 결정학을 통해 수집되었기 때문에 결정을 만들기 쉬운 작고, 둥근 특성을 가진 단백질 데이터가 압도적으로 많습니다.\n반면, 우리 유전자의 20~30%를 차지함에도 불구하고 막단백질이나 유연하거나 정형화되지 않은 단백질(flexible or disordered proteins)은 PDB 전체 항목의 2%도 채 되지 않을 정도로 극심하게 과소 대표되고 있습니다. 여기에 더해 ’출판 편향’도 존재합니다. 신약 개발의 표적이 되거나 의학적 가치가 높은 인간 단백질은 집중적으로 연구되어 동일한 단백질의 구조가 수없이 등록됩니다. 이러한 경향은 최근 단편 기반 스크리닝 캠페인(fragment-screening campaigns)이 증가하면서 더욱 심화되고 있습니다.\n더욱 놀라운 사실은 단백질이 생체 내에서 기능하는 단위인 4차 구조(protein complex)에 대한 정보조차 약 20%의 경우에서 부정확하다는 점입니다. 이는 PDB의 데이터가 그 자체로 완벽한 것이 아닌, 해석과 검증이 필요한 데이터임을 시사합니다.\n\n\n2 ’고해상도’가 ’완벽함’을 의미하지는 않습니다\n단백질 구조의 품질을 논할 때 가장 흔하게 사용되는 지표는 ’해상도(resolution)’입니다. 해상도가 높을수록 더 정밀한 구조를 의미하는 것은 사실이지만, 이것이 전부는 아닙니다. 고해상도 구조라 할지라도 거의 모든 구조에는 국소적인 오류가 몇 군데 포함되어 있으며, 해상도가 낮아질수록 이러한 오류는 구조 전반에 걸쳐 더 광범위하게 나타납니다.\n여기서 한 가지 역설적인 사실은, 구조를 결정하는 실험 방법마다 해상도를 추정하는 방식이 근본적으로 다르다는 점입니다. 예를 들어, X선 결정학의 해상도는 원자 수준의 세부 정보를 직접적으로 반영하지만, 초저온전자현미경(cryo-EM)의 해상도는 두 개의 독립적인 재구성 이미지(half-maps) 간의 푸리에 쉘 상관관계(FSC)를 통해 계산됩니다. 이는 원자 단위의 정밀도보다는 두 이미지 간의 전반적인 유사성을 측정하는 지표이므로, 두 해상도 값을 직접적으로 비교하는 것은 적절하지 않습니다.\n두 구조가 동일한 해상도를 가질지라도, 모델링된 정밀도의 수준은 다를 수 있습니다. 따라서 다른 품질 지표들을 함께 탐색하는 것이 필수적입니다.\n이것이 바로 전문가들이 해상도 숫자 하나에만 의존하지 않고, 라마찬드란 이상치(Ramachandran outliers)와 같은 기하학적 정확성이나 R-값(R-values)처럼 실험 데이터와의 부합도를 종합적으로 평가하기 위해 MolProbity와 같은 검증 도구 모음을 사용하는 이유입니다.\n\n\n3 모든 단백질 구조는 ’사진’이 아닌 ’모델’입니다\n우리가 PDB 파일에서 보는 단백질 구조는 분자의 모습을 그대로 찍은 ’사진’이 아닙니다. 그것은 실험 데이터를 기반으로 과학자들이 해석하여 만든 과학적 ’모델’입니다. 이는 매우 중요한 차이를 만듭니다.\nPDB 모델은 그저 모델일 뿐이라는 점을 기억하는 것이 중요합니다. 이 모델들은 기반이 되는 모든 실험 데이터를 설명하지 않으며 데이터 처리 과정에 따라 달라질 수 있습니다.\n이는 동일한 원본 실험 데이터를 어떤 데이터 처리 프로그램을 선택하고 어떻게 정제(refinement) 과정을 거쳤는지에 따라 미묘하게 다른 최종 모델이 나올 수 있음을 의미합니다. 또한, 연구자들이 주로 관심을 갖는 결합 부위(binding site)는 단백질의 다른 부분보다 더 정교하게 모델링되는 경향이 있습니다. 이러한 편향은 결합 부위 잔기와 다른 영역 잔기의 유연성이나 보존성 같은 특성을 비교하는 분석 결과를 왜곡할 수 있어 주의가 필요합니다.\n\n\n4 ’결정 속의 환상’을 조심해야 합니다\nX선 결정학으로 구조를 얻을 때 발생하는 독특한 현상 중 하나로 ’결정 접촉(crystal contacts)’이 있습니다. 이는 단백질 분자들이 규칙적인 결정 격자 안에 빽빽하게 채워지면서 발생하는 비생물학적인 상호작용을 말합니다. 즉, 실험실의 결정 속에서만 일어나는 인공적인 접촉입니다.\n이것이 왜 중요할까요? 이 결정 접촉은 놀라운 결과를 초래할 수 있습니다. 특정 형태의 단백질 구조를 인위적으로 안정화시키거나, 심지어 실제 우리 몸속(용액 상태)에서는 존재하지 않는 분자 간의 인터페이스를 만들어낼 수도 있습니다.\n이는 PDB 파일에서 관찰된 단백질의 특정 상호작용이나 구조적 형태가 실제 생물학적 특징이 아니라 결정화 과정에서 생긴 ’환상’일 수 있다는 것을 의미합니다. 따라서 연구자들은 이러한 인공물을 배제하기 위해 신중한 통제와 비교 분석을 수행해야 합니다.\n\n\n5 과학 데이터는 끊임없이 재분석되고 개선됩니다\n데이터베이스에 한번 등록된 정보는 영원히 고정된 최종본이라는 생각은 흔한 오해입니다. 과학 데이터는 새로운 기술과 이해가 발전함에 따라 끊임없이 재분석되고 개선됩니다. 이러한 과학적 자기 교정의 대표적인 예가 바로 PDB-REDO 프로젝트입니다.\nPDB-REDO는 PDB에 등록된 기존의 X선 구조들과 원본 실험 데이터를 가져와 현대적이고 자동화된 표준화된 방법으로 다시 처리하는 프로젝트입니다. 이러한 재정제(re-refinement) 과정은 종종 기존 모델보다 더 개선되고 신뢰할 수 있는 새로운 모델을 만들어냅니다. 하지만 2008년 이전에는 원본 실험 데이터(structure factors) 보관을 의무화 하지 않아 제외되는 것도 있다는 점을 기억하세요.\n그럼에도 불구하고 이는 과학 커뮤니티가 단순히 데이터를 쌓아두는 데 그치지 않고, 시간이 지남에 따라 핵심적인 기초 데이터의 품질을 적극적으로 향상시키기 위해 노력하고 있음을 보여주는 증거입니다.\n\n\n6 결론\n단백질 데이터 뱅크(PDB)는 의심할 여지 없이 생명과학 연구를 위한 매우 귀중한 자원입니다. 하지만 그 데이터는 전문가가 올바르게 탐색해야만 하는 미묘한 뉘앙스와 잠재적인 함정으로 가득 차 있습니다. 데이터의 편향성을 인식하고 품질 지표를 비판적으로 해석하며, 구조가 ’모델’이라는 점을 기억하는 것은 정확한 과학적 결론을 내리기 위한 필수적인 과정입니다.\n최근 알파폴드(AlphaFold)와 같은 인공지능(AI) 예측 모델의 등장은 단백질 구조 연구에 새로운 지평을 열었습니다. 이 모델들은 강력하지만 특히 정밀한 원자 수준의 세부 정보와 상호작용(“last-Ångstrom” 문제)에 있어서는 여전히 한계를 가지고 있다는 점을 명심해야 합니다.\nAI가 방대한 양의 구조 데이터를 계속해서 생성해내는 미래에 우리는 다음과 같은 질문을 던져야 합니다. “이러한 ’모델’들을 비판적으로 평가하고 그 의미를 이해하는 능력을 어떻게 키울 수 있을까요?”"
  },
  {
    "objectID": "posts/qmd/tool_uv.html",
    "href": "posts/qmd/tool_uv.html",
    "title": "pip 대신에 uv 사용하기",
    "section": "",
    "text": "pip 는 파이썬 패키지 관리자로 유용하지만 아래와 같은 몇 가지 근본적인 문제가 있습니다. 특히 패키지 의존성과 환경 관리는 문제가 터지면 해결하기가 아주 어렵습니다."
  },
  {
    "objectID": "posts/qmd/tool_uv.html#특징",
    "href": "posts/qmd/tool_uv.html#특징",
    "title": "pip 대신에 uv 사용하기",
    "section": "2.1 특징",
    "text": "2.1 특징\n\n\n⚖️ 일반적인 pip, pip-tools, virtualenv 명령을 드롭인 방식으로 대체합니다.\n⚡️ pip 및 pip-tools(pip-compile 및 pip-sync) 보다 10-100배 빠르다. \n💾 종속성 중복 제거를 위한 글로벌 캐시로 디스크 공간 효율을 높입니다.\n🐍 Rust 나 Python 없이 curl, pip, pipx 등을 통해 바이너리로 설치할 수 있습니다.\n🧪 상위 10,000 개의 PyPI 패키지를 대상으로 대규모 테스트 완료.\n🖥️ macOS, Linux, Windows 를 지원합니다.\n🧰 고급 기능인 종속성 버전 재정의 및 대체 해결 전략 등을 포함.\n⁉️ 현존하는 패키지 관리 중 가장 자세한 오류 메시지와 충돌 추적 해결사 제공.\n🤝 편집 가능한 설치, Git 종속성, 직접 URL 종속성, 로컬 종속성, 제약 조건, 소스 배포, HTML 및 JSON 인덱스 등을 포함한 광범위한 기능 지원."
  },
  {
    "objectID": "posts/qmd/tool_uv.html#설치",
    "href": "posts/qmd/tool_uv.html#설치",
    "title": "pip 대신에 uv 사용하기",
    "section": "3.1 설치",
    "text": "3.1 설치\nuv를 설치하는 여러 가지 방법을 안내합니다. 자신의 환경에 맞는 방법을 선택하세요.\n독립 실행형 설치 프로그램 사용\n운영체제에 맞는 명령어를 터미널(명령 프롬프트)에 입력하여 설치합니다.\n\nmacOS 및 Linux: bash     curl -LsSf https://astral.sh/uv/install.sh | sh\nWindows: powershell     powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n특정 버전 설치 (예: 0.2.29):\n\nmacOS 및 Linux: bash       curl -LsSf https://astral.sh/uv/0.2.29/install.sh | sh\nWindows: powershell       powershell -c \"irm https://astral.sh/uv/0.2.29/install.ps1 | iex\"\n\n\n** 기존 파이썬 패키지 관리자 사용**\n이미 pip 또는 pipx, Homebrew를 사용하고 있다면 다음 명령어로 uv를 설치할 수 있습니다.\n\npip 사용: bash     pip install uv\npipx 사용: bash     pipx install uv\nHomebrew 사용 (macOS): bash     brew install uv"
  },
  {
    "objectID": "posts/qmd/tool_uv.html#가상-환경-관리",
    "href": "posts/qmd/tool_uv.html#가상-환경-관리",
    "title": "pip 대신에 uv 사용하기",
    "section": "3.2 가상 환경 관리",
    "text": "3.2 가상 환경 관리\n프로젝트별로 독립된 환경을 만들어 패키지를 관리할 수 있습니다.\n가상 환경 생성:\nuv venv # 현재 폴더에 .venv라는 이름으로 가상 환경 생성\n가상 환경 활성화:\n운영체제에 따라 다른 명령어를 사용합니다. 활성화되면 터미널 프롬프트 앞에 (.venv)와 같은 표시가 나타납니다.\n\nmacOS 및 Linux: bash     source .venv/bin/activate\nWindows: bash     .venv\\Scripts\\activate"
  },
  {
    "objectID": "posts/qmd/tool_uv.html#패키지-설치",
    "href": "posts/qmd/tool_uv.html#패키지-설치",
    "title": "pip 대신에 uv 사용하기",
    "section": "3.3 패키지 설치",
    "text": "3.3 패키지 설치\n활성화된 가상 환경에 필요한 파이썬 패키지를 설치합니다.\n\n최신 버전 설치: bash     uv pip install flask # Flask 패키지의 최신 버전 설치\n특정 버전 설치: bash     uv pip install flask==2.0.0 # Flask 패키지 2.0.0 버전 설치\nrequirements.txt 파일에서 설치: bash     uv pip install -r requirements.txt # requirements.txt 파일에 명시된 패키지들을 설치\n현재 프로젝트를 편집 가능한 모드로 설치: bash     uv pip install -e . # 개발 중인 프로젝트를 설치하여 코드 변경 사항이 즉시 반영되도록 함\n로컬 패키지 파일에서 설치: bash     uv pip install \"package @ .\" # 현재 폴더에 있는 패키지 파일을 설치\n추가 의존성을 포함하여 설치: bash     uv pip install \"flask[dotenv]\" # Flask와 함께 dotenv 의존성을 함께 설치"
  },
  {
    "objectID": "posts/qmd/tool_uv.html#의존성-관리-파일-생성-및-동기화",
    "href": "posts/qmd/tool_uv.html#의존성-관리-파일-생성-및-동기화",
    "title": "pip 대신에 uv 사용하기",
    "section": "3.4 의존성 관리 파일 생성 및 동기화",
    "text": "3.4 의존성 관리 파일 생성 및 동기화\n프로젝트에 필요한 패키지 목록을 파일로 저장하고 관리합니다.\nrequirements.txt 파일 생성:\n다양한 방법으로 현재 환경의 패키지 목록 또는 특정 설정 파일에서 requirements.txt 파일을 생성할 수 있습니다.\n\nrequirements.in 파일에서 생성: bash     uv pip compile requirements.in -o requirements.txt\npyproject.toml 파일에서 생성: bash     uv pip compile pyproject.toml -o requirements.txt\nsetup.py 파일에서 생성: bash     uv pip compile setup.py -o requirements.txt\n터미널 입력에서 생성: bash     echo flask | uv pip compile - -o requirements.txt\n현재 활성화된 환경의 패키지 목록 저장: bash     uv pip freeze | uv pip compile - -o requirements.txt\n\n** requirements.txt 파일로 패키지 설치:**\n생성한 requirements.txt 파일에 명시된 패키지들을 가상 환경에 설치합니다.\nuv pip sync requirements.txt\nuv의 pip install 및 pip compile 명령어는 -r, -c, -e, --index-url과 같은 기존 pip 옵션들을 그대로 지원합니다."
  },
  {
    "objectID": "posts/qmd/tool_uv.html#uv-핵심-기능-활용",
    "href": "posts/qmd/tool_uv.html#uv-핵심-기능-활용",
    "title": "pip 대신에 uv 사용하기",
    "section": "3.5 uv 핵심 기능 활용",
    "text": "3.5 uv 핵심 기능 활용\nuv는 파이썬 버전 관리 프로젝트 초기화 의존성 관리 등 다양한 편리한 기능을 제공합니다.\n\n3.5.1 Python 버전 관리\n\n\n\n\n\n\n\n\n명령어\n설명\n예시\n\n\n\n\nuv python install &lt;버전&gt;\n지정한 Python 버전 설치\nuv python install 3.12\n\n\nuv python list\n설치 가능한 Python 버전 목록 표시\nuv python list\n\n\nuv use &lt;버전&gt;\n현재 디렉토리에 .python-version 파일 생성하여 기본 Python 버전 지정\nuv use 3.11\n\n\n\n\n\n3.5.2 프로젝트 초기화 및 구성\n\n\n\n\n\n\n\n\n명령어\n설명\n생성되는 파일/디렉토리\n\n\n\n\nuv init\n기본 프로젝트 초기화\npyproject.toml .python-version\n\n\nuv init --package\n패키지 형태 프로젝트 생성\npyproject.toml .python-version src/\n\n\nuv init --lib\n배포용 라이브러리 프로젝트 생성\n라이브러리 구조의 pyproject.toml 테스트 디렉토리 등\n\n\n\n\n\n3.5.3 의존성 관리\n\n\n\n\n\n\n\n\n명령어\n설명\n예시\n\n\n\n\nuv add &lt;패키지&gt;\n의존성 추가\nuv add requests\n\n\nuv add --dev &lt;패키지&gt;\n개발용 의존성 추가\nuv add --dev pytest black\n\n\nuv remove &lt;패키지&gt;\n의존성 제거\nuv remove requests\n\n\nuv lock\n락파일 생성/갱신\nuv lock\n\n\n\n\nuv는 하드 링크를 통해 디스크 공간을 효율적으로 사용합니다. 여러 가상 환경에서 동일한 패키지를 사용하더라도 실제 파일은 한 번만 저장됩니다.\n\n\n\n3.5.4 5.4. 다른 도구에서 마이그레이션\n기존 프로젝트의 설정을 uv로 가져올 수 있습니다.\n# 1. 프로젝트 폴더로 이동\ncd existing-project\n\n# 2. uv 프로젝트 초기화\nuv init\n\n# 3. requirements.txt 파일이 있는 경우 패키지 추가\ncat requirements.txt | xargs uv add\n\n# 4. 의존성 잠금 및 동기화\nuv lock\nuv sync\n\n\n3.5.5 빌드 및 배포\nuv를 사용하여 패키지를 빌드하고 PyPI에 배포할 수 있습니다.\n# 패키지 빌드\nuv build\n\n# PyPI에 배포\nuv publish\n\n\n3.5.6 실사용 예시\n아래는 데이터 과학 프로젝트를 시작하는 과정을 보여줍니다.\n# 1. 프로젝트 폴더 생성\nmkdir ds-project\ncd ds-project\n\n# 2. 프로젝트 초기화 및 Python 버전 설정\nuv init --package\nuv python install 3.11\nuv use 3.11\n\n# 3. 데이터 과학 관련 패키지 설치\nuv add numpy pandas matplotlib scikit-learn\n\n# 4. 개발 도구 설치\nuv add --dev ipython jupyterlab black ruff\n\n# 5. 의존성 잠금 및 동기화\nuv lock\nuv sync\n\n# 6. Jupyter Lab 실행\nuv run jupyter lab"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html",
    "href": "posts/qmd/Rosalind_textbookTrack.html",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "",
    "text": "Phillip Compeau 와 Pavel Pevzner 가 쓴 책 “능동적 접근 방식의 생물정보학 알고리즘” 에서 제공되는 연습 문제 모음입니다.\nRosalind 는 프로젝트 오일러, 구글 코드 잼 에서 영감을 얻었습니다. 이 프로젝트의 이름은 DNA 이중나선을 발견하는 데 기여한 로잘린드 프랭클린 에서 따왔습니다. Rosalind 는 프로그래밍 실력을 키우고자 하는 생물학자와 분자생물학의 계산 문제를 접해본 적이 없는 프로그래머들에게 도움이 될 것입니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#compute-the-number-of-times-a-pattern-appears-in-a-text",
    "href": "posts/qmd/Rosalind_textbookTrack.html#compute-the-number-of-times-a-pattern-appears-in-a-text",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "0.1 Compute the Number of Times a Pattern Appears in a Text",
    "text": "0.1 Compute the Number of Times a Pattern Appears in a Text\nThis is the first problem in a collection of”code challenges”to accompany Bioinformatics Algorithms: An Active-Learning Approach by Phillip Compeau & Pavel Pevzner.\nA k-mer is a string of length k. We define Count(Text, Pattern) as the number of times that a k-mer Pattern appears as a substring of Text.\nFor example, We note that \\(Count(CGATATATCCATAGCGATATATCCATAG,ATAATA)\\) is equal to 3 (not 2) since we should account for overlapping occurrences of Pattern in Text.\nGiven: {DNA strings}} Text and Pattern.\nReturn: Count(Text, Pattern)."
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "0.2 Sample Dataset",
    "text": "0.2 Sample Dataset\nGCGCG\nGCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "0.3 Sample Output",
    "text": "0.3 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "0.4 Solution",
    "text": "0.4 Solution\nfrom typing import Generator\n\ndef generate_substrings(text: str, size: int) -&gt; Generator[str, None, None]:\n    \"\"\"Generate all substrings of a given size from the text.\"\"\"\n    for i in range(len(text) - size + 1):\n        yield text[i:i + size]\n\ndef count_pattern_occurrences(text: str, pattern: str) -&gt; int:\n    \"\"\"Count how many times the pattern occurs in the text.\"\"\"\n    return sum(pattern == substring for substring in generate_substrings(text, len(pattern)))\n\n# Sample input\nsample_input = \"\"\"\nGCGCG\nGCG\n\"\"\"\n\n# Split input into text and pattern\ntext, pattern = sample_input.strip().split(\"\\n\")\n\n# Print the count of pattern occurrences in text\nprint(count_pattern_occurrences(text, pattern))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-1",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-1",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "1.1 Sample Dataset",
    "text": "1.1 Sample Dataset\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-1",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-1",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "1.2 Sample Output",
    "text": "1.2 Sample Output\nCATG GCAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-1",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-1",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "1.3 Solution",
    "text": "1.3 Solution\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef generate_substrings(text: str, size: int) -&gt; List[str]:\n    \"\"\"Generate all substrings of a given size from the text.\"\"\"\n    return [text[i:i + size] for i in range(len(text) - size + 1)]\n\ndef count_kmers(text: str, k: int) -&gt; Dict[str, int]:\n    \"\"\"Count occurrences of each k-mer in the text.\"\"\"\n    kmer_counts = defaultdict(int)\n    for kmer in generate_substrings(text, k):\n        kmer_counts[kmer] += 1\n    return kmer_counts\n\ndef most_frequent_kmers(kmer_counts: Dict[str, int]) -&gt; List[str]:\n    \"\"\"Find the most frequent k-mers.\"\"\"\n    max_count = max(kmer_counts.values())\n    return [kmer for kmer, count in kmer_counts.items() if count == max_count]\n\n# Sample input\nsample_input = \"\"\"\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4\n\"\"\"\n\n# Split input into text and pattern size\ntext, k = sample_input.strip().split(\"\\n\")\nk = int(k)\n\n# Find and print the most frequent k-mers\nmost_frequent = most_frequent_kmers(count_kmers(text, k))\nprint(*most_frequent)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-2",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-2",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "2.1 Sample Dataset",
    "text": "2.1 Sample Dataset\nAAAACCCGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-2",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-2",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "2.2 Sample Output",
    "text": "2.2 Sample Output\nACCGGGTTTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-2",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-2",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "2.3 Solution",
    "text": "2.3 Solution\ndef reverse_complement(seq: str) -&gt; str:\n    \"\"\"Return the reverse complement of a DNA sequence.\"\"\"\n    return seq[::-1].translate(str.maketrans(\"ACGT\", \"TGCA\"))\n\n# Sample input\nsample_input = \"\"\"\nAAAACCCGGT\n\"\"\"\n\n# Process the input and print the reverse complement\nsequence = sample_input.strip().split()[0]\nprint(reverse_complement(sequence))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-3",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-3",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "3.1 Sample Dataset",
    "text": "3.1 Sample Dataset\nATAT\nGATATATGCATATACTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-3",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-3",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "3.2 Sample Output",
    "text": "3.2 Sample Output\n1 3 9"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-3",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-3",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "3.3 Solution",
    "text": "3.3 Solution\nfrom typing import List, Generator\n\ndef generate_substrings(text: str, size: int) -&gt; List[str]:\n    \"\"\"Generate all substrings of a given size from the text.\"\"\"\n    return [text[i:i + size] for i in range(len(text) - size + 1)]\n\ndef find_pattern_indices(text: str, pattern: str) -&gt; Generator[int, None, None]:\n    \"\"\"Yield starting indices where the pattern is found in the text.\"\"\"\n    for i, substring in enumerate(generate_substrings(text, len(pattern))):\n        if substring == pattern:\n            yield i\n\n# Sample input\nsample_input = \"\"\"\nATAT\nGATATATGCATATACTT\n\"\"\"\n\n# Split input into pattern and text\npattern, text = sample_input.strip().split(\"\\n\")\n\n# Print indices where the pattern is found\nprint(*find_pattern_indices(text, pattern))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-4",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-4",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "4.1 Sample Dataset",
    "text": "4.1 Sample Dataset\nCGGACTCGACAGATGTGAAGAAATGTGAAGACTGAGTGAAGAGAAGAGGAAACACGACACGACATTGCGACATAATGTACGAATGTAATGTGCCTATGGC\n5 75 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-4",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-4",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "4.2 Sample Output",
    "text": "4.2 Sample Output\nCGACA GAAGA AATGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-4",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-4",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "4.3 Solution",
    "text": "4.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict\n\ndef generate_substrings(text: str, size: int) -&gt; List[str]:\n    \"\"\"Generate all substrings of a given size from the text.\"\"\"\n    return [text[i:i + size] for i in range(len(text) - size + 1)]\n\ndef find_kmers(text: str, k: int) -&gt; Dict[str, List[int]]:\n    \"\"\"Find positions of k-length kmers within the text.\"\"\"\n    kmer_positions = defaultdict(list)\n    for i, substring in enumerate(generate_substrings(text, k)):\n        kmer_positions[substring].append(i)\n    return kmer_positions\n\ndef has_clump(positions: List[int], L: int, t: int, k: int) -&gt; bool:\n    \"\"\"Check if a given array of kmers at positions forms a clump of t within L.\"\"\"\n    for i in range(len(positions) - t + 1):\n        if (positions[i + t - 1] + k - positions[i]) &lt;= L:\n            return True\n    return False\n\n# Sample input\nsample_input = \"\"\"\nCGGACTCGACAGATGTGAAGAAATGTGAAGACTGAGTGAAGAGAAGAGGAAACACGACACGACATTGCGACATAATGTACGAATGTAATGTGCCTATGGC\n5 75 4\n\"\"\"\n\n# Split input into sequence and parameters\nseq, params = sample_input.strip().split(\"\\n\")\nk, L, t = map(int, params.split())\n\n# Find kmers and print those forming clumps\nkmers = find_kmers(seq, k)\nclumps = [kmer for kmer in kmers if has_clump(kmers[kmer], L, t, k)]\nprint(*clumps)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-5",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-5",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "5.1 Sample Dataset",
    "text": "5.1 Sample Dataset\nCCTATCGGTGGATTAGCATGTCCCTGTACGTTTCGCCGCGAACTAGTTCACACGGCTTGATGGCAAATGGTTTTTCCGGCGACCGTAATCGTCCACCGAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-5",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-5",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "5.2 Sample Output",
    "text": "5.2 Sample Output\n53 97"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-5",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-5",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "5.3 Solution",
    "text": "5.3 Solution\nfrom typing import Generator\n\ndef find_minima(seq: str) -&gt; Generator[int, None, None]:\n    \"\"\"Find positions with the minimum skew in a DNA sequence.\"\"\"\n    skew = [0]\n    delta = {\"G\": 1, \"C\": -1, \"A\": 0, \"T\": 0}\n    \n    for i, nucleotide in enumerate(seq):\n        skew.append(skew[i] + delta[nucleotide])\n    \n    min_skew = min(skew)\n    return (i for i, value in enumerate(skew) if value == min_skew)\n\n# Sample input\nsample_input = \"\"\"\nCCTATCGGTGGATTAGCATGTCCCTGTACGTTTCGCCGCGAACTAGTTCACACGGCTTGATGGCAAATGGTTTTTCCGGCGACCGTAATCGTCCACCGAG\n\"\"\"\n\n# Process the input and print the positions with minimum skew\nsequence = sample_input.strip()\nprint(*find_minima(sequence))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-6",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-6",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "6.1 Sample Dataset",
    "text": "6.1 Sample Dataset\nGGGCCGTTGGT\nGGACCGTTGAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-6",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-6",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "6.2 Sample Output",
    "text": "6.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-6",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-6",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "6.3 Solution",
    "text": "6.3 Solution\nfrom itertools import zip_longest\nfrom typing import Tuple\n\ndef calculate_hamming_distance(sequence1: str, sequence2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip_longest(sequence1, sequence2, fillvalue=None))\n\ndef parse_dna_sequences(input_string: str) -&gt; Tuple[str, str]:\n    return tuple(input_string.strip().split(\"\\n\"))\n\n# Sample input\nSample_input = \"\"\"\nGGGCCGTTGGT\nGGACCGTTGAC\n\"\"\"\n\ndna_sequence1, dna_sequence2 = parse_dna_sequences(Sample_input)\nhamming_distance = calculate_hamming_distance(dna_sequence1, dna_sequence2)\nprint(hamming_distance)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-7",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-7",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "7.1 Sample Dataset",
    "text": "7.1 Sample Dataset\nATTCTGGA\nCGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-7",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-7",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "7.2 Sample Output",
    "text": "7.2 Sample Output\n6 7 26 27 78"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-7",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-7",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "7.3 Solution",
    "text": "7.3 Solution\nfrom typing import Iterator, List\n\ndef generate_substrings(dna_sequence: str, substring_length: int) -&gt; Iterator[str]:\n    return (dna_sequence[i:i + substring_length] for i in range(len(dna_sequence) - substring_length + 1))\n\ndef calculate_hamming_distance(sequence1: str, sequence2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip(sequence1, sequence2))\n\ndef find_approximate_matches(pattern: str, genome: str, max_mismatch: int) -&gt; Iterator[int]:\n    pattern_length = len(pattern)\n    return (position for position, substring in enumerate(generate_substrings(genome, pattern_length))\n            if calculate_hamming_distance(substring, pattern) &lt;= max_mismatch)\n\ndef parse_input(input_data: str) -&gt; tuple[str, str, int]:\n    pattern, genome, max_mismatch_str = input_data.strip().split(\"\\n\")\n    return pattern, genome, int(max_mismatch_str)\n\nsample_input = \"\"\"\nATTCTGGA\nCGCCCGAATCCAGAACGCATTCCCATATTTCGGGACCACTGGCCTCCACGGTACGGACGTCAATCAAATGCCTAGCGGCTTGTGGTTTCTCCTACGCTCC\n3\n\"\"\"\n\npattern, genome, max_mismatch = parse_input(sample_input)\nmatch_positions = list(find_approximate_matches(pattern, genome, max_mismatch))\nprint(*match_positions)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-8",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-8",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "8.1 Sample Dataset",
    "text": "8.1 Sample Dataset\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-8",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-8",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "8.2 Sample Output",
    "text": "8.2 Sample Output\nATGC ATGT GATG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-8",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-8",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "8.3 Solution",
    "text": "8.3 Solution\nfrom collections import defaultdict\nfrom itertools import product\nfrom typing import Dict, List, Iterator, Tuple\n\ndef calculate_hamming_distance(sequence1: str, sequence2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip(sequence1, sequence2))\n\ndef generate_substrings(dna_sequence: str, substring_length: int) -&gt; Iterator[str]:\n    return (dna_sequence[i:i + substring_length] for i in range(len(dna_sequence) - substring_length + 1))\n\ndef count_kmers(dna_sequence: str, kmer_length: int) -&gt; Dict[str, int]:\n    kmer_counts = defaultdict(int)\n    for kmer in generate_substrings(dna_sequence, kmer_length):\n        kmer_counts[kmer] += 1\n    return kmer_counts\n\ndef find_most_frequent(kmer_counts: Dict[str, int]) -&gt; List[str]:\n    max_count = max(kmer_counts.values())\n    return [kmer for kmer, count in kmer_counts.items() if count == max_count]\n\ndef generate_all_kmers(kmer_length: int) -&gt; Iterator[str]:\n    return (\"\".join(bases) for bases in product(\"ACGT\", repeat=kmer_length))\n\ndef count_approximate_kmers(observed_kmers: Dict[str, int], max_mismatches: int, kmer_length: int) -&gt; Iterator[Tuple[str, int]]:\n    for potential_kmer in generate_all_kmers(kmer_length):\n        count = sum(observed_kmers[observed_kmer] \n                    for observed_kmer in observed_kmers \n                    if calculate_hamming_distance(potential_kmer, observed_kmer) &lt;= max_mismatches)\n        if count &gt; 0:\n            yield (potential_kmer, count)\n\ndef parse_input(input_data: str) -&gt; Tuple[str, int, int]:\n    dna_sequence, params = input_data.strip().split(\"\\n\")\n    kmer_length, max_mismatches = map(int, params.split())\n    return dna_sequence, kmer_length, max_mismatches\n\nsample_input = \"\"\"\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4 1\n\"\"\"\n\ndna_sequence, kmer_length, max_mismatches = parse_input(sample_input)\nobserved_kmers = count_kmers(dna_sequence, kmer_length)\napproximate_kmer_counts = dict(count_approximate_kmers(observed_kmers, max_mismatches, kmer_length))\nmost_frequent_kmers = find_most_frequent(approximate_kmer_counts)\nprint(*most_frequent_kmers)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-9",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-9",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "9.1 Sample Dataset",
    "text": "9.1 Sample Dataset\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-9",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-9",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "9.2 Sample Output",
    "text": "9.2 Sample Output\nATGT ACAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-9",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-9",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "9.3 Solution",
    "text": "9.3 Solution\nfrom collections import defaultdict\nfrom itertools import product\nfrom typing import Dict, List, Iterator, Tuple\n\ndef reverse_complement(dna: str) -&gt; str:\n    return dna[::-1].translate(str.maketrans(\"ACGT\", \"TGCA\"))\n\ndef hamming_distance(seq1: str, seq2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip(seq1, seq2))\n\ndef generate_substrings(dna: str, length: int) -&gt; Iterator[str]:\n    return (dna[i:i + length] for i in range(len(dna) - length + 1))\n\ndef count_kmers(dna: str, kmer_length: int) -&gt; Dict[str, int]:\n    kmer_counts = defaultdict(int)\n    for kmer in generate_substrings(dna, kmer_length):\n        kmer_counts[kmer] += 1\n    return kmer_counts\n\ndef find_most_frequent(kmer_counts: Dict[str, int]) -&gt; List[str]:\n    max_count = max(kmer_counts.values())\n    return [kmer for kmer, count in kmer_counts.items() if count == max_count]\n\ndef generate_all_kmers(kmer_length: int) -&gt; Iterator[str]:\n    return (\"\".join(bases) for bases in product(\"ACGT\", repeat=kmer_length))\n\ndef count_approximate_kmers(kmer_counts: Dict[str, int], max_mismatches: int, kmer_length: int) -&gt; Iterator[Tuple[str, int]]:\n    for potential_kmer in generate_all_kmers(kmer_length):\n        count = sum(kmer_counts[observed_kmer] for observed_kmer in kmer_counts \n                    if hamming_distance(potential_kmer, observed_kmer) &lt;= max_mismatches)\n        count += sum(kmer_counts[observed_kmer] for observed_kmer in kmer_counts \n                     if hamming_distance(reverse_complement(potential_kmer), observed_kmer) &lt;= max_mismatches)\n        if count &gt; 0:\n            yield (potential_kmer, count)\n\ndef parse_input(input_data: str) -&gt; Tuple[str, int, int]:\n    dna_sequence, params = input_data.strip().split(\"\\n\")\n    kmer_length, max_mismatches = map(int, params.split())\n    return dna_sequence, kmer_length, max_mismatches\n\nsample_input = \"\"\"\nACGTTGCATGTCGCATGATGCATGAGAGCT\n4 1\n\"\"\"\ndna_sequence, kmer_length, max_mismatches = parse_input(sample_input)\nkmer_counts = count_kmers(dna_sequence, kmer_length)\napproximate_kmer_counts = dict(count_approximate_kmers(kmer_counts, max_mismatches, kmer_length))\nprint(*find_most_frequent(approximate_kmer_counts))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-10",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-10",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "10.1 Sample Dataset",
    "text": "10.1 Sample Dataset\nACGCGGCTCTGAAA\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-10",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-10",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "10.2 Sample Output",
    "text": "10.2 Sample Output\n2 1 0 0 0 0 2 2 1 2 1 0 0 1 1 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-10",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-10",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "10.3 Solution",
    "text": "10.3 Solution\nfrom typing import Iterator, List, Dict, Tuple\nfrom itertools import product\n\ndef generate_substrings(text: str, size: int) -&gt; Iterator[str]:\n    return (text[i : i + size] for i in range(len(text) - size + 1))\n\ndef count_pattern_occurrences(text: str, pattern: str) -&gt; int:\n    return sum(pattern == substring for substring in generate_substrings(text, len(pattern)))\n\ndef calculate_hamming_distance(s1: str, s2: str) -&gt; int:\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\ndef generate_kmers(k: int) -&gt; Iterator[str]:\n    return (\"\".join(bases) for bases in product(\"ACGT\", repeat=k))\n\ndef count_approximate_kmers(kmer_counts: Dict[str, int], max_mismatches: int, kmer_length: int) -&gt; Iterator[Tuple[str, int]]:\n    for potential_kmer in generate_kmers(kmer_length):\n        count = sum(kmer_counts[observed_kmer] for observed_kmer in kmer_counts \n                    if calculate_hamming_distance(potential_kmer, observed_kmer) &lt;= max_mismatches)\n        if count &gt; 0:\n            yield (potential_kmer, count)\n\ndef calculate_kmer_frequencies(sequence: str, kmer_length: int) -&gt; List[int]:\n    return [count_pattern_occurrences(sequence, kmer) for kmer in generate_kmers(kmer_length)]\n\ndef parse_input(input_data: str) -&gt; Tuple[str, int]:\n    sequence, kmer_length = input_data.strip().split(\"\\n\")\n    return sequence, int(kmer_length)\n\nsample_input = \"\"\"\nACGCGGCTCTGAAA\n2\n\"\"\"\nsequence, kmer_length = parse_input(sample_input)\nkmer_frequencies = calculate_kmer_frequencies(sequence, kmer_length)\nprint(*kmer_frequencies"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-11",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-11",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "11.1 Sample Dataset",
    "text": "11.1 Sample Dataset\nAGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-11",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-11",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "11.2 Sample Output",
    "text": "11.2 Sample Output\n11"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-11",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-11",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "11.3 Solution",
    "text": "11.3 Solution\nfrom typing import Dict, Tuple\n\ndef create_nucleotide_to_number_map() -&gt; Dict[str, int]:\n    return {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n\ndef convert_nucleotide_to_number(nucleotide: str, nucleotide_map: Dict[str, int]) -&gt; int:\n    return nucleotide_map[nucleotide]\n\ndef convert_dna_pattern_to_number(dna_pattern: str, nucleotide_map: Dict[str, int]) -&gt; int:\n    if not dna_pattern:\n        return 0\n    return 4 * convert_dna_pattern_to_number(dna_pattern[:-1], nucleotide_map) + convert_nucleotide_to_number(dna_pattern[-1], nucleotide_map)\n\ndef parse_input(input_data: str) -&gt; str:\n    return input_data.strip()\n\nsample_input = \"\"\"\nAGT\n\"\"\"\n\ndna_pattern = parse_input(sample_input)\nnucleotide_map = create_nucleotide_to_number_map()\nresult = convert_dna_pattern_to_number(dna_pattern, nucleotide_map)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-12",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-12",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "12.1 Sample Dataset",
    "text": "12.1 Sample Dataset\n45\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-12",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-12",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "12.2 Sample Output",
    "text": "12.2 Sample Output\nAGTC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-12",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-12",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "12.3 Solution",
    "text": "12.3 Solution\nfrom typing import Tuple\n\ndef number_to_nucleotide(index: int) -&gt; str:\n    nucleotides = [\"A\", \"C\", \"G\", \"T\"]\n    return nucleotides[index]\n\ndef number_to_dna_pattern(index: int, length: int) -&gt; str:\n    if length == 1:\n        return number_to_nucleotide(index)\n    quotient, remainder = divmod(index, 4)\n    return number_to_dna_pattern(quotient, length - 1) + number_to_nucleotide(remainder)\n\ndef parse_input(input_data: str) -&gt; Tuple[int, int]:\n    index_str, length_str = input_data.strip().split(\"\\n\")\n    return int(index_str), int(length_str)\n\nsample_input = \"\"\"\n45\n4\n\"\"\"\nindex, length = parse_input(sample_input)\ndna_pattern = number_to_dna_pattern(index, length)\nprint(dna_pattern)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-13",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-13",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "13.1 Sample Dataset",
    "text": "13.1 Sample Dataset\nACG\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-13",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-13",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "13.2 Sample Output",
    "text": "13.2 Sample Output\nCCG\nTCG\nGCG\nAAG\nATG\nAGG\nACA\nACC\nACT\nACG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-13",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-13",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "13.3 Solution",
    "text": "13.3 Solution\nfrom typing import Set, List, Tuple, Iterator\n\ndef calculate_hamming_distance(seq1: str, seq2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip(seq1, seq2))\n\ndef generate_immediate_neighbors(sequence: str) -&gt; Iterator[str]:\n    nucleotides = [\"A\", \"T\", \"G\", \"C\"]\n    for i, current_base in enumerate(sequence):\n        for new_base in nucleotides:\n            if new_base != current_base:\n                yield sequence[:i] + new_base + sequence[i + 1:]\n\ndef generate_neighbors(sequence: str, max_distance: int) -&gt; Set[str]:\n    nucleotides = [\"A\", \"T\", \"G\", \"C\"]\n    if max_distance == 0:\n        return {sequence}\n    if len(sequence) == 1:\n        return set(nucleotides)\n    \n    neighbors = set()\n    suffix_neighbors = generate_neighbors(sequence[1:], max_distance)\n    for suffix in suffix_neighbors:\n        if calculate_hamming_distance(sequence[1:], suffix) &lt; max_distance:\n            neighbors.update(base + suffix for base in nucleotides)\n        else:\n            neighbors.add(sequence[0] + suffix)\n    return neighbors\n\ndef parse_input(input_data: str) -&gt; Tuple[str, int]:\n    sequence, distance = input_data.strip().split(\"\\n\")\n    return sequence, int(distance)\n\nsample_input = \"\"\"\nACG\n1\n\"\"\"\n\nsequence, max_distance = parse_input(sample_input)\nneighbor_sequences = generate_neighbors(sequence, max_distance)\nprint(*sorted(neighbor_sequences), sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-14",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-14",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "14.1 Sample Dataset",
    "text": "14.1 Sample Dataset\n3 1\nATTTGGC\nTGCCTTA\nCGGTATC\nGAAAATT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-14",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-14",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "14.2 Sample Output",
    "text": "14.2 Sample Output\nATA ATT GTT TTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-14",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-14",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "14.3 Solution",
    "text": "14.3 Solution\nfrom typing import List, Set, Iterator\n\ndef calculate_hamming_distance(sequence1: str, sequence2: str) -&gt; int:\n    return sum(c1 != c2 for c1, c2 in zip(sequence1, sequence2))\n\ndef generate_neighbors(sequence: str, max_distance: int) -&gt; Set[str]:\n    nucleotides = [\"A\", \"T\", \"G\", \"C\"]\n    if max_distance == 0:\n        return {sequence}\n    if len(sequence) == 1:\n        return set(nucleotides)\n    \n    neighbor_set = set()\n    for neighbor in generate_neighbors(sequence[1:], max_distance):\n        if calculate_hamming_distance(sequence[1:], neighbor) &lt; max_distance:\n            for nucleotide in nucleotides:\n                neighbor_set.add(nucleotide + neighbor)\n        else:\n            neighbor_set.add(sequence[0] + neighbor)\n    return neighbor_set\n\ndef generate_substrings(text: str, substring_length: int) -&gt; Iterator[str]:\n    for i in range(len(text) - substring_length + 1):\n        yield text[i : i + substring_length]\n\ndef get_all_kmers(dna_sequences: List[str], kmer_length: int) -&gt; Set[str]:\n    return set(kmer for sequence in dna_sequences for kmer in generate_substrings(sequence, kmer_length))\n\ndef contains_approximate_match(pattern: str, text: str, max_distance: int) -&gt; bool:\n    return any(calculate_hamming_distance(substring, pattern) &lt;= max_distance \n               for substring in generate_substrings(text, len(pattern)))\n\ndef enumerate_motifs(dna_sequences: List[str], kmer_length: int, max_distance: int) -&gt; Set[str]:\n    motif_patterns = set()\n    for kmer in get_all_kmers(dna_sequences, kmer_length):\n        for neighbor_kmer in generate_neighbors(kmer, max_distance):\n            if all(contains_approximate_match(neighbor_kmer, sequence, max_distance) for sequence in dna_sequences):\n                motif_patterns.add(neighbor_kmer)\n    return motif_patterns\n\n# Sample input\nsample_input = \"\"\"\n3 1\nATTTGGC\nTGCCTTA\nCGGTATC\nGAAAATT\n\"\"\"\n\ninput_params, *dna_sequences = sample_input.strip().split(\"\\n\")\nkmer_length, max_distance = map(int, input_params.split())\nprint(*sorted(enumerate_motifs(dna_sequences, kmer_length, max_distance)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-15",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-15",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "15.1 Sample Dataset",
    "text": "15.1 Sample Dataset\n3\nAAATTGACGCAT\nGACGACCACGTT\nCGTCAGCGCCTG\nGCTGAGCACCGG\nAGTACGGGACAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-15",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-15",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "15.2 Sample Output",
    "text": "15.2 Sample Output\nACG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-15",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-15",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "15.3 Solution",
    "text": "15.3 Solution\nfrom typing import Iterator, List\nfrom itertools import product\nimport math\n\ndef generate_substrings(text: str, substring_length: int) -&gt; Iterator[str]:\n    for i in range(len(text) - substring_length + 1):\n        yield text[i : i + substring_length]\n\ndef generate_kmers(kmer_length: int) -&gt; Iterator[str]:\n    return (\"\".join(nucleotides) for nucleotides in product(\"ACGT\", repeat=kmer_length))\n\ndef calculate_hamming_distance(sequence1: str, sequence2: str) -&gt; int:\n    return sum(nucleotide1 != nucleotide2 for nucleotide1, nucleotide2 in zip(sequence1, sequence2))\n\ndef find_minimum_distance(pattern: str, text: str) -&gt; int:\n    return min(calculate_hamming_distance(substring, pattern) for substring in generate_substrings(text, len(pattern)))\n\ndef calculate_total_distance(pattern: str, dna_sequences: List[str]) -&gt; int:\n    return sum(find_minimum_distance(pattern, sequence) for sequence in dna_sequences)\n\ndef find_median_string(dna_sequences: List[str], kmer_length: int) -&gt; str:\n    min_distance = math.inf\n    median_kmer = \"\"\n    \n    for kmer in generate_kmers(kmer_length):\n        current_distance = calculate_total_distance(kmer, dna_sequences)\n        if current_distance &lt; min_distance:\n            min_distance = current_distance\n            median_kmer = kmer\n    \n    return median_kmer\n\n# Sample input\nsample_input = \"\"\"\n3\nAAATTGACGCAT\nGACGACCACGTT\nCGTCAGCGCCTG\nGCTGAGCACCGG\nAGTACGGGACAG\n\"\"\"\n\nkmer_length, *dna_sequences = sample_input.strip().split(\"\\n\")\nresult = find_median_string(dna_sequences, int(kmer_length))\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-16",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-16",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "16.1 Sample Dataset",
    "text": "16.1 Sample Dataset\nACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT\n5\n0.2 0.2 0.3 0.2 0.3\n0.4 0.3 0.1 0.5 0.1\n0.3 0.3 0.5 0.2 0.4\n0.1 0.2 0.1 0.1 0.2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-16",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-16",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "16.2 Sample Output",
    "text": "16.2 Sample Output\nCCGAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-16",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-16",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "16.3 Solution",
    "text": "16.3 Solution\nfrom typing import Iterator, List\nimport math\n\ndef generate_substrings(text: str, substring_length: int) -&gt; Iterator[str]:\n    for i in range(len(text) - substring_length + 1):\n        yield text[i : i + substring_length]\n\ndef find_profile_most_probable_kmer(sequence: str, kmer_length: int, profile_matrix: List[List[float]]) -&gt; str:\n    nucleotide_index = {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n    max_probability = -1\n    most_probable_kmer = \"\"\n\n    for kmer in generate_substrings(sequence, kmer_length):\n        kmer_probability = math.prod(profile_matrix[nucleotide_index[kmer[j]]][j] for j in range(kmer_length))\n        if kmer_probability &gt; max_probability:\n            max_probability = kmer_probability\n            most_probable_kmer = kmer\n\n    return most_probable_kmer\n\n# Sample input\nsample_input = \"\"\"\nACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT\n5\n0.2 0.2 0.3 0.2 0.3\n0.4 0.3 0.1 0.5 0.1\n0.3 0.3 0.5 0.2 0.4\n0.1 0.2 0.1 0.1 0.2\n\"\"\"\n\ndna_sequence, kmer_length, *profile_rows = sample_input.strip().split(\"\\n\")\nprofile_matrix = [list(map(float, row.split())) for row in profile_rows]\nresult = find_profile_most_probable_kmer(dna_sequence, int(kmer_length), profile_matrix)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-17",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-17",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "17.1 Sample Dataset",
    "text": "17.1 Sample Dataset\n3 5\nGGCGTTCAGGCA\nAAGAATCAGTCA\nCAAGGAGTTCGC\nCACGTCAATCAC\nCAATAATATTCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-17",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-17",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "17.2 Sample Output",
    "text": "17.2 Sample Output\nCAG\nCAG\nCAA\nCAA\nCAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-17",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-17",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "17.3 Solution",
    "text": "17.3 Solution\nfrom typing import Iterator, List, Dict\nfrom collections import Counter\nimport math\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; Iterator[str]:\n    for i in range(len(sequence) - kmer_length + 1):\n        yield sequence[i : i + kmer_length]\n\ndef find_most_probable_kmer(sequence: str, kmer_length: int, profile: List[List[float]]) -&gt; str:\n    nucleotide_to_index: Dict[str, int] = {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n    max_probability: float = -1\n    most_probable_kmer: str = \"\"\n\n    for kmer in generate_kmers(sequence, kmer_length):\n        kmer_probability: float = math.prod(profile[nucleotide_to_index[kmer[j]]][j] for j in range(kmer_length))\n        if kmer_probability &gt; max_probability:\n            max_probability = kmer_probability\n            most_probable_kmer = kmer\n\n    return most_probable_kmer\n\ndef create_profile(sequences: List[str], pseudocount: int = 0) -&gt; List[List[float]]:\n    nucleotides: List[str] = [\"A\", \"C\", \"G\", \"T\"]\n    profile: List[List[float]] = [[] for _ in nucleotides]\n    for i, nucleotide in enumerate(nucleotides):\n        profile[i] = [\n            (sum(seq[j] == nucleotide for seq in sequences) + pseudocount) / len(sequences)\n            for j in range(len(sequences[0]))\n        ]\n    return profile\n\ndef calculate_score(motifs: List[str]) -&gt; int:\n    score: int = 0\n    for i in range(len(motifs[0])):\n        column: List[str] = [motif[i] for motif in motifs]\n        most_common: str = Counter(column).most_common()[0][0]\n        score += sum(nucleotide != most_common for nucleotide in column)\n    return score\n\ndef greedy_motif_search(dna_sequences: List[str], kmer_length: int, pseudocount: int = 0) -&gt; List[str]:\n    best_motifs: List[str] = [seq[:kmer_length] for seq in dna_sequences]\n    for kmer in generate_kmers(dna_sequences[0], kmer_length):\n        current_motifs: List[str] = [kmer]\n        for i in range(1, len(dna_sequences)):\n            current_profile: List[List[float]] = create_profile(current_motifs, pseudocount=pseudocount)\n            current_motifs.append(find_most_probable_kmer(dna_sequences[i], kmer_length, current_profile))\n        if calculate_score(current_motifs) &lt; calculate_score(best_motifs):\n            best_motifs = current_motifs\n    return best_motifs\n\n# Sample input\nsample_input: str = \"\"\"\n3 5\nGGCGTTCAGGCA\nAAGAATCAGTCA\nCAAGGAGTTCGC\nCACGTCAATCAC\nCAATAATATTCG\n\"\"\"\n\nints, *dna = sample_input.strip().split(\"\\n\")\nk, t = map(int, ints.split())\nresult: List[str] = greedy_motif_search(dna, k)\nprint(*result, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-18",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-18",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "18.1 Sample Dataset",
    "text": "18.1 Sample Dataset\n3 5\nGGCGTTCAGGCA\nAAGAATCAGTCA\nCAAGGAGTTCGC\nCACGTCAATCAC\nCAATAATATTCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-18",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-18",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "18.2 Sample Output",
    "text": "18.2 Sample Output\nTTC\nATC\nTTC\nATC\nTTC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-18",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-18",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "18.3 Solution",
    "text": "18.3 Solution\nfrom typing import Iterator, List, Dict\nfrom collections import Counter\nimport math\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; Iterator[str]:\n    for i in range(len(sequence) - kmer_length + 1):\n        yield sequence[i : i + kmer_length]\n\ndef find_most_probable_kmer(sequence: str, kmer_length: int, profile: List[List[float]]) -&gt; str:\n    nucleotide_to_index: Dict[str, int] = {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n    return max(\n        generate_kmers(sequence, kmer_length),\n        key=lambda kmer: math.prod(profile[nucleotide_to_index[nucleotide]][position] \n                                   for position, nucleotide in enumerate(kmer))\n    )\n\ndef create_profile(motifs: List[str], pseudocount: int = 0) -&gt; List[List[float]]:\n    nucleotides: List[str] = [\"A\", \"C\", \"G\", \"T\"]\n    motif_count: int = len(motifs)\n    motif_length: int = len(motifs[0])\n    \n    return [\n        [(sum(motif[position] == nucleotide for motif in motifs) + pseudocount) / motif_count \n         for position in range(motif_length)]\n        for nucleotide in nucleotides\n    ]\n\ndef calculate_score(motifs: List[str]) -&gt; int:\n    return sum(\n        sum(nucleotide != Counter(column).most_common(1)[0][0] for nucleotide in column)\n        for column in zip(*motifs)\n    )\n\ndef greedy_motif_search(dna_sequences: List[str], kmer_length: int, pseudocount: int = 0) -&gt; List[str]:\n    best_motifs: List[str] = [sequence[:kmer_length] for sequence in dna_sequences]\n    \n    for kmer in generate_kmers(dna_sequences[0], kmer_length):\n        current_motifs: List[str] = [kmer]\n        for sequence in dna_sequences[1:]:\n            profile: List[List[float]] = create_profile(current_motifs, pseudocount)\n            current_motifs.append(find_most_probable_kmer(sequence, kmer_length, profile))\n        \n        if calculate_score(current_motifs) &lt; calculate_score(best_motifs):\n            best_motifs = current_motifs\n    \n    return best_motifs\n\n# Sample input\nsample_input: str = \"\"\"\n3 5\nGGCGTTCAGGCA\nAAGAATCAGTCA\nCAAGGAGTTCGC\nCACGTCAATCAC\nCAATAATATTCG\n\"\"\"\n\nk_value, _, *dna_sequences = sample_input.strip().split()\nk_value = int(k_value)\nresult: List[str] = greedy_motif_search(dna_sequences, k_value, pseudocount=1)\nprint(*result, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-19",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-19",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "19.1 Sample Dataset",
    "text": "19.1 Sample Dataset\n8 5\nCGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA\nGGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG\nTAGTACCGAGACCGAAAGAAGTATACAGGCGT\nTAGATCAAGTTTCAGGTGCACGTCGGTGAACC\nAATCCACCAGCTCCACGTGCAATGTTGGCCTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-19",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-19",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "19.2 Sample Output",
    "text": "19.2 Sample Output\nAACGGCCA\nAAGTGCCA\nTAGTACCG\nAAGTTTCA\nACGTGCAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-19",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-19",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "19.3 Solution",
    "text": "19.3 Solution\nfrom typing import List, Tuple, Callable\nfrom collections import Counter\nfrom random import randint\nimport math\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; List[str]:\n    return [sequence[i:i+kmer_length] for i in range(len(sequence) - kmer_length + 1)]\n\ndef find_most_probable_kmer(sequence: str, kmer_length: int, profile: List[List[float]]) -&gt; str:\n    nucleotide_to_index = {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n    return max(\n        generate_kmers(sequence, kmer_length),\n        key=lambda kmer: math.prod(profile[nucleotide_to_index[nucleotide]][j] for j, nucleotide in enumerate(kmer))\n    )\n\ndef create_profile(motifs: List[str], pseudocount: int = 0) -&gt; List[List[float]]:\n    nucleotides = [\"A\", \"C\", \"G\", \"T\"]\n    profile = []\n    for nucleotide in nucleotides:\n        profile.append([\n            (sum(seq[j] == nucleotide for seq in motifs) + pseudocount) / (len(motifs) + 4 * pseudocount)\n            for j in range(len(motifs[0]))\n        ])\n    return profile\n\ndef calculate_score(motifs: List[str]) -&gt; int:\n    return sum(\n        sum(nucleotide != Counter(column).most_common(1)[0][0] for nucleotide in column)\n        for column in zip(*motifs)\n    )\n\ndef generate_random_kmer(sequence: str, kmer_length: int) -&gt; str:\n    start = randint(0, len(sequence) - kmer_length)\n    return sequence[start : start + kmer_length]\n\ndef find_motifs(profile: List[List[float]], dna_sequences: List[str]) -&gt; List[str]:\n    kmer_length = len(profile[0])\n    return [find_most_probable_kmer(seq, kmer_length, profile) for seq in dna_sequences]\n\ndef randomized_motif_search(dna_sequences: List[str], kmer_length: int) -&gt; Tuple[int, List[str]]:\n    motifs = [generate_random_kmer(seq, kmer_length) for seq in dna_sequences]\n    best_score = math.inf\n    \n    while True:\n        profile = create_profile(motifs, pseudocount=1)\n        motifs = find_motifs(profile, dna_sequences)\n        current_score = calculate_score(motifs)\n        \n        if current_score &gt;= best_score:\n            return best_score, motifs\n        \n        best_score = current_score\n\ndef find_best_motifs(search_function: Callable, iterations: int, *args) -&gt; List[str]:\n    best_score, best_motifs = search_function(*args)\n    \n    for _ in range(iterations - 1):\n        score, motifs = search_function(*args)\n        if score &lt; best_score:\n            best_score, best_motifs = score, motifs\n    \n    return best_motifs\n\n# Sample input\nsample_input = \"\"\"\n8 5\nCGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA\nGGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG\nTAGTACCGAGACCGAAAGAAGTATACAGGCGT\nTAGATCAAGTTTCAGGTGCACGTCGGTGAACC\nAATCCACCAGCTCCACGTGCAATGTTGGCCTA\n\"\"\"\n\nkmer_length, _, *dna_sequences = sample_input.strip().split()\nkmer_length = int(kmer_length)\n\nresult = find_best_motifs(randomized_motif_search, 1000, dna_sequences, kmer_length)\nprint(*result, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-20",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-20",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "20.1 Sample Dataset",
    "text": "20.1 Sample Dataset\n8 5 100\nCGCCCCTCTCGGGGGTGTTCAGTAAACGGCCA\nGGGCGAGGTATGTGTAAGTGCCAAGGTGCCAG\nTAGTACCGAGACCGAAAGAAGTATACAGGCGT\nTAGATCAAGTTTCAGGTGCACGTCGGTGAACC\nAATCCACCAGCTCCACGTGCAATGTTGGCCTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-20",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-20",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "20.2 Sample Output",
    "text": "20.2 Sample Output\nTCTCGGGG\nCCAAGGTG\nTACAGGCG\nTTCAGGTG\nTCCACGTG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-20",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-20",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "20.3 Solution",
    "text": "20.3 Solution\nfrom typing import List, Iterator, Tuple, Callable\nfrom collections import Counter\nimport math\nimport random\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; Iterator[str]:\n    for i in range(len(sequence) - kmer_length + 1):\n        yield sequence[i : i + kmer_length]\n\ndef create_profile(motifs: List[str], pseudocount: int = 0) -&gt; List[List[float]]:\n    nucleotides: List[str] = [\"A\", \"C\", \"G\", \"T\"]\n    motif_count: int = len(motifs)\n    motif_length: int = len(motifs[0])\n    \n    return [\n        [(sum(motif[position] == nucleotide for motif in motifs) + pseudocount) / (motif_count + 4*pseudocount)\n         for position in range(motif_length)]\n        for nucleotide in nucleotides\n    ]\n\ndef calculate_score(motifs: List[str]) -&gt; int:\n    return sum(\n        sum(nucleotide != Counter(column).most_common(1)[0][0] for nucleotide in column)\n        for column in zip(*motifs)\n    )\n\ndef generate_random_kmer(sequence: str, kmer_length: int) -&gt; str:\n    start_index = random.randint(0, len(sequence) - kmer_length)\n    return sequence[start_index : start_index + kmer_length]\n\ndef find_best_motifs(search_function: Callable, iterations: int, *args) -&gt; List[str]:\n    best_score, best_motifs = search_function(*args)\n    for _ in range(iterations - 1):\n        score, motifs = search_function(*args)\n        if score &lt; best_score:\n            best_score, best_motifs = score, motifs\n    return best_motifs\n\ndef calculate_kmer_probabilities(sequence: str, kmer_length: int, profile: List[List[float]]) -&gt; List[float]:\n    nucleotide_to_index: Dict[str, int] = {\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3}\n    return [\n        math.prod(profile[nucleotide_to_index[kmer[j]]][j] for j in range(kmer_length))\n        for kmer in generate_kmers(sequence, kmer_length)\n    ]\n\ndef select_random_kmer(sequence: str, kmer_length: int, profile: List[List[float]]) -&gt; str:\n    probabilities = calculate_kmer_probabilities(sequence, kmer_length, profile)\n    start_index = random.choices(range(len(probabilities)), probabilities)[0]\n    return sequence[start_index : start_index + kmer_length]\n\ndef gibbs_sampler(dna_sequences: List[str], kmer_length: int, num_iterations: int) -&gt; Tuple[int, List[str]]:\n    motifs = [generate_random_kmer(seq, kmer_length) for seq in dna_sequences]\n    best_motifs = motifs.copy()\n    for _ in range(num_iterations):\n        i = random.randint(0, len(dna_sequences) - 1)\n        profile = create_profile(motifs[:i] + motifs[i + 1 :], pseudocount=1)\n        motifs[i] = select_random_kmer(dna_sequences[i], kmer_length, profile)\n        if calculate_score(motifs) &lt; calculate_score(best_motifs):\n            best_motifs = motifs.copy()\n    return calculate_score(best_motifs), best_motifs\n\n# Sample input\nsample_input = \"\"\"\n8 5 100\nTCTCGGGG\nCCAAGGTG\nTACAGGCG\nTTCAGGTG\nTCCACGTG\n\"\"\"\n\nkmer_length, num_sequences, num_iterations, *dna_sequences = sample_input.strip().split()\nkmer_length = int(kmer_length)\nnum_iterations = int(num_iterations)\nresult = find_best_motifs(gibbs_sampler, 20, dna_sequences, kmer_length, num_iterations)\nprint(*result, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-21",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-21",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "21.1 Sample Dataset",
    "text": "21.1 Sample Dataset\nAAA\nTTACCTTAAC GATATCTGTC ACGGCGTTCG CCCTAAAGAG CGTCAGAGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-21",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-21",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "21.2 Sample Output",
    "text": "21.2 Sample Output\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-21",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-21",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "21.3 Solution",
    "text": "21.3 Solution\nfrom typing import List, Iterator\nimport math\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; Iterator[str]:\n    for i in range(len(sequence) - kmer_length + 1):\n        yield sequence[i : i + kmer_length]\n\ndef calculate_hamming_distance(seq1: str, seq2: str) -&gt; int:\n    return sum(base1 != base2 for base1, base2 in zip(seq1, seq2))\n\ndef find_minimum_distance(pattern: str, text: str) -&gt; int:\n    return min(calculate_hamming_distance(kmer, pattern) for kmer in generate_kmers(text, len(pattern)))\n\ndef calculate_pattern_distance_to_strings(pattern: str, dna_strings: List[str]) -&gt; int:\n    return sum(find_minimum_distance(pattern, dna_string) for dna_string in dna_strings)\n\n# Sample input\nsample_input = \"\"\"\nAAA\nTTACCTTAAC GATATCTGTC ACGGCGTTCG CCCTAAAGAG CGTCAGAGGT\n\"\"\"\n\npattern, dna_strings_raw = sample_input.strip().split(\"\\n\")\ndna_strings = dna_strings_raw.split()\n\nresult = calculate_pattern_distance_to_strings(pattern, dna_strings)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-22",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-22",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "22.1 Sample Dataset",
    "text": "22.1 Sample Dataset\n5\nCAATCCAAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-22",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-22",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "22.2 Sample Output",
    "text": "22.2 Sample Output\nCAATC\nAATCC\nATCCA\nTCCAA\nCCAAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-22",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-22",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "22.3 Solution",
    "text": "22.3 Solution\nfrom typing import Iterator\n\ndef generate_kmers(sequence: str, kmer_length: int) -&gt; Iterator[str]:\n    for i in range(len(sequence) - kmer_length + 1):\n        yield sequence[i:i + kmer_length]\n\nsample_input: str = \"\"\"\n5\nCAATCCAAC\n\"\"\"\n\ninput_lines: list[str] = sample_input.strip().split(\"\\n\")\nkmer_length: int = int(input_lines[0])\ndna_sequence: str = input_lines[1]\n\nfor kmer in generate_kmers(dna_sequence, kmer_length):\n    print(kmer)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-23",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-23",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "23.1 Sample Dataset",
    "text": "23.1 Sample Dataset\nACCGA\nCCGAA\nCGAAG\nGAAGC\nAAGCT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-23",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-23",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "23.2 Sample Output",
    "text": "23.2 Sample Output\nACCGAAGCT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-23",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-23",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "23.3 Solution",
    "text": "23.3 Solution\nfrom typing import List\n\ndef reconstruct_dna_sequence(kmers: List[str]) -&gt; str:\n    reconstructed_sequence: str = kmers[0]\n    for i in range(1, len(kmers)):\n        reconstructed_sequence += kmers[i][-1]\n    return reconstructed_sequence\n\nsample_input: str = \"\"\"\nACCGA\nCCGAA\nCGAAG\nGAAGC\nAAGCT\n\"\"\"\n\nkmer_list: List[str] = sample_input.strip().split(\"\\n\")\nprint(reconstruct_dna_sequence(kmer_list))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-24",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-24",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "24.1 Sample Dataset",
    "text": "24.1 Sample Dataset\nATGCG\nGCATG\nCATGC\nAGGCA\nGGCAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-24",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-24",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "24.2 Sample Output",
    "text": "24.2 Sample Output\nGCATG -&gt; CATGC\nCATGC -&gt; ATGCG\nAGGCA -&gt; GGCAT\nGGCAT -&gt; GCATG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-24",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-24",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "24.3 Solution",
    "text": "24.3 Solution\nfrom typing import List\n\ndef overlap_graph(patterns: List[str]) -&gt; List[tuple[str, str]]:\n    adj_list = []\n    for i in range(len(patterns)):\n        for j in range(len(patterns)):\n            if i != j and patterns[i][1:] == patterns[j][:-1]:\n                adj_list.append((patterns[i], patterns[j]))\n    return adj_list\n\nsample_input = \"\"\"\nATGCG\nGCATG\nCATGC\nAGGCA\nGGCAT\n\"\"\"\n\nPatterns: List[str] = sample_input.strip().split(\"\\n\")\n\nadj_list = overlap_graph(Patterns)\nfor edge in adj_list:\n    print(f\"{edge[0]} -&gt; {edge[1]}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-25",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-25",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "25.1 Sample Dataset",
    "text": "25.1 Sample Dataset\n4\nAAGATTCTCTAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-25",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-25",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "25.2 Sample Output",
    "text": "25.2 Sample Output\nAAG -&gt; AGA\nAGA -&gt; GAT\nATT -&gt; TTC\nCTA -&gt; TAC\nCTC -&gt; TCT\nGAT -&gt; ATT\nTCT -&gt; CTA,CTC\nTTC -&gt; TCT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-25",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-25",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "25.3 Solution",
    "text": "25.3 Solution\nfrom collections import OrderedDict\nfrom typing import List, Set, OrderedDict as OrderedDictType\n\ndef construct_de_bruijn_graph(sequence: str, kmer_length: int) -&gt; OrderedDictType[str, Set[str]]:\n    adjacency_list: OrderedDictType[str, Set[str]] = OrderedDict()\n    \n    for i in range(len(sequence) - kmer_length + 2):\n        adjacency_list[sequence[i:i + kmer_length - 1]] = set()\n\n    for i in range(len(sequence) - kmer_length + 1):\n        prefix = sequence[i:i + kmer_length - 1]\n        suffix = sequence[i + 1:i + kmer_length]\n        adjacency_list[prefix].add(suffix)\n\n    return adjacency_list\n\nsample_input: str = \"\"\"\n4\nAAGATTCTCTAC\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nkmer_length: int = int(input_lines[0])\ndna_sequence: str = input_lines[1]\n\nadjacency_list = construct_de_bruijn_graph(dna_sequence, kmer_length)\nfor node, neighbors in adjacency_list.items():\n    if neighbors:\n        print(f\"{node} -&gt; {','.join(neighbors)}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-26",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-26",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "26.1 Sample Dataset",
    "text": "26.1 Sample Dataset\nGAGG\nCAGG\nGGGG\nGGGA\nCAGG\nAGGG\nGGAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-26",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-26",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "26.2 Sample Output",
    "text": "26.2 Sample Output\nGAG -&gt; AGG\nCAG -&gt; AGG,AGG\nGGG -&gt; GGG,GGA\nAGG -&gt; GGG\nGGA -&gt; GAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-26",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-26",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "26.3 Solution",
    "text": "26.3 Solution\nfrom typing import List, Dict\n\ndef construct_de_bruijn_graph(kmers: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_list: Dict[str, List[str]] = {}\n    for kmer in kmers:\n        prefix = kmer[:-1]\n        suffix = kmer[1:]\n        if prefix not in adjacency_list:\n            adjacency_list[prefix] = [suffix]\n        else:\n            adjacency_list[prefix].append(suffix)\n    return adjacency_list\n\nsample_input: str = \"\"\"\nGAGG\nCAGG\nGGGG\nGGGA\nCAGG\nAGGG\nGGAG\n\"\"\"\n\nkmer_list: List[str] = sample_input.strip().split(\"\\n\")\n\nadjacency_list = construct_de_bruijn_graph(kmer_list)\nfor node, neighbors in adjacency_list.items():\n    print(f\"{node} -&gt; {','.join(neighbors)}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-27",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-27",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "27.1 Sample Dataset",
    "text": "27.1 Sample Dataset\n0 -&gt; 3\n1 -&gt; 0\n2 -&gt; 1,6\n3 -&gt; 2\n4 -&gt; 2\n5 -&gt; 4\n6 -&gt; 5,8\n7 -&gt; 9\n8 -&gt; 7\n9 -&gt; 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-27",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-27",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "27.2 Sample Output",
    "text": "27.2 Sample Output\n6-&gt;8-&gt;7-&gt;9-&gt;6-&gt;5-&gt;4-&gt;2-&gt;1-&gt;0-&gt;3-&gt;2-&gt;6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-27",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-27",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "27.3 Solution",
    "text": "27.3 Solution\nfrom re import split\nfrom random import choice\nfrom typing import Dict, List, Tuple\n\ndef parse_adjacency_list(adjacency_list_text: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = {}\n    for element in adjacency_list_text:\n        node, neighbors = split(' -&gt; ', element)\n        adjacency_dict[node] = neighbors.split(',')\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_eulerian_cycle(graph: Dict[str, List[str]]) -&gt; List[str]:\n    # Form a cycle by randomly walking in the graph\n    start_node, edges = choice(list(graph.items()))\n    next_node = choice(edges)\n    graph = remove_edge(graph, start_node, next_node)\n\n    cycle: List[str] = [start_node, next_node]\n    current_node = next_node\n    while current_node != start_node:\n        edges = graph[current_node]\n        next_node = choice(edges)\n        graph = remove_edge(graph, current_node, next_node)\n        current_node = next_node\n        cycle.append(current_node)\n\n    while graph:\n        potential_starts: List[Tuple[int, str]] = [(idx, node) for idx, node in enumerate(cycle) if node in graph]\n        idx, new_start = choice(potential_starts)\n\n        # Form new_cycle by traversing cycle (starting at new_start) and then randomly walking\n        new_cycle = cycle[idx:] + cycle[1:idx + 1]\n\n        next_node = choice(graph[new_start])\n        graph = remove_edge(graph, new_start, next_node)\n        current_node = next_node\n        new_cycle.append(current_node)\n        while current_node != new_start:\n            edges = graph[current_node]\n            next_node = choice(edges)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n            new_cycle.append(current_node)\n        cycle = new_cycle\n    return cycle\n\nsample_input: str = \"\"\"\n0 -&gt; 3\n1 -&gt; 0\n2 -&gt; 1,6\n3 -&gt; 2\n4 -&gt; 2\n5 -&gt; 4\n6 -&gt; 5,8\n7 -&gt; 9\n8 -&gt; 7\n9 -&gt; 6\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nadjacency_list = parse_adjacency_list(input_lines)\n\nprint(\"-&gt;\".join(find_eulerian_cycle(adjacency_list)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-28",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-28",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "28.1 Sample Dataset",
    "text": "28.1 Sample Dataset\n0 -&gt; 2\n1 -&gt; 3\n2 -&gt; 1\n3 -&gt; 0,4\n6 -&gt; 3,7\n7 -&gt; 8\n8 -&gt; 9\n9 -&gt; 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-28",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-28",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "28.2 Sample Output",
    "text": "28.2 Sample Output\n6-&gt;7-&gt;8-&gt;9-&gt;6-&gt;3-&gt;0-&gt;2-&gt;1-&gt;3-&gt;4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-28",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-28",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "28.3 Solution",
    "text": "28.3 Solution\nfrom re import split\nfrom random import choice\nfrom typing import Dict, List, Tuple\n\ndef parse_adjacency_list(adjacency_text: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = {}\n    for line in adjacency_text:\n        node, neighbors = split(' -&gt; ', line)\n        adjacency_dict[node] = neighbors.split(',')\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_eulerian_cycle(graph: Dict[str, List[str]]) -&gt; List[str]:\n    start_node, edges = choice(list(graph.items()))\n    next_node = choice(edges)\n    graph = remove_edge(graph, start_node, next_node)\n\n    cycle: List[str] = [start_node, next_node]\n    current_node = next_node\n    while current_node != start_node:\n        edges = graph[current_node]\n        next_node = choice(edges)\n        graph = remove_edge(graph, current_node, next_node)\n        current_node = next_node\n        cycle.append(current_node)\n\n    while graph:\n        potential_starts: List[Tuple[int, str]] = [(idx, node) for idx, node in enumerate(cycle) if node in graph]\n        idx, new_start = choice(potential_starts)\n\n        new_cycle = cycle[idx:] + cycle[1:idx + 1]\n\n        next_node = choice(graph[new_start])\n        graph = remove_edge(graph, new_start, next_node)\n        current_node = next_node\n        new_cycle.append(current_node)\n        while current_node != new_start:\n            edges = graph[current_node]\n            next_node = choice(edges)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n            new_cycle.append(current_node)\n        cycle = new_cycle\n    return cycle\n\ndef find_eulerian_path(graph: Dict[str, List[str]]) -&gt; List[str]:\n    degree_differences: Dict[str, int] = {}\n    for source, targets in graph.items():\n        degree_differences[source] = degree_differences.get(source, 0) + len(targets)\n        for target in targets:\n            degree_differences[target] = degree_differences.get(target, 0) - 1\n\n    start_node = [node for node, diff in degree_differences.items() if diff == -1][0]\n    end_node = [node for node, diff in degree_differences.items() if diff == 1][0]\n    \n    if start_node in graph:\n        graph[start_node].append(end_node)\n    else:\n        graph[start_node] = [end_node]\n\n    cycle = find_eulerian_cycle(graph)\n    for idx, node in enumerate(cycle):\n        if node == start_node and cycle[(idx + 1) % len(cycle)] == end_node:\n            return cycle[idx + 1:] + cycle[1:idx + 1]\n\n    return cycle  # This should never happen if the input is valid\n\nsample_input: str = \"\"\"\n0 -&gt; 2\n1 -&gt; 3\n2 -&gt; 1\n3 -&gt; 0,4\n6 -&gt; 3,7\n7 -&gt; 8\n8 -&gt; 9\n9 -&gt; 6\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nadjacency_list = parse_adjacency_list(input_lines)\n\nprint(\"-&gt;\".join(find_eulerian_path(adjacency_list)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-29",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-29",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "29.1 Sample Dataset",
    "text": "29.1 Sample Dataset\n4\nCTTA\nACCA\nTACC\nGGCT\nGCTT\nTTAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-29",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-29",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "29.2 Sample Output",
    "text": "29.2 Sample Output\nGGCTTACCA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-29",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-29",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "29.3 Solution",
    "text": "29.3 Solution\nfrom typing import List, Dict, Tuple\nfrom random import choice\n\ndef construct_de_bruijn_graph(kmers: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = {}\n    for kmer in kmers:\n        prefix = kmer[:-1]\n        suffix = kmer[1:]\n        if prefix not in adjacency_dict:\n            adjacency_dict[prefix] = [suffix]\n        else:\n            adjacency_dict[prefix].append(suffix)\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_eulerian_cycle(graph: Dict[str, List[str]]) -&gt; List[str]:\n    start_node, edges = choice(list(graph.items()))\n    next_node = choice(edges)\n    graph = remove_edge(graph, start_node, next_node)\n\n    cycle: List[str] = [start_node, next_node]\n    current_node = next_node\n    while current_node != start_node:\n        edges = graph[current_node]\n        next_node = choice(edges)\n        graph = remove_edge(graph, current_node, next_node)\n        current_node = next_node\n        cycle.append(current_node)\n\n    while graph:\n        potential_starts: List[Tuple[int, str]] = [(idx, node) for idx, node in enumerate(cycle) if node in graph]\n        idx, new_start = choice(potential_starts)\n\n        new_cycle = cycle[idx:] + cycle[1:idx + 1]\n\n        next_node = choice(graph[new_start])\n        graph = remove_edge(graph, new_start, next_node)\n        current_node = next_node\n        new_cycle.append(current_node)\n        while current_node != new_start:\n            edges = graph[current_node]\n            next_node = choice(edges)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n            new_cycle.append(current_node)\n        cycle = new_cycle\n    return cycle\n\ndef find_eulerian_path(graph: Dict[str, List[str]]) -&gt; List[str]:\n    degree_differences: Dict[str, int] = {}\n    for source, targets in graph.items():\n        degree_differences[source] = degree_differences.get(source, 0) + len(targets)\n        for target in targets:\n            degree_differences[target] = degree_differences.get(target, 0) - 1\n\n    start_node = [node for node, diff in degree_differences.items() if diff == -1][0]\n    end_node = [node for node, diff in degree_differences.items() if diff == 1][0]\n    \n    if start_node in graph:\n        graph[start_node].append(end_node)\n    else:\n        graph[start_node] = [end_node]\n\n    cycle = find_eulerian_cycle(graph)\n    for idx, node in enumerate(cycle):\n        if node == start_node and cycle[(idx + 1) % len(cycle)] == end_node:\n            return cycle[idx + 1:] + cycle[1:idx + 1]\n\n    return cycle  # This should never happen if the input is valid\n\ndef reconstruct_string(kmers: List[str]) -&gt; str:\n    adjacency_list = construct_de_bruijn_graph(kmers)\n    path = find_eulerian_path(adjacency_list)\n    reconstructed_string = path[0][:-1]\n    for node in path:\n        reconstructed_string += node[-1]\n    return reconstructed_string\n\nsample_input: str = \"\"\"\n4\nCTTA\nACCA\nTACC\nGGCT\nGCTT\nTTAC\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nk: int = int(input_lines[0])\nkmers: List[str] = input_lines[1:]\n\nprint(reconstruct_string(kmers))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-30",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-30",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "30.1 Sample Dataset",
    "text": "30.1 Sample Dataset\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-30",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-30",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "30.2 Sample Output",
    "text": "30.2 Sample Output\n1111010010110000"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-30",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-30",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "30.3 Solution",
    "text": "30.3 Solution\nfrom typing import List, Dict, Tuple\nfrom random import choice\n\ndef construct_de_bruijn_graph(kmers: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = {}\n    for kmer in kmers:\n        prefix = kmer[:-1]\n        suffix = kmer[1:]\n        if prefix not in adjacency_dict:\n            adjacency_dict[prefix] = [suffix]\n        else:\n            adjacency_dict[prefix].append(suffix)\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_eulerian_cycle(graph: Dict[str, List[str]]) -&gt; List[str]:\n    start_node, edges = choice(list(graph.items()))\n    next_node = choice(edges)\n    graph = remove_edge(graph, start_node, next_node)\n\n    cycle: List[str] = [start_node, next_node]\n    current_node = next_node\n    while current_node != start_node:\n        edges = graph[current_node]\n        next_node = choice(edges)\n        graph = remove_edge(graph, current_node, next_node)\n        current_node = next_node\n        cycle.append(current_node)\n\n    while graph:\n        potential_starts: List[Tuple[int, str]] = [(idx, node) for idx, node in enumerate(cycle) if node in graph]\n        idx, new_start = choice(potential_starts)\n\n        new_cycle = cycle[idx:] + cycle[1:idx + 1]\n\n        next_node = choice(graph[new_start])\n        graph = remove_edge(graph, new_start, next_node)\n        current_node = next_node\n        new_cycle.append(current_node)\n        while current_node != new_start:\n            edges = graph[current_node]\n            next_node = choice(edges)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n            new_cycle.append(current_node)\n        cycle = new_cycle\n    return cycle\n\ndef generate_k_universal_circular_string(k: int) -&gt; str:\n    kmers: List[str] = []\n    for i in range(2 ** k):\n        kmer = format(i, f'0{k}b')\n        kmers.append(kmer)\n\n    adjacency_list = construct_de_bruijn_graph(kmers)\n    cycle = find_eulerian_cycle(adjacency_list)\n\n    cycle = cycle[:len(cycle) - k + 1]\n    circular_string = cycle[0][:-1]\n    for node in cycle:\n        circular_string += node[-1]\n    return circular_string\n\nsample_input: str = \"\"\"\n4\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nk: int = int(input_lines[0])\n\nprint(generate_k_universal_circular_string(k))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-31",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-31",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "31.1 Sample Dataset",
    "text": "31.1 Sample Dataset\n4 2\nGAGA|TTGA\nTCGT|GATG\nCGTG|ATGT\nTGGT|TGAG\nGTGA|TGTT\nGTGG|GTGA\nTGAG|GTTG\nGGTC|GAGA\nGTCG|AGAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-31",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-31",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "31.2 Sample Output",
    "text": "31.2 Sample Output\nGTGGTCGTGAGATGTTGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-31",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-31",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "31.3 Solution",
    "text": "31.3 Solution\nimport sys\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict\nfrom random import choice\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_eulerian_cycle(graph: Dict[str, List[str]]) -&gt; List[str]:\n    start_node, edges = choice(list(graph.items()))\n    next_node = choice(edges)\n    graph = remove_edge(graph, start_node, next_node)\n\n    cycle: List[str] = [start_node, next_node]\n    current_node = next_node\n    while current_node != start_node:\n        edges = graph[current_node]\n        next_node = choice(edges)\n        graph = remove_edge(graph, current_node, next_node)\n        current_node = next_node\n        cycle.append(current_node)\n\n    while graph:\n        potential_starts: List[Tuple[int, str]] = [(idx, node) for idx, node in enumerate(cycle) if node in graph]\n        idx, new_start = choice(potential_starts)\n\n        new_cycle = cycle[idx:] + cycle[1:idx + 1]\n\n        next_node = choice(graph[new_start])\n        graph = remove_edge(graph, new_start, next_node)\n        current_node = next_node\n        new_cycle.append(current_node)\n        while current_node != new_start:\n            edges = graph[current_node]\n            next_node = choice(edges)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n            new_cycle.append(current_node)\n        cycle = new_cycle\n    return cycle\n\ndef find_eulerian_path(graph: Dict[str, List[str]]) -&gt; List[str]:\n    degree_differences: Dict[str, int] = {}\n    for source, targets in graph.items():\n        degree_differences[source] = degree_differences.get(source, 0) + len(targets)\n        for target in targets:\n            degree_differences[target] = degree_differences.get(target, 0) - 1\n\n    start_node = [node for node, diff in degree_differences.items() if diff == -1][0]\n    end_node = [node for node, diff in degree_differences.items() if diff == 1][0]\n    \n    if start_node in graph:\n        graph[start_node].append(end_node)\n    else:\n        graph[start_node] = [end_node]\n\n    cycle = find_eulerian_cycle(graph)\n    for idx, node in enumerate(cycle):\n        if node == start_node and cycle[(idx + 1) % len(cycle)] == end_node:\n            return cycle[idx + 1:] + cycle[1:idx + 1]\n\n    return cycle  # This should never happen if the input is valid\n\ndef construct_de_bruijn_graph_paired_reads(paired_reads: List[Tuple[str, str]]) -&gt; Dict[Tuple[str, str], List[Tuple[str, str]]]:\n    graph = defaultdict(list)\n    for pair in paired_reads:\n        graph[(pair[0][:-1], pair[1][:-1])].append((pair[0][1:], pair[1][1:]))\n    return graph\n\ndef string_spelled_by_gapped_patterns(gapped_patterns: List[Tuple[str, str]], k: int, d: int) -&gt; str:\n    prefix_string = ''.join(pattern[0][0] for pattern in gapped_patterns[:-1]) + gapped_patterns[-1][0]\n    suffix_string = ''.join(pattern[1][0] for pattern in gapped_patterns[:-1]) + gapped_patterns[-1][1]\n    \n    for i in range(k + d + 1, len(prefix_string)):\n        if prefix_string[i] != suffix_string[i - k - d - 1]:\n            return \"-1\"\n    return prefix_string + suffix_string[len(suffix_string) - k - d - 1:]\n\ndef reconstruct_string_from_read_pairs(k: int, d: int, paired_reads: List[Tuple[str, str]]) -&gt; str:\n    graph = construct_de_bruijn_graph_paired_reads(paired_reads)\n    path = find_eulerian_path(graph)\n    return string_spelled_by_gapped_patterns(path, k - 1, d)\n\nsample_input: str = \"\"\"\n4 2\nGAGA|TTGA\nTCGT|GATG\nCGTG|ATGT\nTGGT|TGAG\nGTGA|TGTT\nGTGG|GTGA\nTGAG|GTTG\nGGTC|GAGA\nGTCG|AGAT\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nk, d = map(int, input_lines[0].split())\npaired_reads: List[Tuple[str, str]] = [tuple(line.split(\"|\")) for line in input_lines[1:]]\n\nprint(reconstruct_string_from_read_pairs(k, d, paired_reads))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-32",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-32",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "32.1 Sample Dataset",
    "text": "32.1 Sample Dataset\nATG\nATG\nTGT\nTGG\nCAT\nGGA\nGAT\nAGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-32",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-32",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "32.2 Sample Output",
    "text": "32.2 Sample Output\nAGA ATG ATG CAT GAT TGGA TGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-32",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-32",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "32.3 Solution",
    "text": "32.3 Solution\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\n\ndef construct_de_bruijn_graph(kmers: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = defaultdict(list)\n    for kmer in kmers:\n        prefix, suffix = kmer[:-1], kmer[1:]\n        adjacency_dict[prefix].append(suffix)\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_maximal_non_branching_paths(graph: Dict[str, List[str]]) -&gt; List[List[str]]:\n    paths: List[List[str]] = []\n    in_out_degrees: Dict[str, List[int]] = {}\n\n    # Calculate in and out degrees\n    for source, targets in graph.items():\n        if source not in in_out_degrees:\n            in_out_degrees[source] = [0, len(targets)]\n        else:\n            in_out_degrees[source][1] += len(targets)\n\n        for target in targets:\n            if target not in in_out_degrees:\n                in_out_degrees[target] = [1, 0]\n            else:\n                in_out_degrees[target][0] += 1\n\n    # Find all non-branching paths\n    for node in list(in_out_degrees):\n        if in_out_degrees[node] != [1, 1]:\n            if in_out_degrees[node][1] &gt; 0:\n                while node in graph:\n                    next_node = graph[node][0]\n                    non_branching_path = [node, next_node]\n                    graph = remove_edge(graph, node, next_node)\n                    while in_out_degrees[next_node] == [1, 1]:\n                        following_node = graph[next_node][0]\n                        non_branching_path.append(following_node)\n                        graph = remove_edge(graph, next_node, following_node)\n                        next_node = following_node\n                    paths.append(non_branching_path)\n\n    # Find isolated cycles\n    while graph:\n        start_node = next(iter(graph))\n        current_node = graph[start_node][0]\n        graph = remove_edge(graph, start_node, current_node)\n        cycle = [start_node, current_node]\n        while current_node != start_node:\n            next_node = graph[current_node][0]\n            cycle.append(next_node)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n        paths.append(cycle)\n\n    return paths\n\ndef generate_contigs(kmers: List[str]) -&gt; List[str]:\n    graph = construct_de_bruijn_graph(kmers)\n    paths = find_maximal_non_branching_paths(graph)\n    contigs: List[str] = []\n    for path in paths:\n        contig = path[0]\n        for node in path[1:]:\n            contig += node[-1]\n        contigs.append(contig)\n    return contigs\n\nsample_input: str = \"\"\"\nATG\nATG\nTGT\nTGG\nCAT\nGGA\nGAT\nAGA\n\"\"\"\n\nkmers: List[str] = sample_input.strip().split(\"\\n\")\ncontigs = generate_contigs(kmers)\ncontigs.sort()\nprint(\" \".join(contigs))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-33",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-33",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "33.1 Sample Dataset",
    "text": "33.1 Sample Dataset\n4 2\nGACC|GCGC\nACCG|CGCC\nCCGA|GCCG\nCGAG|CCGG\nGAGC|CGGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-33",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-33",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "33.2 Sample Output",
    "text": "33.2 Sample Output\nGACCGAGCGCCGGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-33",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-33",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "33.3 Solution",
    "text": "33.3 Solution\nfrom typing import List, Tuple\n\ndef reconstruct_string_from_gapped_patterns(gapped_patterns: List[Tuple[str, str]], k: int, d: int) -&gt; str:\n    prefix_string = ''\n    suffix_string = ''\n    for i, (prefix, suffix) in enumerate(gapped_patterns):\n        if i != len(gapped_patterns) - 1:\n            prefix_string += prefix[0]\n            suffix_string += suffix[0]\n        else:\n            prefix_string += prefix\n            suffix_string += suffix\n    \n    for i in range(k + d + 1, len(prefix_string)):\n        if prefix_string[i] != suffix_string[i - k - d - 1]:\n            return \"-1\"\n    \n    return prefix_string + suffix_string[len(suffix_string) - k - d - 1:]\n\nsample_input: str = \"\"\"\n4 2\nGACC|GCGC\nACCG|CGCC\nCCGA|GCCG\nCGAG|CCGG\nGAGC|CGGA\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nk, d = map(int, input_lines[0].split())\ngapped_patterns: List[Tuple[str, str]] = [tuple(line.split(\"|\")) for line in input_lines[1:]]\n\nprint(reconstruct_string_from_gapped_patterns(gapped_patterns, k - 1, d))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-34",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-34",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "34.1 Sample Dataset",
    "text": "34.1 Sample Dataset\n1 -&gt; 2\n2 -&gt; 3\n3 -&gt; 4,5\n6 -&gt; 7\n7 -&gt; 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-34",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-34",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "34.2 Sample Output",
    "text": "34.2 Sample Output\n1 -&gt; 2 -&gt; 3\n3 -&gt; 4\n3 -&gt; 5\n6 -&gt; 7 -&gt; 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-34",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-34",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "34.3 Solution",
    "text": "34.3 Solution\nfrom typing import List, Dict, Tuple\nfrom re import split\n\ndef parse_adjacency_list(adjacency_text: List[str]) -&gt; Dict[str, List[str]]:\n    adjacency_dict: Dict[str, List[str]] = {}\n    for line in adjacency_text:\n        source, targets = split(' -&gt; ', line)\n        adjacency_dict[source] = targets.split(',')\n    return adjacency_dict\n\ndef remove_edge(graph: Dict[str, List[str]], source: str, target: str) -&gt; Dict[str, List[str]]:\n    graph[source].remove(target)\n    if not graph[source]:\n        del graph[source]\n    return graph\n\ndef find_maximal_non_branching_paths(graph: Dict[str, List[str]]) -&gt; List[List[str]]:\n    paths: List[List[str]] = []\n    in_out_degrees: Dict[str, List[int]] = {}\n\n    # Calculate in and out degrees\n    for node, neighbors in graph.items():\n        if node not in in_out_degrees:\n            in_out_degrees[node] = [0, len(neighbors)]\n        else:\n            in_out_degrees[node][1] += len(neighbors)\n\n        for neighbor in neighbors:\n            if neighbor not in in_out_degrees:\n                in_out_degrees[neighbor] = [1, 0]\n            else:\n                in_out_degrees[neighbor][0] += 1\n\n    # Find all non-branching paths\n    for node in list(in_out_degrees):\n        if in_out_degrees[node] != [1, 1]:\n            if in_out_degrees[node][1] &gt; 0:\n                while node in graph:\n                    next_node = graph[node][0]\n                    non_branching_path = [node, next_node]\n                    graph = remove_edge(graph, node, next_node)\n                    while in_out_degrees[next_node] == [1, 1]:\n                        following_node = graph[next_node][0]\n                        non_branching_path.append(following_node)\n                        graph = remove_edge(graph, next_node, following_node)\n                        next_node = following_node\n                    paths.append(non_branching_path)\n\n    # Find isolated cycles\n    while graph:\n        start_node = next(iter(graph))\n        current_node = graph[start_node][0]\n        graph = remove_edge(graph, start_node, current_node)\n        cycle = [start_node, current_node]\n        while current_node != start_node:\n            next_node = graph[current_node][0]\n            cycle.append(next_node)\n            graph = remove_edge(graph, current_node, next_node)\n            current_node = next_node\n        paths.append(cycle)\n\n    return paths\n\nsample_input: str = \"\"\"\n1 -&gt; 2\n2 -&gt; 3\n3 -&gt; 4,5\n6 -&gt; 7\n7 -&gt; 6\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nadjacency_list = parse_adjacency_list(input_lines)\n\nresult = find_maximal_non_branching_paths(adjacency_list)\nfor path in result:\n    print(\" -&gt; \".join(path))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-35",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-35",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "35.1 Sample Dataset",
    "text": "35.1 Sample Dataset\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-35",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-35",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "35.2 Sample Output",
    "text": "35.2 Sample Output\nMAMAPRTEINSTRING"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-35",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-35",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "35.3 Solution",
    "text": "35.3 Solution\nfrom typing import Dict, List\n\ndef translate_rna_to_protein(rna_sequence: str) -&gt; str:\n    # RNA 코돈을 아미노산으로 변환하는 딕셔너리\n    codon_table: Dict[str, str] = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',\n        'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n    \n    protein_sequence: str = \"\"\n    \n    # RNA 서열을 3개의 뉴클레오티드(코돈)씩 나누어 처리\n    for i in range(0, len(rna_sequence), 3):\n        codon: str = rna_sequence[i:i+3]\n        \n        # 코돈이 3개의 뉴클레오티드로 완전하지 않으면 중단\n        if len(codon) != 3:\n            break\n        \n        # 코돈을 아미노산으로 변환\n        amino_acid: str = codon_table.get(codon, '')\n        \n        # 종결 코돈('*')을 만나면 번역 중단\n        if amino_acid == '*':\n            break\n        \n        protein_sequence += amino_acid\n    \n    return protein_sequence\n\n# 입력 RNA 서열\nsample_input: str = \"\"\"\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\n\"\"\"\n\nrna_sequence: str = ''.join(sample_input.strip().split())\n\n# RNA를 단백질로 번역\nprotein: str = translate_rna_to_protein(rna_sequence)\n\nprint(protein)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-36",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-36",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "36.1 Sample Dataset",
    "text": "36.1 Sample Dataset\nATGGCCATGGCCCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA\nMA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-36",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-36",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "36.2 Sample Output",
    "text": "36.2 Sample Output\nATGGCC\nGGCCAT\nATGGCC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-36",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-36",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "36.3 Solution",
    "text": "36.3 Solution\nfrom typing import Dict, List\n\ndef translate_rna_to_protein(rna_sequence: str) -&gt; str:\n    codon_to_amino_acid: Dict[str, str] = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',\n        'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n    \n    protein_sequence: List[str] = []\n    \n    for i in range(0, len(rna_sequence), 3):\n        codon: str = rna_sequence[i:i+3]\n        \n        if len(codon) != 3:\n            break\n        \n        amino_acid: str = codon_to_amino_acid.get(codon, '')\n        \n        if amino_acid == '*':\n            break\n        \n        protein_sequence.append(amino_acid)\n    \n    return ''.join(protein_sequence)\n\ndef reverse_complement(dna_sequence: str) -&gt; str:\n    return dna_sequence[::-1].translate(str.maketrans(\"ACGT\", \"TGCA\"))\n\ndef dna_to_rna(dna_sequence: str) -&gt; str:\n    return dna_sequence.replace(\"T\", \"U\")\n\ndef find_peptide_encoding_substrings(dna_sequence: str, peptide: str) -&gt; List[str]:\n    substring_length: int = len(peptide) * 3\n    encoding_substrings: List[str] = []\n\n    for i in range(len(dna_sequence) - substring_length + 1):\n        dna_substring: str = dna_sequence[i:i + substring_length]\n        reverse_complement_substring: str = reverse_complement(dna_substring)\n\n        rna_substring: str = dna_to_rna(dna_substring)\n        reverse_complement_rna: str = dna_to_rna(reverse_complement_substring)\n\n        if (translate_rna_to_protein(rna_substring) == peptide or \n            translate_rna_to_protein(reverse_complement_rna) == peptide):\n            encoding_substrings.append(dna_substring)\n\n    return encoding_substrings\n\nsample_input: str = \"\"\"\nATGGCCATGGCCCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA\nMA\n\"\"\"\n\ndna_sequence, peptide = sample_input.strip().split('\\n')\nresult: List[str] = find_peptide_encoding_substrings(dna_sequence, peptide)\nprint(\"\\n\".join(result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-37",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-37",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "37.1 Sample Dataset",
    "text": "37.1 Sample Dataset\nLEQN"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-37",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-37",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "37.2 Sample Output",
    "text": "37.2 Sample Output\n0 113 114 128 129 227 242 242 257 355 356 370 371 484"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-37",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-37",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "37.3 Solution",
    "text": "37.3 Solution\nfrom typing import Dict, List\n\nAMINO_ACID_MASSES: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\n\ndef calculate_cyclospectrum(peptide: str) -&gt; List[int]:\n    total_mass: int = sum(AMINO_ACID_MASSES[amino_acid] for amino_acid in peptide)\n    spectrum: List[int] = [0, total_mass]\n    circular_peptide: str = peptide + peptide\n    \n    for subpeptide_length in range(1, len(peptide)):\n        for start_index in range(len(peptide)):\n            subpeptide: str = circular_peptide[start_index:start_index + subpeptide_length]\n            subpeptide_mass: int = sum(AMINO_ACID_MASSES[amino_acid] for amino_acid in subpeptide)\n            spectrum.append(subpeptide_mass)\n    \n    return sorted(spectrum)\n\nsample_input: str = \"\"\"\nLEQN\n\"\"\"\n\ninput_peptide: str = sample_input.strip()\n\nresult: List[int] = calculate_cyclospectrum(input_peptide)\nprint(\" \".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-38",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-38",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "38.1 Sample Dataset",
    "text": "38.1 Sample Dataset\n1024"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-38",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-38",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "38.2 Sample Output",
    "text": "38.2 Sample Output\n14712706211"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-38",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-38",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "38.3 Solution",
    "text": "38.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict\n\nAMINO_ACID_MASSES: List[int] = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]\nLIGHTEST_AMINO_ACID: int = min(AMINO_ACID_MASSES)\n\ndef count_possible_peptides(target_mass: int) -&gt; int:\n    peptide_count: Dict[int, int] = defaultdict(int)\n    \n    for current_mass in range(LIGHTEST_AMINO_ACID, target_mass + 1):\n        peptide_count[current_mass] = sum(1 for amino_acid_mass in AMINO_ACID_MASSES if amino_acid_mass == current_mass)\n        \n        for amino_acid_mass in AMINO_ACID_MASSES:\n            if current_mass &gt;= amino_acid_mass:\n                peptide_count[current_mass] += peptide_count[current_mass - amino_acid_mass]\n\n    return peptide_count[target_mass]\n\nsample_input: str = \"\"\"\n1024\n\"\"\"\ntarget_peptide_mass: int = int(sample_input.strip())\nresult: int = count_possible_peptides(target_peptide_mass)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-39",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-39",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "39.1 Sample Dataset",
    "text": "39.1 Sample Dataset\n0 113 128 186 241 299 314 427"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-39",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-39",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "39.2 Sample Output",
    "text": "39.2 Sample Output\n113-128-186 113-186-128 186-128-113 128-186-113 186-113-128 128-113-186"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-39",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-39",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "39.3 Solution",
    "text": "39.3 Solution\nfrom typing import List, Set\n\nAMINO_ACID_MASSES: List[int] = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]\n\ndef calculate_cyclospectrum(peptide: List[int]) -&gt; List[int]:\n    spectrum: List[int] = [0, sum(peptide)]\n    extended_peptide: List[int] = peptide + peptide\n    for k in range(1, len(peptide)):\n        for i in range(len(peptide)):\n            subpeptide: List[int] = extended_peptide[i:i + k]\n            spectrum.append(sum(subpeptide))\n    spectrum.sort()\n    return spectrum\n\ndef calculate_linear_spectrum(peptide: List[int]) -&gt; List[int]:\n    prefix_mass: List[int] = [0]\n    for mass in peptide:\n        prefix_mass.append(prefix_mass[-1] + mass)\n    linear_spectrum: List[int] = [0]\n    for i in range(len(peptide)):\n        for j in range(i + 1, len(peptide) + 1):\n            linear_spectrum.append(prefix_mass[j] - prefix_mass[i])\n    linear_spectrum.sort()\n    return linear_spectrum\n\ndef expand_peptides(peptides: List[List[int]]) -&gt; List[List[int]]:\n    expanded_peptides: List[List[int]] = []\n    for peptide in peptides:\n        for mass in AMINO_ACID_MASSES:\n            expanded_peptides.append(peptide + [mass])\n    return expanded_peptides\n\ndef is_consistent(peptide: List[int], spectrum: List[int]) -&gt; bool:\n    if sum(peptide) &gt; spectrum[-1] - AMINO_ACID_MASSES[0]:\n        return False\n    peptide_spectrum: List[int] = calculate_linear_spectrum(peptide)\n    return all(mass in spectrum for mass in peptide_spectrum)\n\ndef cyclopeptide_sequencing(spectrum: List[int]) -&gt; Set[str]:\n    candidate_peptides: List[List[int]] = [[]]\n    result: Set[str] = set()\n    \n    while candidate_peptides:\n        candidate_peptides = expand_peptides(candidate_peptides)\n        for peptide in candidate_peptides[:]:\n            if sum(peptide) == spectrum[-1]:\n                if calculate_cyclospectrum(peptide) == spectrum:\n                    result.add(\"-\".join(map(str, peptide)))\n                candidate_peptides.remove(peptide)\n            elif not is_consistent(peptide, spectrum):\n                candidate_peptides.remove(peptide)\n    \n    return result\n\nsample_input: str = \"\"\"\n0 113 128 186 241 299 314 427\n\"\"\"\n\ninput_spectrum: List[int] = [int(x) for x in sample_input.strip().split()]\n\nresult: Set[str] = cyclopeptide_sequencing(input_spectrum)\nprint(\" \".join(result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-40",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-40",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "40.1 Sample Dataset",
    "text": "40.1 Sample Dataset\nNQEL\n0 99 113 114 128 227 257 299 355 356 370 371 484"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-40",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-40",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "40.2 Sample Output",
    "text": "40.2 Sample Output\n11"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-40",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-40",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "40.3 Solution",
    "text": "40.3 Solution\nfrom typing import Dict, List\n\nAMINO_ACID_MASSES: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\n\ndef calculate_cyclospectrum(peptide: str) -&gt; List[int]:\n    total_mass: int = sum(AMINO_ACID_MASSES[aa] for aa in peptide)\n    spectrum: List[int] = [0, total_mass]\n    extended_peptide: str = peptide + peptide\n    \n    for length in range(1, len(peptide)):\n        for start in range(len(peptide)):\n            subpeptide: str = extended_peptide[start:start + length]\n            subpeptide_mass: int = sum(AMINO_ACID_MASSES[aa] for aa in subpeptide)\n            spectrum.append(subpeptide_mass)\n    \n    spectrum.sort()\n    return spectrum\n\ndef calculate_score(peptide: str, experimental_spectrum: List[int]) -&gt; int:\n    theoretical_spectrum: List[int] = calculate_cyclospectrum(peptide)\n    score: int = 0\n    unique_masses: set = set(theoretical_spectrum + experimental_spectrum)\n    \n    for mass in unique_masses:\n        score += min(theoretical_spectrum.count(mass), experimental_spectrum.count(mass))\n    \n    return score\n\nsample_input: str = \"\"\"\nNQEL\n0 99 113 114 128 227 257 299 355 356 370 371 484\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\ninput_peptide: str = input_lines[0]\ninput_spectrum: List[int] = [int(x) for x in input_lines[1].split()]\n\nresult: int = calculate_score(input_peptide, input_spectrum)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-41",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-41",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "41.1 Sample Dataset",
    "text": "41.1 Sample Dataset\n10\n0 71 113 129 147 200 218 260 313 331 347 389 460"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-41",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-41",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "41.2 Sample Output",
    "text": "41.2 Sample Output\n113-147-71-129"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-41",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-41",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "41.3 Solution",
    "text": "41.3 Solution\nfrom typing import List, Set, Dict\n\nAMINO_ACID_MASSES: List[int] = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]\n\ndef expand_peptides(peptides: List[List[int]]) -&gt; List[List[int]]:\n    expanded_peptides: List[List[int]] = []\n    for peptide in peptides:\n        for mass in AMINO_ACID_MASSES:\n            expanded_peptides.append(peptide + [mass])\n    return expanded_peptides\n\ndef calculate_cyclospectrum(peptide: List[int]) -&gt; List[int]:\n    total_mass: int = sum(peptide)\n    spectrum: List[int] = [0, total_mass]\n    extended_peptide: List[int] = peptide + peptide\n    \n    for length in range(1, len(peptide)):\n        for start in range(len(peptide)):\n            subpeptide: List[int] = extended_peptide[start:start + length]\n            subpeptide_mass: int = sum(subpeptide)\n            spectrum.append(subpeptide_mass)\n    \n    spectrum.sort()\n    return spectrum\n\ndef is_consistent(peptide: List[int], spectrum: List[int]) -&gt; bool:\n    peptide_spectrum: List[int] = calculate_cyclospectrum(peptide)\n    return all(peptide_spectrum.count(mass) &lt;= spectrum.count(mass) for mass in set(peptide_spectrum))\n\ndef cyclopeptide_sequencing(spectrum: List[int]) -&gt; Set[str]:\n    result: Set[str] = set()\n    candidate_peptides: List[List[int]] = [[]]\n    while candidate_peptides:\n        candidate_peptides = expand_peptides(candidate_peptides)\n        for peptide in candidate_peptides[:]:\n            if sum(peptide) == spectrum[-1]:\n                if calculate_cyclospectrum(peptide) == spectrum:\n                    result.add(\"-\".join(map(str, peptide)))\n                candidate_peptides.remove(peptide)\n            elif not is_consistent(peptide, spectrum):\n                candidate_peptides.remove(peptide)\n    return result\n\ndef calculate_score(peptide: List[int], spectrum: List[int]) -&gt; int:\n    peptide_spectrum: List[int] = calculate_cyclospectrum(peptide)\n    score: int = 0\n    unique_masses: Set[int] = set(peptide_spectrum + spectrum)\n    for mass in unique_masses:\n        score += min(peptide_spectrum.count(mass), spectrum.count(mass))\n    return score\n\ndef trim_leaderboard(leaderboard: List[List[int]], spectrum: List[int], n: int) -&gt; List[List[int]]:\n    if len(leaderboard) &lt;= n:\n        return leaderboard\n\n    scores: Dict[int, int] = {}\n    for i, peptide in enumerate(leaderboard):\n        scores[i] = calculate_score(peptide, spectrum)\n\n    sorted_scores: List[int] = sorted(scores.values(), reverse=True)\n    threshold: int = sorted_scores[n - 1] if n &lt;= len(sorted_scores) else sorted_scores[-1]\n\n    return [leaderboard[idx] for idx, score in scores.items() if score &gt;= threshold]\n\ndef leaderboard_cyclopeptide_sequencing(spectrum: List[int], n: int) -&gt; List[int]:\n    leaderboard: List[List[int]] = [[]]\n    leader_peptide: List[int] = []\n\n    while leaderboard:\n        leaderboard = expand_peptides(leaderboard)\n        for peptide in leaderboard[:]:\n            if sum(peptide) == spectrum[-1]:\n                if calculate_score(peptide, spectrum) &gt; calculate_score(leader_peptide, spectrum):\n                    leader_peptide = peptide\n            elif sum(peptide) &gt; spectrum[-1]:\n                leaderboard.remove(peptide)\n        leaderboard = trim_leaderboard(leaderboard, spectrum, n)\n    return leader_peptide\n\nsample_input: str = \"\"\"\n10\n0 71 113 129 147 200 218 260 313 331 347 389 460\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nn: int = int(input_lines[0])\nspectrum: List[int] = [int(x) for x in input_lines[1].split()]\n\nresult: List[int] = leaderboard_cyclopeptide_sequencing(spectrum, n)\nprint(\"-\".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-42",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-42",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "42.1 Sample Dataset",
    "text": "42.1 Sample Dataset\n0 137 186 323"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-42",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-42",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "42.2 Sample Output",
    "text": "42.2 Sample Output\n137 137 186 186 323 49"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-42",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-42",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "42.3 Solution",
    "text": "42.3 Solution\nfrom typing import List, Dict\n\ndef calculate_spectrum_convolution(spectrum: List[int]) -&gt; List[int]:\n    spectrum.sort()\n    convolution_list: List[int] = []\n    \n    for i in range(len(spectrum) - 1):\n        for j in range(i + 1, len(spectrum)):\n            mass_difference: int = spectrum[j] - spectrum[i]\n            if mass_difference != 0:\n                convolution_list.append(mass_difference)\n\n    frequency_dict: Dict[int, int] = {}\n    for mass in set(convolution_list):\n        frequency_dict[mass] = convolution_list.count(mass)\n\n    sorted_masses: List[int] = sorted(frequency_dict, key=frequency_dict.get, reverse=True)\n    \n    result: List[int] = []\n    for mass in sorted_masses:\n        result.extend([mass] * frequency_dict[mass])\n    \n    return result\n\nsample_input: str = \"\"\"\n0 137 186 323\n\"\"\"\n\ninput_spectrum: List[int] = [int(x) for x in sample_input.strip().split()]\n\nconvolution_result: List[int] = calculate_spectrum_convolution(input_spectrum)\nprint(\" \".join(map(str, convolution_result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-43",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-43",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "43.1 Sample Dataset",
    "text": "43.1 Sample Dataset\n20\n60\n57 57 71 99 129 137 170 186 194 208 228 265 285 299 307 323 356 364 394 422 493"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-43",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-43",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "43.2 Sample Output",
    "text": "43.2 Sample Output\n99-71-137-57-72-57"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-43",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-43",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "43.3 Solution",
    "text": "43.3 Solution\nfrom typing import List, Dict, Tuple\n\ndef calculate_spectrum_convolution(spectrum: List[int]) -&gt; List[int]:\n    spectrum.sort()\n    convolution_list: List[int] = []\n    for i in range(len(spectrum) - 1):\n        for j in range(i, len(spectrum)):\n            if spectrum[j] - spectrum[i] != 0:\n                convolution_list.append(spectrum[j] - spectrum[i])\n\n    frequency_dict: Dict[int, int] = {}\n    for mass in set(convolution_list):\n        frequency_dict[mass] = convolution_list.count(mass)\n\n    sorted_masses: List[int] = [k for k, _ in sorted(frequency_dict.items(), key=lambda item: item[1], reverse=True)]\n    result: List[int] = []\n    for mass in sorted_masses:\n        result += [mass] * frequency_dict[mass]\n    return result\n\ndef trim_leaderboard(leaderboard: List[List[int]], spectrum: List[int], n: int) -&gt; List[List[int]]:\n    if len(leaderboard) &lt;= n:\n        return leaderboard\n\n    scores: Dict[int, int] = {}\n    for i, peptide in enumerate(leaderboard):\n        scores[i] = calculate_score(peptide, spectrum)\n\n    sorted_scores: List[int] = sorted(scores.values(), reverse=True)\n    threshold: int = sorted_scores[n - 1]\n\n    return [leaderboard[idx] for idx, score in scores.items() if score &gt;= threshold]\n\ndef calculate_cyclospectrum(peptide: List[int]) -&gt; List[int]:\n    spectrum: List[int] = [0, sum(peptide)]\n    extended_peptide: List[int] = peptide + peptide\n    for k in range(1, len(peptide)):\n        for i in range(len(peptide)):\n            subpeptide: List[int] = extended_peptide[i:i + k]\n            spectrum.append(sum(subpeptide))\n    spectrum.sort()\n    return spectrum\n\ndef calculate_score(peptide: List[int], spectrum: List[int]) -&gt; int:\n    peptide_spectrum: List[int] = calculate_cyclospectrum(peptide)\n    score: int = 0\n    unique_masses: set = set(peptide_spectrum + spectrum)\n    for mass in unique_masses:\n        score += min(peptide_spectrum.count(mass), spectrum.count(mass))\n    return score\n\ndef find_top_masses(spectrum: List[int], m: int) -&gt; List[int]:\n    convolution: List[int] = calculate_spectrum_convolution(spectrum)\n    filtered_convolution: List[int] = [x for x in convolution if 57 &lt;= x &lt;= 200]\n\n    frequency_dict: Dict[int, int] = {}\n    for mass in set(filtered_convolution):\n        frequency_dict[mass] = filtered_convolution.count(mass)\n\n    sorted_elements: List[Tuple[int, int]] = sorted(frequency_dict.items(), key=lambda kv: kv[1], reverse=True)\n    top_masses: List[int] = [mass for mass, freq in sorted_elements if freq &gt;= sorted_elements[m - 1][1]]\n    top_masses.sort()\n    return top_masses\n\ndef expand_peptides(peptides: List[List[int]], masses: List[int]) -&gt; List[List[int]]:\n    expanded_peptides: List[List[int]] = []\n    for peptide in peptides:\n        for mass in masses:\n            expanded_peptides.append(peptide + [mass])\n    return expanded_peptides\n\ndef convolution_cyclopeptide_sequencing(spectrum: List[int], m: int, n: int) -&gt; List[int]:\n    masses: List[int] = find_top_masses(spectrum, m)\n    leaderboard: List[List[int]] = [[]]\n    leader_peptide: List[int] = []\n\n    while leaderboard:\n        leaderboard = expand_peptides(leaderboard, masses)\n        for peptide in leaderboard[:]:\n            if sum(peptide) == spectrum[-1]:\n                if calculate_score(peptide, spectrum) &gt; calculate_score(leader_peptide, spectrum):\n                    leader_peptide = peptide\n            elif sum(peptide) &gt; spectrum[-1]:\n                leaderboard.remove(peptide)\n        leaderboard = trim_leaderboard(leaderboard, spectrum, n)\n    return leader_peptide\n\nsample_input: str = \"\"\"\n20\n60\n57 57 71 99 129 137 170 186 194 208 228 265 285 299 307 323 356 364 394 422 493\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nm: int = int(input_lines[0])\nn: int = int(input_lines[1])\nspectrum: List[int] = [int(x) for x in input_lines[2].split()]\n\nresult: List[int] = convolution_cyclopeptide_sequencing(spectrum, m, n)\nprint(\"-\".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-44",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-44",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "44.1 Sample Dataset",
    "text": "44.1 Sample Dataset\nNQEL"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-44",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-44",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "44.2 Sample Output",
    "text": "44.2 Sample Output\n0 113 114 128 129 242 242 257 370 371 484"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-44",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-44",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "44.3 Solution",
    "text": "44.3 Solution\nfrom typing import List, Dict\n\nAMINO_ACID_MASSES: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137,\n    'K': 128, 'M': 131, 'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156,\n    'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\n\ndef calculate_linear_spectrum(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = [0]\n    \n    for amino_acid in peptide:\n        current_mass = prefix_masses[-1] + AMINO_ACID_MASSES[amino_acid]\n        prefix_masses.append(current_mass)\n    \n    linear_spectrum: List[int] = [0]\n    \n    for i in range(len(peptide)):\n        for j in range(i + 1, len(peptide) + 1):\n            subpeptide_mass = prefix_masses[j] - prefix_masses[i]\n            linear_spectrum.append(subpeptide_mass)\n    \n    return sorted(linear_spectrum)\n\n# Sample input\nsample_peptide: str = \"NQEL\"\n\n# Calculate and print the linear spectrum\nresult: List[int] = calculate_linear_spectrum(sample_peptide)\nprint(\" \".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-45",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-45",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "45.1 Sample Dataset",
    "text": "45.1 Sample Dataset\nNQEL\n0 99 113 114 128 227 257 299 355 356 370 371 484"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-45",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-45",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "45.2 Sample Output",
    "text": "45.2 Sample Output\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-45",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-45",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "45.3 Solution",
    "text": "45.3 Solution\nfrom typing import List, Dict\n\nAMINO_ACID_MASSES: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137,\n    'K': 128, 'M': 131, 'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156,\n    'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\n\ndef calculate_linear_spectrum(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = [0]\n    \n    for amino_acid in peptide:\n        current_mass = prefix_masses[-1] + AMINO_ACID_MASSES[amino_acid]\n        prefix_masses.append(current_mass)\n    \n    linear_spectrum: List[int] = [0]\n    \n    for i in range(len(peptide)):\n        for j in range(i + 1, len(peptide) + 1):\n            subpeptide_mass = prefix_masses[j] - prefix_masses[i]\n            linear_spectrum.append(subpeptide_mass)\n    \n    return sorted(linear_spectrum)\n\ndef calculate_linear_score(peptide: str, experimental_spectrum: List[int]) -&gt; int:\n    theoretical_spectrum: List[int] = calculate_linear_spectrum(peptide)\n    score: int = 0\n    unique_masses: set = set(theoretical_spectrum + experimental_spectrum)\n    \n    for mass in unique_masses:\n        score += min(theoretical_spectrum.count(mass), experimental_spectrum.count(mass))\n    \n    return score\n\n# Sample input\nsample_input: str = \"\"\"\nNQEL\n0 99 113 114 128 227 257 299 355 356 370 371 484\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\ninput_peptide: str = input_lines[0]\ninput_spectrum: List[int] = [int(x) for x in input_lines[1].split()]\n\n# Calculate and print the linear score\nresult: int = calculate_linear_score(input_peptide, input_spectrum)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-46",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-46",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "46.1 Sample Dataset",
    "text": "46.1 Sample Dataset\nLAST ALST TLLT TQAS\n0 71 87 101 113 158 184 188 259 271 372\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-46",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-46",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "46.2 Sample Output",
    "text": "46.2 Sample Output\nLAST ALST"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-46",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-46",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "46.3 Solution",
    "text": "46.3 Solution\nfrom typing import List, Dict\n\nAMINO_ACID_MASSES: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137,\n    'K': 128, 'M': 131, 'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156,\n    'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\n\ndef calculate_linear_spectrum(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = [0]\n    \n    for amino_acid in peptide:\n        current_mass = prefix_masses[-1] + AMINO_ACID_MASSES[amino_acid]\n        prefix_masses.append(current_mass)\n    \n    linear_spectrum: List[int] = [0]\n    \n    for i in range(len(peptide)):\n        for j in range(i + 1, len(peptide) + 1):\n            subpeptide_mass = prefix_masses[j] - prefix_masses[i]\n            linear_spectrum.append(subpeptide_mass)\n    \n    return sorted(linear_spectrum)\n\ndef calculate_linear_score(peptide: str, experimental_spectrum: List[int]) -&gt; int:\n    theoretical_spectrum: List[int] = calculate_linear_spectrum(peptide)\n    score: int = 0\n    unique_masses: set = set(theoretical_spectrum + experimental_spectrum)\n    \n    for mass in unique_masses:\n        score += min(theoretical_spectrum.count(mass), experimental_spectrum.count(mass))\n    \n    return score\n\ndef trim_leaderboard(leaderboard: List[str], spectrum: List[int], n: int) -&gt; List[str]:\n    if len(leaderboard) &lt;= n:\n        return leaderboard\n\n    peptide_scores: Dict[int, int] = {}\n    for i, peptide in enumerate(leaderboard):\n        peptide_scores[i] = calculate_linear_score(peptide, spectrum)\n\n    sorted_scores: List[int] = sorted(peptide_scores.values(), reverse=True)\n    score_threshold: int = sorted_scores[n - 1]\n\n    return [leaderboard[idx] for idx, score in peptide_scores.items() if score &gt;= score_threshold]\n\n# Sample input\nsample_input: str = \"\"\"\nLAST ALST TLLT TQAS\n0 71 87 101 113 158 184 188 259 271 372\n2\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\ninput_leaderboard: List[str] = input_lines[0].split()\ninput_spectrum: List[int] = [int(x) for x in input_lines[1].split()]\ninput_n: int = int(input_lines[2])\n\nresult: List[str] = trim_leaderboard(input_leaderboard, input_spectrum, input_n)\nprint(\" \".join(result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-47",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-47",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "47.1 Sample Dataset",
    "text": "47.1 Sample Dataset\n-10 -8 -7 -6 -5 -4 -3 -3 -2 -2 0 0 0 0 0 2 2 3 3 4 5 6 7 8 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-47",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-47",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "47.2 Sample Output",
    "text": "47.2 Sample Output\n0 2 4 7 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-47",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-47",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "47.3 Solution",
    "text": "47.3 Solution\nfrom typing import List, Set, Optional\n\ndef calculate_absolute_differences(set_a: Set[int], set_b: Set[int]) -&gt; List[int]:\n    return [abs(a - b) for a in set_a for b in set_b]\n\ndef is_multiset_subset(subset: List[int], superset: List[int]) -&gt; bool:\n    return all(subset.count(elem) &lt;= superset.count(elem) for elem in set(subset))\n\ndef multiset_difference(set_a: List[int], set_b: List[int]) -&gt; List[int]:\n    difference: List[int] = []\n    unique_elements: Set[int] = set(set_a)\n    for elem in unique_elements:\n        count_difference = set_a.count(elem) - set_b.count(elem)\n        if count_difference &gt; 0:\n            difference.extend([elem] * count_difference)\n    return sorted(difference)\n\ndef place_elements(distances: List[int]) -&gt; Optional[Set[int]]:\n    if not distances:\n        return placed_elements\n\n    current_distance: int = distances[-1]\n    \n    # Try placing on the left\n    left_differences: List[int] = calculate_absolute_differences({current_distance}, placed_elements)\n    if is_multiset_subset(left_differences, distances):\n        placed_elements.add(current_distance)\n        remaining_distances_left: List[int] = multiset_difference(distances, left_differences)\n        left_result: Optional[Set[int]] = place_elements(remaining_distances_left)\n        if left_result:\n            return left_result\n        placed_elements.remove(current_distance)\n\n    # Try placing on the right\n    right_differences: List[int] = calculate_absolute_differences({total_width - current_distance}, placed_elements)\n    if is_multiset_subset(right_differences, distances):\n        placed_elements.add(total_width - current_distance)\n        remaining_distances_right: List[int] = multiset_difference(distances, right_differences)\n        right_result: Optional[Set[int]] = place_elements(remaining_distances_right)\n        if right_result:\n            return right_result\n        placed_elements.remove(total_width - current_distance)\n\n    return None\n\n# Sample input\nsample_input: str = \"\"\"\n-10 -8 -7 -6 -5 -4 -3 -3 -2 -2 0 0 0 0 0 2 2 3 3 4 5 6 7 8 10\n\"\"\"\n\ninput_distances: List[int] = [int(x) for x in sample_input.strip().split()]\npositive_distances: List[int] = [x for x in input_distances if x &gt; 0]\n\ntotal_width: int = positive_distances.pop(-1)\nplaced_elements: Set[int] = {0, total_width}\n\nresult: Optional[Set[int]] = place_elements(positive_distances)\nprint(\" \".join(map(str, sorted(result))))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-48",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-48",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "48.1 Sample Dataset",
    "text": "48.1 Sample Dataset\n40\n1,5,10,20,25,50"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-48",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-48",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "48.2 Sample Output",
    "text": "48.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-48",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-48",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "48.3 Solution",
    "text": "48.3 Solution\nfrom typing import List\n\ndef min_coins_for_change(target_amount: int, available_coins: List[int]) -&gt; int:\n    min_coins_needed = [0]\n    for current_amount in range(1, target_amount + 1):\n        min_coins_needed.append(target_amount + 1)\n        for coin in available_coins:\n            if current_amount &gt;= coin:\n                coins_for_current = min_coins_needed[current_amount - coin] + 1\n                if coins_for_current &lt; min_coins_needed[current_amount]:\n                    min_coins_needed[current_amount] = coins_for_current\n    return min_coins_needed[target_amount]\n\nsample_input = \"\"\"\n40\n1,5,10,20,25,50\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\ntarget_amount = int(input_lines[0])\navailable_coins = [int(x) for x in input_lines[1].split(\",\")]\n\nprint(min_coins_for_change(target_amount, available_coins))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-49",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-49",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "49.1 Sample Dataset",
    "text": "49.1 Sample Dataset\n4 4\n1 0 2 4 3\n4 6 5 2 1\n4 4 5 2 1\n5 6 8 5 3\n-\n3 2 4 0\n3 2 4 2\n0 7 3 3\n3 3 0 2\n1 3 2 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-49",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-49",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "49.2 Sample Output",
    "text": "49.2 Sample Output\n34"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-49",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-49",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "49.3 Solution",
    "text": "49.3 Solution\nfrom typing import List, Tuple\n\ndef parse_manhattan_tourist_input(input_text: str) -&gt; Tuple[int, int, List[List[int]], List[List[int]]]:\n    lines = input_text.strip().split('\\n')\n    rows, cols = map(int, lines[0].split())\n    \n    down_weights = [[0] * (cols + 1) for _ in range(rows)]\n    for i in range(rows):\n        line = list(map(int, lines[i + 1].split()))\n        for j in range(cols + 1):\n            down_weights[i][j] = line[j]\n\n    separator_index = rows + 1\n    right_weights = [[0] * cols for _ in range(rows + 1)]\n    for i in range(rows + 1):\n        line = list(map(int, lines[i + separator_index + 1].split()))\n        for j in range(cols):\n            right_weights[i][j] = line[j]\n\n    return rows, cols, down_weights, right_weights\n\ndef calculate_longest_manhattan_path(rows: int, cols: int, down_weights: List[List[int]], right_weights: List[List[int]]) -&gt; int:\n    path_scores = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        path_scores[i][0] = path_scores[i - 1][0] + down_weights[i - 1][0]\n\n    for j in range(1, cols + 1):\n        path_scores[0][j] = path_scores[0][j - 1] + right_weights[0][j - 1]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            path_scores[i][j] = max(path_scores[i - 1][j] + down_weights[i - 1][j],\n                                    path_scores[i][j - 1] + right_weights[i][j - 1])\n    \n    return path_scores[rows][cols]\n\nsample_input = \"\"\"\n4 4\n1 0 2 4 3\n4 6 5 2 1\n4 4 5 2 1\n5 6 8 5 3\n-\n3 2 4 0\n3 2 4 2\n0 7 3 3\n3 3 0 2\n1 3 2 2\n\"\"\"\n\nrows, cols, down_weights, right_weights = parse_manhattan_tourist_input(sample_input)\nlongest_path_score = calculate_longest_manhattan_path(rows, cols, down_weights, right_weights)\nprint(f\"{longest_path_score}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-50",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-50",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "50.1 Sample Dataset",
    "text": "50.1 Sample Dataset\nAACCTTGG\nACACTGTGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-50",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-50",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "50.2 Sample Output",
    "text": "50.2 Sample Output\nAACTGG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-50",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-50",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "50.3 Solution",
    "text": "50.3 Solution\nfrom typing import List, Tuple\n\ndef longest_common_subsequence(sequence1: str, sequence2: str) -&gt; str:\n    padded_seq1 = '-' + sequence1\n    padded_seq2 = '-' + sequence2\n\n    score_matrix: List[List[int]] = [[0 for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n    backtrack_matrix: List[List[str]] = [['' for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n\n    for i in range(1, len(padded_seq1)):\n        for j in range(1, len(padded_seq2)):\n            match_score = score_matrix[i - 1][j - 1] + (1 if padded_seq1[i] == padded_seq2[j] else 0)\n            score_matrix[i][j] = max(score_matrix[i - 1][j], score_matrix[i][j - 1], match_score)\n\n            if score_matrix[i][j] == score_matrix[i - 1][j]:\n                backtrack_matrix[i][j] = \"up\"\n            elif score_matrix[i][j] == score_matrix[i][j - 1]:\n                backtrack_matrix[i][j] = \"left\"\n            else:\n                backtrack_matrix[i][j] = \"diag\"\n\n    lcs = \"\"\n    i, j = len(padded_seq1) - 1, len(padded_seq2) - 1\n    while i &gt; 0 and j &gt; 0:\n        if backtrack_matrix[i][j] == \"diag\":\n            lcs = padded_seq1[i] + lcs\n            i -= 1\n            j -= 1\n        elif backtrack_matrix[i][j] == \"left\":\n            j -= 1\n        else:\n            i -= 1\n\n    return lcs\n\nsample_input = \"\"\"\nAACCTTGG\nACACTGTGA\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\nsequence1 = input_lines[0]\nsequence2 = input_lines[1]\n\nprint(longest_common_subsequence(sequence1, sequence2))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-51",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-51",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "51.1 Sample Dataset",
    "text": "51.1 Sample Dataset\n0\n4\n0-&gt;1:7\n0-&gt;2:4\n2-&gt;3:2\n1-&gt;4:1\n3-&gt;4:3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-51",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-51",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "51.2 Sample Output",
    "text": "51.2 Sample Output\n9\n0-&gt;2-&gt;3-&gt;4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-51",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-51",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "51.3 Solution",
    "text": "51.3 Solution\nfrom typing import List, Tuple, Dict, Optional\n\nclass Node:\n    def __init__(self, label: str):\n        self.label: str = label\n        self.parent_nodes: List[Tuple['Node', int]] = []\n        self.target_nodes: List[Tuple['Node', int]] = []\n        self.visited: bool = False\n\nclass DAG:\n    def __init__(self):\n        self.nodes_dict: Dict[str, Node] = {}\n        self.distances: Dict[str, float] = {}\n        self.backtrack: Dict[str, Optional[str]] = {}\n\n    def add_node(self, label: str) -&gt; Node:\n        if label in self.nodes_dict:\n            return self.nodes_dict[label]\n\n        new_node = Node(label)\n        self.nodes_dict[label] = new_node\n        return new_node\n\n    def construct_dag(self, adjacency_list: List[str]) -&gt; None:\n        for line in adjacency_list:\n            source_label, temp = line.split(\"-&gt;\")\n            target_label, weight_str = temp.split(\":\")\n            weight = int(weight_str)\n\n            source_node = self.add_node(source_label)\n            target_node = self.add_node(target_label)\n\n            source_node.target_nodes.append((target_node, weight))\n            target_node.parent_nodes.append((source_node, weight))\n\n    def topological_sort_util(self, current_node: Node, sorted_labels: List[str]) -&gt; None:\n        current_node.visited = True\n        for neighbor, _ in current_node.target_nodes:\n            if not neighbor.visited:\n                self.topological_sort_util(neighbor, sorted_labels)\n        sorted_labels.insert(0, current_node.label)\n\n    def topological_sort(self) -&gt; List[str]:\n        sorted_labels: List[str] = []\n        for node in self.nodes_dict.values():\n            if not node.visited:\n                self.topological_sort_util(node, sorted_labels)\n        return sorted_labels\n\n    def longest_path(self, source: str, sink: str) -&gt; Tuple[float, List[str]]:\n        for label in self.nodes_dict:\n            self.distances[label] = float(\"-inf\")\n\n        self.distances[source] = 0\n        self.backtrack[source] = None\n\n        topological_order = self.topological_sort()\n        for label in topological_order:\n            current_node = self.nodes_dict[label]\n            for target_node, weight in current_node.target_nodes:\n                if self.distances[target_node.label] &lt; self.distances[label] + weight:\n                    self.distances[target_node.label] = self.distances[label] + weight\n                    self.backtrack[target_node.label] = label\n\n        path: List[str] = [sink]\n        current_label = self.backtrack[sink]\n        while current_label != source:\n            path = [current_label] + path\n            current_label = self.backtrack[current_label]\n        path = [source] + path\n        return self.distances[sink], path\n\n# Sample input\nsample_input: str = \"\"\"\n0\n4\n0-&gt;1:7\n0-&gt;2:4\n2-&gt;3:2\n1-&gt;4:1\n3-&gt;4:3\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\nsource_label: str = input_lines[0]\nsink_label: str = input_lines[1]\nadjacency_list: List[str] = input_lines[2:]\n\ngraph = DAG()\ngraph.construct_dag(adjacency_list)\nlongest_distance, longest_path = graph.longest_path(source_label, sink_label)\nprint(longest_distance)\nprint(\"-&gt;\".join(longest_path))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-52",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-52",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "52.1 Sample Dataset",
    "text": "52.1 Sample Dataset\nPLEASANTLY\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-52",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-52",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "52.2 Sample Output",
    "text": "52.2 Sample Output\n8\nPLEASANTLY\n-MEA--N-LY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-52",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-52",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "52.3 Solution",
    "text": "52.3 Solution\nfrom typing import Dict, Tuple, List\n\nBLOSUM62: Dict[Tuple[str, str], int] = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef global_alignment(sequence1: str, sequence2: str, indel_penalty: int = 5) -&gt; Tuple[int, str, str]:\n    padded_seq1: str = \"-\" + sequence1\n    padded_seq2: str = \"-\" + sequence2\n\n    score_matrix: List[List[int]] = [[0 for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n    backtrack_matrix: List[List[str]] = [['' for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n\n    for j in range(len(padded_seq2)):\n        score_matrix[0][j] = -indel_penalty * j\n        backtrack_matrix[0][j] = \"left\"\n\n    for i in range(len(padded_seq1)):\n        score_matrix[i][0] = -indel_penalty * i\n        backtrack_matrix[i][0] = \"up\"\n\n    for i in range(1, len(padded_seq1)):\n        for j in range(1, len(padded_seq2)):\n            key: Tuple[str, str] = (padded_seq1[i], padded_seq2[j]) if (padded_seq1[i], padded_seq2[j]) in BLOSUM62 else (padded_seq2[j], padded_seq1[i])\n            diagonal_score: int = score_matrix[i - 1][j - 1] + BLOSUM62[key]\n            up_score: int = score_matrix[i - 1][j] - indel_penalty\n            left_score: int = score_matrix[i][j - 1] - indel_penalty\n            score_matrix[i][j] = max(diagonal_score, up_score, left_score)\n            \n            if score_matrix[i][j] == diagonal_score:\n                backtrack_matrix[i][j] = \"diagonal\"\n            elif score_matrix[i][j] == up_score:\n                backtrack_matrix[i][j] = \"up\"\n            else:\n                backtrack_matrix[i][j] = \"left\"\n\n    i: int = len(padded_seq1) - 1\n    j: int = len(padded_seq2) - 1\n    aligned_seq1: str = \"\"\n    aligned_seq2: str = \"\"\n    \n    while i != 0 or j != 0:\n        direction: str = backtrack_matrix[i][j]\n        if direction == \"diagonal\":\n            aligned_seq1 = padded_seq1[i] + aligned_seq1\n            aligned_seq2 = padded_seq2[j] + aligned_seq2\n            i -= 1\n            j -= 1\n        elif direction == \"up\":\n            aligned_seq1 = padded_seq1[i] + aligned_seq1\n            aligned_seq2 = \"-\" + aligned_seq2\n            i -= 1\n        else:\n            aligned_seq1 = \"-\" + aligned_seq1\n            aligned_seq2 = padded_seq2[j] + aligned_seq2\n            j -= 1\n\n    return score_matrix[len(padded_seq1) - 1][len(padded_seq2) - 1], aligned_seq1, aligned_seq2\n\n# Sample input\nsample_input: str = \"\"\"\nPLEASANTLY\nMEANLY\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nsequence1: str = input_lines[0]\nsequence2: str = input_lines[1]\nalignment_score: int\naligned_sequence1: str\naligned_sequence2: str\nalignment_score, aligned_sequence1, aligned_sequence2 = global_alignment(sequence1, sequence2)\nprint(alignment_score)\nprint(aligned_sequence1)\nprint(aligned_sequence2)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-53",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-53",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "53.1 Sample Dataset",
    "text": "53.1 Sample Dataset\nMEANLY\nPENALTY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-53",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-53",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "53.2 Sample Output",
    "text": "53.2 Sample Output\n15\nEANL-Y\nENALTY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-53",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-53",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "53.3 Solution",
    "text": "53.3 Solution\nfrom typing import Dict, List, Tuple, Optional\n\nPAM250: Dict[str, Dict[str, int]] = {\n        'A': {'A': 2, 'C': -2, 'D': 0, 'E': 0, 'F': -3, 'G': 1, 'H': -1, 'I': -1, 'K': -1, 'L': -2, 'M': -1, 'N': 0,\n                'P': 1, 'Q': 0, 'R': -2, 'S': 1, 'T': 1, 'V': 0, 'W': -6, 'Y': -3},\n          'C': {'A': -2, 'C': 12, 'D': -5, 'E': -5, 'F': -4, 'G': -3, 'H': -3, 'I': -2, 'K': -5, 'L': -6, 'M': -5,\n                'N': -4, 'P': -3, 'Q': -5, 'R': -4, 'S': 0, 'T': -2, 'V': -2, 'W': -8, 'Y': 0},\n          'D': {'A': 0, 'C': -5, 'D': 4, 'E': 3, 'F': -6, 'G': 1, 'H': 1, 'I': -2, 'K': 0, 'L': -4, 'M': -3, 'N': 2,\n                'P': -1, 'Q': 2, 'R': -1, 'S': 0, 'T': 0, 'V': -2, 'W': -7, 'Y': -4},\n          'E': {'A': 0, 'C': -5, 'D': 3, 'E': 4, 'F': -5, 'G': 0, 'H': 1, 'I': -2, 'K': 0, 'L': -3, 'M': -2, 'N': 1,\n                'P': -1, 'Q': 2, 'R': -1, 'S': 0, 'T': 0, 'V': -2, 'W': -7, 'Y': -4},\n          'F': {'A': -3, 'C': -4, 'D': -6, 'E': -5, 'F': 9, 'G': -5, 'H': -2, 'I': 1, 'K': -5, 'L': 2, 'M': 0, 'N': -3,\n                'P': -5, 'Q': -5, 'R': -4, 'S': -3, 'T': -3, 'V': -1, 'W': 0, 'Y': 7},\n          'G': {'A': 1, 'C': -3, 'D': 1, 'E': 0, 'F': -5, 'G': 5, 'H': -2, 'I': -3, 'K': -2, 'L': -4, 'M': -3, 'N': 0,\n                'P': 0, 'Q': -1, 'R': -3, 'S': 1, 'T': 0, 'V': -1, 'W': -7, 'Y': -5},\n          'H': {'A': -1, 'C': -3, 'D': 1, 'E': 1, 'F': -2, 'G': -2, 'H': 6, 'I': -2, 'K': 0, 'L': -2, 'M': -2, 'N': 2,\n                'P': 0, 'Q': 3, 'R': 2, 'S': -1, 'T': -1, 'V': -2, 'W': -3, 'Y': 0},\n          'I': {'A': -1, 'C': -2, 'D': -2, 'E': -2, 'F': 1, 'G': -3, 'H': -2, 'I': 5, 'K': -2, 'L': 2, 'M': 2, 'N': -2,\n                'P': -2, 'Q': -2, 'R': -2, 'S': -1, 'T': 0, 'V': 4, 'W': -5, 'Y': -1},\n          'K': {'A': -1, 'C': -5, 'D': 0, 'E': 0, 'F': -5, 'G': -2, 'H': 0, 'I': -2, 'K': 5, 'L': -3, 'M': 0, 'N': 1,\n                'P': -1, 'Q': 1, 'R': 3, 'S': 0, 'T': 0, 'V': -2, 'W': -3, 'Y': -4},\n          'L': {'A': -2, 'C': -6, 'D': -4, 'E': -3, 'F': 2, 'G': -4, 'H': -2, 'I': 2, 'K': -3, 'L': 6, 'M': 4, 'N': -3,\n                'P': -3, 'Q': -2, 'R': -3, 'S': -3, 'T': -2, 'V': 2, 'W': -2, 'Y': -1},\n          'M': {'A': -1, 'C': -5, 'D': -3, 'E': -2, 'F': 0, 'G': -3, 'H': -2, 'I': 2, 'K': 0, 'L': 4, 'M': 6, 'N': -2,\n                'P': -2, 'Q': -1, 'R': 0, 'S': -2, 'T': -1, 'V': 2, 'W': -4, 'Y': -2},\n          'N': {'A': 0, 'C': -4, 'D': 2, 'E': 1, 'F': -3, 'G': 0, 'H': 2, 'I': -2, 'K': 1, 'L': -3, 'M': -2, 'N': 2,\n                'P': 0, 'Q': 1, 'R': 0, 'S': 1, 'T': 0, 'V': -2, 'W': -4, 'Y': -2},\n          'P': {'A': 1, 'C': -3, 'D': -1, 'E': -1, 'F': -5, 'G': 0, 'H': 0, 'I': -2, 'K': -1, 'L': -3, 'M': -2, 'N': 0,\n                'P': 6, 'Q': 0, 'R': 0, 'S': 1, 'T': 0, 'V': -1, 'W': -6, 'Y': -5},\n          'Q': {'A': 0, 'C': -5, 'D': 2, 'E': 2, 'F': -5, 'G': -1, 'H': 3, 'I': -2, 'K': 1, 'L': -2, 'M': -1, 'N': 1,\n                'P': 0, 'Q': 4, 'R': 1, 'S': -1, 'T': -1, 'V': -2, 'W': -5, 'Y': -4},\n          'R': {'A': -2, 'C': -4, 'D': -1, 'E': -1, 'F': -4, 'G': -3, 'H': 2, 'I': -2, 'K': 3, 'L': -3, 'M': 0, 'N': 0,\n                'P': 0, 'Q': 1, 'R': 6, 'S': 0, 'T': -1, 'V': -2, 'W': 2, 'Y': -4},\n          'S': {'A': 1, 'C': 0, 'D': 0, 'E': 0, 'F': -3, 'G': 1, 'H': -1, 'I': -1, 'K': 0, 'L': -3, 'M': -2, 'N': 1,\n                'P': 1, 'Q': -1, 'R': 0, 'S': 2, 'T': 1, 'V': -1, 'W': -2, 'Y': -3},\n          'T': {'A': 1, 'C': -2, 'D': 0, 'E': 0, 'F': -3, 'G': 0, 'H': -1, 'I': 0, 'K': 0, 'L': -2, 'M': -1, 'N': 0,\n                'P': 0, 'Q': -1, 'R': -1, 'S': 1, 'T': 3, 'V': 0, 'W': -5, 'Y': -3},\n          'V': {'A': 0, 'C': -2, 'D': -2, 'E': -2, 'F': -1, 'G': -1, 'H': -2, 'I': 4, 'K': -2, 'L': 2, 'M': 2, 'N': -2,\n                'P': -1, 'Q': -2, 'R': -2, 'S': -1, 'T': 0, 'V': 4, 'W': -6, 'Y': -2},\n          'W': {'A': -6, 'C': -8, 'D': -7, 'E': -7, 'F': 0, 'G': -7, 'H': -3, 'I': -5, 'K': -3, 'L': -2, 'M': -4,\n                'N': -4, 'P': -6, 'Q': -5, 'R': 2, 'S': -2, 'T': -5, 'V': -6, 'W': 17, 'Y': 0},\n          'Y': {'A': -3, 'C': 0, 'D': -4, 'E': -4, 'F': 7, 'G': -5, 'H': 0, 'I': -1, 'K': -4, 'L': -1, 'M': -2, 'N': -2,\n                'P': -5, 'Q': -4, 'R': -4, 'S': -3, 'T': -3, 'V': -2, 'W': 0, 'Y': 10}}\n\ndef local_alignment(sequence1: str, sequence2: str, indel_penalty: int = 5) -&gt; Tuple[int, str, str]:\n    padded_seq1: str = \"-\" + sequence1\n    padded_seq2: str = \"-\" + sequence2\n\n    score_matrix: List[List[int]] = [[0 for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n    backtrack_matrix: List[List[Optional[str]]] = [[None for _ in range(len(padded_seq2))] for _ in range(len(padded_seq1))]\n\n    for i in range(1, len(padded_seq1)):\n        for j in range(1, len(padded_seq2)):\n            key1: str = padded_seq1[i] if padded_seq1[i] in PAM250 else padded_seq2[j]\n            key2: str = padded_seq2[j] if padded_seq1[i] in PAM250 else padded_seq1[i]\n\n            diagonal_score: int = score_matrix[i - 1][j - 1] + PAM250[key1][key2]\n            up_score: int = score_matrix[i - 1][j] - indel_penalty\n            left_score: int = score_matrix[i][j - 1] - indel_penalty\n            score_matrix[i][j] = max(diagonal_score, up_score, left_score, 0)\n\n            if score_matrix[i][j] == diagonal_score:\n                backtrack_matrix[i][j] = \"diagonal\"\n            elif score_matrix[i][j] == up_score:\n                backtrack_matrix[i][j] = \"up\"\n            elif score_matrix[i][j] == left_score:\n                backtrack_matrix[i][j] = \"left\"\n\n    max_score: int = -1\n    max_i: int = 0\n    max_j: int = 0\n    for i in range(len(padded_seq1)):\n        for j in range(len(padded_seq2)):\n            if score_matrix[i][j] &gt; max_score:\n                max_score = score_matrix[i][j]\n                max_i, max_j = i, j\n\n    i: int = max_i\n    j: int = max_j\n    aligned_seq1: str = \"\"\n    aligned_seq2: str = \"\"\n    while backtrack_matrix[i][j] is not None:\n        direction: str = backtrack_matrix[i][j]\n        if direction == \"diagonal\":\n            aligned_seq1 = padded_seq1[i] + aligned_seq1\n            aligned_seq2 = padded_seq2[j] + aligned_seq2\n            i -= 1\n            j -= 1\n        elif direction == \"up\":\n            aligned_seq1 = padded_seq1[i] + aligned_seq1\n            aligned_seq2 = \"-\" + aligned_seq2\n            i -= 1\n        else:\n            aligned_seq1 = \"-\" + aligned_seq1\n            aligned_seq2 = padded_seq2[j] + aligned_seq2\n            j -= 1\n\n    return max_score, aligned_seq1, aligned_seq2\n\n# Sample input\nsample_input: str = \"\"\"\nMEANLY\nPENALTY\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nsequence1: str = input_lines[0]\nsequence2: str = input_lines[1]\n\nalignment_score: int\naligned_sequence1: str\naligned_sequence2: str\nalignment_score, aligned_sequence1, aligned_sequence2 = local_alignment(sequence1, sequence2)\nprint(alignment_score)\nprint(aligned_sequence1)\nprint(aligned_sequence2)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-54",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-54",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "54.1 Sample Dataset",
    "text": "54.1 Sample Dataset\nPLEASANTLY\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-54",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-54",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "54.2 Sample Output",
    "text": "54.2 Sample Output\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-54",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-54",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "54.3 Solution",
    "text": "54.3 Solution\ndef calculate_edit_distance(source: str, target: str) -&gt; int:\n    distance_matrix = {}\n    \n    for target_index in range(len(target) + 1):\n        distance_matrix[target_index, 0] = target_index\n    \n    for source_index in range(len(source) + 1):\n        distance_matrix[0, source_index] = source_index\n\n    for target_index in range(len(target)):\n        for source_index in range(len(source)):\n            if source[source_index] == target[target_index]:\n                distance_matrix[target_index + 1, source_index + 1] = distance_matrix[target_index, source_index]\n            else:\n                distance_matrix[target_index + 1, source_index + 1] = min([\n                    distance_matrix[target_index + 1, source_index],\n                    distance_matrix[target_index, source_index],\n                    distance_matrix[target_index, source_index + 1]\n                ]) + 1\n\n    return distance_matrix[len(target), len(source)]\n\nsample_input: str = \"\"\"\nPLEASANTLY\nMEANLY\n\"\"\"\n\nsource, target = sample_input.strip().split(\"\\n\")\nprint(calculate_edit_distance(source, target))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-55",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-55",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "55.1 Sample Dataset",
    "text": "55.1 Sample Dataset\nGTAGGCTTAAGGTTA\nTAGATA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-55",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-55",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "55.2 Sample Output",
    "text": "55.2 Sample Output\n2\nTAGGCTTA\nTAGA--TA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-55",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-55",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "55.3 Solution",
    "text": "55.3 Solution\nfrom typing import Tuple, Dict\n\ndef calculate_fitting_alignment(sequence1: str, sequence2: str) -&gt; Tuple[int, str, str]:\n    score_matrix: Dict[Tuple[int, int], int] = {}\n    path_matrix: Dict[Tuple[int, int], str] = {}\n    \n    for seq2_index in range(len(sequence2) + 1):\n        score_matrix[seq2_index, 0] = -seq2_index\n        path_matrix[seq2_index, 0] = \"↑\"\n    for seq1_index in range(len(sequence1) + 1):\n        score_matrix[0, seq1_index] = 0\n        path_matrix[0, seq1_index] = \"←\"\n\n    score_matrix[0, 0] = 0\n    for seq2_index in range(len(sequence2)):\n        for seq1_index in range(len(sequence1)):\n            current_position = (seq2_index + 1, seq1_index + 1)\n            match_score = 1 if sequence1[seq1_index] == sequence2[seq2_index] else -1\n            options = [\n                score_matrix[seq2_index, seq1_index] + match_score,\n                score_matrix[seq2_index, seq1_index + 1] - 1,\n                score_matrix[seq2_index + 1, seq1_index] - 1,\n            ]\n            score_matrix[current_position] = max(options)\n            path_matrix[current_position] = [\"↖\", \"↑\", \"←\"][options.index(max(options))]\n\n    final_scores = [score_matrix[len(sequence2), i] for i in range(len(sequence1) + 1)]\n    max_score = max(final_scores)\n    seq1_end_index = final_scores.index(max_score)\n    seq2_end_index = len(sequence2)\n\n    aligned_seq1, aligned_seq2 = \"\", \"\"\n    while seq1_end_index &gt; 0 and seq2_end_index &gt; 0:\n        if path_matrix[seq2_end_index, seq1_end_index] == \"↖\":\n            aligned_seq1 += sequence1[seq1_end_index - 1]\n            aligned_seq2 += sequence2[seq2_end_index - 1]\n            seq2_end_index, seq1_end_index = seq2_end_index - 1, seq1_end_index - 1\n        elif path_matrix[seq2_end_index, seq1_end_index] == \"←\":\n            aligned_seq1 += sequence1[seq1_end_index - 1]\n            aligned_seq2 += \"-\"\n            seq1_end_index = seq1_end_index - 1\n        elif path_matrix[seq2_end_index, seq1_end_index] == \"↑\":\n            aligned_seq1 += \"-\"\n            aligned_seq2 += sequence2[seq2_end_index - 1]\n            seq2_end_index = seq2_end_index - 1\n\n    return max_score, aligned_seq1[::-1], aligned_seq2[::-1]\n\nsample_input: str = \"\"\"\nGTAGGCTTAAGGTTA\nTAGATA\n\"\"\"\n\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nprint(*calculate_fitting_alignment(sequence1, sequence2), sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-56",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-56",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "56.1 Sample Dataset",
    "text": "56.1 Sample Dataset\nPAWHEAE\nHEAGAWGHEE"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-56",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-56",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "56.2 Sample Output",
    "text": "56.2 Sample Output\n1\nHEAE\nHEAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-56",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-56",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "56.3 Solution",
    "text": "56.3 Solution\nfrom typing import Tuple, Dict\n\ndef calculate_overlap_alignment(sequence1: str, sequence2: str, mismatch_penalty: int = -2) -&gt; Tuple[int, str, str]:\n    score_matrix: Dict[Tuple[int, int], int] = {}\n    path_matrix: Dict[Tuple[int, int], str] = {}\n    \n    for seq2_index in range(len(sequence2) + 1):\n        score_matrix[seq2_index, 0] = seq2_index * mismatch_penalty\n        path_matrix[seq2_index, 0] = \"↑\"\n    for seq1_index in range(len(sequence1) + 1):\n        score_matrix[0, seq1_index] = 0\n        path_matrix[0, seq1_index] = \"←\"\n\n    score_matrix[0, 0] = 0\n    for seq2_index in range(len(sequence2)):\n        for seq1_index in range(len(sequence1)):\n            current_position = (seq2_index + 1, seq1_index + 1)\n            match_score = 1 if sequence1[seq1_index] == sequence2[seq2_index] else mismatch_penalty\n            options = [\n                score_matrix[seq2_index, seq1_index] + match_score,\n                score_matrix[seq2_index, seq1_index + 1] + mismatch_penalty,\n                score_matrix[seq2_index + 1, seq1_index] + mismatch_penalty,\n            ]\n            score_matrix[current_position] = max(options)\n            path_matrix[current_position] = [\"↖\", \"↑\", \"←\"][options.index(max(options))]\n\n    final_scores = [score_matrix[seq2_index, len(sequence1)] for seq2_index in range(len(sequence2) + 1)]\n    max_score = max(final_scores)\n    seq2_end_index = final_scores.index(max_score)\n    seq1_end_index = len(sequence1)\n\n    aligned_seq1, aligned_seq2 = \"\", \"\"\n    while seq1_end_index &gt; 0 and seq2_end_index &gt; 0:\n        if path_matrix[seq2_end_index, seq1_end_index] == \"↖\":\n            aligned_seq1 += sequence1[seq1_end_index - 1]\n            aligned_seq2 += sequence2[seq2_end_index - 1]\n            seq2_end_index, seq1_end_index = seq2_end_index - 1, seq1_end_index - 1\n        elif path_matrix[seq2_end_index, seq1_end_index] == \"←\":\n            aligned_seq1 += sequence1[seq1_end_index - 1]\n            aligned_seq2 += \"-\"\n            seq1_end_index = seq1_end_index - 1\n        elif path_matrix[seq2_end_index, seq1_end_index] == \"↑\":\n            aligned_seq1 += \"-\"\n            aligned_seq2 += sequence2[seq2_end_index - 1]\n            seq2_end_index = seq2_end_index - 1\n\n    return max_score, aligned_seq1[::-1], aligned_seq2[::-1]\n\nsample_input: str = \"\"\"\nPAWHEAE\nHEAGAWGHEE\n\"\"\"\n\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nprint(*calculate_overlap_alignment(sequence1, sequence2), sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-57",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-57",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "57.1 Sample Dataset",
    "text": "57.1 Sample Dataset\nPRTEINS\nPRTWPSEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-57",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-57",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "57.2 Sample Output",
    "text": "57.2 Sample Output\n8\nPRT---EINS\nPRTWPSEIN-"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-57",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-57",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "57.3 Solution",
    "text": "57.3 Solution\nfrom typing import Dict, Tuple, List, Optional\n\nBLOSUM62: Dict[Tuple[str, str], int] = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef insert_gap(sequence: str, position: int) -&gt; str:\n    \"\"\"Insert a gap ('-') into the sequence at the specified position.\"\"\"\n    return sequence[:position] + \"-\" + sequence[position:]\n\ndef global_alignment_affine(seq1: str, seq2: str, gap_open_penalty: int = -11, gap_extend_penalty: int = -1) -&gt; Tuple[int, str, str]:\n    \"\"\"\n    Perform global sequence alignment with affine gap penalty.\n    \n    Args:\n    seq1 (str): First sequence to align\n    seq2 (str): Second sequence to align\n    gap_open_penalty (int): Penalty for opening a gap\n    gap_extend_penalty (int): Penalty for extending a gap\n    \n    Returns:\n    Tuple[int, str, str]: Alignment score and aligned sequences\n    \"\"\"\n    scoring_matrix: Dict[Tuple[str, str], int] = BLOSUM62\n    match_score: Dict[Tuple[int, int], int] = {}\n    gap_seq1_score: Dict[Tuple[int, int], int] = {}\n    gap_seq2_score: Dict[Tuple[int, int], int] = {}\n    prev_match: Dict[Tuple[int, int], int] = {}\n    prev_gap_seq1: Dict[Tuple[int, int], int] = {}\n    prev_gap_seq2: Dict[Tuple[int, int], int] = {}\n\n    # Initialize matrices\n    gap_seq1_score[0, 0] = match_score[0, 0] = gap_seq2_score[0, 0] = 0\n    for i in range(1, len(seq1) + 1):\n        gap_seq1_score[i, 0] = gap_open_penalty + (i - 1) * gap_extend_penalty\n        match_score[i, 0] = gap_open_penalty + (i - 1) * gap_extend_penalty\n        gap_seq2_score[i, 0] = gap_open_penalty * 10  # Large penalty to avoid this case\n    for j in range(1, len(seq2) + 1):\n        gap_seq2_score[0, j] = gap_open_penalty + (j - 1) * gap_extend_penalty\n        match_score[0, j] = gap_open_penalty + (j - 1) * gap_extend_penalty\n        gap_seq1_score[0, j] = gap_open_penalty * 10  # Large penalty to avoid this case\n\n    # Fill matrices\n    for i in range(1, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            # Calculate scores for gap in seq1\n            gap_seq1_options: List[int] = [\n                gap_seq1_score[i - 1, j] + gap_extend_penalty,\n                match_score[i - 1, j] + gap_open_penalty\n            ]\n            gap_seq1_score[i, j] = max(gap_seq1_options)\n            prev_gap_seq1[i, j] = gap_seq1_options.index(gap_seq1_score[i, j])\n\n            # Calculate scores for gap in seq2\n            gap_seq2_options: List[int] = [\n                gap_seq2_score[i, j - 1] + gap_extend_penalty,\n                match_score[i, j - 1] + gap_open_penalty\n            ]\n            gap_seq2_score[i, j] = max(gap_seq2_options)\n            prev_gap_seq2[i, j] = gap_seq2_options.index(gap_seq2_score[i, j])\n\n            # Calculate match/mismatch score\n            blosum_score: int = scoring_matrix.get((seq1[i-1], seq2[j-1]), scoring_matrix.get((seq2[j-1], seq1[i-1]), 0))\n            match_options: List[int] = [\n                gap_seq1_score[i, j],\n                match_score[i - 1, j - 1] + blosum_score,\n                gap_seq2_score[i, j]\n            ]\n            match_score[i, j] = max(match_options)\n            prev_match[i, j] = match_options.index(match_score[i, j])\n\n    # Traceback\n    i, j = len(seq1), len(seq2)\n    aligned_seq1, aligned_seq2 = seq1, seq2\n\n    scores: List[int] = [gap_seq1_score[i, j], match_score[i, j], gap_seq2_score[i, j]]\n    max_score: int = max(scores)\n    current_matrix: int = scores.index(max_score)\n\n    while i * j != 0:\n        if current_matrix == 0:  # In gap_seq1_score matrix\n            if prev_gap_seq1[i, j] == 1:\n                current_matrix = 1\n            i -= 1\n            aligned_seq2 = insert_gap(aligned_seq2, j)\n        elif current_matrix == 1:  # In match_score matrix\n            if prev_match[i, j] == 1:\n                i -= 1\n                j -= 1\n            else:\n                current_matrix = prev_match[i, j]\n        else:  # In gap_seq2_score matrix\n            if prev_gap_seq2[i, j] == 1:\n                current_matrix = 1\n            j -= 1\n            aligned_seq1 = insert_gap(aligned_seq1, i)\n\n    # Handle remaining overhangs\n    while i &gt; 0:\n        aligned_seq2 = insert_gap(aligned_seq2, 0)\n        i -= 1\n    while j &gt; 0:\n        aligned_seq1 = insert_gap(aligned_seq1, 0)\n        j -= 1\n\n    return max_score, aligned_seq1, aligned_seq2\n\n# Sample usage\nsample_input: str = \"\"\"\nPRTEINS\nPRTWPSEIN\n\"\"\"\n\nseq1, seq2 = sample_input.strip().split(\"\\n\")\nalignment_score, aligned_seq1, aligned_seq2 = global_alignment_affine(seq1, seq2)\nprint(alignment_score, aligned_seq1, aligned_seq2, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-58",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-58",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "58.1 Sample Dataset",
    "text": "58.1 Sample Dataset\nPLEASANTLY\nMEASNLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-58",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-58",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "58.2 Sample Output",
    "text": "58.2 Sample Output\n(4, 3) (5, 4)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-58",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-58",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "58.3 Solution",
    "text": "58.3 Solution\nfrom math import floor\nfrom typing import Dict, Tuple, List\n\nBLOSUM62: Dict[Tuple[str, str], int] = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef calculate_alignment_scores(\n    sequence1: str,\n    sequence2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; Tuple[List[int], List[int]]:\n    current_scores = list(range(0, (len(sequence1) + 1) * gap_penalty, gap_penalty))\n    backtrack = [0] * (len(sequence1) + 1)\n    \n    for j in range(1, len(sequence2) + 1):\n        previous_scores = current_scores[:]\n        current_scores[0] = previous_scores[0] + gap_penalty\n        for i in range(1, len(sequence1) + 1):\n            options = [\n                previous_scores[i] + gap_penalty,\n                current_scores[i - 1] + gap_penalty,\n                previous_scores[i - 1] + scoring_matrix.get(\n                    (sequence1[i - 1], sequence2[j - 1]),\n                    scoring_matrix.get((sequence2[j - 1], sequence1[i - 1]), 0)\n                ),\n            ]\n            current_scores[i] = max(options)\n            backtrack[i] = options.index(current_scores[i])\n    \n    return current_scores, backtrack\n\ndef find_middle_edge(\n    sequence1: str,\n    sequence2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n    midpoint = floor(len(sequence2) / 2)\n    \n    forward_scores, _ = calculate_alignment_scores(\n        sequence1, sequence2[:midpoint], scoring_matrix, gap_penalty\n    )\n    reverse_scores, reverse_backtrack = calculate_alignment_scores(\n        sequence1[::-1], sequence2[midpoint:][::-1], scoring_matrix, gap_penalty\n    )\n    \n    total_scores = [f + r for f, r in zip(forward_scores, reverse_scores[::-1])]\n    best_score_index = total_scores.index(max(total_scores))\n    \n    start_node = (best_score_index, midpoint)\n    possible_moves = [\n        (start_node[0], start_node[1] + 1),\n        (start_node[0] + 1, start_node[1]),\n        (start_node[0] + 1, start_node[1] + 1)\n    ]\n    end_node = possible_moves[reverse_backtrack[::-1][best_score_index]]\n    \n    return (start_node, end_node)\n\n# Sample usage\nsample_input: str = \"\"\"\nPLEASANTLY\nMEASNLY\n\"\"\"\n\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nresult = find_middle_edge(sequence1, sequence2, BLOSUM62, -5)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-59",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-59",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "59.1 Sample Dataset",
    "text": "59.1 Sample Dataset\nPLEASANTLY\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-59",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-59",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "59.2 Sample Output",
    "text": "59.2 Sample Output\n8\nPLEASANTLY\n-MEA--N-LY"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-59",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-59",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "59.3 Solution",
    "text": "59.3 Solution\nfrom math import floor\nfrom typing import Dict, Tuple, List\n\nBLOSUM62: Dict[Tuple[str, str], int] = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef calculate_alignment_scores(\n    sequence1: str,\n    sequence2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; Tuple[List[int], List[int]]:\n    current_scores = list(range(0, (len(sequence1) + 1) * gap_penalty, gap_penalty))\n    backtrack = [0] * (len(sequence1) + 1)\n    \n    for j in range(1, len(sequence2) + 1):\n        previous_scores = current_scores[:]\n        current_scores[0] = previous_scores[0] + gap_penalty\n        for i in range(1, len(sequence1) + 1):\n            options = [\n                previous_scores[i] + gap_penalty,\n                current_scores[i - 1] + gap_penalty,\n                previous_scores[i - 1] + scoring_matrix.get(\n                    (sequence1[i - 1], sequence2[j - 1]),\n                    scoring_matrix.get((sequence2[j - 1], sequence1[i - 1]), 0)\n                ),\n            ]\n            current_scores[i] = max(options)\n            backtrack[i] = options.index(current_scores[i])\n    \n    return current_scores, backtrack\n\ndef find_middle_edge(\n    sequence1: str,\n    sequence2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n    midpoint = floor(len(sequence2) / 2)\n    \n    forward_scores, _ = calculate_alignment_scores(\n        sequence1, sequence2[:midpoint], scoring_matrix, gap_penalty\n    )\n    reverse_scores, reverse_backtrack = calculate_alignment_scores(\n        sequence1[::-1], sequence2[midpoint:][::-1], scoring_matrix, gap_penalty\n    )\n    \n    total_scores = [f + r for f, r in zip(forward_scores, reverse_scores[::-1])]\n    best_score_index = total_scores.index(max(total_scores))\n    \n    start_node = (best_score_index, midpoint)\n    possible_moves = [\n        (start_node[0], start_node[1] + 1),\n        (start_node[0] + 1, start_node[1]),\n        (start_node[0] + 1, start_node[1] + 1)\n    ]\n    end_node = possible_moves[reverse_backtrack[::-1][best_score_index]]\n    \n    return (start_node, end_node)\n\ndef calculate_alignment_score(\n    aligned_seq1: str,\n    aligned_seq2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; int:\n    return sum(\n        gap_penalty if aligned_seq1[i] == \"-\" or aligned_seq2[i] == \"-\" else\n        scoring_matrix.get((aligned_seq1[i], aligned_seq2[i]),\n                           scoring_matrix.get((aligned_seq2[i], aligned_seq1[i]), 0))\n        for i in range(len(aligned_seq1))\n    )\n\ndef find_alignment_path(\n    sequence1: str,\n    sequence2: str,\n    scoring_matrix: Dict[Tuple[str, str], int],\n    gap_penalty: int\n) -&gt; str:\n    def linear_space_alignment(top: int, bottom: int, left: int, right: int) -&gt; str:\n        if left == right:\n            return \"↓\" * (bottom - top)\n        elif top == bottom:\n            return \"→\" * (right - left)\n        else:\n            ((i, j), (i2, j2)) = find_middle_edge(\n                sequence1[top:bottom], sequence2[left:right], scoring_matrix, gap_penalty\n            )\n            edge = \"↓\" if j == j2 else \"→\" if i == i2 else \"↘\"\n            return (\n                linear_space_alignment(top, i + top, left, j + left) +\n                edge +\n                linear_space_alignment(i2 + top, bottom, j2 + left, right)\n            )\n\n    return linear_space_alignment(0, len(sequence1), 0, len(sequence2))\n\ndef construct_alignment(\n    alignment_path: str,\n    sequence1: str,\n    sequence2: str\n) -&gt; Tuple[str, str]:\n    aligned_seq1, aligned_seq2 = \"\", \"\"\n    i, j = 0, 0\n    for direction in alignment_path:\n        if direction == \"↘\":\n            aligned_seq1 += sequence1[i]\n            aligned_seq2 += sequence2[j]\n            i += 1\n            j += 1\n        elif direction == \"↓\":\n            aligned_seq1 += sequence1[i]\n            aligned_seq2 += \"-\"\n            i += 1\n        else:\n            aligned_seq1 += \"-\"\n            aligned_seq2 += sequence2[j]\n            j += 1\n    return aligned_seq1, aligned_seq2\n\n# Sample usage\nsample_input: str = \"\"\"\nPLEASANTLY\nMEANLY\n\"\"\"\n\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nscoring_matrix = BLOSUM62\nalignment_path = find_alignment_path(sequence1, sequence2, scoring_matrix, -5)\naligned_seq1, aligned_seq2 = construct_alignment(alignment_path, sequence1, sequence2)\nprint(calculate_alignment_score(aligned_seq1, aligned_seq2, scoring_matrix, -5))\nprint(aligned_seq1, aligned_seq2, sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-60",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-60",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "60.1 Sample Dataset",
    "text": "60.1 Sample Dataset\nATATCCG\nTCCGA\nATGTACTG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-60",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-60",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "60.2 Sample Output",
    "text": "60.2 Sample Output\n3\nATATCC-G-\n---TCC-GA\nATGTACTG-"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-60",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-60",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "60.3 Solution",
    "text": "60.3 Solution\nfrom itertools import product\nfrom typing import List, Tuple, Dict\n\n# Check if the coordinates are non-negative in the alignment matrix\ndef is_valid_coordinate(pointer: Tuple[int, ...], position: Tuple[int, ...]) -&gt; bool:\n    return all([i &gt;= 0 for i in get_previous_position(position, pointer)])\n\n# Get the previous position given a current position and a pointer\ndef get_previous_position(position: Tuple[int, ...], pointer: Tuple[int, ...]) -&gt; Tuple[int, ...]:\n    return tuple([p + d for p, d in zip(position, pointer)])\n\n# Calculate the score for a given position and pointer\ndef calculate_score(sequences: List[str], position: Tuple[int, ...], pointer: Tuple[int, ...]) -&gt; int:\n    if pointer == (-1, -1, -1):\n        bases = [sequences[i][j] for i, j in enumerate(get_previous_position(position, pointer))]\n        return int(all(base == bases[0] for base in bases))\n    else:\n        return 0\n\n# Generate possible previous cell pointers\ndef generate_moves(dimension: int) -&gt; List[Tuple[int, ...]]:\n    return list(product([0, -1], repeat=dimension))[1:]\n\ndef multiple_sequence_alignment(sequences: List[str]) -&gt; Tuple[int, str, str, str]:\n    scores: Dict[Tuple[int, ...], int] = {}\n    pointers: Dict[Tuple[int, ...], Tuple[int, ...]] = {}\n    scores[(0, 0, 0)] = 0\n    \n    ranges = [range(0, len(seq) + 1) for seq in sequences]\n    \n    for position in product(*ranges):\n        valid_pointers = list(filter(lambda x: is_valid_coordinate(x, position), generate_moves(3)))\n        if not valid_pointers:\n            continue\n        \n        possible_scores = [scores[get_previous_position(position, ptr)] + calculate_score(sequences, position, ptr) for ptr in valid_pointers]\n        scores[position] = max(possible_scores)\n        pointers[position] = valid_pointers[possible_scores.index(max(possible_scores))]\n\n    # Traceback to recover alignment\n    total_score = scores[position]\n    aligned_sequences = [\"\", \"\", \"\"]\n    \n    while any([x &gt; 0 for x in position]):\n        pointer = pointers[position]\n        for i, seq in enumerate(sequences):\n            aligned_sequences[i] += seq[position[i] - 1] if pointer[i] == -1 else \"-\"\n        position = get_previous_position(position, pointer)\n\n    return (total_score, \n            aligned_sequences[0][::-1], \n            aligned_sequences[1][::-1], \n            aligned_sequences[2][::-1])\n\nsample_input = \"\"\"\nATATCCG\nTCCGA\nATGTACTG\n\"\"\"\n\nsequences = sample_input.strip().split(\"\\n\")\nalignment_score, seq1, seq2, seq3 = multiple_sequence_alignment(sequences)\nprint(alignment_score)\nprint(seq1)\nprint(seq2)\nprint(seq3)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-61",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-61",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "61.1 Sample Dataset",
    "text": "61.1 Sample Dataset\n1 -&gt; 2\n2 -&gt; 3\n4 -&gt; 2\n5 -&gt; 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-61",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-61",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "61.2 Sample Output",
    "text": "61.2 Sample Output\n1, 4, 5, 2, 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-61",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-61",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "61.3 Solution",
    "text": "61.3 Solution\nfrom typing import Dict, List, Tuple, Set\n\nNodeLabel = str\nGraph = Dict[NodeLabel, List[NodeLabel]]\n\ndef create_graph(edge_list: List[str]) -&gt; Graph:\n    graph: Graph = {}\n    for edge in edge_list:\n        source, targets = edge.split(\" -&gt; \")\n        target_list = targets.split(\",\")\n        if source not in graph:\n            graph[source] = []\n        graph[source].extend(target_list)\n        for target in target_list:\n            if target not in graph:\n                graph[target] = []\n    return graph\n\ndef depth_first_search(graph: Graph, node: NodeLabel, visited: Set[NodeLabel], stack: List[NodeLabel]) -&gt; None:\n    visited.add(node)\n    for neighbor in graph.get(node, []):\n        if neighbor not in visited:\n            depth_first_search(graph, neighbor, visited, stack)\n    stack.insert(0, node)\n\ndef topological_sort(graph: Graph) -&gt; List[NodeLabel]:\n    visited: Set[NodeLabel] = set()\n    stack: List[NodeLabel] = []\n    for node in graph:\n        if node not in visited:\n            depth_first_search(graph, node, visited, stack)\n    return stack\n\ndef parse_input(input_text: str) -&gt; List[str]:\n    return input_text.strip().split(\"\\n\")\n\n# Sample usage\nsample_input = \"\"\"\n1 -&gt; 2\n2 -&gt; 3\n4 -&gt; 2\n5 -&gt; 3\n\"\"\"\n\nedge_list = parse_input(sample_input)\ngraph = create_graph(edge_list)\nsorted_nodes = topological_sort(graph)\nprint(\", \".join(sorted_nodes))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-62",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-62",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "62.1 Sample Dataset",
    "text": "62.1 Sample Dataset\n(-3 +4 +1 +5 -2)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-62",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-62",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "62.2 Sample Output",
    "text": "62.2 Sample Output\n(-1 -4 +3 +5 -2)\n(+1 -4 +3 +5 -2)\n(+1 +2 -5 -3 +4)\n(+1 +2 +3 +5 +4)\n(+1 +2 +3 -4 -5)\n(+1 +2 +3 +4 -5)\n(+1 +2 +3 +4 +5)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-62",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-62",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "62.3 Solution",
    "text": "62.3 Solution\nfrom typing import List, Tuple\n\ndef perform_k_sorting_reversal(permutation: List[int], k: int) -&gt; List[int]:\n    j = k\n    while abs(permutation[j]) != k + 1:\n        j += 1\n    permutation[k:j+1] = [-x for x in reversed(permutation[k:j+1])]\n    return permutation\n\ndef greedy_sorting(permutation: List[int]) -&gt; List[List[int]]:\n    reversal_sequence: List[List[int]] = []\n    for k in range(len(permutation)):\n        while permutation[k] != k + 1:\n            permutation = perform_k_sorting_reversal(permutation, k)\n            reversal_sequence.append(list(permutation))\n    return reversal_sequence\n\ndef parse_permutation(input_text: str) -&gt; List[int]:\n    cleaned_input = input_text.strip().replace(\"(\", \"\").replace(\")\", \"\")\n    return [int(x) for x in cleaned_input.split()]\n\ndef format_permutation(permutation: List[int]) -&gt; str:\n    formatted_elements = [(\"+\" if x &gt; 0 else \"\") + str(x) for x in permutation]\n    return \"(\" + \" \".join(formatted_elements) + \")\"\n\n# Sample usage\nsample_input = \"\"\"\n(-3 +4 +1 +5 -2)\n\"\"\"\n\ninitial_permutation = parse_permutation(sample_input)\nsorting_sequence = greedy_sorting(initial_permutation)\n\nfor permutation in sorting_sequence:\n    print(format_permutation(permutation))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-63",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-63",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "63.1 Sample Dataset",
    "text": "63.1 Sample Dataset\n(+3 +4 +5 -12 -8 -7 -6 +1 +2 +10 +9 -11 +13 +14)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-63",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-63",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "63.2 Sample Output",
    "text": "63.2 Sample Output\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-63",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-63",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "63.3 Solution",
    "text": "63.3 Solution\nfrom typing import List\n\ndef count_breakpoints(permutation: List[int]) -&gt; int:\n    augmented_permutation = [0] + permutation + [max(permutation) + 1]\n    breakpoint_count = 0\n    \n    for i in range(1, len(augmented_permutation) - 1):\n        if augmented_permutation[i] != augmented_permutation[i - 1] + 1:\n            breakpoint_count += 1\n    \n    return breakpoint_count\n\nsample_input = \"\"\"\n(+3 +4 +5 -12 -8 -7 -6 +1 +2 +10 +9 -11 +13 +14)\n\"\"\"\n\npermutation_string = sample_input.strip()\npermutation_string = permutation_string.replace(\"(\", \"\").replace(\")\", \"\")\npermutation = [int(x) for x in permutation_string.split()]\n\nprint(count_breakpoints(permutation))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-64",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-64",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "64.1 Sample Dataset",
    "text": "64.1 Sample Dataset\n(+1 +2 +3 +4 +5 +6)\n(+1 -3 -6 -5)(+2 -4)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-64",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-64",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "64.2 Sample Output",
    "text": "64.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-64",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-64",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "64.3 Solution",
    "text": "64.3 Solution\nimport re\nfrom collections import defaultdict\nfrom typing import List, Dict, Set, DefaultDict\n\ndef find_component(start_node: int, graph: Dict[int, List[int]]) -&gt; Set[int]:\n    queue: List[int] = [start_node]\n    visited: Set[int] = set()\n    while queue:\n        current_node = queue.pop(0)\n        visited.add(current_node)\n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return visited\n\ndef parse_genome_graph(genome_string: str) -&gt; DefaultDict[int, List[int]]:\n    genome_graph: DefaultDict[int, List[int]] = defaultdict(list)\n    for component in re.findall(r\"\\((.+?)\\)\", genome_string):\n        chromosome = list(map(int, component.split()))\n        for i in range(len(chromosome) - 1):\n            genome_graph[chromosome[i]].append(-chromosome[i + 1])\n            genome_graph[-chromosome[i + 1]].append(chromosome[i])\n        genome_graph[chromosome[-1]].append(-chromosome[0])\n        genome_graph[-chromosome[0]].append(chromosome[-1])\n    return genome_graph\n\ndef breakpoint_graph(genome1: DefaultDict[int, List[int]], genome2: DefaultDict[int, List[int]]) -&gt; Dict[int, List[int]]:\n    combined_graph: Dict[int, List[int]] = {}\n    for node in genome1.keys():\n        combined_graph[node] = genome1[node] + genome2[node]\n    return combined_graph\n\ndef calculate_two_break_distance(genomes: List[DefaultDict[int, List[int]]]) -&gt; int:\n    combined_graph = breakpoint_graph(*genomes)\n    nodes: Set[int] = set(combined_graph.keys())\n    num_blocks = len(nodes) // 2\n    num_components = 0\n    while nodes:\n        component = find_component(next(iter(nodes)), combined_graph)\n        nodes -= component\n        num_components += 1\n    return num_blocks - num_components\n\nsample_input = \"\"\"\n(+1 +2 +3 +4 +5 +6)\n(+1 -3 -6 -5)(+2 -4)\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\ngenomes = [parse_genome_graph(genome_string) for genome_string in input_lines]\nprint(calculate_two_break_distance(genomes))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-65",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-65",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "65.1 Sample Dataset",
    "text": "65.1 Sample Dataset\n(+1 -2 -3 +4)\n(+1 +2 -4 -3)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-65",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-65",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "65.2 Sample Output",
    "text": "65.2 Sample Output\n(+1 -2 -3 +4)\n(+1 +2 -3 +4)\n(+1 +2 -4 +3)\n(+1 +2 -4 -3)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-65",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-65",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "65.3 Solution",
    "text": "65.3 Solution\nimport re\nfrom collections import defaultdict\nfrom typing import List, Dict, Set, Generator, DefaultDict\n\ndef find_component(start_node: int, graph: Dict[int, List[int]]) -&gt; Set[int]:\n    queue: List[int] = [start_node]\n    visited: Set[int] = set()\n    while queue:\n        current_node = queue.pop(0)\n        visited.add(current_node)\n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return visited\n\ndef parse_genome_graph(genome_string: str) -&gt; DefaultDict[int, List[int]]:\n    genome_graph: DefaultDict[int, List[int]] = defaultdict(list)\n    for component in re.findall(r\"\\((.+?)\\)\", genome_string):\n        chromosome = list(map(int, component.split()))\n        for i in range(len(chromosome) - 1):\n            genome_graph[chromosome[i]].append(-chromosome[i + 1])\n            genome_graph[-chromosome[i + 1]].append(chromosome[i])\n        genome_graph[chromosome[-1]].append(-chromosome[0])\n        genome_graph[-chromosome[0]].append(chromosome[-1])\n    return genome_graph\n\ndef breakpoint_graph(genome1: DefaultDict[int, List[int]], genome2: DefaultDict[int, List[int]]) -&gt; Dict[int, List[int]]:\n    combined_graph: Dict[int, List[int]] = {}\n    for node in genome1.keys():\n        combined_graph[node] = genome1[node] + genome2[node]\n    return combined_graph\n\ndef format_perm(perm: List[int]) -&gt; str:\n    return \"(\" + \" \".join([f\"{x:+}\" for x in perm]) + \")\"\n\ndef find_components(graph: Dict[int, List[int]]) -&gt; Generator[Set[int], None, None]:\n    nodes: Set[int] = set(graph.keys())\n    while nodes:\n        component = find_component(next(iter(nodes)), graph)\n        nodes = nodes - component\n        yield component\n\ndef non_trivial_cycle_nodes(graph: Dict[int, List[int]]) -&gt; List[int] | None:\n    for component in find_components(graph):\n        if len(component) &gt; 2:\n            return list(component)\n    return None\n\ndef find_genome_component(start_node: int, graph: Dict[int, List[int]]) -&gt; List[int]:\n    queue: List[int] = [start_node]\n    visited: List[int] = []\n    while queue:\n        current_node = queue.pop(0)\n        visited.append(current_node)\n        for neighbor in graph[current_node]:\n            if -neighbor not in visited:\n                queue.append(-neighbor)\n    return visited\n\ndef format_genome_graph(genome_graph: Dict[int, List[int]]) -&gt; str:\n    nodes: Set[int] = set(genome_graph.keys())\n    components: List[List[int]] = []\n    while nodes:\n        component = find_genome_component(next(iter(nodes)), genome_graph)\n        nodes = nodes - set(component)\n        nodes = nodes - set(-x for x in component)\n        components.append(component)\n    return \"\".join([format_perm(c) for c in components])\n\ndef add_edge(graph: Dict[int, List[int]], node1: int, node2: int) -&gt; None:\n    graph[node1].append(node2)\n    graph[node2].append(node1)\n\ndef del_edge(graph: Dict[int, List[int]], node1: int, node2: int) -&gt; None:\n    graph[node1].remove(node2)\n    graph[node2].remove(node1)\n\ndef ba6d(genome1: DefaultDict[int, List[int]], genome2: DefaultDict[int, List[int]]) -&gt; Generator[str, None, None]:\n    combined_graph = breakpoint_graph(genome1, genome2)\n    nodes = non_trivial_cycle_nodes(combined_graph)\n    yield format_genome_graph(genome1)\n    while nodes:\n        j = nodes[0]\n        i2 = genome2[nodes[0]][0]\n        i = genome1[j][0]\n        j2 = genome1[i2][0]\n\n        del_edge(genome1, i, j)\n        del_edge(genome1, i2, j2)\n        add_edge(genome1, j, i2)\n        add_edge(genome1, j2, i)\n\n        yield format_genome_graph(genome1)\n        combined_graph = breakpoint_graph(genome1, genome2)\n        nodes = non_trivial_cycle_nodes(combined_graph)\n\nsample_input = \"\"\"\n(+1 -2 -3 +4)\n(+1 +2 -4 -3)\n\"\"\"\n\ngenome1, genome2 = [parse_genome_graph(s) for s in sample_input.strip().split(\"\\n\")]\nfor genome in ba6d(genome1, genome2):\n    print(genome)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-66",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-66",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "66.1 Sample Dataset",
    "text": "66.1 Sample Dataset\n3\nAAACTCATC\nTTTCAAATC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-66",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-66",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "66.2 Sample Output",
    "text": "66.2 Sample Output\n(0, 4)\n(0, 0)\n(4, 2)\n(6, 6)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-66",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-66",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "66.3 Solution",
    "text": "66.3 Solution\nimport re\nfrom typing import List, Tuple, Iterator\n\ndef reverse_complement(sequence: str) -&gt; str:\n    return sequence[::-1].translate(str.maketrans(\"ACGT\", \"TGCA\"))\n\ndef find_overlapping_matches(pattern: str, sequence: str) -&gt; Iterator[re.Match]:\n    return re.finditer(rf\"(?=({pattern}))\", sequence)\n\ndef find_shared_kmers(kmer_length: int, sequence1: str, sequence2: str) -&gt; Iterator[Tuple[int, int]]:\n    for i in range(len(sequence1) - kmer_length + 1):\n        kmer = sequence1[i : (i + kmer_length)]\n        for current_sequence in [kmer, reverse_complement(kmer)]:\n            matches = list(find_overlapping_matches(current_sequence, sequence2))\n            for match in matches:\n                yield (i, match.start())\n\n# Sample usage\nsample_input = \"\"\"\n3\nAAACTCATC\nTTTCAAATC\n\"\"\"\n\nkmer_length, sequence1, sequence2 = sample_input.strip().split(\"\\n\")\nfor match in find_shared_kmers(int(kmer_length), sequence1, sequence2):\n    print(match)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-67",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-67",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "67.1 Sample Dataset",
    "text": "67.1 Sample Dataset\n(+1 -2 -3 +4)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-67",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-67",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "67.2 Sample Output",
    "text": "67.2 Sample Output\n(1 2 4 3 6 5 7 8)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-67",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-67",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "67.3 Solution",
    "text": "67.3 Solution\nfrom typing import List\n\ndef parse_permutation(permutation_string: str) -&gt; List[int]:\n    return list(map(int, permutation_string[1:-1].split()))\n\ndef chromosome_to_cycle(chromosome: List[int]) -&gt; List[int]:\n    nodes: List[int] = []\n    for gene in chromosome:\n        if gene &gt; 0:\n            nodes.extend([2 * gene - 1, 2 * gene])\n        else:\n            nodes.extend([-2 * gene, -2 * gene - 1])\n    return nodes\n\ndef convert_chromosome_to_cycle(chromosome_string: str) -&gt; List[int]:\n    return chromosome_to_cycle(parse_permutation(chromosome_string))\n\ndef format_cycle(cycle: List[int]) -&gt; str:\n    return \"(\" + \" \".join(map(str, cycle)) + \")\"\n\nsample_input: str = \"(+1 -2 -3 +4)\"\n\nchromosome_string: str = sample_input.strip()\nprint(format_cycle(convert_chromosome_to_cycle(chromosome_string)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-68",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-68",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "68.1 Sample Dataset",
    "text": "68.1 Sample Dataset\n(1 2 4 3 6 5 7 8)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-68",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-68",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "68.2 Sample Output",
    "text": "68.2 Sample Output\n(+1 -2 -3 +4)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-68",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-68",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "68.3 Solution",
    "text": "68.3 Solution\nfrom typing import List\n\ndef parse_cycle(cycle_string: str) -&gt; List[int]:\n    return list(map(int, cycle_string[1:-1].split()))\n\ndef format_chromosome(chromosome: List[int]) -&gt; str:\n    return \"(\" + \" \".join([f\"{gene:+}\" for gene in chromosome]) + \")\"\n\ndef cycle_to_chromosome(cycle: List[int]) -&gt; List[int]:\n    chromosome: List[int] = []\n    for j1, j2 in zip(cycle[::2], cycle[1::2]):\n        if j1 &lt; j2:\n            chromosome.append(j2 // 2)\n        else:\n            chromosome.append(-j1 // 2)\n    return chromosome\n\nsample_input: str = \"(1 2 4 3 6 5 7 8)\"\n\ncycle_string: str = sample_input.strip()\nchromosome: List[int] = cycle_to_chromosome(parse_cycle(cycle_string))\nprint(format_chromosome(chromosome))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-69",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-69",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "69.1 Sample Dataset",
    "text": "69.1 Sample Dataset\n(+1 -2 -3)(+4 +5 -6)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-69",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-69",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "69.2 Sample Output",
    "text": "69.2 Sample Output\n(2, 4), (3, 6), (5, 1), (8, 9), (10, 12), (11, 7)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-69",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-69",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "69.3 Solution",
    "text": "69.3 Solution\nimport re\nfrom typing import List, Dict, Tuple\n\ndef chromosome_to_cycle(chromosome: List[int]) -&gt; List[int]:\n    nodes: List[int] = []\n    for gene in chromosome:\n        if gene &gt; 0:\n            nodes.extend([2 * gene - 1, 2 * gene])\n        else:\n            nodes.extend([-2 * gene, -2 * gene - 1])\n    return nodes\n\ndef parse_integers(string: str) -&gt; List[int]:\n    return list(map(int, string.split()))\n\ndef get_colored_edges(genome: List[List[int]]) -&gt; Dict[int, int]:\n    edge_dict: Dict[int, int] = {}\n    for chromosome in genome:\n        nodes = chromosome_to_cycle(chromosome)\n        for j in range(len(chromosome)):\n            start_index = 2 * j + 1\n            end_index = (2 * j + 2) % len(nodes)\n            edge_dict[nodes[start_index]] = nodes[end_index]\n    return edge_dict\n\nsample_input: str = \"(+1 -2 -3)(+4 +5 -6)\"\n\ngenome_string: str = sample_input.strip()\ngenome: List[List[int]] = [parse_integers(x) for x in re.findall(r\"\\((.+?)\\)\", genome_string)]\nedges: List[Tuple[int, int]] = [(k, v) for k, v in get_colored_edges(genome).items()]\nprint(*edges, sep=\", \")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-70",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-70",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "70.1 Sample Dataset",
    "text": "70.1 Sample Dataset\n(2, 4), (3, 6), (5, 1), (7, 9), (10, 12), (11, 8)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-70",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-70",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "70.2 Sample Output",
    "text": "70.2 Sample Output\n(+1 -2 -3)(-4 +5 -6)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-70",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-70",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "70.3 Solution",
    "text": "70.3 Solution\nimport re\nfrom typing import List, Dict, Tuple, Iterator\nfrom copy import copy\n\ndef format_chromosome(chromosome: List[int]) -&gt; str:\n    return \"(\" + \" \".join([f\"{gene:+}\" for gene in chromosome]) + \")\"\n\ndef cycle_to_chromosome(cycle: List[int]) -&gt; List[int]:\n    chromosome: List[int] = []\n    for j1, j2 in zip(cycle[::2], cycle[1::2]):\n        if j1 &lt; j2:\n            chromosome.append(j2 // 2)\n        else:\n            chromosome.append(-j1 // 2)\n    return chromosome\n\ndef parse_integers(string: str) -&gt; List[int]:\n    return list(map(int, string.split(\", \")))\n\ndef get_first_key(dictionary: Dict) -&gt; int:\n    return next(iter(dictionary.keys()))\n\n# Find a single cycle from colored edges\ndef find_node_cycle(graph: Dict[int, int]) -&gt; List[int]:\n    start: int = get_first_key(graph)\n    current: int = start\n    component: List[int] = []\n    while graph:\n        next_node: int = graph.pop(current)\n        graph.pop(next_node)\n        neighbor: int = next_node + 1 if next_node % 2 else next_node - 1\n        if neighbor == start:\n            return [next_node] + component + [current]\n        component.extend([current, next_node])\n        current = neighbor\n\n# find cycles in colored edges\n# to do this, we first make each edge \"undirected\"\ndef find_node_cycles(graph: Dict[int, int]) -&gt; Iterator[List[int]]:\n    graph = copy(graph)\n    for k, v in list(graph.items()):\n        graph[v] = k\n    while graph:\n        yield find_node_cycle(graph)\n\ndef graph_to_genome(genome_graph: Dict[int, int]) -&gt; List[List[int]]:\n    genome: List[List[int]] = []\n    for nodes in find_node_cycles(genome_graph):\n        genome.append(cycle_to_chromosome(nodes))\n    return genome\n\ndef parse_edge_string(edge_string: str) -&gt; Dict[int, int]:\n    graph: Dict[int, int] = {}\n    for x in re.findall(r\"\\((.+?)\\)\", edge_string):\n        a, b = parse_integers(x)\n        graph[a] = b\n    return graph\n\nsample_input: str = \"(2, 4), (3, 6), (5, 1), (7, 9), (10, 12), (11, 8)\"\n\nedge_string: str = sample_input.strip()\ngenome_graph: Dict[int, int] = parse_edge_string(edge_string)\nprint(*[format_chromosome(x) for x in graph_to_genome(genome_graph)], sep=\"\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-71",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-71",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "71.1 Sample Dataset",
    "text": "71.1 Sample Dataset\n(2, 4), (3, 8), (7, 5), (6, 1)\n1, 6, 3, 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-71",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-71",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "71.2 Sample Output",
    "text": "71.2 Sample Output\n(2, 4), (3, 1), (7, 5), (6, 8)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-71",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-71",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "71.3 Solution",
    "text": "71.3 Solution\nimport re\nfrom typing import Dict, List, Tuple\nfrom copy import copy\n\ndef parse_edge_string(edge_string: str) -&gt; Dict[int, int]:\n    graph: Dict[int, int] = {}\n    for match in re.findall(r\"\\((.+?)\\)\", edge_string):\n        node1, node2 = parse_integers(match)\n        graph[node1] = node2\n    return graph\n\ndef parse_integers(string: str) -&gt; List[int]:\n    return list(map(int, string.split(\", \")))\n\ndef remove_edge(graph: Dict[int, int], edge: Tuple[int, int]) -&gt; None:\n    if edge[0] in graph:\n        graph.pop(edge[0])\n    else:\n        graph.pop(edge[1])\n\ndef two_break_on_genome_graph(graph: Dict[int, int], i: int, ip: int, j: int, jp: int) -&gt; Dict[int, int]:\n    new_graph: Dict[int, int] = copy(graph)\n    for edge in [(i, ip), (j, jp)]:\n        remove_edge(new_graph, edge)\n    new_graph[i] = j\n    new_graph[ip] = jp\n    return new_graph\n\nsample_input: str = \"\"\"\n(2, 4), (3, 8), (7, 5), (6, 1)\n1, 6, 3, 8\n\"\"\"\n\nedge_string, break_points = sample_input.strip().split(\"\\n\")\ngraph: Dict[int, int] = parse_edge_string(edge_string)\nbreak_points_list: List[int] = parse_integers(break_points)\nnew_graph: Dict[int, int] = two_break_on_genome_graph(graph, *break_points_list)\nedges: List[Tuple[int, int]] = [(k, v) for k, v in new_graph.items()]\nprint(*edges, sep=\", \")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-72",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-72",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "72.1 Sample Dataset",
    "text": "72.1 Sample Dataset\n(+1 -2 -4 +3)\n1, 6, 3, 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-72",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-72",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "72.2 Sample Output",
    "text": "72.2 Sample Output\n(+1 -2) (-4 +3)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-72",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-72",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "72.3 Solution",
    "text": "72.3 Solution\nfrom typing import List, Dict, Tuple, Iterator\nfrom copy import copy\n\ndef parse_permutation(s: str) -&gt; List[int]:\n    return list(map(int, s[1:-1].split()))\n\ndef format_permutation(chromosome: List[int]) -&gt; str:\n    return \"(\" + \" \".join([f\"{gene:+}\" for gene in chromosome]) + \")\"\n\ndef chromosome_to_cycle(chromosome: List[int]) -&gt; List[int]:\n    nodes: List[int] = []\n    for gene in chromosome:\n        if gene &gt; 0:\n            nodes.extend([2 * gene - 1, 2 * gene])\n        else:\n            nodes.extend([-2 * gene, -2 * gene - 1])\n    return nodes\n    \ndef colored_edges(genome: List[List[int]]) -&gt; Dict[int, int]:\n    graph: Dict[int, int] = {}\n    for chromosome in genome:\n        nodes = chromosome_to_cycle(chromosome)\n        for j in range(len(chromosome)):\n            start_index = 2 * j + 1\n            end_index = (2 * j + 2) % len(nodes)\n            graph[nodes[start_index]] = nodes[end_index]\n    return graph\n\ndef remove_edge(graph: Dict[int, int], edge: Tuple[int, int]) -&gt; None:\n    if edge[0] in graph:\n        graph.pop(edge[0])\n    else:\n        graph.pop(edge[1])\n        \ndef two_break_on_genome_graph(graph: Dict[int, int], i: int, ip: int, j: int, jp: int) -&gt; Dict[int, int]:\n    new_graph = copy(graph)\n    for edge in [(i, ip), (j, jp)]:\n        remove_edge(new_graph, edge)\n    new_graph[i] = j\n    new_graph[ip] = jp\n    return new_graph\n\ndef get_first_key(dictionary: Dict) -&gt; int:\n    return next(iter(dictionary.keys()))\n    \ndef find_node_cycle(graph: Dict[int, int]) -&gt; List[int]:\n    start = get_first_key(graph)\n    current = start\n    component: List[int] = []\n    while graph:\n        next_node = graph.pop(current)\n        graph.pop(next_node)\n        neighbor = next_node + 1 if next_node % 2 else next_node - 1\n        if neighbor == start:\n            return [next_node] + component + [current]\n        component.extend([current, next_node])\n        current = neighbor\n        \ndef find_node_cycles(graph: Dict[int, int]) -&gt; Iterator[List[int]]:\n    graph = copy(graph)\n    for k, v in list(graph.items()):\n        graph[v] = k\n    while graph:\n        yield find_node_cycle(graph)\n\ndef cycle_to_chromosome(cycle: List[int]) -&gt; List[int]:\n    chromosome: List[int] = []\n    for j1, j2 in zip(cycle[::2], cycle[1::2]):\n        if j1 &lt; j2:\n            chromosome.append(j2 // 2)\n        else:\n            chromosome.append(-j1 // 2)\n    return chromosome\n\ndef graph_to_genome(genome_graph: Dict[int, int]) -&gt; List[List[int]]:\n    genome: List[List[int]] = []\n    for nodes in find_node_cycles(genome_graph):\n        genome.append(cycle_to_chromosome(nodes))\n    return genome\n\ndef parse_integers(x: str) -&gt; List[int]:\n    return list(map(int, x.split(\", \")))\n\ndef two_break_on_genome(chromosome: List[int], i: int, ip: int, j: int, jp: int) -&gt; List[List[int]]:\n    genome_graph = colored_edges([chromosome])\n    genome_graph = two_break_on_genome_graph(genome_graph, i, ip, j, jp)\n    return graph_to_genome(genome_graph)\n\nsample_input: str = \"\"\"\n(+1 -2 -4 +3)\n1, 6, 3, 8\n\"\"\"\n\ngenome_str, indices_str = sample_input.strip().split(\"\\n\")\ngenome = parse_permutation(genome_str)\nnew_genome = two_break_on_genome(genome, *parse_integers(indices_str))\nprint(*[format_permutation(x) for x in new_genome])"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-73",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-73",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "73.1 Sample Dataset",
    "text": "73.1 Sample Dataset\n4\n0-&gt;4:11\n1-&gt;4:2\n2-&gt;5:6\n3-&gt;5:7\n4-&gt;0:11\n4-&gt;1:2\n4-&gt;5:4\n5-&gt;4:4\n5-&gt;3:7\n5-&gt;2:6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-73",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-73",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "73.2 Sample Output",
    "text": "73.2 Sample Output\n0   13  21  22\n13  0   12  13\n21  12  0   13\n22  13  13  0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-73",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-73",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "73.3 Solution",
    "text": "73.3 Solution\nfrom re import split\nfrom collections import defaultdict\nfrom math import inf\nfrom heapq import heappush, heappop\nfrom typing import Dict, List, Set, Tuple\n\ndef get_all_nodes(graph: Dict[int, List[Dict[str, int]]]) -&gt; Set[int]:\n    source_nodes = set(graph.keys())\n    destination_nodes = {edge[\"n\"] for edges in graph.values() for edge in edges}\n    return source_nodes | destination_nodes\n\n# Dijkstra's algorithm to find distance from start to all other nodes\n# Assumes nodes are integers starting at 0!\ndef dijkstra(start: int, graph: Dict[int, List[Dict[str, int]]]) -&gt; List[float]:\n    distances = [inf for _ in range(len(get_all_nodes(graph)))]\n    distances[start] = 0\n    priority_queue: List[Tuple[float, int]] = []\n    heappush(priority_queue, (0, start))\n    processed_nodes: Set[int] = set()\n\n    while priority_queue:\n        current_node = heappop(priority_queue)[1]\n        processed_nodes.add(current_node)\n        for neighbor in graph[current_node]:\n            if neighbor[\"n\"] not in processed_nodes:\n                distances[neighbor[\"n\"]] = min(distances[current_node] + neighbor[\"w\"], distances[neighbor[\"n\"]])\n                heappush(priority_queue, (distances[neighbor[\"n\"]], neighbor[\"n\"]))\n\n    return distances\n\ndef parse_weighted_graph(edges: List[str]) -&gt; Dict[int, List[Dict[str, int]]]:\n    graph: Dict[int, List[Dict[str, int]]] = defaultdict(list)\n\n    for edge in edges:\n        from_node, to_node, weight = map(int, split(r\"\\D+\", edge))\n        graph[from_node].append({\"n\": to_node, \"w\": weight})\n\n    return graph\n\nsample_input = \"\"\"\n4\n0-&gt;4:11\n1-&gt;4:2\n2-&gt;5:6\n3-&gt;5:7\n4-&gt;0:11\n4-&gt;1:2\n4-&gt;5:4\n5-&gt;4:4\n5-&gt;3:7\n5-&gt;2:6\n\"\"\"\n\nnum_leaves, *edges = sample_input.strip().split(\"\\n\")\nnum_leaves = int(num_leaves)\ngraph = parse_weighted_graph(edges)\nfor i in range(num_leaves):\n    print(*dijkstra(i, graph)[:num_leaves])"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-74",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-74",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "74.1 Sample Dataset",
    "text": "74.1 Sample Dataset\n4\n1\n0   13  21  22\n13  0   12  13\n21  12  0   13\n22  13  13  0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-74",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-74",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "74.2 Sample Output",
    "text": "74.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-74",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-74",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "74.3 Solution",
    "text": "74.3 Solution\nfrom re import split\nfrom collections import defaultdict\nfrom math import inf\nfrom heapq import heappush, heappop\nfrom typing import Dict, List, Set, Tuple\n\ndef get_all_nodes(graph: Dict[int, List[Dict[str, int]]]) -&gt; Set[int]:\n    source_nodes: Set[int] = set(graph.keys())\n    destination_nodes: Set[int] = {edge[\"to\"] for edges in graph.values() for edge in edges}\n    return source_nodes | destination_nodes\n\n# Dijkstra's algorithm to find distance from start to all other nodes\n# Assumes nodes are integers starting at 0!\ndef dijkstra(start: int, graph: Dict[int, List[Dict[str, int]]]) -&gt; List[float]:\n    distances: List[float] = [inf for _ in range(len(get_all_nodes(graph)))]\n    distances[start] = 0\n    priority_queue: List[Tuple[float, int]] = []\n    heappush(priority_queue, (0, start))\n    processed_nodes: Set[int] = set()\n\n    while priority_queue:\n        current_distance, current_node = heappop(priority_queue)\n        if current_node in processed_nodes:\n            continue\n        processed_nodes.add(current_node)\n        for neighbor in graph[current_node]:\n            neighbor_node: int = neighbor[\"to\"]\n            edge_weight: int = neighbor[\"weight\"]\n            if neighbor_node not in processed_nodes:\n                new_distance: float = current_distance + edge_weight\n                if new_distance &lt; distances[neighbor_node]:\n                    distances[neighbor_node] = new_distance\n                    heappush(priority_queue, (new_distance, neighbor_node))\n\n    return distances\n\ndef parse_weighted_graph(edges: List[str]) -&gt; Dict[int, List[Dict[str, int]]]:\n    graph: Dict[int, List[Dict[str, int]]] = defaultdict(list)\n\n    for edge in edges:\n        from_node, to_node, weight = map(int, split(r\"\\D+\", edge))\n        graph[from_node].append({\"to\": to_node, \"weight\": weight})\n\n    return graph\n\nsample_input: str = \"\"\"\n4\n0-&gt;4:11\n1-&gt;4:2\n2-&gt;5:6\n3-&gt;5:7\n4-&gt;0:11\n4-&gt;1:2\n4-&gt;5:4\n5-&gt;4:4\n5-&gt;3:7\n5-&gt;2:6\n\"\"\"\n\nnum_leaves, *edges = sample_input.strip().split(\"\\n\")\nnum_leaves: int = int(num_leaves)\ngraph: Dict[int, List[Dict[str, int]]] = parse_weighted_graph(edges)\nfor i in range(num_leaves):\n    print(*dijkstra(i, graph)[:num_leaves])"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-75",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-75",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "75.1 Sample Dataset",
    "text": "75.1 Sample Dataset\n4\n0   13  21  22\n13  0   12  13\n21  12  0   13\n22  13  13  0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-75",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-75",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "75.2 Sample Output",
    "text": "75.2 Sample Output\n0-&gt;4:11\n1-&gt;4:2\n2-&gt;5:6\n3-&gt;5:7\n4-&gt;0:11\n4-&gt;1:2\n4-&gt;5:4\n5-&gt;2:6\n5-&gt;3:7\n5-&gt;4:4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-75",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-75",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "75.3 Solution",
    "text": "75.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict, Set, Tuple, Generator\n\n# Type aliases for clarity\nDistanceMatrix = List[List[int]]\nGraph = Dict[int, List[Dict[str, int]]]\n\ndef parse_distance_matrix(lines: List[str]) -&gt; DistanceMatrix:\n    \"\"\"Parse integer matrix from set of lines\"\"\"\n    return [[int(x) for x in line.split()] for line in lines]\n\ndef calculate_limb_length(distance_matrix: DistanceMatrix, j: int) -&gt; int:\n    \"\"\"Calculate limb length j for distance matrix\"\"\"\n    min_limb_length = float('inf')\n    n = len(distance_matrix)\n    for k in range(n):\n        for i in range(n):\n            if j != k and i != j:\n                limb_length = (distance_matrix[i][j] + distance_matrix[j][k] - distance_matrix[i][k]) // 2\n                min_limb_length = min(limb_length, min_limb_length)\n    return min_limb_length\n\ndef get_all_nodes(graph: Graph) -&gt; Set[int]:\n    \"\"\"Get all nodes in the graph\"\"\"\n    source_nodes = set(graph.keys())\n    target_nodes = {edge[\"n\"] for edges in graph.values() for edge in edges}\n    return source_nodes | target_nodes\n\ndef find_path(graph: Graph, path: List[Tuple[int, int]], target: int) -&gt; Generator[List[Tuple[int, int]], None, None]:\n    \"\"\"Search tree, returning route to target and cumulative distance\"\"\"\n    if target in [x[0] for x in path]:\n        yield path\n    current_node, current_distance = path[-1]\n    if current_node in graph:\n        for edge in graph[current_node]:\n            if edge[\"n\"] not in [x[0] for x in path]:\n                new_path = path + [(edge[\"n\"], current_distance + edge[\"w\"])]\n                yield from find_path(graph, new_path, target)\n\ndef find_leaves(distance_matrix: DistanceMatrix, n: int) -&gt; Tuple[int, int, int]:\n    \"\"\"Find three leaves i, n, k such that D[i][k] = D[i][n] + D[n][k]\"\"\"\n    for i in range(len(distance_matrix)):\n        for k in range(i + 1, len(distance_matrix)):\n            if distance_matrix[i][k] == distance_matrix[i][n] + distance_matrix[n][k]:\n                return i, n, k\n    raise ValueError(\"No suitable leaves found\")\n\ndef add_node(tree: Graph, i: int, k: int, x: int, n: int) -&gt; Graph:\n    \"\"\"Add node in graph between i and k, distance x from i, labelled n\"\"\"\n    path = list(find_path(tree, [(i, 0)], k))[0]\n    for p, node in enumerate(path):\n        if node[1] &gt; x:\n            break\n    p = p - 1\n    i, d1 = path[p]\n    k, d2 = path[p + 1]\n\n    # Delete old edge and add new edges\n    tree[i] = [edge for edge in tree[i] if edge[\"n\"] != k]\n    tree[i].append({\"n\": n, \"w\": x - d1})\n    tree.setdefault(n, []).append({\"n\": k, \"w\": d2 - x})\n    return tree\n\ndef additive_phylogeny(distance_matrix: DistanceMatrix, m: int) -&gt; Graph:\n    n = len(distance_matrix) - 1\n    if len(distance_matrix) == 2:\n        graph = defaultdict(list)\n        graph[0].append({\"n\": 1, \"w\": distance_matrix[0][1]})\n        return graph\n\n    limb_length = calculate_limb_length(distance_matrix, n)\n    for j in range(len(distance_matrix)):\n        if j != n:\n            distance_matrix[j][n] -= limb_length\n            distance_matrix[n][j] = distance_matrix[j][n]\n\n    i, n, k = find_leaves(distance_matrix, n)\n    x = distance_matrix[i][n]\n\n    # Remove row n and column n from distance_matrix\n    reduced_matrix = [row[:n] + row[n+1:] for row in distance_matrix[:n] + distance_matrix[n+1:]]\n\n    tree = additive_phylogeny(reduced_matrix, m)\n\n    # Label for new internal node\n    v = max(max(get_all_nodes(tree)), m - 1) + 1\n\n    # Break an internal edge adding a new node (possibly) and add the new leaf node\n    tree = add_node(tree, i, k, x, v)\n    tree.setdefault(v, []).append({\"n\": n, \"w\": limb_length})\n    return tree\n\ndef get_edges(graph: Graph) -&gt; List[str]:\n    edges = []\n    for k in sorted(graph):\n        for v in graph[k]:\n            edges.append(f\"{k}-&gt;{v['n']}:{v['w']}\")\n            edges.append(f\"{v['n']}-&gt;{k}:{v['w']}\")\n    return sorted(edges)\n\n# Sample usage\nsample_input = \"\"\"\n4\n0   13  21  22\n13  0   12  13\n21  12  0   13\n22  13  13  0\n\"\"\"\n\nn, *distance_matrix_str = sample_input.strip().split(\"\\n\")\ndistance_matrix = parse_distance_matrix(distance_matrix_str)\ngraph = additive_phylogeny(distance_matrix, int(n))\nfor edge in get_edges(graph):\n    print(edge)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-76",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-76",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "76.1 Sample Dataset",
    "text": "76.1 Sample Dataset\n4\n0   20  17  11\n20  0   20  13\n17  20  0   10\n11  13  10  0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-76",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-76",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "76.2 Sample Output",
    "text": "76.2 Sample Output\n0-&gt;5:7.000\n1-&gt;6:8.833\n2-&gt;4:5.000\n3-&gt;4:5.000\n4-&gt;2:5.000\n4-&gt;3:5.000\n4-&gt;5:2.000\n5-&gt;0:7.000\n5-&gt;4:2.000\n5-&gt;6:1.833\n6-&gt;5:1.833\n6-&gt;1:8.833"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-76",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-76",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "76.3 Solution",
    "text": "76.3 Solution\nfrom typing import List\n\ndef parse_matrix(lines: List[str]) -&gt; List[List[int]]:\n    \"\"\"Parse integer matrix from set of lines\"\"\"\n    return [[int(x) for x in line.split()] for line in lines]\n\nimport numpy as np\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\ndef as_edges(graph: Dict[int, List[Dict[str, float]]]) -&gt; List[str]:\n    edges = []\n    for source in sorted(graph):\n        for target in graph[source]:\n            edges.append(f\"{source}-&gt;{target['n']}:{target['w']:f}\")\n            edges.append(f\"{target['n']}-&gt;{source}:{target['w']:f}\")\n    return sorted(edges)\n\ndef closest(distance_matrix: np.ndarray) -&gt; Tuple[int, int]:\n    \"\"\"Find (first) minimum off diagonal index in an array\"\"\"\n    distance_matrix = np.copy(distance_matrix)\n    np.fill_diagonal(distance_matrix, distance_matrix.max() + 1)\n    return divmod(distance_matrix.argmin(), distance_matrix.shape[1])\n\ndef average_ind(distance_matrix: np.ndarray, i: int, j: int, size_i: int, size_j: int) -&gt; np.ndarray:\n    \"\"\"Replace the ith row/col with the average of the ith and jth and remove the jth\"\"\"\n    distance_matrix = np.copy(distance_matrix)\n    average = (distance_matrix[i, :] * size_i + distance_matrix[j, :] * size_j) / (size_i + size_j)\n    distance_matrix[i, :] = average\n    distance_matrix[:, i] = average\n    distance_matrix = np.delete(distance_matrix, j, 0)\n    distance_matrix = np.delete(distance_matrix, j, 1)\n    np.fill_diagonal(distance_matrix, 0)\n    return distance_matrix\n\ndef upgma(distance_matrix: np.ndarray, num_clusters: int) -&gt; Dict[int, List[Dict[str, float]]]:\n    clusters = list(range(0, num_clusters))\n    ages: Dict[int, float] = defaultdict(lambda: 0)  # the \"age\" of a node\n    size: Dict[int, int] = defaultdict(lambda: 1)  # the number of descendants of a node\n    tree: Dict[int, List[Dict[str, float]]] = {}  # the graph / tree we're building\n    node_label = num_clusters  # a label for internal nodes as we add them\n    \n    while len(clusters) &gt; 1:\n        i, j = closest(distance_matrix)\n        a, b = clusters[i], clusters[j]\n\n        tree[node_label] = [\n            {\"n\": a, \"w\": distance_matrix[i, j] / 2 - ages[a]},\n            {\"n\": b, \"w\": distance_matrix[i, j] / 2 - ages[b]},\n        ]\n        size[node_label] = size[a] + size[b]\n        ages[node_label] = distance_matrix[i, j] / 2\n        clusters[i] = node_label\n        del clusters[j]\n        distance_matrix = average_ind(distance_matrix, *closest(distance_matrix), size[a], size[b])\n        node_label += 1\n\n    return tree\n\nsample_input = \"\"\"\n4\n0   20  17  11\n20  0   20  13\n17  20  0   10\n11  13  10  0\n\"\"\"\n\nnum_clusters, *distance_data = sample_input.strip().split(\"\\n\")\ndistance_matrix = np.array(parse_matrix(distance_data), float)\ngraph = upgma(distance_matrix, int(num_clusters))\nfor edge in as_edges(graph):\n    print(edge)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-77",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-77",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "77.1 Sample Dataset",
    "text": "77.1 Sample Dataset\n4\n0   23  27  20\n23  0   30  28\n27  30  0   30\n20  28  30  0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-77",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-77",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "77.2 Sample Output",
    "text": "77.2 Sample Output\n0-&gt;4:8.000\n1-&gt;5:13.500\n2-&gt;5:16.500\n3-&gt;4:12.000\n4-&gt;5:2.000\n4-&gt;0:8.000\n4-&gt;3:12.000\n5-&gt;1:13.500\n5-&gt;2:16.500\n5-&gt;4:2.000"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-77",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-77",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "77.3 Solution",
    "text": "77.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict, Union\nimport numpy as np\n\ndef parse_matrix(lines: List[str]) -&gt; List[List[int]]:\n    \"\"\"Parse integer matrix from set of lines\"\"\"\n    return [[int(x) for x in line.split()] for line in lines]\n\ndef format_edges(tree: Dict[int, List[Dict[str, Union[int, float]]]]) -&gt; List[str]:\n    formatted_edges = []\n    for node in sorted(tree):\n        for neighbor in tree[node]:\n            formatted_edges.append(f\"{node}-&gt;{neighbor['node']}:{neighbor['weight']:f}\")\n            formatted_edges.append(f\"{neighbor['node']}-&gt;{node}:{neighbor['weight']:f}\")\n    return sorted(formatted_edges)\n\ndef find_closest_pair(distance_matrix: np.ndarray) -&gt; tuple[int, int]:\n    \"\"\"Find (first) minimum off-diagonal index in an array\"\"\"\n    temp_matrix = np.copy(distance_matrix)\n    np.fill_diagonal(temp_matrix, temp_matrix.max() + 1)\n    return divmod(temp_matrix.argmin(), temp_matrix.shape[1])\n\ndef calculate_neighbor_joining_matrix(distance_matrix: np.ndarray, num_nodes: int) -&gt; np.ndarray:\n    nj_matrix = np.copy(distance_matrix)\n    for i in range(len(distance_matrix)):\n        for j in range(len(distance_matrix)):\n            if i != j:\n                nj_matrix[i, j] = (num_nodes - 2) * distance_matrix[i, j] - sum(distance_matrix[i, :]) - sum(distance_matrix[j, :])\n    return nj_matrix\n\ndef neighbor_joining(distance_matrix: np.ndarray, num_nodes: int, labels: List[int] = None) -&gt; Dict[int, List[Dict[str, Union[int, float]]]]:\n    if not labels:\n        labels = list(range(num_nodes))\n\n    if num_nodes == 2:\n        tree = defaultdict(list)\n        tree[labels[0]].append({\"node\": labels[1], \"weight\": distance_matrix[0][1]})\n        return tree\n\n    nj_matrix = calculate_neighbor_joining_matrix(distance_matrix, num_nodes)\n    i, j = find_closest_pair(nj_matrix)\n    delta = (sum(distance_matrix[i, :]) - sum(distance_matrix[j, :])) / (num_nodes - 2)\n    limb_i = (distance_matrix[i, j] + delta) / 2\n    limb_j = (distance_matrix[i, j] - delta) / 2\n\n    label_i = labels[i]\n    label_j = labels[j]\n\n    distance_matrix = np.append(distance_matrix, np.zeros((1, len(distance_matrix))), axis=0)\n    distance_matrix = np.append(distance_matrix, np.zeros((len(distance_matrix), 1)), axis=1)\n    labels = labels + [max(labels) + 1]\n\n    for k in range(num_nodes):\n        distance_matrix[k, num_nodes] = (distance_matrix[k, i] + distance_matrix[k, j] - distance_matrix[i, j]) / 2\n        distance_matrix[num_nodes, k] = (distance_matrix[k, i] + distance_matrix[k, j] - distance_matrix[i, j]) / 2\n    for x in [j, i]:\n        distance_matrix = np.delete(distance_matrix, x, 0)\n        distance_matrix = np.delete(distance_matrix, x, 1)\n        del labels[x]\n\n    tree = neighbor_joining(distance_matrix, num_nodes - 1, labels)\n\n    tree[labels[-1]].append({\"node\": label_i, \"weight\": limb_i})\n    tree[labels[-1]].append({\"node\": label_j, \"weight\": limb_j})\n    return tree\n\nsample_input = \"\"\"\n4\n0   23  27  20\n23  0   30  28\n27  30  0   30\n20  28  30  0\n\"\"\"\n\nnum_nodes, *distance_matrix = sample_input.strip().split(\"\\n\")\ndistance_matrix = np.array(parse_matrix(distance_matrix), float)\ntree = neighbor_joining(distance_matrix, int(num_nodes))\nfor edge in format_edges(tree):\n    print(edge)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-78",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-78",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "78.1 Sample Dataset",
    "text": "78.1 Sample Dataset\n4\n4-&gt;CAAATCCC\n4-&gt;ATTGCGAC\n5-&gt;CTGCGCTG\n5-&gt;ATGGACGA\n6-&gt;4\n6-&gt;5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-78",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-78",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "78.2 Sample Output",
    "text": "78.2 Sample Output\n16\nATAGACAA-&gt;ATAGACAC:1\nATAGACAC-&gt;ATAGACAA:1\nATAGACAC-&gt;CAAATCCC:5\nCAAATCCC-&gt;ATAGACAC:5\nATAGACAC-&gt;ATTGCGAC:3\nATTGCGAC-&gt;ATAGACAC:3\nATAGACAA-&gt;ATGGACAA:1\nATGGACAA-&gt;ATAGACAA:1\nATGGACAA-&gt;CTGCGCTG:5\nCTGCGCTG-&gt;ATGGACAA:5\nATGGACAA-&gt;ATGGACGA:1\nATGGACGA-&gt;ATGGACAA:1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-78",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-78",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "78.3 Solution",
    "text": "78.3 Solution"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-79",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-79",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "79.1 Sample Dataset",
    "text": "79.1 Sample Dataset\n4\nTCGGCCAA-&gt;4\n4-&gt;TCGGCCAA\nCCTGGCTG-&gt;4\n4-&gt;CCTGGCTG\nCACAGGAT-&gt;5\n5-&gt;CACAGGAT\nTGAGTACC-&gt;5\n5-&gt;TGAGTACC\n4-&gt;5\n5-&gt;4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-79",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-79",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "79.2 Sample Output",
    "text": "79.2 Sample Output\n17\nTCGGCCAA-&gt;CCAGGCAC:4\nCCTGGCTG-&gt;CCAGGCAC:3\nTGAGTACC-&gt;CAAGGAAC:4\nCCAGGCAC-&gt;CCTGGCTG:3\nCCAGGCAC-&gt;CAAGGAAC:2\nCCAGGCAC-&gt;TCGGCCAA:4\nCACAGGAT-&gt;CAAGGAAC:4\nCAAGGAAC-&gt;CACAGGAT:4\nCAAGGAAC-&gt;TGAGTACC:4\nCAAGGAAC-&gt;CCAGGCAC:2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-79",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-79",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "79.3 Solution",
    "text": "79.3 Solution\nfrom collections import defaultdict\nfrom math import inf\nfrom typing import Dict, List, Set, Tuple\n\n# return all nodes of a simple graph\ndef nodes(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    s = list(graph.keys())\n    e = [y for v in graph.values() for y in v]\n    return set(s) | set(e)\n\n# return all leaves of a simple graph\ndef leaves(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    return set(y for v in list(graph.values()) for y in v if not graph[y])\n\n# return all root node of a simple graph\ndef root(graph: Dict[int, List[int]]) -&gt; int:\n    rev = reverse_graph(graph)\n    node = list(nodes(graph))[0]\n    while node in rev:\n        node = rev[node]\n    return node\n\n# reverse a simple graph (child points to parent)\ndef reverse_graph(graph: Dict[int, List[int]]) -&gt; Dict[int, int]:\n    rev: Dict[int, int] = {}\n    for node in graph:\n        for child in graph[node]:\n            rev[child] = node\n    return rev\n\ndef parse_input(input_string: str) -&gt; Tuple[Dict[int, str], Dict[int, List[int]]]:\n    lines = input_string.strip().split('\\n')\n    n = int(lines[0])\n    seqs: Dict[int, str] = {}\n    graph: Dict[int, List[int]] = defaultdict(list)\n    for i, edge in enumerate(lines[1:n+1]):\n        f, t = edge.rstrip().split(\"-&gt;\")\n        graph[int(f)].append(i)\n        seqs[i] = t\n    for edge in lines[n+1:]:\n        f, t = edge.rstrip().split(\"-&gt;\")\n        graph[int(f)].append(int(t))\n    return seqs, graph\n\n# print (bidirectional) edges\ndef print_edges(graph: Dict[int, List[int]], seqs: Dict[int, str], node: int) -&gt; None:\n    for child in graph[node]:\n        if node in seqs and child in seqs:\n            dist = sum(a != b for a, b in zip(seqs[node], seqs[child]))\n            print(f\"{seqs[node]}-&gt;{seqs[child]}:{dist}\")\n            print(f\"{seqs[child]}-&gt;{seqs[node]}:{dist}\")\n        print_edges(graph, seqs, child)\n\ndef extract_position(graph: Dict[int, List[int]], seqs: Dict[int, str], pos: int) -&gt; Dict[int, str]:\n    chars: Dict[int, str] = {}\n    for n in nodes(graph) - leaves(graph):\n        chars[n] = \"\"\n    for leaf in leaves(graph):\n        chars[leaf] = seqs[leaf][pos]\n    return chars\n\ndef traceback(skp: Dict[int, List[Dict[int, int]]], node: int, ind: int) -&gt; Dict[int, str]:\n    bases = [\"A\", \"C\", \"T\", \"G\"]\n    chars: Dict[int, str] = {}\n    chars[node] = bases[ind]\n    for k, v in skp[node][ind].items():\n        if k in skp:\n            chars = chars | traceback(skp, k, v)\n    return chars\n\ndef small_parsimony(graph: Dict[int, List[int]], chars: Dict[int, str]) -&gt; Tuple[int, Dict[int, str]]:\n    bases = [\"A\", \"C\", \"T\", \"G\"]\n    sk: Dict[int, List[int]] = {}  # minimum parsimony score of the subtree over possible labels\n    skp: Dict[int, List[Dict[int, int]]] = {}  # pointer to selected base for each child over possible labels\n    to_process = nodes(graph)\n\n    # initialise leaves\n    for leaf in leaves(graph):\n        sk[leaf] = [0 if chars[leaf] == c else inf for c in bases]\n        to_process.remove(leaf)\n\n    # iterate over available nodes till all are processed\n    while to_process:\n        for n in list(to_process):\n            if all(v in sk for v in graph[n]):\n                sk[n], skp[n] = [], []\n                for k in bases:\n                    tot = 0\n                    ptr: Dict[int, int] = {}\n                    for d, sk_child in [(d, sk[d]) for d in graph[n]]:\n                        score = []\n                        for i, c in enumerate(bases):\n                            score += [sk_child[i] + (0 if c == k else 1)]\n                        tot += min(score)\n                        ptr[d] = score.index(min(score))\n                    skp[n] += [ptr]\n                    sk[n] += [tot]\n                to_process.remove(n)\n\n    # Recover sequence\n    node = root(graph)\n    score = min(sk[node])\n    return score, traceback(skp, node, sk[node].index(score))\n\ndef ba6f(graph: Dict[int, List[int]], seqs: Dict[int, str]) -&gt; Tuple[int, Dict[int, str]]:\n    # initialise sequences\n    for n in nodes(graph) - leaves(graph):\n        seqs[n] = \"\"\n\n    total_score = 0\n    for pos in range(len(next(iter(seqs.values())))):\n        chars = extract_position(graph, seqs, pos)\n        score, tbchars = small_parsimony(graph, chars)\n        total_score += score\n        for k, v in tbchars.items():\n            seqs[k] += v\n\n    return total_score, seqs\n\nsample_input = \"\"\"\n4\n4-&gt;CAAATCCC\n4-&gt;ATTGCGAC\n5-&gt;CTGCGCTG\n5-&gt;ATGGACGA\n6-&gt;4\n6-&gt;5\n\"\"\"\n\nseqs, graph = parse_input(sample_input)\ntotal_score, seqs = ba6f(graph, seqs)\nprint(total_score)\nprint_edges(graph, seqs, root(graph))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-80",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-80",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "80.1 Sample Dataset",
    "text": "80.1 Sample Dataset\n4\nTCGGCCAA-&gt;4\n4-&gt;TCGGCCAA\nCCTGGCTG-&gt;4\n4-&gt;CCTGGCTG\nCACAGGAT-&gt;5\n5-&gt;CACAGGAT\nTGAGTACC-&gt;5\n5-&gt;TGAGTACC\n4-&gt;5\n5-&gt;4"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-80",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-80",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "80.2 Sample Output",
    "text": "80.2 Sample Output\n17\nTCGGCCAA-&gt;CCAGGCAC:4\nCCTGGCTG-&gt;CCAGGCAC:3\nTGAGTACC-&gt;CAAGGAAC:4\nCCAGGCAC-&gt;CCTGGCTG:3\nCCAGGCAC-&gt;CAAGGAAC:2\nCCAGGCAC-&gt;TCGGCCAA:4\nCACAGGAT-&gt;CAAGGAAC:4\nCAAGGAAC-&gt;CACAGGAT:4\nCAAGGAAC-&gt;TGAGTACC:4\nCAAGGAAC-&gt;CCAGGCAC:2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-80",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-80",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "80.3 Solution",
    "text": "80.3 Solution\nfrom collections import defaultdict\nfrom typing import Dict, List, Set, Tuple, TextIO\nimport io\nfrom math import inf\n\ndef nodes(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    s = list(graph.keys())\n    e = [y for v in graph.values() for y in v]\n    return set(s) | set(e)\n\ndef leaves(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    return set(y for v in list(graph.values()) for y in v if not graph[y])\n\ndef root(graph: Dict[int, List[int]]) -&gt; int:\n    rev = reverse_graph(graph)\n    node = list(nodes(graph))[0]\n    while node in rev:\n        node = rev[node]\n    return node\n\ndef get_all_nodes(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    source_nodes = set(graph.keys())\n    target_nodes = {target for targets in graph.values() for target in targets}\n    return source_nodes | target_nodes\n\ndef reverse_graph(graph: Dict[int, List[int]]) -&gt; Dict[int, int]:\n    reversed_graph: Dict[int, int] = {}\n    for parent, children in graph.items():\n        for child in children:\n            reversed_graph[child] = parent\n    return reversed_graph\n\ndef get_leaves(graph: Dict[int, List[int]]) -&gt; Set[int]:\n    return {child for children in graph.values() for child in children if not graph[child]}\n\ndef find_root(graph: Dict[int, List[int]]) -&gt; int:\n    reversed_graph = reverse_graph(graph)\n    node = next(iter(get_all_nodes(graph)))\n    while node in reversed_graph:\n        node = reversed_graph[node]\n    return node\n\ndef print_edges(graph: Dict[int, List[int]], sequences: Dict[int, str], node: int) -&gt; None:\n    for child in graph[node]:\n        distance = sum(a != b for a, b in zip(sequences[node], sequences[child]))\n        print(f\"{sequences[node]}-&gt;{sequences[child]}:{distance}\")\n        print(f\"{sequences[child]}-&gt;{sequences[node]}:{distance}\")\n        print_edges(graph, sequences, child)\n\ndef root_tree(graph: Dict[int, List[int]], node: int) -&gt; None:\n    for child in graph[node]:\n        if node in graph[child]:\n            graph[child].remove(node)\n        root_tree(graph, child)\n\ndef parse_input(handle: TextIO) -&gt; Tuple[Dict[int, str], Dict[int, List[int]]]:\n    n = int(next(handle))\n    sequences: Dict[int, str] = {}\n    graph: Dict[int, List[int]] = defaultdict(list)\n    for i in range(n):\n        next(handle)\n        from_node, to_seq = next(handle).rstrip().split(\"-&gt;\")\n        graph[int(from_node)].append(i)\n        sequences[i] = to_seq\n\n    lines = handle.readlines()\n    root = int(lines[0].rstrip().split(\"-&gt;\")[0])\n    for edge in lines:\n        from_node, to_node = edge.rstrip().split(\"-&gt;\")\n        graph[int(from_node)].append(int(to_node))\n\n    root_tree(graph, root)\n    return sequences, graph\n\ndef extract_position(graph: Dict[int, List[int]], sequences: Dict[int, str], pos: int) -&gt; Dict[int, str]:\n    chars: Dict[int, str] = {}\n    for n in get_all_nodes(graph) - get_leaves(graph):\n        chars[n] = \"\"\n    for leaf in get_leaves(graph):\n        chars[leaf] = sequences[leaf][pos]\n    return chars\n\ndef ba6f(graph: Dict[int, List[int]], sequences: Dict[int, str]) -&gt; Tuple[int, Dict[int, str]]:\n    for n in get_all_nodes(graph) - get_leaves(graph):\n        sequences[n] = \"\"\n\n    total_score = 0\n    for pos in range(len(next(iter(sequences.values())))):\n        chars = extract_position(graph, sequences, pos)\n        score, tbchars = small_parsimony(graph, chars)\n        total_score += score\n        for k, v in tbchars.items():\n            sequences[k] += v\n\n    return total_score, sequences\n\ndef small_parsimony(graph: Dict[int, List[int]], chars: Dict[int, str]) -&gt; Tuple[int, Dict[int, str]]:\n    bases = [\"A\", \"C\", \"T\", \"G\"]\n    sk: Dict[int, List[int]] = {}\n    skp: Dict[int, List[Dict[int, int]]] = {}\n    to_process = nodes(graph)\n\n    for leaf in leaves(graph):\n        sk[leaf] = [0 if chars[leaf] == c else inf for c in bases]\n        to_process.remove(leaf)\n\n    while to_process:\n        for n in list(to_process):\n            if all(v in sk for v in graph[n]):\n                sk[n], skp[n] = [], []\n                for k in bases:\n                    tot = 0\n                    ptr: Dict[int, int] = {}\n                    for d, sk_child in [(d, sk[d]) for d in graph[n]]:\n                        score = []\n                        for i, c in enumerate(bases):\n                            score += [sk_child[i] + (0 if c == k else 1)]\n                        tot += min(score)\n                        ptr[d] = score.index(min(score))\n                    skp[n] += [ptr]\n                    sk[n] += [tot]\n                to_process.remove(n)\n\n    node = root(graph)\n    score = min(sk[node])\n    return score, traceback(skp, node, sk[node].index(score))\n\ndef traceback(skp: Dict[int, List[Dict[int, int]]], node: int, ind: int) -&gt; Dict[int, str]:\n    bases = [\"A\", \"C\", \"T\", \"G\"]\n    chars: Dict[int, str] = {}\n    chars[node] = bases[ind]\n    for k, v in skp[node][ind].items():\n        if k in skp:\n            chars = chars | traceback(skp, k, v)\n    return chars\n\nsample_input = \"\"\"\n4\nTCGGCCAA-&gt;4\n4-&gt;TCGGCCAA\nCCTGGCTG-&gt;4\n4-&gt;CCTGGCTG\nCACAGGAT-&gt;5\n5-&gt;CACAGGAT\nTGAGTACC-&gt;5\n5-&gt;TGAGTACC\n4-&gt;5\n5-&gt;4\n\"\"\"\n\nsequences, graph = parse_input(io.StringIO(sample_input.strip()))\ntotal_score, sequences = ba6f(graph, sequences)\nprint(total_score)\nprint_edges(graph, sequences, find_root(graph))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-81",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-81",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "81.1 Sample Dataset",
    "text": "81.1 Sample Dataset\n3 2\n0.0 0.0\n5.0 5.0\n0.0 5.0\n1.0 1.0\n2.0 2.0\n3.0 3.0\n1.0 2.0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-81",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-81",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "81.2 Sample Output",
    "text": "81.2 Sample Output\n0.0 0.0\n5.0 5.0\n0.0 5.0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-81",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-81",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "81.3 Solution",
    "text": "81.3 Solution\nfrom math import sqrt\nfrom typing import List, Tuple, Iterator, TextIO, TypeVar\nimport io\n\nT = TypeVar('T')\n\ndef read_types(file_handle: TextIO, data_type: type) -&gt; Iterator[List[T]]:\n    for line in file_handle:\n        yield list(map(data_type, line.split()))\n\ndef euclidean_distance(point_a: List[float], point_b: List[float]) -&gt; float:\n    \"\"\"Euclidean distance between a pair of n-dimensional points\"\"\"\n    return sqrt(sum((coord_a - coord_b) ** 2 for coord_a, coord_b in zip(point_a, point_b)))\n\ndef nearest_center_distance(data_point: List[float], center_points: List[List[float]]) -&gt; float:\n    \"\"\"Euclidean distance from DataPoint to its closest center\"\"\"\n    return min(euclidean_distance(data_point, center) for center in center_points)\n\ndef farthest_first_traversal(data_points: List[List[float]], num_centers: int) -&gt; List[List[float]]:\n    center_points = [data_points[0]]\n    while len(center_points) &lt; num_centers:\n        distances = [(i, nearest_center_distance(point, center_points)) for i, point in enumerate(data_points)]\n        center_points.append(data_points[max(distances, key=lambda x: x[1])[0]])\n    return center_points\n\nimport io\n\nsample_input = \"\"\"\n3 2\n0.0 0.0\n5.0 5.0\n0.0 5.0\n1.0 1.0\n2.0 2.0\n3.0 3.0\n1.0 2.0\n\"\"\"\n\nfile_handle = io.StringIO(sample_input.strip())\nnum_centers, dimensions = next(read_types(file_handle, int))\ndata_points = [point for point in read_types(file_handle, float)]\ncenter_points = farthest_first_traversal(data_points, num_centers)\nfor center in center_points:\n    print(*center)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-82",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-82",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "82.1 Sample Dataset",
    "text": "82.1 Sample Dataset\n2 2\n2.31 4.55\n5.96 9.08\n--------\n3.42 6.03\n6.23 8.25\n4.76 1.64\n4.47 4.33\n3.95 7.61\n8.93 2.97\n9.74 4.03\n1.73 1.28\n9.72 5.01\n7.27 3.77"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-82",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-82",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "82.2 Sample Output",
    "text": "82.2 Sample Output\n18.246"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-82",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-82",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "82.3 Solution",
    "text": "82.3 Solution\nfrom math import sqrt\nimport io\nfrom typing import List, Tuple, Iterator, TextIO, TypeVar\n\nT = TypeVar('T')\n\ndef read_types(file_handle: TextIO, data_type: type) -&gt; Iterator[List[T]]:\n    for line in file_handle:\n        yield list(map(data_type, line.split()))\n\ndef euclidean_distance(point_a: List[float], point_b: List[float]) -&gt; float:\n    \"\"\"Euclidean distance between a pair of n-dimensional points\"\"\"\n    return sqrt(sum((coord_a - coord_b) ** 2 for coord_a, coord_b in zip(point_a, point_b)))\n\ndef nearest_center_distance(data_point: List[float], center_points: List[List[float]]) -&gt; float:\n    \"\"\"Euclidean distance from DataPoint to its closest center\"\"\"\n    return min(euclidean_distance(data_point, center) for center in center_points)\n\ndef calculate_distortion(data_points: List[List[float]], center_points: List[List[float]]) -&gt; float:\n    return (1 / len(data_points)) * sum(nearest_center_distance(point, center_points) ** 2 for point in data_points)\n\nsample_input = \"\"\"\n2 2\n2.31 4.55\n5.96 9.08\n--------\n3.42 6.03\n6.23 8.25\n4.76 1.64\n4.47 4.33\n3.95 7.61\n8.93 2.97\n9.74 4.03\n1.73 1.28\n9.72 5.01\n7.27 3.77\n\"\"\"\n\nfile_handle = io.StringIO(sample_input.strip())\nnum_centers, _ = next(read_types(file_handle, int))\ndata_generator = read_types(file_handle, float)\ncenter_points = [next(data_generator) for _ in range(num_centers)]\n_ = next(file_handle)\ndata_points = [point for point in data_generator]\nprint(round(calculate_distortion(data_points, center_points), 3))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-83",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-83",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "83.1 Sample Dataset",
    "text": "83.1 Sample Dataset\n2 2\n1.3 1.1\n1.3 0.2\n0.6 2.8\n3.0 3.2\n1.2 0.7\n1.4 1.6\n1.2 1.0\n1.2 1.1\n0.6 1.5\n1.8 2.6\n1.2 1.3\n1.2 1.0\n0.0 1.9"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-83",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-83",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "83.2 Sample Output",
    "text": "83.2 Sample Output\n1.800 2.867\n1.060 1.140"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-83",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-83",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "83.3 Solution",
    "text": "83.3 Solution\nimport numpy as np\nimport io\nfrom math import sqrt\nfrom typing import List, Iterator, TypeVar, Any\n\nT = TypeVar('T')\n\ndef read_types(file_handle: io.StringIO, data_type: type) -&gt; Iterator[List[T]]:\n    for line in file_handle:\n        yield list(map(data_type, line.split()))\n\ndef euclidean_distance(point_a: np.ndarray, point_b: np.ndarray) -&gt; float:\n    \"\"\"Euclidean distance between a pair of n-dimensional points\"\"\"\n    return sqrt(sum((x - y) ** 2 for x, y in zip(point_a, point_b)))\n\ndef nearest_center_assignment(data_point: np.ndarray, center_points: List[np.ndarray]) -&gt; int:\n    \"\"\"Center index that minimises Euclidean distance to point\"\"\"\n    distances = [euclidean_distance(data_point, center) for center in center_points]\n    return distances.index(min(distances))\n\ndef compute_center(data_points: List[np.ndarray], assignments: List[int], center_index: int) -&gt; np.ndarray:\n    cluster_points = [p for p, a in zip(data_points, assignments) if a == center_index]\n    return np.mean(np.array(cluster_points), axis=0) if cluster_points else np.zeros_like(data_points[0])\n\ndef k_means(data_points: List[np.ndarray], num_clusters: int, max_iterations: int = 20) -&gt; List[np.ndarray]:\n    center_points = data_points[:num_clusters]\n    for _ in range(max_iterations):\n        assignments = [nearest_center_assignment(point, center_points) for point in data_points]\n        center_points = [compute_center(data_points, assignments, i) for i in range(num_clusters)]\n    return center_points\n\nsample_input = \"\"\"\n2 2\n1.3 1.1\n1.3 0.2\n0.6 2.8\n3.0 3.2\n1.2 0.7\n1.4 1.6\n1.2 1.0\n1.2 1.1\n0.6 1.5\n1.8 2.6\n1.2 1.3\n1.2 1.0\n0.0 1.9\n\"\"\"\n\nfile_handle = io.StringIO(sample_input.strip())\nnum_clusters, dimensions = next(read_types(file_handle, int))\ndata_points = [np.array(point) for point in read_types(file_handle, float)]\nfor center in k_means(data_points, num_clusters):\n    print(*[f\"{coord:f}\" for coord in center])"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-84",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-84",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "84.1 Sample Dataset",
    "text": "84.1 Sample Dataset\n2 2\n2.7\n1.3 1.1\n1.3 0.2\n0.6 2.8\n3.0 3.2\n1.2 0.7\n1.4 1.6\n1.2 1.0\n1.2 1.1\n0.6 1.5\n1.8 2.6\n1.2 1.3\n1.2 1.0\n0.0 1.9"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-84",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-84",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "84.2 Sample Output",
    "text": "84.2 Sample Output\n1.662 2.623\n1.075 1.148"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-84",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-84",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "84.3 Solution",
    "text": "84.3 Solution\nimport numpy as np\nfrom math import sqrt\nimport io\nfrom typing import List, Iterator, TypeVar, Any\n\nT = TypeVar('T')\n\ndef read_types(file_handle: io.StringIO, data_type: type) -&gt; Iterator[List[T]]:\n    for line in file_handle:\n        yield list(map(data_type, line.split()))\n\ndef euclidean_distance(point_a: np.ndarray, point_b: np.ndarray) -&gt; float:\n    \"\"\"Euclidean distance between a pair of n-dimensional points\"\"\"\n    return sqrt(sum((x - y) ** 2 for x, y in zip(point_a, point_b)))\n\ndef partition_function(data_point: np.ndarray, center_points: np.ndarray, beta: float) -&gt; np.ndarray:\n    numerator = [np.exp(-beta * euclidean_distance(data_point, center)) for center in center_points]\n    return np.array(numerator) / sum(numerator)\n\ndef hidden_matrix(data_points: np.ndarray, center_points: np.ndarray, beta: float) -&gt; np.ndarray:\n    return np.array([partition_function(x, center_points, beta) for x in data_points])\n\ndef soft_k_means(data_points: List[np.ndarray], num_clusters: int, beta: float, max_iterations: int = 20) -&gt; np.ndarray:\n    center_points = np.array(data_points[:num_clusters])\n    data_points = np.array(data_points)\n    for _ in range(max_iterations):\n        h_matrix = hidden_matrix(data_points, center_points, beta)\n        center_points = [np.dot(h_matrix[:, i], data_points) for i in range(num_clusters)]\n        sums = np.sum(h_matrix, 0)\n        center_points = np.transpose(np.transpose(center_points) / sums)\n    return center_points\n\nsample_input = \"\"\"\n2 2\n2.7\n1.3 1.1\n1.3 0.2\n0.6 2.8\n3.0 3.2\n1.2 0.7\n1.4 1.6\n1.2 1.0\n1.2 1.1\n0.6 1.5\n1.8 2.6\n1.2 1.3\n1.2 1.0\n0.0 1.9\n\"\"\"\n\nfile_handle = io.StringIO(sample_input.strip())\nnum_clusters, dimensions = next(read_types(file_handle, int))\nbeta = next(read_types(file_handle, float))[0]\ndata_points = [np.array(point) for point in read_types(file_handle, float)]\nfor center in soft_k_means(data_points, num_clusters, beta):\n    print(*[f\"{coord:f}\" for coord in center])"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-85",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-85",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "85.1 Sample Dataset",
    "text": "85.1 Sample Dataset\n7\n0.00 0.74 0.85 0.54 0.83 0.92 0.89\n0.74 0.00 1.59 1.35 1.20 1.48 1.55\n0.85 1.59 0.00 0.63 1.13 0.69 0.73\n0.54 1.35 0.63 0.00 0.66 0.43 0.88\n0.83 1.20 1.13 0.66 0.00 0.72 0.55\n0.92 1.48 0.69 0.43 0.72 0.00 0.80\n0.89 1.55 0.73 0.88 0.55 0.80 0.00"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-85",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-85",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "85.2 Sample Output",
    "text": "85.2 Sample Output\n4 6\n5 7\n3 4 6\n1 2\n5 7 3 4 6\n1 2 5 7 3 4 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-85",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-85",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "85.3 Solution",
    "text": "85.3 Solution\nimport numpy as np\nfrom collections import defaultdict\nimport io\nfrom typing import List, Tuple, Dict, Generator\n\n# find (first) minimum off diagonal index in an array\ndef find_closest_pair(distance_matrix: np.ndarray) -&gt; Tuple[int, int]:\n    temp_matrix = np.copy(distance_matrix)\n    np.fill_diagonal(temp_matrix, temp_matrix.max() + 1)\n    return divmod(temp_matrix.argmin(), temp_matrix.shape[1])\n\ndef average_distances(distance_matrix: np.ndarray, i: int, j: int, size_i: int, size_j: int) -&gt; np.ndarray:\n    temp_matrix = np.copy(distance_matrix)\n    average = (temp_matrix[i, :] * size_i + temp_matrix[j, :] * size_j) / (size_i + size_j)\n    temp_matrix[i, :] = average\n    temp_matrix[:, i] = average\n    temp_matrix = np.delete(temp_matrix, j, 0)\n    temp_matrix = np.delete(temp_matrix, j, 1)\n    np.fill_diagonal(temp_matrix, 0)\n    return temp_matrix\n\ndef get_descendants(tree: Dict[int, List[int]], node: int) -&gt; List[int]:\n    queue = [node]\n    descendants = []\n    while queue:\n        current_node = queue.pop(0)\n        if current_node in tree:\n            queue.extend(tree[current_node])\n        else:\n            descendants.append(current_node)\n    return descendants\n\ndef hierarchical_clustering(distance_matrix: np.ndarray, num_elements: int) -&gt; Generator[List[int], None, None]:\n    clusters = list(range(1, num_elements + 1))\n    tree: Dict[int, List[int]] = {}\n    cluster_size = defaultdict(lambda: 1)  # the number of descendants of a node\n    next_node = num_elements\n    while len(clusters) &gt; 1:\n        next_node += 1\n        i, j = find_closest_pair(distance_matrix)\n        cluster_a, cluster_b = clusters[i], clusters[j]\n        tree[next_node] = [cluster_a, cluster_b]\n        cluster_size[next_node] = cluster_size[cluster_a] + cluster_size[cluster_b]\n        distance_matrix = average_distances(distance_matrix, *find_closest_pair(distance_matrix), cluster_size[cluster_a], cluster_size[cluster_b])\n        clusters[i] = next_node\n        del clusters[j]\n        yield get_descendants(tree, cluster_a) + get_descendants(tree, cluster_b)\n\nsample_input = \"\"\"\n7\n0.00 0.74 0.85 0.54 0.83 0.92 0.89\n0.74 0.00 1.59 1.35 1.20 1.48 1.55\n0.85 1.59 0.00 0.63 1.13 0.69 0.73\n0.54 1.35 0.63 0.00 0.66 0.43 0.88\n0.83 1.20 1.13 0.66 0.00 0.72 0.55\n0.92 1.48 0.69 0.43 0.72 0.00 0.80\n0.89 1.55 0.73 0.88 0.55 0.80 0.00\n\"\"\"\n\nnum_elements, *distance_data = io.StringIO(sample_input.strip()).read().splitlines()\ndistance_matrix = np.array([list(map(float, row.split())) for row in distance_data])\nfor step in hierarchical_clustering(distance_matrix, int(num_elements)):\n    print(*step)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-86",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-86",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "86.1 Sample Dataset",
    "text": "86.1 Sample Dataset\nATAGA\nATC\nGAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-86",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-86",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "86.2 Sample Output",
    "text": "86.2 Sample Output\n0-&gt;1:A\n1-&gt;2:T\n2-&gt;3:A\n3-&gt;4:G\n4-&gt;5:A\n2-&gt;6:C\n0-&gt;7:G\n7-&gt;8:A\n8-&gt;9:T"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-86",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-86",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "86.3 Solution",
    "text": "86.3 Solution\nfrom itertools import count\nfrom typing import List, Dict, Tuple, Any\n\nclass Trie:\n    def __init__(self) -&gt; None:\n        self.id_generator = count(start=0)\n        self.root: Tuple[int, Dict[str, Any]] = (next(self.id_generator), {})\n    \n    def insert(self, sequence: str) -&gt; None:\n        current_node = self.root\n        for character in sequence:\n            if character not in current_node[1]:\n                current_node[1][character] = (next(self.id_generator), {})\n            current_node = current_node[1][character]\n            \ndef build_trie(sequences: List[str]) -&gt; Tuple[int, Dict[str, Any]]:\n    trie = Trie()\n    for sequence in sequences:\n        trie.insert(sequence)\n    return trie.root\n\ndef format_trie(node: Tuple[int, Dict[str, Any]]) -&gt; List[str]:\n    formatted_output: List[str] = []\n    node_id, children = node\n    for char, child_node in children.items():\n        child_id, _ = child_node\n        formatted_output.append(f\"{node_id}-&gt;{child_id}:{char}\")\n        formatted_output.extend(format_trie(child_node))\n    return formatted_output\n\nsample_input: str = \"\"\"\nATAGA\nATC\nGAT\n\"\"\"\n\nsequences: List[str] = sample_input.strip().split(\"\\n\")\n\nfor edge in format_trie(build_trie(sequences)):\n    print(edge)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-87",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-87",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "87.1 Sample Dataset",
    "text": "87.1 Sample Dataset\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-87",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-87",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "87.2 Sample Output",
    "text": "87.2 Sample Output\n1 4 11 15"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-87",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-87",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "87.3 Solution",
    "text": "87.3 Solution\nfrom collections import defaultdict\nfrom typing import List, DefaultDict, Set\n\nsample_input: str = \"\"\"\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT\n\"\"\"\n\nsequences: List[str] = sample_input.strip().split(\"\\n\")\nmain_sequence: str = sequences[0]\nkmers: List[str] = sequences[1:]\n\nkmer_positions: DefaultDict[str, Set[int]] = defaultdict(set)\n\nkmer_length: int = len(kmers[0])\n\nfor start_index in range(len(main_sequence) - kmer_length + 1):\n    current_kmer: str = main_sequence[start_index:start_index + kmer_length]\n    kmer_positions[current_kmer].add(start_index)\n\nall_positions: Set[int] = set()\nfor kmer in kmers:\n    all_positions.update(kmer_positions[kmer])\n\nsorted_positions: List[int] = sorted(all_positions)\noutput: str = \" \".join(map(str, sorted_positions))\n\nprint(output)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-88",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-88",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "88.1 Sample Dataset",
    "text": "88.1 Sample Dataset\nATAAATG$"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-88",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-88",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "88.2 Sample Output",
    "text": "88.2 Sample Output\nAAATG$\nG$\nT\nATG$\nTG$\nA\nA\nAAATG$\nG$\nT\nG$\n$"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-88",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-88",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "88.3 Solution",
    "text": "88.3 Solution\nfrom typing import List, Optional\n\nclass Tree:\n    class Node:\n        def __init__(self) -&gt; None:\n            self.label: Optional[int] = None\n            self.edges: List['Tree.Edge'] = []\n            self.indicator: Optional[str] = None\n            self.depth: int = 0\n\n    class Edge:\n        def __init__(self) -&gt; None:\n            self.from_node: Optional['Tree.Node'] = None\n            self.target_node: Optional['Tree.Node'] = None\n            self.position: Optional[int] = None\n            self.length: Optional[int] = None\n\n    def __init__(self) -&gt; None:\n        self.all_nodes: List[Tree.Node] = []\n        self.all_edges: List[Tree.Edge] = []\n        self.root: Tree.Node = self.add_node()\n\n    def add_node(self) -&gt; Node:\n        new_node = Tree.Node()\n        new_node.label = len(self.all_nodes)\n        self.all_nodes.append(new_node)\n        return new_node\n\n    def add_edge(self, from_node: Node, target_node: Node, pos: int, length: int) -&gt; Edge:\n        new_edge = Tree.Edge()\n        new_edge.from_node = from_node\n        new_edge.target_node = target_node\n        new_edge.position = pos\n        new_edge.length = length\n        target_node.depth = from_node.depth + length\n        from_node.edges.append(new_edge)\n        self.all_edges.append(new_edge)\n        return new_edge\n\n    def edge_labels(self, text: str) -&gt; List[str]:\n        return [text[edge.position : edge.position + edge.length] for edge in self.all_edges]\n\n    def return_ripe_nodes(self) -&gt; List[Node]:\n        ripe_nodes = []\n        for node in self.all_nodes:\n            if node.indicator is None and all(edge.target_node.indicator is not None for edge in node.edges):\n                ripe_nodes.append(node)\n        return ripe_nodes\n\n    def add_indicators(self) -&gt; None:\n        ripe_nodes = self.return_ripe_nodes()\n        while ripe_nodes:\n            for node in ripe_nodes:\n                children_indicators = set(edge.target_node.indicator for edge in node.edges)\n                node.indicator = '*' if len(children_indicators) != 1 else next(iter(children_indicators))\n            ripe_nodes = self.return_ripe_nodes()\n\n    def construct_suffix_tree(self, trie_node: 'Trie.Node', tree_node: Node, path: List['Trie.Edge'] = []) -&gt; None:\n        while len(trie_node.edges) == 1:\n            trie_edge = trie_node.edges[0]\n            path.append(trie_edge)\n            trie_node = trie_edge.target_node\n\n        if path:\n            new_tree_node = self.add_node()\n            self.add_edge(tree_node, new_tree_node, path[0].position, len(path))\n            tree_node = new_tree_node\n\n        if not trie_node.edges:\n            tree_node.indicator = trie_node.indicator\n            tree_node.label = trie_node.label\n            return\n\n        for trie_edge in trie_node.edges:\n            self.construct_suffix_tree(trie_edge.target_node, tree_node, [trie_edge])\n\n    def populate_suffix_tree(self, text: str) -&gt; None:\n        suffix_trie = Trie()\n        suffix_trie.construct_suffix_trie(text)\n        self.construct_suffix_tree(suffix_trie.root, self.root)\n\nclass Trie:\n    class Node:\n        def __init__(self) -&gt; None:\n            self.label: Optional[int] = None\n            self.edges: List['Trie.Edge'] = []\n            self.indicator: Optional[str] = None\n\n    class Edge:\n        def __init__(self) -&gt; None:\n            self.from_node: Optional['Trie.Node'] = None\n            self.target_node: Optional['Trie.Node'] = None\n            self.label: Optional[str] = None\n            self.position: Optional[int] = None\n\n    def __init__(self) -&gt; None:\n        self.all_nodes: List[Trie.Node] = []\n        self.all_edges: List[Trie.Edge] = []\n        self.root: Trie.Node = self.add_node()\n\n    def add_node(self) -&gt; Node:\n        new_node = Trie.Node()\n        new_node.label = len(self.all_nodes)\n        self.all_nodes.append(new_node)\n        return new_node\n\n    def add_edge(self, from_node: Node, target_node: Node, label: str, pos: Optional[int] = None) -&gt; Edge:\n        new_edge = Trie.Edge()\n        new_edge.from_node = from_node\n        new_edge.target_node = target_node\n        new_edge.label = label\n        new_edge.position = pos\n        from_node.edges.append(new_edge)\n        self.all_edges.append(new_edge)\n        return new_edge\n\n    def construct_suffix_trie(self, text: str) -&gt; None:\n        indicator = '#'\n        for i in range(len(text)):\n            current_node = self.root\n            for j in range(i, len(text)):\n                current_symbol = text[j]\n                next_node = next((edge.target_node for edge in current_node.edges if edge.label == current_symbol), None)\n                if next_node is None:\n                    new_node = self.add_node()\n                    self.add_edge(current_node, new_node, current_symbol, j)\n                    current_node = new_node\n                else:\n                    current_node = next_node\n            if not current_node.edges:\n                current_node.label = f'L{i}'\n                current_node.indicator = indicator\n            if text[i] == '#':\n                indicator = '$'\n\nsample_input = \"ATAAATG$\"\ninput_lines = sample_input.strip().split()\ntext = input_lines[0]\n\ntree = Tree()\ntree.populate_suffix_tree(text)\n\nresult = tree.edge_labels(text)\nprint(\"\\n\".join(result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-89",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-89",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "89.1 Sample Dataset",
    "text": "89.1 Sample Dataset\nATATCGTTTTATCGTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-89",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-89",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "89.2 Sample Output",
    "text": "89.2 Sample Output\nTATCGTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-89",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-89",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "89.3 Solution",
    "text": "89.3 Solution\nfrom functools import cache\nfrom os.path import commonprefix\nfrom typing import Dict, List, Tuple, Generator, Iterator\n\ndef get_edges(graph: Dict[str, Dict]) -&gt; Generator[str, None, None]:\n    for key in graph.keys():\n        yield key\n        yield from get_edges(graph[key])\n\n@cache\ndef suffix_tree(sequence: str, start_positions: Tuple[int, ...]) -&gt; Dict[str, Dict]:\n    tree: Dict[str, Dict] = {}\n    unique_bases = sorted(set([sequence[start] for start in start_positions]))\n    \n    for base in unique_bases:\n        matching_positions = [start for start in start_positions if sequence[start] == base]\n        subsequences = [sequence[s:] for s in matching_positions]\n        common_prefix = commonprefix(subsequences)\n        prefix_length = len(common_prefix)\n        new_start_positions = [start + prefix_length for start in matching_positions if start + prefix_length &lt; len(sequence)]\n        tree[common_prefix] = suffix_tree(sequence, tuple(new_start_positions))\n    \n    return tree\n\ndef create_suffix_tree(sequence: str) -&gt; Dict[str, Dict]:\n    return suffix_tree(sequence, tuple(range(len(sequence))))\n\ndef internal_edges(tree: Dict[str, Dict]) -&gt; Iterator[str]:\n    for node in tree.keys():\n        if not len(tree[node]):\n            yield \"\"\n        for child_edge in internal_edges(tree[node]):\n            yield node + child_edge\n\ndef longest_shared_substring(tree: Dict[str, Dict]) -&gt; str:\n    return max(internal_edges(tree), key=lambda x: len(x))\n\nsample_input = \"\"\"\nATATCGTTTTATCGTT\n\"\"\"\n\nsequence = sample_input.strip()\nsuffix_tree = create_suffix_tree(sequence)\nprint(longest_shared_substring(suffix_tree))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-90",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-90",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "90.1 Sample Dataset",
    "text": "90.1 Sample Dataset\nTCGGTAGATTGCGCCCACTC\nAGGGGCTCGCAGTGTAAGAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-90",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-90",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "90.2 Sample Output",
    "text": "90.2 Sample Output\nAGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-90",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-90",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "90.3 Solution",
    "text": "90.3 Solution\nfrom collections import defaultdict\nimport re\nfrom functools import cache\nfrom os.path import commonprefix\nfrom typing import Dict, List, Set, Tuple, Generator\n\n@cache\ndef build_suffix_tree(sequence: str, start_positions: Tuple[int, ...]) -&gt; Dict[str, Dict]:\n    tree: Dict[str, Dict] = {}\n    unique_bases = sorted(set([sequence[start] for start in start_positions]))\n    for base in unique_bases:\n        matching_positions = [start for start in start_positions if sequence[start] == base]\n        subsequences = [sequence[s:] for s in matching_positions]\n        common_prefix = commonprefix(subsequences)\n        prefix_length = len(common_prefix)\n        new_start_positions = [start + prefix_length for start in matching_positions if start + prefix_length &lt; len(sequence)]\n        tree[common_prefix] = build_suffix_tree(sequence, tuple(new_start_positions))\n    return tree\n\ndef create_suffix_tree(sequence: str) -&gt; Dict[str, Dict]:\n    return build_suffix_tree(sequence, tuple(range(len(sequence))))\n\ndef convert_to_graph(suffix_tree: Dict[str, Dict]) -&gt; Dict[int, List[Dict[str, int]]]:\n    def build_graph_structure(subtree: Dict[str, Dict], graph: Dict[int, List[Dict[str, int]]], node_id: int) -&gt; int:\n        next_node_id = node_id\n        for edge in sorted(subtree):\n            next_node_id += 1\n            graph[node_id].append({\"n\": next_node_id, \"l\": edge})\n            next_node_id = build_graph_structure(subtree[edge], graph, next_node_id)\n        return next_node_id\n\n    graph: Dict[int, List[Dict[str, int]]] = defaultdict(list)\n    build_graph_structure(suffix_tree, graph, 0)\n    return graph\n\ndef find_leaf_nodes(graph: Dict[int, List[Dict[str, int]]]) -&gt; Set[int]:\n    all_child_nodes = set(node[\"n\"] for nodes in graph.values() for node in nodes)\n    parent_nodes = set(graph.keys())\n    return all_child_nodes - parent_nodes\n\ndef reverse_graph_structure(graph: Dict[int, List[Dict[str, int]]]) -&gt; Dict[int, Dict[str, int]]:\n    reversed_graph: Dict[int, Dict[str, int]] = {}\n    for parent_node, children in graph.items():\n        for child in children:\n            reversed_graph[child[\"n\"]] = {\"n\": parent_node, \"l\": child[\"l\"]}\n    return reversed_graph\n\ndef get_purple_edges(tree: Dict[int, List[Dict[str, int]]], colors: Dict[int, str]) -&gt; Generator[str, None, None]:\n    def _get_purple_edges(node: int, sequence: str) -&gt; Generator[str, None, None]:\n        if colors[node] == \"purple\":\n            has_purple_child = any(colors[child[\"n\"]] == \"purple\" for child in tree[node])\n            if has_purple_child:\n                for child in tree[node]:\n                    yield from _get_purple_edges(child[\"n\"], sequence + child[\"l\"])\n            else:\n                yield sequence\n\n    yield from _get_purple_edges(0, \"\")\n\ndef initialize_leaf_colors(tree: Dict[int, List[Dict[str, int]]]) -&gt; Dict[int, str]:\n    reversed_graph = reverse_graph_structure(tree)\n    colors: Dict[int, str] = defaultdict(lambda: None)\n    for leaf in find_leaf_nodes(tree):\n        edge = reversed_graph[leaf][\"l\"]\n        match = re.search(r\"([$#])\", edge)\n        colors[leaf] = \"red\" if match.group() == \"$\" else \"blue\"\n    return colors\n\ndef color_tree_nodes(tree: Dict[int, List[Dict[str, int]]], colors: Dict[int, str]) -&gt; Dict[int, str]:\n    nodes_to_process = list(tree.keys())\n    while nodes_to_process:\n        for node in nodes_to_process:\n            child_colors = [colors[child[\"n\"]] for child in tree[node]]\n            if all(child_colors):\n                unique_colors = set(child_colors)\n                if unique_colors == {\"red\"}:\n                    colors[node] = \"red\"\n                elif unique_colors == {\"blue\"}:\n                    colors[node] = \"blue\"\n                else:\n                    colors[node] = \"purple\"\n                nodes_to_process.remove(node)\n    return colors\n\ndef find_longest_shared_substring(seq1: str, seq2: str) -&gt; str:\n    combined_sequence = seq1 + \"$\" + seq2 + \"#\"\n    suffix_tree = create_suffix_tree(combined_sequence)\n    graph = convert_to_graph(suffix_tree)\n    initial_colors = initialize_leaf_colors(graph)\n    final_colors = color_tree_nodes(graph, initial_colors)\n    return max(get_purple_edges(graph, final_colors), key=len)\n\nsample_input = \"\"\"\nTCGGTAGATTGCGCCCACTC\nAGGGGCTCGCAGTGTAAGAA\n\"\"\"\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nprint(find_longest_shared_substring(sequence1, sequence2))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-91",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-91",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "91.1 Sample Dataset",
    "text": "91.1 Sample Dataset\nCCAAGCTGCTAGAGG\nCATGCTGGGCTGGCT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-91",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-91",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "91.2 Sample Output",
    "text": "91.2 Sample Output\nAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-91",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-91",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "91.3 Solution",
    "text": "91.3 Solution\nfrom functools import cache\nfrom os.path import commonprefix\nfrom typing import Dict, List, Tuple, Set\nfrom collections import defaultdict\nimport re\n\n@cache\ndef build_suffix_tree(sequence: str, start_positions: Tuple[int, ...]) -&gt; Dict[str, Dict]:\n    tree: Dict[str, Dict] = {}\n    unique_bases = sorted(set([sequence[start] for start in start_positions]))\n    for base in unique_bases:\n        matching_positions = [start for start in start_positions if sequence[start] == base]\n        subsequences = [sequence[s:] for s in matching_positions]\n        common_prefix = commonprefix(subsequences)\n        prefix_length = len(common_prefix)\n        new_start_positions = [start + prefix_length for start in matching_positions if start + prefix_length &lt; len(sequence)]\n        tree[common_prefix] = build_suffix_tree(sequence, tuple(new_start_positions))\n    return tree\n\ndef create_suffix_tree(sequence: str) -&gt; Dict[str, Dict]:\n    return build_suffix_tree(sequence, tuple(range(len(sequence))))\n\ndef find_leaf_nodes(graph: Dict[int, List[Dict[str, int]]]) -&gt; Set[int]:\n    all_child_nodes = set(node[\"n\"] for nodes in graph.values() for node in nodes)\n    parent_nodes = set(graph.keys())\n    return all_child_nodes - parent_nodes\n\ndef reverse_graph_structure(graph: Dict[int, List[Dict[str, int]]]) -&gt; Dict[int, Dict[str, int]]:\n    reversed_graph: Dict[int, Dict[str, int]] = {}\n    for parent, children in graph.items():\n        for child in children:\n            reversed_graph[child[\"n\"]] = {\"n\": parent, \"l\": child[\"l\"]}\n    return reversed_graph\n\ndef convert_to_graph(suffix_tree: Dict[str, Dict]) -&gt; Dict[int, List[Dict[str, int]]]:\n    def build_graph_structure(subtree: Dict[str, Dict], graph: Dict[int, List[Dict[str, int]]], node_id: int) -&gt; int:\n        next_node_id = node_id\n        for edge in sorted(subtree):\n            next_node_id += 1\n            graph[node_id].append({\"n\": next_node_id, \"l\": edge})\n            next_node_id = build_graph_structure(subtree[edge], graph, next_node_id)\n        return next_node_id\n\n    graph: Dict[int, List[Dict[str, int]]] = defaultdict(list)\n    build_graph_structure(suffix_tree, graph, 0)\n    return graph\n\ndef initialize_leaf_colors(tree: Dict[int, List[Dict[str, int]]]) -&gt; Dict[int, str]:\n    reversed_graph = reverse_graph_structure(tree)\n    colors: Dict[int, str] = defaultdict(lambda: None)\n    for leaf in find_leaf_nodes(tree):\n        edge = reversed_graph[leaf][\"l\"]\n        match = re.search(r\"([$#])\", edge)\n        colors[leaf] = \"red\" if match and match.group() == \"$\" else \"blue\"\n    return colors\n\ndef color_tree_nodes(tree: Dict[int, List[Dict[str, int]]], colors: Dict[int, str]) -&gt; Dict[int, str]:\n    nodes_to_process = list(tree.keys())\n    while nodes_to_process:\n        for node in nodes_to_process[:]:\n            child_colors = [colors[n[\"n\"]] for n in tree[node]]\n            if all(child_colors):\n                unique_colors = set(child_colors)\n                if unique_colors == {\"red\"}:\n                    colors[node] = \"red\"\n                elif unique_colors == {\"blue\"}:\n                    colors[node] = \"blue\"\n                else:\n                    colors[node] = \"purple\"\n                nodes_to_process.remove(node)\n    return colors\n\ndef find_non_purple_edges(tree: Dict[int, List[Dict[str, int]]], colors: Dict[int, str]):\n    def _find_non_purple_edges(node: int, sequence: List[str], path: List[int]):\n        if colors[node] == \"purple\":\n            for child in tree[node]:\n                yield from _find_non_purple_edges(child[\"n\"], sequence + [child[\"l\"]], path + [node])\n        else:\n            if colors[node] == \"red\":\n                sequence[-1] = sequence[-1][0]\n                joined_sequence = \"\".join(sequence)\n                if \"#\" not in joined_sequence and \"$\" not in joined_sequence:\n                    yield joined_sequence\n\n    yield from _find_non_purple_edges(0, [], [])\n\ndef find_shortest_nonshared_substring(seq1: str, seq2: str) -&gt; str:\n    combined_sequence = seq1 + \"$\" + seq2 + \"#\"\n    suffix_tree = create_suffix_tree(combined_sequence)\n    graph = convert_to_graph(suffix_tree)\n    initial_colors = initialize_leaf_colors(graph)\n    final_colors = color_tree_nodes(graph, initial_colors)\n    return min(find_non_purple_edges(graph, final_colors), key=len)\n\nsample_input = \"\"\"\nCCAAGCTGCTAGAGG\nCATGCTGGGCTGGCT\n\"\"\"\n\nsequence1, sequence2 = sample_input.strip().split(\"\\n\")\nprint(find_shortest_nonshared_substring(sequence1, sequence2))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-92",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-92",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "92.1 Sample Dataset",
    "text": "92.1 Sample Dataset\nAACGATAGCGGTAGA$"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-92",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-92",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "92.2 Sample Output",
    "text": "92.2 Sample Output\n15, 14, 0, 1, 12, 6, 4, 2, 8, 13, 3, 7, 9, 10, 11, 5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-92",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-92",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "92.3 Solution",
    "text": "92.3 Solution\nfrom typing import List\n\ndef create_suffix_array(text: str) -&gt; List[int]:\n    \"\"\"\n    Create a suffix array for the given text.\n\n    Args:\n    text (str): The input string to create a suffix array for.\n\n    Returns:\n    List[int]: A list of indices representing the suffix array.\n    \"\"\"\n    suffixes = [(i, text[i:]) for i in range(len(text))]\n    sorted_suffixes = sorted(suffixes, key=lambda x: x[1])\n    return [index for index, _ in sorted_suffixes]\n\nsample_input = \"AACGATAGCGGTAGA$\"\nsuffix_array = create_suffix_array(sample_input.strip())\nprint(*suffix_array, sep=\", \")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-93",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-93",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "93.1 Sample Dataset",
    "text": "93.1 Sample Dataset\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-93",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-93",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "93.2 Sample Output",
    "text": "93.2 Sample Output\n1 4 11 15"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-93",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-93",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "93.3 Solution",
    "text": "93.3 Solution\nfrom typing import List, Tuple\n\ndef create_suffix_array(text: str) -&gt; List[int]:\n    \"\"\"\n    Create a suffix array for the given text.\n\n    Args:\n    text (str): The input string to create a suffix array for.\n\n    Returns:\n    List[int]: A list of indices representing the suffix array.\n    \"\"\"\n    suffixes: List[Tuple[int, str]] = [(i, text[i:]) for i in range(len(text))]\n    sorted_suffixes: List[Tuple[int, str]] = sorted(suffixes, key=lambda x: x[1])\n    return [index for index, _ in sorted_suffixes]\n\ndef find_pattern_occurrences(text: str, pattern: str, suffix_array: List[int]) -&gt; List[int]:\n    \"\"\"\n    Find all occurrences of a pattern in the text using the suffix array.\n\n    Args:\n    text (str): The input text to search in.\n    pattern (str): The pattern to search for.\n    suffix_array (List[int]): The suffix array of the text.\n\n    Returns:\n    List[int]: A list of indices where the pattern occurs in the text.\n    \"\"\"\n    lower_bound: int = 0\n    upper_bound: int = len(text)\n    \n    while lower_bound &lt; upper_bound:\n        mid_point: int = (lower_bound + upper_bound) // 2\n        if pattern &gt; text[suffix_array[mid_point]:][: len(pattern)]:\n            lower_bound = mid_point + 1\n        else:\n            upper_bound = mid_point\n    \n    first_occurrence: int = lower_bound\n    upper_bound = len(text)\n    \n    while lower_bound &lt; upper_bound:\n        mid_point: int = (lower_bound + upper_bound) // 2\n        if pattern &lt; text[suffix_array[mid_point]:][: len(pattern)]:\n            upper_bound = mid_point\n        else:\n            lower_bound = mid_point + 1\n    \n    last_occurrence: int = upper_bound\n    \n    if first_occurrence &gt; last_occurrence:\n        return []\n    else:\n        return list(range(first_occurrence, last_occurrence))\n\nsample_input: str = \"\"\"\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT\n\"\"\"\n\nsequence, *patterns = sample_input.strip().split(\"\\n\")\nsuffix_array: List[int] = create_suffix_array(sequence)\nmatching_indices: List[int] = []\n\nfor pattern in patterns:\n    for index in find_pattern_occurrences(sequence, pattern, suffix_array):\n        matching_indices.append(suffix_array[index])\n\nprint(*sorted(set(matching_indices)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-94",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-94",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "94.1 Sample Dataset",
    "text": "94.1 Sample Dataset\nGCGTGCCTGGTCA$"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-94",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-94",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "94.2 Sample Output",
    "text": "94.2 Sample Output\nACTGGCT$TGCGGC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-94",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-94",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "94.3 Solution",
    "text": "94.3 Solution\nfrom typing import List\n\ndef create_suffix_array(text: str) -&gt; List[int]:\n    \"\"\"\n    Create a suffix array for the given text.\n\n    Args:\n    text (str): The input string to create a suffix array for.\n\n    Returns:\n    List[int]: A list of indices representing the suffix array.\n    \"\"\"\n    suffixes = sorted(range(len(text)), key=lambda i: text[i:])\n    return suffixes\n\ndef burrows_wheeler_transform(sequence: str) -&gt; str:\n    \"\"\"\n    Perform the Burrows-Wheeler Transform on the input sequence.\n\n    Args:\n    sequence (str): The input string to transform.\n\n    Returns:\n    str: The Burrows-Wheeler Transform of the input sequence.\n    \"\"\"\n    suffix_array = create_suffix_array(sequence)\n    return ''.join(sequence[i - 1] for i in suffix_array)\n\nsample_input = \"GCGTGCCTGGTCA$\"\ntransformed_sequence = burrows_wheeler_transform(sample_input.strip())\nprint(transformed_sequence)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-95",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-95",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "95.1 Sample Dataset",
    "text": "95.1 Sample Dataset\nTTCCTAACG$A"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-95",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-95",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "95.2 Sample Output",
    "text": "95.2 Sample Output\nTACATCACGT$"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-95",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-95",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "95.3 Solution",
    "text": "95.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Tuple, Generator\n\ndef index_characters(sequence: str) -&gt; Generator[Tuple[str, int], None, None]:\n    \"\"\"\n    Generate each character with its occurrence number in the sequence.\n\n    Args:\n    sequence (str): The input string to index.\n\n    Yields:\n    Tuple[str, int]: A tuple containing the character and its occurrence number.\n    \"\"\"\n    char_counts = defaultdict(int)\n    for char in sequence:\n        yield char, char_counts[char]\n        char_counts[char] += 1\n\ndef burrows_wheeler_transform_inverse(bwt_sequence: str) -&gt; str:\n    \"\"\"\n    Perform the inverse Burrows-Wheeler Transform on the input sequence.\n\n    Args:\n    bwt_sequence (str): The Burrows-Wheeler transformed string.\n\n    Returns:\n    str: The original string before BWT.\n    \"\"\"\n    first_column = list(index_characters(sorted(bwt_sequence)))\n    last_column = list(index_characters(bwt_sequence))\n    \n    current_char: Tuple[str, int] = (\"$\", 0)\n    original_sequence: List[str] = []\n    \n    for _ in range(len(bwt_sequence)):\n        current_char = first_column[last_column.index(current_char)]\n        original_sequence.append(current_char[0])\n    \n    return ''.join(original_sequence)\n\nsample_input = \"TTCCTAACG$A\"\noriginal_sequence = burrows_wheeler_transform_inverse(sample_input.strip())\nprint(original_sequence)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-96",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-96",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "96.1 Sample Dataset",
    "text": "96.1 Sample Dataset\nT$GACCA\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-96",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-96",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "96.2 Sample Output",
    "text": "96.2 Sample Output\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-96",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-96",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "96.3 Solution",
    "text": "96.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Tuple, Generator\n\ndef index_characters(sequence: str) -&gt; Generator[Tuple[str, int], None, None]:\n    \"\"\"\n    Generate each character with its occurrence number in the sequence.\n\n    Args:\n    sequence (str): The input string to index.\n\n    Yields:\n    Tuple[str, int]: A tuple containing the character and its occurrence number.\n    \"\"\"\n    char_counts = defaultdict(int)\n    for char in sequence:\n        yield char, char_counts[char]\n        char_counts[char] += 1\n\ndef last_to_first_mapping(sequence: str, index: int) -&gt; int:\n    \"\"\"\n    Find the mapping from Last column to First column in the Burrows-Wheeler Transform matrix.\n\n    Args:\n    sequence (str): The input string (Last column of BWT matrix).\n    index (int): The index in the Last column.\n\n    Returns:\n    int: The corresponding index in the First column.\n    \"\"\"\n    first_column = list(index_characters(sorted(sequence)))\n    last_column = list(index_characters(sequence))\n    return first_column.index(last_column[index])\n\nsample_input = \"\"\"\nT$GACCA\n3\n\"\"\"\nsequence, index_str = sample_input.strip().split(\"\\n\")\nindex = int(index_str)\n\nresult = last_to_first_mapping(sequence.strip(), index)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-97",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-97",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "97.1 Sample Dataset",
    "text": "97.1 Sample Dataset\nTCCTCTATGAGATCCTATTCTATGAAACCTTCA$GACCAAAATTCTCCGGC\nCCT CAC GAG CAG ATC"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-97",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-97",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "97.2 Sample Output",
    "text": "97.2 Sample Output\n2 1 1 0 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-97",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-97",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "97.3 Solution",
    "text": "97.3 Solution\nfrom typing import List, Dict, Tuple\n\ndef BWMatching(bwt: str, patterns: List[str]) -&gt; List[int]:\n    def create_count_and_first_occurrence(bwt: str) -&gt; Tuple[Dict[str, List[int]], Dict[str, int]]:\n        count: Dict[str, List[int]] = {char: [0] * (len(bwt) + 1) for char in set(bwt)}\n        first_occurrence: Dict[str, int] = {}\n        sorted_bwt: List[str] = sorted(bwt)\n        \n        for i, char in enumerate(bwt):\n            for c in count:\n                count[c][i + 1] = count[c][i]\n            count[char][i + 1] += 1\n        \n        for i, char in enumerate(sorted_bwt):\n            if char not in first_occurrence:\n                first_occurrence[char] = i\n        \n        return count, first_occurrence\n\n    def count_matches(pattern: str) -&gt; int:\n        top: int = 0\n        bottom: int = len(bwt) - 1\n        while top &lt;= bottom:\n            if pattern:\n                symbol: str = pattern[-1]\n                pattern = pattern[:-1]\n                if symbol in bwt[top:bottom+1]:\n                    top = first_occurrence[symbol] + count[symbol][top]\n                    bottom = first_occurrence[symbol] + count[symbol][bottom+1] - 1\n                else:\n                    return 0\n            else:\n                return bottom - top + 1\n\n    count, first_occurrence = create_count_and_first_occurrence(bwt)\n    return [count_matches(pattern) for pattern in patterns]\n\n# Sample input processing\nsample_input: str = \"\"\"\nTCCTCTATGAGATCCTATTCTATGAAACCTTCA$GACCAAAATTCTCCGGC\nCCT CAC GAG CAG ATC\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nbwt: str = input_lines[0]\npatterns: List[str] = input_lines[1].split()\n\n# Run the BWMatching algorithm\nresult: List[int] = BWMatching(bwt, patterns)\nprint(\" \".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-98",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-98",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "98.1 Sample Dataset",
    "text": "98.1 Sample Dataset\nGGCGCCGC$TAGTCACACACGCCGTA\nACC CCG CAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-98",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-98",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "98.2 Sample Output",
    "text": "98.2 Sample Output\n1 2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-98",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-98",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "98.3 Solution",
    "text": "98.3 Solution\nfrom typing import List, Dict, Tuple\n\ndef BetterBWMatching(bwt: str, patterns: List[str]) -&gt; List[int]:\n    def preprocess_bwt(bwt: str) -&gt; Tuple[List[str], Dict[str, List[int]], Dict[str, int]]:\n        first_column: List[str] = sorted(bwt)\n        count: Dict[str, List[int]] = {char: [0] * (len(bwt) + 1) for char in set(bwt)}\n        start_index: Dict[str, int] = {char: first_column.index(char) for char in set(bwt)}\n        \n        for i, char in enumerate(bwt):\n            for c in count:\n                count[c][i + 1] = count[c][i]\n            count[char][i + 1] += 1\n        \n        return first_column, count, start_index\n\n    def count_occurrences(pattern: str) -&gt; int:\n        top: int = 0\n        bottom: int = len(bwt) - 1\n        \n        while top &lt;= bottom:\n            if pattern:\n                symbol: str = pattern[-1]\n                pattern = pattern[:-1]\n                if symbol in bwt[top:bottom+1]:\n                    top = start_index[symbol] + count[symbol][top]\n                    bottom = start_index[symbol] + count[symbol][bottom+1] - 1\n                else:\n                    return 0\n            else:\n                return bottom - top + 1\n\n    first_column, count, start_index = preprocess_bwt(bwt)\n    return [count_occurrences(pattern) for pattern in patterns]\n\n# Sample input processing\nsample_input: str = \"\"\"\nGGCGCCGC$TAGTCACACACGCCGTA\nACC CCG CAG\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nbwt: str = input_lines[0]\npatterns: List[str] = input_lines[1].split()\n\n# Run the BetterBWMatching algorithm\nresult: List[int] = BetterBWMatching(bwt, patterns)\nprint(\" \".join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-99",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-99",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "99.1 Sample Dataset",
    "text": "99.1 Sample Dataset\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-99",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-99",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "99.2 Sample Output",
    "text": "99.2 Sample Output\n1 4 11 15"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-99",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-99",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "99.3 Solution",
    "text": "99.3 Solution\nfrom typing import List, Dict, Tuple\n\ndef burrows_wheeler_transform(text: str) -&gt; str:\n    n = len(text)\n    rotations = sorted([text[i:] + text[:i] for i in range(n)])\n    bwt = ''.join([rot[-1] for rot in rotations])\n    return bwt\n\ndef create_checkpoint_array(bwt: str, checkpoint_interval: int) -&gt; Dict[int, Dict[str, int]]:\n    symbols = list(set(bwt))\n    checkpoint_array = {}\n    for idx in range(0, len(bwt), checkpoint_interval):\n        checkpoint_array[idx] = {symbol: bwt[:idx].count(symbol) for symbol in symbols}\n    return checkpoint_array\n\ndef count_symbol(checkpoint_array: Dict[int, Dict[str, int]], idx: int, last_column: str, symbol: str) -&gt; int:\n    checkpoints = [x for x in checkpoint_array.keys() if x &lt;= idx]\n    nearest_checkpoint = max(checkpoints)\n    count = checkpoint_array[nearest_checkpoint][symbol]\n    count += last_column[nearest_checkpoint:idx].count(symbol)\n    return count\n\ndef create_partial_suffix_array(text: str, k: int) -&gt; Dict[int, int]:\n    suffixes = [(text[i:], i) for i in range(len(text))]\n    sorted_suffixes = sorted(suffixes)\n    return {i: pos for i, (_, pos) in enumerate(sorted_suffixes) if pos % k == 0}\n\ndef multiple_pattern_matching(first_occurrence: Dict[str, int], last_column: str, pattern: str, checkpoint_array: Dict[int, Dict[str, int]]) -&gt; Tuple[int, int]:\n    top = 0\n    bottom = len(last_column) - 1\n\n    while top &lt;= bottom:\n        if pattern:\n            symbol = pattern[-1]\n            pattern = pattern[:-1]\n            if symbol in last_column[top: bottom + 1]:\n                top = first_occurrence[symbol] + count_symbol(checkpoint_array, top, last_column, symbol)\n                bottom = first_occurrence[symbol] + count_symbol(checkpoint_array, bottom + 1, last_column, symbol) - 1\n            else:\n                return -1, -1\n        else:\n            return top, bottom\n    return -1, -1\n\ndef find_pattern_occurrences(text: str, patterns: List[str], checkpoint_interval: int = 100) -&gt; List[int]:\n    bwt = burrows_wheeler_transform(text + '$')\n\n    first_occurrence = {}\n    for idx, symbol in enumerate(sorted(bwt)):\n        if symbol not in first_occurrence:\n            first_occurrence[symbol] = idx\n\n    checkpoint_array = create_checkpoint_array(bwt, checkpoint_interval)\n    partial_suffix_array = create_partial_suffix_array(text + '$', checkpoint_interval)\n\n    positions = []\n    for pattern in patterns:\n        top, bottom = multiple_pattern_matching(first_occurrence, bwt, pattern, checkpoint_array)\n        if top != -1:\n            for idx in range(top, bottom + 1):\n                offset = 0\n                while idx not in partial_suffix_array:\n                    idx = first_occurrence[bwt[idx]] + count_symbol(checkpoint_array, idx, bwt, bwt[idx])\n                    offset += 1\n                positions.append(partial_suffix_array[idx] + offset)\n\n    return sorted(positions)\n\n# Sample input processing\nsample_input: str = \"\"\"\nAATCGGGTTCAATCGGGGT\nATCG\nGGGT\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\ntext = input_lines[0]\npatterns = input_lines[1:]\n\nresult = find_pattern_occurrences(text, patterns)\nprint(' '.join(str(pos) for pos in result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-100",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-100",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "100.1 Sample Dataset",
    "text": "100.1 Sample Dataset\nACATGCTACTTT\nATT GCC GCTA TATT\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-100",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-100",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "100.2 Sample Output",
    "text": "100.2 Sample Output\n2 4 4 6 7 8 9"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-100",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-100",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "100.3 Solution",
    "text": "100.3 Solution\nfrom collections import defaultdict\nfrom copy import copy\nfrom typing import Dict, List, Tuple, Iterator\n\ndef suffix_array(text: str) -&gt; List[int]:\n    suffixes: Dict[int, str] = {i: text[i:] for i in range(len(text))}\n    return sorted(suffixes.keys(), key=lambda x: suffixes[x])\n\ndef partial_suffix_array(sequence: str, k: int) -&gt; List[Tuple[int, int]]:\n    return [(i, x) for i, x in enumerate(suffix_array(sequence)) if x % k == 0]\n\ndef burrows_wheeler_transform(sequence: str) -&gt; str:\n    return \"\".join(sequence[i - 1] for i in suffix_array(sequence))\n\nfrom itertools import accumulate\n\ndef first_occurrence(sequence: str) -&gt; Dict[str, int]:\n    unique_letters: List[str] = sorted(set(sequence))\n    counts: List[int] = [0] + list(accumulate(sequence.count(x) for x in unique_letters))\n    return dict(zip(unique_letters, counts))\n\ndef count_symbols(sequence: str) -&gt; List[Dict[str, int]]:\n    count: List[Dict[str, int]] = []\n    count.append(defaultdict(int))\n    for i, symbol in enumerate(sequence):\n        count.append(copy(count[i]))\n        count[i + 1][symbol] += 1\n    return count\n\ndef find_location(row: int, psa: Dict[int, int], last_column: str, fo: Dict[str, int], cs: List[Dict[str, int]]) -&gt; int:\n    steps: int = 0\n    while row not in psa:\n        predecessor: str = last_column[row]\n        row = fo[predecessor] + cs[row][predecessor]\n        steps += 1\n    return steps + psa[row]\n\nclass BWMatch:\n    def __init__(self, sequence: str, k: int = 10):\n        self.psa: Dict[int, int] = dict(partial_suffix_array(sequence + \"$\", k))\n        self.sequence: str = burrows_wheeler_transform(sequence + \"$\")\n        self.fo: Dict[str, int] = first_occurrence(self.sequence)\n        self.cs: List[Dict[str, int]] = count_symbols(self.sequence)\n        self.max_mismatches: int = 0\n\n    def update(self, pointers: Tuple[int, int], x: str) -&gt; Tuple[int, int]:\n        top, bottom = pointers\n        return (self.fo[x] + self.cs[top][x], self.fo[x] + self.cs[bottom + 1][x] - 1)\n\n    def bwm(self, pattern: str, pointers: Tuple[int, int], mismatch_count: int) -&gt; List[int]:\n        if not pattern:\n            return list(range(pointers[0], pointers[1] + 1))\n        matches: List[int] = []\n        pattern, symbol = pattern[:-1], pattern[-1]\n        if symbol in self.sequence[pointers[0] : pointers[1] + 1]:\n            matches += self.bwm(pattern, self.update(pointers, symbol), mismatch_count)\n        if mismatch_count &lt; self.max_mismatches:\n            for mismatch in [\"A\", \"C\", \"G\", \"T\"]:\n                if mismatch != symbol:\n                    matches += self.bwm(pattern, self.update(pointers, mismatch), mismatch_count + 1)\n        return matches\n\n    def match_patterns(self, patterns: List[str], max_mismatches: int) -&gt; Iterator[int]:\n        self.max_mismatches = max_mismatches\n        for pattern in patterns:\n            for match in self.bwm(pattern, (0, len(self.sequence) - 1), 0):\n                yield find_location(match, self.psa, self.sequence, self.fo, self.cs)\n\nsample_input: str = \"\"\"\nACATGCTACTTT\nATT GCC GCTA TATT\n1\n\"\"\"\nsequence, patterns, mismatches = sample_input.strip().split(\"\\n\")\npatterns: List[str] = patterns.split()\nmismatches: int = int(mismatches)\nmatcher: BWMatch = BWMatch(sequence)\nprint(*sorted(matcher.match_patterns(patterns, mismatches)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-101",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-101",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "101.1 Sample Dataset",
    "text": "101.1 Sample Dataset\n0 -&gt; {}\n1 -&gt; {}\n2 -&gt; 0,1\n3 -&gt; {}\n4 -&gt; {}\n5 -&gt; 3,2\n6 -&gt; {}\n7 -&gt; 4,5,6\n-\n0: red\n1: red\n3: blue\n4: blue\n6: red"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-101",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-101",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "101.2 Sample Output",
    "text": "101.2 Sample Output\n0: red\n1: red\n2: red\n3: blue\n4: blue\n5: purple\n6: red\n7: purple"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-101",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-101",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "101.3 Solution",
    "text": "101.3 Solution\nfrom collections import defaultdict\nimport io\nfrom typing import Dict, List, Union, TextIO\n\ndef color_tree(tree: Dict[int, List[Dict[str, int]]], node_colors: Dict[int, Union[str, None]]) -&gt; Dict[int, Union[str, None]]:\n    uncolored_nodes = list(tree.keys())\n    while uncolored_nodes:\n        for node in list(uncolored_nodes):  # Create a copy of uncolored_nodes to iterate over\n            child_colors = [node_colors[child[\"n\"]] for child in tree[node] if node_colors[child[\"n\"]] is not None]\n            if len(child_colors) == len(tree[node]):  # Check if all children are colored\n                if all(color == \"red\" for color in child_colors):\n                    node_colors[node] = \"red\"\n                elif all(color == \"blue\" for color in child_colors):\n                    node_colors[node] = \"blue\"\n                else:\n                    node_colors[node] = \"purple\"\n                uncolored_nodes.remove(node)\n    return node_colors\n\ndef parse_input(input_data: Union[str, TextIO]) -&gt; Tuple[Dict[int, List[Dict[str, int]]], Dict[int, Union[str, None]]]:\n    if isinstance(input_data, str):\n        if '\\n' in input_data:\n            # If input_data contains newlines, treat it as a string input\n            file_obj = io.StringIO(input_data)\n        else:\n            # Otherwise, treat it as a filename\n            file_obj = open(input_data)\n    elif isinstance(input_data, TextIO):\n        file_obj = input_data\n    else:\n        raise ValueError(\"Input must be a filename, a string, or a file-like object\")\n\n    tree: Dict[int, List[Dict[str, int]]] = defaultdict(list)\n    node_colors: Dict[int, Union[str, None]] = defaultdict(lambda: None)\n    \n    parsing_tree = True\n    for line in file_obj:\n        line = line.strip()\n        if line == \"-\":\n            parsing_tree = False\n            continue\n        \n        if parsing_tree:\n            if \" -&gt; \" in line:\n                parent, children = line.split(\" -&gt; \")\n                if children != \"{}\":\n                    for child in children.split(\",\"):\n                        tree[int(parent)].append({\"n\": int(child)})\n        else:\n            node, color = line.split(\": \")\n            node_colors[int(node)] = color\n\n    if isinstance(input_data, str) and '\\n' not in input_data:\n        file_obj.close()\n    \n    return tree, node_colors\n\nsample_input = \"\"\"\n0 -&gt; {}\n1 -&gt; {}\n2 -&gt; 0,1\n3 -&gt; {}\n4 -&gt; {}\n5 -&gt; 3,2\n6 -&gt; {}\n7 -&gt; 4,5,6\n-\n0: red\n1: red\n3: blue\n4: blue\n6: red\n\"\"\"\n\ntree, node_colors = parse_input(sample_input)\ncolored_tree = color_tree(tree, node_colors)\nfor node in sorted(colored_tree.keys()):\n    print(f\"{node}: {colored_tree[node]}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-102",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-102",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "102.1 Sample Dataset",
    "text": "102.1 Sample Dataset\nPANAMABANANAS$\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-102",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-102",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "102.2 Sample Output",
    "text": "102.2 Sample Output\n1,5\n11,10\n12,0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-102",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-102",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "102.3 Solution",
    "text": "102.3 Solution\nfrom typing import List, Dict, Tuple\n\ndef suffix_array(text: str) -&gt; List[int]:\n    suffixes: Dict[int, str] = {i: text[i:] for i in range(len(text))}\n    return sorted(suffixes.keys(), key=lambda x: suffixes[x])\n\ndef partial_suffix_array(sequence: str, step: int) -&gt; List[Tuple[int, int]]:\n    return [(index, position) for index, position in enumerate(suffix_array(sequence)) if position % step == 0]\n\nsample_input: str = \"\"\"\nPANAMABANANAS$\n5\n\"\"\"\n\nsequence, step_str = sample_input.strip().split(\"\\n\")\nstep: int = int(step_str)\n\nfor entry in partial_suffix_array(sequence, step):\n    print(*entry, sep=\",\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-103",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-103",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "103.1 Sample Dataset",
    "text": "103.1 Sample Dataset\nGTAGT$\n5, 2, 3, 0, 4, 1\n0, 0, 0, 2, 0, 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-103",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-103",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "103.2 Sample Output",
    "text": "103.2 Sample Output\n$\n$\n$\nAGT$\nAGT$\nAGT$\nGT\nT"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-103",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-103",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "103.3 Solution",
    "text": "103.3 Solution\nfrom typing import Dict, List, Union\n\nclass Node:\n    def __init__(self, parent: Union[int, str, None] = None, label: str = \"\"):\n        self.parent: Union[int, str, None] = parent\n        self.label: str = label\n\ndef calculate_depth(tree: Dict[Union[int, str], Node], node: Union[int, str]) -&gt; int:\n    \"\"\"\n    Calculate the length of the concatenation of all path labels from the root to node\n    \"\"\"\n    depth: int = len(tree[node].label)\n    while tree[node].parent is not None:\n        node = tree[node].parent\n        depth += len(tree[node].label)\n    return depth\n\ndef construct_suffix_tree(text: str, suffix_array: List[int], lcp_array: List[int]) -&gt; Dict[Union[int, str], Node]:\n    tree: Dict[Union[int, str], Node] = {-1: Node()}\n\n    for i in range(len(text)):\n        current_node: int = i - 1\n        while tree[current_node].parent is not None and calculate_depth(tree, current_node) &gt; lcp_array[i]:\n            current_node = tree[current_node].parent\n        current_depth: int = calculate_depth(tree, current_node)\n\n        if lcp_array[i] == current_depth:\n            tree[i] = Node(current_node, text[suffix_array[i] + lcp_array[i]:])\n        else:\n            temp_node: int = i - 1\n            while tree[temp_node].parent is not None and tree[temp_node].parent != current_node:\n                temp_node = tree[temp_node].parent\n\n            new_node_key: str = f\"y{i}\"\n            tree[new_node_key] = Node(current_node, text[suffix_array[i - 1] + current_depth : suffix_array[i - 1] + lcp_array[i]])\n            tree[temp_node] = Node(new_node_key, text[suffix_array[i - 1] + lcp_array[i] : suffix_array[i - 1] + calculate_depth(tree, temp_node)])\n            tree[i] = Node(new_node_key, text[suffix_array[i] + lcp_array[i]:])\n\n    del tree[-1]\n    return tree\n\nsample_input: str = \"\"\"\nGTAGT$\n5, 2, 3, 0, 4, 1\n0, 0, 0, 2, 0, 1\n\"\"\"\n\ntext, suffix_array_str, lcp_array_str = sample_input.strip().split(\"\\n\")\nsuffix_array: List[int] = [int(x) for x in suffix_array_str.split(\", \")]\nlcp_array: List[int] = [int(x) for x in lcp_array_str.split(\", \")]\n\nsuffix_tree: Dict[Union[int, str], Node] = construct_suffix_tree(text, suffix_array, lcp_array)\nlabels: List[str] = [suffix_tree[key].label for key in suffix_tree.keys()]\nprint(*sorted(labels), sep=\"\\n\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-104",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-104",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "104.1 Sample Dataset",
    "text": "104.1 Sample Dataset\nAABBBAABABAAAABBBBAABBABABBBAABBAAAABABAABBABABBAB\n--------\nA   B\n--------\n    A   B\nA   0.194   0.806\nB   0.273   0.727"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-104",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-104",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "104.2 Sample Output",
    "text": "104.2 Sample Output\n5.01732865318e-19"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-104",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-104",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "104.3 Solution",
    "text": "104.3 Solution\nfrom math import prod\nfrom io import StringIO\n\ndef parse_hidden_path_data(input_lines):\n    hidden_path = next(input_lines).strip()\n    next(input_lines)  # Skip separator\n    states = next(input_lines).split()\n    next(input_lines)  # Skip separator\n    next(input_lines)  # Skip column headers\n    \n    transition_probabilities = {}\n    for line in input_lines:\n        if line.strip():\n            row_data = line.split()\n            current_state = row_data[0]\n            for next_state, probability in zip(states, row_data[1:]):\n                transition_probabilities[(current_state, next_state)] = float(probability)\n    \n    return hidden_path, transition_probabilities\n\ndef calculate_hidden_path_probability(hidden_path, transition_probabilities):\n    initial_probability = 0.5\n    path_probability = initial_probability * prod(\n        transition_probabilities[state_pair] \n        for state_pair in zip(hidden_path, hidden_path[1:])\n    )\n    return path_probability\n\nsample_input = \"\"\"\nAABBBAABABAAAABBBBAABBABABBBAABBAAAABABAABBABABBAB\n--------\nA B\n--------\n    A   B\nA   0.194   0.806\nB   0.273   0.727\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nhidden_path, transition_probabilities = parse_hidden_path_data(input_lines)\nresult_probability = calculate_hidden_path_probability(hidden_path, transition_probabilities)\nprint(f\"{result_probability:e}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-105",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-105",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "105.1 Sample Dataset",
    "text": "105.1 Sample Dataset\nxxyzyxzzxzxyxyyzxxzzxxyyxxyxyzzxxyzyzxzxxyxyyzxxzx\n--------\nx   y   z\n--------\nBBBAAABABABBBBBBAAAAAABAAAABABABBBBBABAABABABABBBB\n--------\nA   B\n--------\n    x   y   z\nA   0.612   0.314   0.074 \nB   0.346   0.317   0.336"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-105",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-105",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "105.2 Sample Output",
    "text": "105.2 Sample Output\n1.93157070893e-28"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-105",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-105",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "105.3 Solution",
    "text": "105.3 Solution\nfrom math import prod\nfrom io import StringIO\n\ndef parse_emission_data(input_lines):\n    emission_sequence = next(input_lines).strip()\n    next(input_lines)  # Skip separator\n    symbols = next(input_lines).split()\n    next(input_lines)  # Skip separator\n    hidden_path = next(input_lines).strip()\n    next(input_lines)  # Skip separator\n    states = next(input_lines).split()\n    next(input_lines)  # Skip separator\n    next(input_lines)  # Skip column headers\n    \n    emission_probabilities = {}\n    for line in input_lines:\n        if line.strip():\n            row_data = line.split()\n            state = row_data[0]\n            for symbol, probability in zip(symbols, row_data[1:]):\n                emission_probabilities[(state, symbol)] = float(probability)\n    \n    return emission_sequence, hidden_path, emission_probabilities\n\ndef calculate_emission_probability(emission_sequence, hidden_path, emission_probabilities):\n    return prod(emission_probabilities[state_symbol] for state_symbol in zip(hidden_path, emission_sequence))\n\nsample_input = \"\"\"\nxxyzyxzzxzxyxyyzxxzzxxyyxxyxyzzxxyzyzxzxxyxyyzxxzx\n--------\nx y z\n--------\nBBBAAABABABBBBBBAAAAAABAAAABABABBBBBABAABABABABBBB\n--------\nA B\n--------\n    x   y   z\nA   0.612   0.314   0.074 \nB   0.346   0.317   0.336\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nemission_sequence, hidden_path, emission_probabilities = parse_emission_data(input_lines)\nresult_probability = calculate_emission_probability(emission_sequence, hidden_path, emission_probabilities)\nprint(f\"{result_probability:e}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-106",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-106",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "106.1 Sample Dataset",
    "text": "106.1 Sample Dataset\nxyxzzxyxyy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.641   0.359\nB   0.729   0.271\n--------\n    x   y   z\nA   0.117   0.691   0.192   \nB   0.097   0.42    0.483"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-106",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-106",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "106.2 Sample Output",
    "text": "106.2 Sample Output\nAAABBAAAAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-106",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-106",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "106.3 Solution",
    "text": "106.3 Solution\nfrom io import StringIO\nfrom math import log\nfrom typing import List, Dict, Tuple, Iterator\nimport numpy as np\n\ndef parse_input(input_iterator: Iterator[str]) -&gt; Tuple[str, List[str], Dict[Tuple[str, str], float], Dict[Tuple[str, str], float]]:\n    sequence = next(input_iterator).rstrip()\n    next(input_iterator)\n    alphabet = next(input_iterator).split()\n    next(input_iterator)\n    states = next(input_iterator).split()\n    next(input_iterator)\n    \n    transition_lines = [next(input_iterator) for _ in range(len(states) + 1)]\n    transition_matrix = {\n        (states[i], states[j]): float(value)\n        for i, row in enumerate(transition_lines[1:])\n        for j, value in enumerate(row.split()[1:])\n    }\n    \n    next(input_iterator)\n    emission_lines = [next(input_iterator) for _ in range(len(states) + 1)]\n    emission_matrix = {\n        (states[i], alphabet[j]): float(value)\n        for i, row in enumerate(emission_lines[1:])\n        for j, value in enumerate(row.split()[1:])\n    }\n    \n    return sequence, states, transition_matrix, emission_matrix\n\ndef viterbi(sequence: str, states: List[str], transition_matrix: Dict[Tuple[str, str], float], emission_matrix: Dict[Tuple[str, str], float]) -&gt; str:\n    num_states = len(states)\n    sequence_length = len(sequence)\n    viterbi_matrix = np.zeros((sequence_length, num_states))\n    backpointer = np.zeros((sequence_length, num_states), dtype=int)\n\n    # Initialize the first column of the viterbi matrix\n    for i, state in enumerate(states):\n        viterbi_matrix[0, i] = log(emission_matrix[state, sequence[0]] / num_states)\n\n    # Fill in the rest of the viterbi matrix\n    for t in range(1, sequence_length):\n        for j, current_state in enumerate(states):\n            probabilities = [\n                log(transition_matrix[previous_state, current_state]) + \n                log(emission_matrix[current_state, sequence[t]]) + \n                viterbi_matrix[t-1, k]\n                for k, previous_state in enumerate(states)\n            ]\n            max_prob_index = probabilities.index(max(probabilities))\n            backpointer[t, j] = max_prob_index\n            viterbi_matrix[t, j] = max(probabilities)\n\n    best_path_index = np.argmax(viterbi_matrix[-1, :])\n    best_path = states[best_path_index]\n    for t in range(sequence_length - 1, 0, -1):\n        best_path_index = backpointer[t, best_path_index]\n        best_path = states[best_path_index] + best_path\n\n    return best_path\n\n# Example usage\nsample_input = \"\"\"\nxyxzzxyxyy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.641   0.359\nB   0.729   0.271\n--------\n    x   y   z\nA   0.117   0.691   0.192   \nB   0.097   0.42    0.483\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nsequence, states, transition_matrix, emission_matrix = parse_input(input_lines)\nresult = viterbi(sequence, states, transition_matrix, emission_matrix)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-107",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-107",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "107.1 Sample Dataset",
    "text": "107.1 Sample Dataset\nxzyyzzyzyy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.303   0.697 \nB   0.831   0.169 \n--------\n    x   y   z\nA   0.533   0.065   0.402 \nB   0.342   0.334   0.324"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-107",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-107",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "107.2 Sample Output",
    "text": "107.2 Sample Output\n1.1005510319694847e-06"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-107",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-107",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "107.3 Solution",
    "text": "107.3 Solution\nfrom io import StringIO\nimport numpy as np\n\ndef parse_hmm_input(input_iterator):\n    sequence = next(input_iterator).rstrip()\n    next(input_iterator)\n    alphabet = next(input_iterator).split()\n    next(input_iterator)\n    states = next(input_iterator).split()\n    next(input_iterator)\n    \n    transition_lines = [next(input_iterator) for _ in range(len(states) + 1)]\n    transition_matrix = {\n        (states[i], states[j]): float(value)\n        for i, row in enumerate(transition_lines[1:])\n        for j, value in enumerate(row.split()[1:])\n    }\n    \n    next(input_iterator)\n    emission_lines = [next(input_iterator) for _ in range(len(states) + 1)]\n    emission_matrix = {\n        (states[i], alphabet[j]): float(value)\n        for i, row in enumerate(emission_lines[1:])\n        for j, value in enumerate(row.split()[1:])\n    }\n    \n    return sequence, states, transition_matrix, emission_matrix\n\ndef calculate_hmm_likelihood(sequence, states, transition_matrix, emission_matrix):\n    probability_matrix = np.ones((len(sequence) + 1, len(states)))\n\n    for i, state in enumerate(states):\n        probability_matrix[0, i] = emission_matrix[state, sequence[0]] / len(states)\n\n    for i, emission in enumerate(sequence[1:], start=1):\n        for j, current_state in enumerate(states):\n            probability_matrix[i, j] = sum(\n                transition_matrix[previous_state, current_state] * \n                emission_matrix[current_state, emission] * \n                probability_matrix[i - 1, k]\n                for k, previous_state in enumerate(states)\n            )\n\n    return sum(probability_matrix[i, :])\n\nsample_input = \"\"\"\nxzyyzzyzyy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.303   0.697 \nB   0.831   0.169 \n--------\n    x   y   z\nA   0.533   0.065   0.402 \nB   0.342   0.334   0.324\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nsequence, states, transition_matrix, emission_matrix = parse_hmm_input(input_lines)\nresult = calculate_hmm_likelihood(sequence, states, transition_matrix, emission_matrix)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-108",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-108",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "108.1 Sample Dataset",
    "text": "108.1 Sample Dataset\n0.289\n--------\nA   B   C   D   E\n--------\nEBA\nEBD\nEB-\nEED\nEBD\nEBE\nE-D\nEBD"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-108",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-108",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "108.2 Sample Output",
    "text": "108.2 Sample Output\nS   I0  M1  D1  I1  M2  D2  I2  M3  D3  I3  E\nS   0   0   1.0 0   0   0   0   0   0   0   0   0\nI0  0   0   0   0   0   0   0   0   0   0   0   0\nM1  0   0   0   0   0   0.875   0.125   0   0   0   0   0\nD1  0   0   0   0   0   0   0   0   0   0   0   0\nI1  0   0   0   0   0   0   0   0   0   0   0   0\nM2  0   0   0   0   0   0   0   0   0.857   0.143   0   0\nD2  0   0   0   0   0   0   0   0   1.0 0   0   0\nI2  0   0   0   0   0   0   0   0   0   0   0   0\nM3  0   0   0   0   0   0   0   0   0   0   0   1.0\nD3  0   0   0   0   0   0   0   0   0   0   0   1.0\nI3  0   0   0   0   0   0   0   0   0   0   0   0\nE   0   0   0   0   0   0   0   0   0   0   0   0\n--------\n    A   B   C   D   E\nS   0   0   0   0   0\nI0  0   0   0   0   0\nM1  0   0   0   0   1.0\nD1  0   0   0   0   0\nI1  0   0   0   0   0\nM2  0   0.857   0   0   0.143\nD2  0   0   0   0   0\nI2  0   0   0   0   0\nM3  0.143   0   0   0.714   0.143\nD3  0   0   0   0   0\nI3  0   0   0   0   0\nE   0   0   0   0   0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-108",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-108",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "108.3 Solution",
    "text": "108.3 Solution\nimport numpy as np\nfrom io import StringIO\nfrom typing import List, Tuple, Iterator\n\ndef parse_hmm_input(input_iterator: Iterator[str]) -&gt; Tuple[float, List[str], np.ndarray]:\n    threshold = float(next(input_iterator).rstrip())\n    next(input_iterator)\n    alphabet = next(input_iterator).split()\n    next(input_iterator)\n    alignment = np.array([list(sequence.strip()) for sequence in input_iterator])\n    return threshold, alphabet, alignment\n\ndef calculate_state_index(position: int, state_type: str) -&gt; int:\n    if state_type == \"ins\":\n        return (position + 1) * 3 + 1\n    else:\n        return {\"match\": 0, \"del\": 1}[state_type] + 3 * position + 2\n\ndef normalize_row(row: np.ndarray, include_zeros: bool = False, min_value: float = 0.0) -&gt; np.ndarray:\n    if include_zeros and sum(row) == 0:\n        row[:] = 1\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        normalized = row / sum(row)\n        normalized[row == 0.0] = min_value\n        return normalized\n\ndef normalize_matrix(matrix: np.ndarray, include_zeros: bool = False, min_value: float = 0.0) -&gt; np.ndarray:\n    return np.array([normalize_row(row, include_zeros=include_zeros, min_value=min_value) for row in matrix])\n\ndef print_matrix(matrix: np.ndarray, row_labels: List[str], column_labels: List[str]) -&gt; None:\n    print(*column_labels, sep=\"\\t\")\n    for i, row in enumerate(matrix):\n        formatted_row = [row_labels[i]] + [round(x, 3) if x &gt; 0.0 else \"0\" for x in row]\n        print(*formatted_row, sep=\"\\t\")\n\ndef print_transition_probabilities(transition_matrix: np.ndarray) -&gt; None:\n    n = (transition_matrix.shape[0] - 3) // 3\n    print_matrix(transition_matrix, generate_state_labels(n), generate_state_labels(n))\n\ndef print_emission_probabilities(emission_matrix: np.ndarray, alphabet: List[str]) -&gt; None:\n    n = (emission_matrix.shape[0] - 3) // 3\n    print_matrix(emission_matrix, generate_state_labels(n), alphabet)\n\ndef generate_state_labels(n: int) -&gt; List[str]:\n    labels = [\"S\", \"I0\"]\n    for i in range(1, n + 1):\n        labels += [f\"M{i}\", f\"D{i}\", f\"I{i}\"]\n    labels.append(\"E\")\n    return labels\n\ndef create_transition_matrix(n: int) -&gt; np.ndarray:\n    return np.zeros((n * 3 + 3, n * 3 + 3), dtype=float)\n\ndef create_emission_matrix(n: int, m: int) -&gt; np.ndarray:\n    return np.zeros((n * 3 + 3, m), dtype=float)\n\ndef build_profile_hmm(threshold: float, alphabet: List[str], alignment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    valid_columns = np.mean(alignment == \"-\", axis=0) &lt; threshold\n    valid_column_count = sum(valid_columns)\n    end_state = valid_column_count * 3 + 2\n    transition_probs = create_transition_matrix(valid_column_count)\n    emission_probs = create_emission_matrix(valid_column_count, len(alphabet))\n\n    for sequence in alignment:\n        prev_index = 0\n        column_index = -1\n        for i, char in enumerate(sequence):\n            if valid_columns[i]:\n                column_index += 1\n                if char == \"-\":\n                    current_index = calculate_state_index(column_index, \"del\")\n                else:\n                    current_index = calculate_state_index(column_index, \"match\")\n                transition_probs[prev_index, current_index] += 1\n                prev_index = current_index\n            else:\n                if char != \"-\":\n                    current_index = calculate_state_index(column_index, \"ins\")\n                    transition_probs[prev_index, current_index] += 1\n                    prev_index = current_index\n            if char != \"-\":\n                emission_probs[current_index, alphabet.index(char)] += 1\n        transition_probs[prev_index, end_state] += 1\n\n    transition_probs = normalize_matrix(transition_probs)\n    emission_probs = normalize_matrix(emission_probs)\n\n    return transition_probs, emission_probs\n\nsample_input = \"\"\"\n0.289\n--------\nA   B   C   D   E\n--------\nEBA\nEBD\nEB-\nEED\nEBD\nEBE\nE-D\nEBD\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nthreshold, alphabet, alignment = parse_hmm_input(input_lines)\ntransition_probs, emission_probs = build_profile_hmm(threshold, alphabet, alignment)\nprint_transition_probabilities(transition_probs)\nprint(\"--------\")\nprint_emission_probabilities(emission_probs, alphabet)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-109",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-109",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "109.1 Sample Dataset",
    "text": "109.1 Sample Dataset\n0.358   0.01\n--------\nA   B   C   D   E\n--------\nADA\nADA\nAAA\nADC\n-DA\nD-A"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-109",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-109",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "109.2 Sample Output",
    "text": "109.2 Sample Output\nS   I0  M1  D1  I1  M2  D2  I2  M3  D3  I3  E\nS   0   0.01    0.819   0.172   0   0   0   0   0   0   0   0\nI0  0   0.333   0.333   0.333   0   0   0   0   0   0   0   0\nM1  0   0   0   0   0.01    0.786   0.204   0   0   0   0   0\nD1  0   0   0   0   0.01    0.981   0.01    0   0   0   0   0\nI1  0   0   0   0   0.333   0.333   0.333   0   0   0   0   0\nM2  0   0   0   0   0   0   0   0.01    0.981   0.01    0   0\nD2  0   0   0   0   0   0   0   0.01    0.981   0.01    0   0\nI2  0   0   0   0   0   0   0   0.333   0.333   0.333   0   0\nM3  0   0   0   0   0   0   0   0   0   0   0.01    0.99\nD3  0   0   0   0   0   0   0   0   0   0   0.5 0.5\nI3  0   0   0   0   0   0   0   0   0   0   0.5 0.5\nE   0   0   0   0   0   0   0   0   0   0   0   0\n--------\n    A   B   C   D   E\nS   0   0   0   0   0\nI0  0.2 0.2 0.2 0.2 0.2\nM1  0.771   0.01    0.01    0.2 0.01\nD1  0   0   0   0   0\nI1  0.2 0.2 0.2 0.2 0.2\nM2  0.2 0.01    0.01    0.771   0.01\nD2  0   0   0   0   0\nI2  0.2 0.2 0.2 0.2 0.2\nM3  0.803   0.01    0.168   0.01    0.01\nD3  0   0   0   0   0\nI3  0.2 0.2 0.2 0.2 0.2\nE   0   0   0   0   0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-109",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-109",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "109.3 Solution",
    "text": "109.3 Solution\nimport numpy as np\nfrom io import StringIO\nfrom typing import List, Tuple\n\ndef normalize_matrix(matrix: np.ndarray, include_zeros: bool = False, min_value: float = 0.0) -&gt; np.ndarray:\n    return np.array([normalize_row(row, include_zeros=include_zeros, min_value=min_value) for row in matrix])\n\ndef normalize_row(row: np.ndarray, include_zeros: bool = False, min_value: float = 0.0) -&gt; np.ndarray:\n    if include_zeros and sum(row) == 0:\n        row[:] = 1\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        normalized = row / sum(row)\n        normalized[row == 0.0] = min_value\n        return normalized\n\ndef print_matrix(matrix: np.ndarray, row_labels: List[str], col_labels: List[str]) -&gt; None:\n    print(*col_labels, sep=\"\\t\")\n    for i, row in enumerate(matrix):\n        formatted_row = [row_labels[i]] + [round(x, 3) if x &gt; 0.0 else \"0\" for x in row]\n        print(*formatted_row, sep=\"\\t\")\n\ndef print_transition_probs(transition_matrix: np.ndarray) -&gt; None:\n    n = (transition_matrix.shape[0] - 3) // 3\n    print_matrix(transition_matrix, generate_state_labels(n), generate_state_labels(n))\n\ndef print_emission_probs(emission_matrix: np.ndarray, alphabet: List[str]) -&gt; None:\n    n = (emission_matrix.shape[0] - 3) // 3\n    print_matrix(emission_matrix, generate_state_labels(n), alphabet)\n\ndef generate_state_labels(n: int) -&gt; List[str]:\n    labels = [\"S\", \"I0\"]\n    for i in range(1, n + 1):\n        labels += [f\"M{i}\", f\"D{i}\", f\"I{i}\"]\n    labels.append(\"E\")\n    return labels\n\ndef create_transition_matrix(n: int) -&gt; np.ndarray:\n    return np.zeros((n * 3 + 3, n * 3 + 3), dtype=float)\n\ndef create_emission_matrix(n: int, m: int) -&gt; np.ndarray:\n    return np.zeros((n * 3 + 3, m), dtype=float)\n\ndef calculate_state_index(position: int, state_type: str) -&gt; int:\n    if state_type == \"ins\":\n        return (position + 1) * 3 + 1\n    else:\n        return {\"match\": 0, \"del\": 1}[state_type] + 3 * position + 2\n\ndef build_profile_hmm(threshold: float, alphabet: List[str], alignment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    valid_columns = np.mean(alignment == \"-\", axis=0) &lt; threshold\n    valid_column_count = sum(valid_columns)\n    end_state = valid_column_count * 3 + 2\n    transition_probs = create_transition_matrix(valid_column_count)\n    emission_probs = create_emission_matrix(valid_column_count, len(alphabet))\n\n    for sequence in alignment:\n        prev_index = 0\n        column_index = -1\n        for i, char in enumerate(sequence):\n            if valid_columns[i]:\n                column_index += 1\n                if char == \"-\":\n                    current_index = calculate_state_index(column_index, \"del\")\n                else:\n                    current_index = calculate_state_index(column_index, \"match\")\n                transition_probs[prev_index, current_index] += 1\n                prev_index = current_index\n            else:\n                if char != \"-\":\n                    current_index = calculate_state_index(column_index, \"ins\")\n                    transition_probs[prev_index, current_index] += 1\n                    prev_index = current_index\n            if char != \"-\":\n                emission_probs[current_index, alphabet.index(char)] += 1\n        transition_probs[prev_index, end_state] += 1\n\n    transition_probs = normalize_matrix(transition_probs)\n    emission_probs = normalize_matrix(emission_probs)\n\n    return transition_probs, emission_probs\n\ndef parse_input(input_handle: Iterator[str]) -&gt; Tuple[float, float, List[str], np.ndarray]:\n    threshold, pseudocount = map(float, next(input_handle).rstrip().split())\n    next(input_handle)\n    alphabet = next(input_handle).split()\n    next(input_handle)\n    alignment = np.array([list(sequence.strip()) for sequence in input_handle])\n    return threshold, pseudocount, alphabet, alignment\n\ndef add_transition_pseudocounts(transition_matrix: np.ndarray, pseudocount: float) -&gt; np.ndarray:\n    n = (transition_matrix.shape[0] - 3) // 3\n    transition_matrix[0, 1:4] += pseudocount\n    transition_matrix[1, 1:4] += pseudocount\n    for i in range(n):\n        transition_matrix[i * 3 + 2 : i * 3 + 5, (i + 1) * 3 + 1 : (i + 1) * 3 + 4] += pseudocount\n    return normalize_matrix(transition_matrix)\n\ndef add_emission_pseudocounts(emission_matrix: np.ndarray, pseudocount: float) -&gt; np.ndarray:\n    n = (emission_matrix.shape[0] - 3) // 3\n    emission_matrix[1, :] += pseudocount\n    for i in range(n):\n        emission_matrix[i * 3 + 2, :] += pseudocount\n        emission_matrix[i * 3 + 4, :] += pseudocount\n    return normalize_matrix(emission_matrix)\n\ndef build_pseudocount_profile_hmm(threshold: float, pseudocount: float, alphabet: List[str], alignment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    transition_probs, emission_probs = build_profile_hmm(threshold, alphabet, alignment)\n    transition_probs = add_transition_pseudocounts(transition_probs, pseudocount)\n    emission_probs = add_emission_pseudocounts(emission_probs, pseudocount)\n    return transition_probs, emission_probs\n\nsample_input = \"\"\"\n0.358   0.01\n--------\nA   B   C   D   E\n--------\nADA\nADA\nAAA\nADC\n-DA\nD-A\n\"\"\"\n\ninput_lines = iter(StringIO(sample_input.strip()).readlines())\nthreshold, pseudocount, alphabet, alignment = parse_input(input_lines)\ntransition_probs, emission_probs = build_pseudocount_profile_hmm(threshold, pseudocount, alphabet, alignment)\nprint_transition_probs(transition_probs)\nprint(\"--------\")\nprint_emission_probs(emission_probs, alphabet)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-110",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-110",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "110.1 Sample Dataset",
    "text": "110.1 Sample Dataset\nAEFDFDC\n--------\n0.4 0.01\n--------\nA   B   C   D   E   F\n--------\nACDEFACADF\nAFDA---CCF\nA--EFD-FDC\nACAEF--A-C\nADDEFAAADF"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-110",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-110",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "110.2 Sample Output",
    "text": "110.2 Sample Output\nM1 D2 D3 M4 M5 I5 M6 M7 M8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-110",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-110",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "110.3 Solution",
    "text": "110.3 Solution\nfrom io import StringIO\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict, Iterator\nimport numpy as np\nfrom math import inf, log\n\ndef generate_state_labels(num_states: int) -&gt; List[str]:\n    labels = [\"S\", \"I0\"]\n    for i in range(1, num_states + 1):\n        labels.extend([f\"M{i}\", f\"D{i}\", f\"I{i}\"])\n    labels.append(\"E\")\n    return labels\n\ndef normalize_row(row: np.ndarray, include_zeros: bool = False, minimum_value: float = 0.0) -&gt; np.ndarray:\n    if include_zeros and sum(row) == 0:\n        row[:] = 1\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        normalized = row / sum(row)\n        normalized[row == 0.0] = minimum_value\n        return normalized\n\ndef normalize_matrix(matrix: np.ndarray, include_zeros: bool = False, minimum_value: float = 0.0) -&gt; np.ndarray:\n    return np.array([normalize_row(r, include_zeros=include_zeros, minimum_value=minimum_value) for r in matrix])\n\ndef create_transition_matrix(num_states: int) -&gt; np.ndarray:\n    return np.zeros((num_states * 3 + 3, num_states * 3 + 3), dtype=float)\n\ndef create_emission_matrix(num_states: int, num_symbols: int) -&gt; np.ndarray:\n    return np.zeros((num_states * 3 + 3, num_symbols), dtype=float)\n\ndef calculate_index(state_num: int, state_type: str) -&gt; int:\n    if state_type == \"ins\":\n        return (state_num + 1) * 3 + 1\n    else:\n        return {\"match\": 0, \"del\": 1}[state_type] + 3 * state_num + 2\n\ndef build_profile_hmm(threshold: float, alphabet: List[str], alignment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    valid_columns = np.mean(alignment == \"-\", axis=0) &lt; threshold\n    valid_length = sum(valid_columns)\n    end_state = valid_length * 3 + 2\n    transition_probs = create_transition_matrix(valid_length)\n    emission_probs = create_emission_matrix(valid_length, len(alphabet))\n\n    for sequence in alignment:\n        prev_index = 0\n        valid_col_count = -1\n        for col, char in enumerate(sequence):\n            if valid_columns[col]:\n                valid_col_count += 1\n                if char == \"-\":\n                    current_index = calculate_index(valid_col_count, \"del\")\n                else:\n                    current_index = calculate_index(valid_col_count, \"match\")\n                transition_probs[prev_index, current_index] += 1\n                prev_index = current_index\n            else:\n                if char != \"-\":\n                    current_index = calculate_index(valid_col_count, \"ins\")\n                    transition_probs[prev_index, current_index] += 1\n                    prev_index = current_index\n            if char != \"-\":\n                emission_probs[current_index, alphabet.index(char)] += 1\n        transition_probs[prev_index, end_state] += 1\n\n    transition_probs = normalize_matrix(transition_probs)\n    emission_probs = normalize_matrix(emission_probs)\n\n    return transition_probs, emission_probs\n\ndef add_pseudocounts_to_transitions(matrix: np.ndarray, pseudocount: float) -&gt; np.ndarray:\n    num_states = (matrix.shape[0] - 3) // 3\n    matrix[0, 1:4] += pseudocount\n    matrix[1, 1:4] += pseudocount\n    for i in range(num_states):\n        matrix[i*3+2:i*3+5, (i+1)*3+1:(i+1)*3+4] += pseudocount\n    return normalize_matrix(matrix)\n\ndef add_pseudocounts_to_emissions(matrix: np.ndarray, pseudocount: float) -&gt; np.ndarray:\n    num_states = (matrix.shape[0] - 3) // 3\n    matrix[1, :] += pseudocount\n    for i in range(num_states):\n        matrix[i*3+2, :] += pseudocount\n        matrix[i*3+4, :] += pseudocount\n    return normalize_matrix(matrix)\n\ndef build_profile_hmm_with_pseudocounts(threshold: float, pseudocount: float, alphabet: List[str], alignment: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    transition_probs, emission_probs = build_profile_hmm(threshold, alphabet, alignment)\n    transition_probs = add_pseudocounts_to_transitions(transition_probs, pseudocount)\n    emission_probs = add_pseudocounts_to_emissions(emission_probs, pseudocount)\n    return transition_probs, emission_probs\n\ndef parse_input_data(input_iterator: Iterator[str]) -&gt; Tuple[str, float, float, List[str], np.ndarray]:\n    sequence = next(input_iterator).rstrip()\n    next(input_iterator)\n    threshold, pseudocount = map(float, next(input_iterator).rstrip().split())\n    next(input_iterator)\n    alphabet = next(input_iterator).split()\n    next(input_iterator)\n    alignment = np.array([list(x.strip()) for x in input_iterator])\n    return sequence, threshold, pseudocount, alphabet, alignment\n\ndef convert_transition_probs_to_dict(matrix: np.ndarray) -&gt; Dict[Tuple[str, str], float]:\n    prob_dict = defaultdict(float)\n    num_states = (matrix.shape[0] - 3) // 3\n    labels = generate_state_labels(num_states)\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[0]):\n            prob_dict[labels[i], labels[j]] = matrix[i][j]\n    return prob_dict\n\ndef convert_emission_probs_to_dict(matrix: np.ndarray, alphabet: List[str]) -&gt; Dict[Tuple[str, str], float]:\n    prob_dict = defaultdict(float)\n    num_states = (matrix.shape[0] - 3) // 3\n    labels = generate_state_labels(num_states)\n    for i in range(matrix.shape[0]):\n        for j, symbol in enumerate(alphabet):\n            prob_dict[labels[i], symbol] = matrix[i][j]\n    return prob_dict\n\ndef build_hmm_graph(transition_probs: Dict[Tuple[str, str], float], num_states: int) -&gt; Dict[str, List[Dict[str, float]]]:\n    def add_edge(source: str, target: str) -&gt; None:\n        graph[source].append({\"node\": target, \"weight\": transition_probs[source, target]})\n\n    graph = defaultdict(list)\n    for target in [\"I0\", \"M1\", \"D1\"]:\n        add_edge(\"S\", target)\n    for i in range(num_states):\n        source = f\"I{i}\"\n        for target in [source, f\"M{i+1}\", f\"D{i+1}\"]:\n            add_edge(source, target)\n    for i in range(1, num_states):\n        for source in [f\"M{i}\", f\"D{i}\"]:\n            for target in [f\"M{i+1}\", f\"I{i}\", f\"D{i+1}\"]:\n                add_edge(source, target)\n    for source in [f\"I{num_states}\", f\"M{num_states}\", f\"D{num_states}\"]:\n        for target in [f\"I{num_states}\", \"E\"]:\n            add_edge(source, target)\n\n    return graph\n\ndef generate_topological_order(num_states: int, seq_length: int) -&gt; Iterator[Tuple[str, int]]:\n    yield (\"S\", 0)\n    for j in range(num_states):\n        yield (f\"D{j+1}\", 0)\n    for i in range(seq_length):\n        yield (\"I0\", i + 1)\n        for j in range(num_states):\n            for state_type in [\"M\", \"D\", \"I\"]:\n                yield (f\"{state_type}{j+1}\", i + 1)\n    yield (\"E\", seq_length + 1)\n\ndef get_previous_nodes(current_node: str, current_col: int, num_states: int, seq_length: int) -&gt; List[Tuple[str, int]]:\n    if current_node[0] == \"E\":\n        return [(f\"D{num_states}\", seq_length), (f\"M{num_states}\", seq_length), (f\"I{num_states}\", seq_length)]\n    state_num = int(current_node[1:])\n    if current_col == 0:\n        return [(\"S\", 0)] if state_num == 1 else [(f\"D{state_num-1}\", 0)]\n    elif current_node == \"I0\":\n        return [(\"S\", 0)] if current_col == 1 else [(\"I0\", current_col - 1)]\n    elif current_node == \"M1\":\n        return [(\"S\", 0)] if current_col == 1 else [(\"I0\", current_col - 1)]\n    elif current_node[0] == \"I\":\n        return [(f\"D{state_num}\", 0)] if current_col == 1 else [(f\"D{state_num}\", current_col - 1), (f\"M{state_num}\", current_col - 1), (f\"I{state_num}\", current_col - 1)]\n    elif current_node[0] == \"M\":\n        return [(f\"D{state_num-1}\", 0)] if current_col == 1 else [(f\"D{state_num-1}\", current_col - 1), (f\"M{state_num-1}\", current_col - 1), (f\"I{state_num-1}\", current_col - 1)]\n    elif current_node[0] == \"D\":\n        return [(\"I0\", current_col)] if state_num == 1 else [(f\"D{state_num-1}\", current_col), (f\"M{state_num-1}\", current_col), (f\"I{state_num-1}\", current_col)]\n    else:\n        print(f\"Unhandled node: {current_node}\")\n        return []\n\ndef simplify_graph(graph: Dict[str, List[Dict[str, float]]]) -&gt; Dict[str, Dict[str, float]]:\n    return {k: {x[\"node\"]: x[\"weight\"] for x in v} for k, v in graph.items()}\n\n# Main execution\ndef main(sample_input):\n    input_lines = iter(StringIO(sample_input.strip()).readlines())\n    sequence, threshold, pseudocount, alphabet, alignment = parse_input_data(input_lines)\n    transition_probs, emission_probs = build_profile_hmm_with_pseudocounts(threshold, pseudocount, alphabet, alignment)\n    num_states = (transition_probs.shape[0] - 3) // 3\n    transition_probs_dict = convert_transition_probs_to_dict(transition_probs)\n    emission_probs_dict = convert_emission_probs_to_dict(emission_probs, alphabet)\n\n    graph = build_hmm_graph(transition_probs_dict, num_states)\n    topological_order = generate_topological_order(num_states, len(sequence))\n    simplified_graph = simplify_graph(graph)\n\n    # Dynamic programming to find the most probable path\n    previous_node = next(topological_order)\n    scores = {previous_node: 0}\n    backpointers = {previous_node: (None, None)}\n\n    for current_node, current_col in topological_order:\n        backpointers[(current_node, current_col)] = 0\n        scores[(current_node, current_col)] = -inf\n        for prev_node, prev_col in get_previous_nodes(current_node, current_col, num_states, len(sequence)):\n            if prev_col &lt; current_col and current_node != \"E\":\n                emission_prob = emission_probs_dict[current_node, sequence[current_col - 1]]\n            else:\n                emission_prob = 1\n            log_prob = log(simplified_graph[prev_node][current_node]) + log(emission_prob) + scores[(prev_node, prev_col)]\n            if log_prob &gt; scores[(current_node, current_col)]:\n                scores[(current_node, current_col)] = log_prob\n                backpointers[(current_node, current_col)] = (prev_node, prev_col)\n\n    # Traceback to find the path\n    path = []\n    position = (\"E\", len(sequence) + 1)\n    while position[0]:\n        path.append(backpointers[position][0])\n        position = backpointers[position]\n\n    print(*path[::-1][2:])\n\nsample_input = \"\"\"\nAEFDFDC\n--------\n0.4 0.01\n--------\nA   B   C   D   E   F\n--------\nACDEFACADF\nAFDA---CCF\nA--EFD-FDC\nACAEF--A-C\nADDEFAAADF\n\"\"\"\n\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-111",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-111",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "111.1 Sample Dataset",
    "text": "111.1 Sample Dataset\nyzzzyxzxxx\n--------\nx   y   z\n--------\nBBABABABAB\n--------\nA   B   C"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-111",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-111",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "111.2 Sample Output",
    "text": "111.2 Sample Output\nA   B   C\nA   0.0 1.0 0.0\nB   0.8 0.2 0.0\nC   0.333   0.333   0.333\n--------\n    x   y   z\nA   0.25    0.25    0.5\nB   0.5 0.167   0.333\nC   0.333   0.333   0.333"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-111",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-111",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "111.3 Solution",
    "text": "111.3 Solution\nfrom io import StringIO\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict, Iterator, Union\nimport numpy as np\n\ndef normalize_row(row: np.ndarray, include_zeros: bool = False, minimum_value: float = 0.0) -&gt; np.ndarray:\n    if include_zeros and sum(row) == 0:\n        row[:] = 1\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        normalized = row / sum(row)\n        normalized[row == 0.0] = minimum_value\n        return normalized\n\ndef normalize_matrix(matrix: np.ndarray, include_zeros: bool = False, minimum_value: float = 0.0) -&gt; np.ndarray:\n    return np.array([normalize_row(r, include_zeros=include_zeros, minimum_value=minimum_value) for r in matrix])\n\ndef print_matrix(matrix: np.ndarray, row_labels: List[str], column_labels: List[str]) -&gt; None:\n    print(*column_labels, sep=\"\\t\")\n    for i, row in enumerate(matrix):\n        r = [row_labels[i]] + [round(x, 3) if x &gt; 0.0 else \"0\" for x in row]\n        print(*r, sep=\"\\t\")\n\ndef parse_input(handle: Iterator[str]) -&gt; Tuple[str, List[str], str, List[str]]:\n    sequence = next(handle).rstrip()\n    next(handle)\n    alphabet = next(handle).split()\n    next(handle)\n    path = next(handle).rstrip()\n    next(handle)\n    states = next(handle).split()\n    return sequence, alphabet, path, states\n\ndef convert_to_dict(matrix: np.ndarray, row_labels: List[str], column_labels: List[str]) -&gt; Dict[Tuple[str, str], float]:\n    result = defaultdict(float)\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            result[row_labels[i], column_labels[j]] = matrix[i][j]\n    return result\n\ndef estimate_transition_matrix(path: str, states: List[str], to_dict: bool = False) -&gt; Union[np.ndarray, Dict[Tuple[str, str], float]]:\n    transition_matrix = np.zeros((len(states), len(states)), dtype=float)\n    for current_state, next_state in zip(path, path[1:]):\n        transition_matrix[states.index(current_state)][states.index(next_state)] += 1\n    transition_matrix = normalize_matrix(transition_matrix, include_zeros=True, minimum_value=1e-16)\n    if to_dict:\n        return convert_to_dict(transition_matrix, states, states)\n    else:\n        return transition_matrix\n\ndef estimate_emission_matrix(sequence: str, alphabet: List[str], path: str, states: List[str], to_dict: bool = False) -&gt; Union[np.ndarray, Dict[Tuple[str, str], float]]:\n    emission_matrix = np.zeros((len(states), len(alphabet)), dtype=float)\n    for state, symbol in zip(path, sequence):\n        emission_matrix[states.index(state)][alphabet.index(symbol)] += 1\n    emission_matrix = normalize_matrix(emission_matrix, include_zeros=True, minimum_value=1e-16)\n    if to_dict:\n        return convert_to_dict(emission_matrix, states, alphabet)\n    else:\n        return emission_matrix\n\ndef main(sample_input: str) -&gt; None:\n    input_lines = iter(StringIO(sample_input.strip()).readlines())\n    sequence, alphabet, path, states = parse_input(input_lines)\n    transition_matrix = estimate_transition_matrix(path, states)\n    emission_matrix = estimate_emission_matrix(sequence, alphabet, path, states)\n    print_matrix(transition_matrix, states, states)\n    print(\"--------\")\n    print_matrix(emission_matrix, states, alphabet)\n\nsample_input = \"\"\"\nyzzzyxzxxx\n--------\nx   y   z\n--------\nBBABABABAB\n--------\nA   B   C\n\"\"\"\n\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-112",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-112",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "112.1 Sample Dataset",
    "text": "112.1 Sample Dataset\n100\n--------\nxxxzyzzxxzxyzxzxyxxzyzyzyyyyzzxxxzzxzyzzzxyxzzzxyzzxxxxzzzxyyxzzzzzyzzzxxzzxxxyxyzzyxzxxxyxzyxxyzyxz\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.582   0.418\nB   0.272   0.728\n--------\n    x   y   z\nA   0.129   0.35    0.52\nB   0.422   0.151   0.426"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-112",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-112",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "112.2 Sample Output",
    "text": "112.2 Sample Output\nA   B\nA   0.875   0.125\nB   0.011   0.989\n--------\n    x   y   z\nA   0.0 0.75    0.25\nB   0.402   0.174   0.424"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-112",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-112",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "112.3 Solution",
    "text": "112.3 Solution\nfrom io import StringIO\nfrom typing import List, Dict, Tuple\nimport numpy as np\nfrom math import log\n\ndef viterbi(sequence: str, states: List[str], transition_matrix: Dict[Tuple[str, str], float], emission_matrix: Dict[Tuple[str, str], float]) -&gt; str:\n    mat = np.zeros((len(sequence), len(states)))\n    ptr = np.zeros((len(sequence), len(states)), dtype=int)\n\n    for i, state in enumerate(states):\n        mat[0, i] = log(emission_matrix[state, sequence[0]] / len(states))\n\n    for i, emission in enumerate(sequence[1:], start=1):\n        for j, state in enumerate(states):\n            opt = [\n                log(transition_matrix[prev, state]) + log(emission_matrix[state, emission]) + mat[i - 1, k]\n                for k, prev in enumerate(states)\n            ]\n            p = opt.index(max(opt))\n            ptr[i, j] = p\n            mat[i, j] = max(opt)\n    ind = np.argmax(mat[i, :])\n\n    state_sequence = states[ind]\n    while i &gt; 0:\n        state_sequence = states[ptr[i, ind]] + state_sequence\n        ind = ptr[i, ind]\n        i -= 1\n    return state_sequence\n\ndef print_matrix(matrix: np.ndarray, row_labels: List[str], column_labels: List[str]) -&gt; None:\n    print(*column_labels, sep=\"\\t\")\n    for i, row in enumerate(matrix):\n        r = [row_labels[i]] + [round(x, 3) if x &gt; 0.0 else \"0\" for x in row]\n        print(*r, sep=\"\\t\")\n\ndef normalize_matrix(matrix: np.ndarray, include_zeros: bool = True, min_val: float = 1e-16) -&gt; np.ndarray:\n    normalized = matrix / matrix.sum(axis=1, keepdims=True)\n    if include_zeros:\n        normalized[normalized == 0] = min_val\n    return normalized\n\ndef estimate_transition_matrix(path: str, states: List[str], to_dict: bool = False) -&gt; Dict[Tuple[str, str], float]:\n    tmat = np.zeros((len(states), len(states)), dtype=float)\n    for a, b in zip(path, path[1:]):\n        tmat[states.index(a)][states.index(b)] += 1\n    tmat = normalize_matrix(tmat)\n    if to_dict:\n        return {(states[i], states[j]): tmat[i, j] for i in range(len(states)) for j in range(len(states))}\n    return tmat\n\ndef estimate_emission_matrix(sequence: str, alphabet: List[str], path: str, states: List[str], to_dict: bool = False) -&gt; Dict[Tuple[str, str], float]:\n    emat = np.zeros((len(states), len(alphabet)), dtype=float)\n    for a, b in zip(path, sequence):\n        emat[states.index(a)][alphabet.index(b)] += 1\n    emat = normalize_matrix(emat)\n    if to_dict:\n        return {(states[i], alphabet[j]): emat[i, j] for i in range(len(states)) for j in range(len(alphabet))}\n    return emat\n\ndef print_dict(d: Dict[Tuple[str, str], float], row_labels: List[str], column_labels: List[str]) -&gt; None:\n    mat = np.zeros((len(row_labels), len(column_labels)), dtype=float)\n    for i, r in enumerate(row_labels):\n        for j, c in enumerate(column_labels):\n            mat[i, j] = d[r, c]\n    print_matrix(mat, row_labels, column_labels)\n\ndef parse_input(handle: StringIO) -&gt; Tuple[int, str, List[str], List[str], Dict[Tuple[str, str], float], Dict[Tuple[str, str], float]]:\n    niter = int(next(handle).rstrip())\n    next(handle)\n    sequence = next(handle).rstrip()\n    next(handle)\n    alphabet = next(handle).split()\n    next(handle)\n    states = next(handle).split()\n    next(handle)\n    lines = [next(handle) for _ in range(len(states) + 1)]\n    transition_matrix = {\n        (states[i], states[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    next(handle)\n    lines = [next(handle) for i in range(len(states) + 1)]\n    emission_matrix = {\n        (states[i], alphabet[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    return niter, sequence, states, alphabet, transition_matrix, emission_matrix\n\ndef main(sample_input: str) -&gt; None:\n    input_lines = StringIO(sample_input.strip())\n    niter, sequence, states, alphabet, transition_matrix, emission_matrix = parse_input(input_lines)\n    for _ in range(niter):\n        path = viterbi(sequence, states, transition_matrix, emission_matrix)\n        transition_matrix = estimate_transition_matrix(path, states, to_dict=True)\n        emission_matrix = estimate_emission_matrix(sequence, alphabet, path, states, to_dict=True)\n    print_dict(transition_matrix, states, states)\n    print(\"--------\")\n    print_dict(emission_matrix, states, alphabet)\n\nsample_input = \"\"\"\n100\n--------\nxxxzyzzxxzxyzxzxyxxzyzyzyyyyzzxxxzzxzyzzzxyxzzzxyzzxxxxzzzxyyxzzzzzyzzzxxzzxxxyxyzzyxzxxxyxzyxxyzyxz\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.582   0.418\nB   0.272   0.728\n--------\n    x   y   z\nA   0.129   0.35    0.52\nB   0.422   0.151   0.426\n\"\"\"\n\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-113",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-113",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "113.1 Sample Dataset",
    "text": "113.1 Sample Dataset\nzyxxxxyxzz\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.911   0.089\nB   0.228   0.772\n--------\n    x   y   z\nA   0.356   0.191   0.453 \nB   0.04    0.467   0.493"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-113",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-113",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "113.2 Sample Output",
    "text": "113.2 Sample Output\nA   B \n0.5438  0.4562 \n0.6492  0.3508 \n0.9647  0.0353 \n0.9936  0.0064 \n0.9957  0.0043 \n0.9891  0.0109 \n0.9154  0.0846 \n0.964   0.036 \n0.8737  0.1263 \n0.8167  0.1833"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-113",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-113",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "113.3 Solution",
    "text": "113.3 Solution\nfrom typing import List, Dict, Tuple, Iterator\nfrom io import StringIO\nimport numpy as np\n\ndef parse_input(handle: Iterator[str]) -&gt; Tuple[str, List[str], Dict[Tuple[str, str], float], Dict[Tuple[str, str], float]]:\n    seq: str = next(handle).rstrip()\n    next(handle)\n    alphabet: List[str] = next(handle).split()\n    next(handle)\n    states: List[str] = next(handle).split()\n    next(handle)\n    lines: List[str] = [next(handle) for _ in range(len(states) + 1)]\n    tmat: Dict[Tuple[str, str], float] = {\n        (states[i], states[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    next(handle)\n    lines = [next(handle) for i in range(len(states) + 1)]\n    emat: Dict[Tuple[str, str], float] = {\n        (states[i], alphabet[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    return seq, states, tmat, emat\n\ndef forward(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; np.ndarray:\n    mat: np.ndarray = np.ones((len(seq), len(states)))\n\n    for i, state in enumerate(states):\n        mat[0, i] = emat[state, seq[0]]\n    for i, emission in enumerate(seq[1:], start=1):\n        for j, state in enumerate(states):\n            mat[i, j] = sum(\n                tmat[prev, state] * emat[state, emission] * mat[i - 1, k]\n                for k, prev in enumerate(states)\n            )\n\n    return mat\n\ndef backward(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; np.ndarray:\n    mat: np.ndarray = np.ones((len(seq), len(states)))\n\n    for i, emission in enumerate(seq[::-1][:-1], start=1):\n        for j, state in enumerate(states):\n            mat[len(seq) - i - 1, j] = sum(\n                tmat[state, prev] * emat[prev, emission] * mat[len(seq) - i, k]\n                for k, prev in enumerate(states)\n            )\n    return mat\n\ndef soft_decode(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float], normalise: bool = True) -&gt; np.ndarray:\n    tot: np.ndarray = forward(seq, states, tmat, emat) * backward(seq, states, tmat, emat)\n    if normalise:\n        tot = tot / np.sum(tot, axis=1, keepdims=True)\n    return tot\n\ndef main(sample_input: str) -&gt; None:\n    input_lines: Iterator[str] = StringIO(sample_input.strip())\n    seq, states, tmat, emat = parse_input(input_lines)\n    tot: np.ndarray = soft_decode(seq, states, tmat, emat)\n    print(*states, sep=\"\\t\")\n    for r in np.round(tot, 4):\n        print(*r, sep=\"\\t\")\n\nsample_input: str = \"\"\"\nzyxxxxyxzz\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.911   0.089\nB   0.228   0.772\n--------\n    x   y   z\nA   0.356   0.191   0.453 \nB   0.04    0.467   0.493\n\"\"\"\n\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-114",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-114",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "114.1 Sample Dataset",
    "text": "114.1 Sample Dataset\n10\n--------\nxzyyzyzyxy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.019   0.981 \nB   0.668   0.332 \n--------\nx   y   z\nA   0.175   0.003   0.821 \nB   0.196   0.512   0.293"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-114",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-114",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "114.2 Sample Output",
    "text": "114.2 Sample Output\nA   B\nA   0.000   1.000   \nB   0.786   0.214   \n--------\n    x   y   z\nA   0.242   0.000   0.758   \nB   0.172   0.828   0.000"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-114",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-114",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "114.3 Solution",
    "text": "114.3 Solution\nfrom typing import List, Dict, Tuple, Iterator\nfrom io import StringIO\nimport numpy as np\nfrom collections import defaultdict\n\ndef print_matrix(matrix: np.ndarray, row_labels: List[str], col_labels: List[str]) -&gt; None:\n    print(*col_labels, sep=\"\\t\")\n    for i, row in enumerate(matrix):\n        r = [row_labels[i]] + [round(x, 3) if x &gt; 0.0 else \"0\" for x in row]\n        print(*r, sep=\"\\t\")\n\ndef print_dict(d: Dict[Tuple[str, str], float], row_labels: List[str], col_labels: List[str]) -&gt; None:\n    mat = np.zeros((len(row_labels), len(col_labels)), dtype=float)\n    for i, r in enumerate(row_labels):\n        for j, c in enumerate(col_labels):\n            mat[i, j] = d[r, c]\n    print_matrix(mat, row_labels, col_labels)\n\ndef parse_input(handle: Iterator[str]) -&gt; Tuple[int, str, List[str], List[str], Dict[Tuple[str, str], float], Dict[Tuple[str, str], float]]:\n    niter = int(next(handle).rstrip())\n    next(handle)\n    seq = next(handle).rstrip()\n    next(handle)\n    alphabet = next(handle).split()\n    next(handle)\n    states = next(handle).split()\n    next(handle)\n    lines = [next(handle) for _ in range(len(states) + 1)]\n    tmat = {\n        (states[i], states[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    next(handle)\n    lines = [next(handle) for _ in range(len(states) + 1)]\n    emat = {\n        (states[i], alphabet[j]): float(v)\n        for i, x in enumerate(lines[1:])\n        for j, v in enumerate(x.split()[1:])\n    }\n    return niter, seq, states, alphabet, tmat, emat\n\ndef forward(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; np.ndarray:\n    mat = np.ones((len(seq), len(states)))\n    for i, state in enumerate(states):\n        mat[0, i] = emat[state, seq[0]]\n    for i, emission in enumerate(seq[1:], start=1):\n        for j, state in enumerate(states):\n            mat[i, j] = sum(\n                tmat[prev, state] * emat[state, emission] * mat[i - 1, k]\n                for k, prev in enumerate(states)\n            )\n    return mat\n\ndef backward(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; np.ndarray:\n    mat = np.ones((len(seq), len(states)))\n    for i, emission in enumerate(seq[::-1][:-1], start=1):\n        for j, state in enumerate(states):\n            mat[len(seq) - i - 1, j] = sum(\n                tmat[state, prev] * emat[prev, emission] * mat[len(seq) - i, k]\n                for k, prev in enumerate(states)\n            )\n    return mat\n\ndef soft_decode(seq: str, states: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float], normalise: bool = True) -&gt; np.ndarray:\n    tot = forward(seq, states, tmat, emat) * backward(seq, states, tmat, emat)\n    if normalise:\n        tot = tot / np.sum(tot, axis=1, keepdims=True)\n    return tot\n\ndef as_dict(x: np.ndarray, r: List[str], c: List[str]) -&gt; Dict[Tuple[str, str], float]:\n    g = defaultdict(float)\n    for i in range(x.shape[0]):\n        for j in range(x.shape[1]):\n            g[r[i], c[j]] = x[i][j]\n    return g\n\ndef estimate_pi2(seq: str, fwd: np.ndarray, bak: np.ndarray, tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float], states: List[str]) -&gt; np.ndarray:\n    rep_mat = np.zeros((fwd.shape[0] - 1, len(states), len(states)), dtype=float)\n    for i in range(0, fwd.shape[0] - 1):\n        for j, s1 in enumerate(states):\n            for k, s2 in enumerate(states):\n                weight = tmat[s1, s2] * emat[s2, seq[i + 1]]\n                rep_mat[i, j, k] = (\n                    fwd[i, j] * bak[i + 1, k] * weight / sum(fwd[i, :] * bak[i, :])\n                )\n    return rep_mat\n\ndef estimate_tmat(seq: str, st: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; Dict[Tuple[str, str], float]:\n    fwd = forward(seq, st, tmat, emat)\n    bak = backward(seq, st, tmat, emat)\n    pi2 = estimate_pi2(seq, fwd, bak, tmat, emat, st)\n    tmat_new = np.sum(pi2, 0)\n    tmat_new = tmat_new / np.sum(tmat_new, axis=1, keepdims=True)\n    return as_dict(tmat_new, st, st)\n\ndef estimate_emat(seq: str, al: List[str], st: List[str], tmat: Dict[Tuple[str, str], float], emat: Dict[Tuple[str, str], float]) -&gt; Dict[Tuple[str, str], float]:\n    pi1 = soft_decode(seq, st, tmat, emat)\n    emat_new = np.zeros((len(st), len(al)), dtype=float)\n    for i, emission in enumerate(al):\n        ind = np.array(list(seq)) == emission\n        emat_new[:, i] = np.sum(pi1[ind, :], 0)\n    emat_new = emat_new / np.sum(emat_new, axis=1, keepdims=True)\n    return as_dict(emat_new, st, al)\n\ndef main(sample_input: str) -&gt; None:\n    input_lines = StringIO(sample_input.strip())\n    niter, seq, st, al, tmat, emat = parse_input(input_lines)\n    for _ in range(niter):\n        tmat2 = estimate_tmat(seq, st, tmat, emat)\n        emat2 = estimate_emat(seq, al, st, tmat, emat)\n        emat, tmat = emat2, tmat2\n    print_dict(tmat, st, st)\n    print(\"--------\")\n    print_dict(emat, st, al)\n\nsample_input: str = \"\"\"\n10\n--------\nxzyyzyzyxy\n--------\nx   y   z\n--------\nA   B\n--------\n    A   B\nA   0.019   0.981 \nB   0.668   0.332 \n--------\nx   y   z\nA   0.175   0.003   0.821 \nB   0.196   0.512   0.293\n\"\"\"\n\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-115",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-115",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "115.1 Sample Dataset",
    "text": "115.1 Sample Dataset\n57 71 154 185 301 332 415 429 486"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-115",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-115",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "115.2 Sample Output",
    "text": "115.2 Sample Output\n0-&gt;57:G\n0-&gt;71:A\n57-&gt;154:P\n57-&gt;185:K\n71-&gt;185:N\n154-&gt;301:F\n185-&gt;332:F\n301-&gt;415:N\n301-&gt;429:K\n332-&gt;429:P\n415-&gt;486:A\n429-&gt;486:G"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-115",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-115",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "115.3 Solution",
    "text": "115.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict, DefaultDict\n\n# Amino acid weights dictionary\namino_acid_weights: Dict[str, int] = {\n    'G': 57, 'A': 71, 'S': 87, 'P': 97, 'V': 99,\n    'T': 101, 'C': 103, 'I': 113, 'L': 113, 'N': 114,\n    'D': 115, 'K': 128, 'Q': 128, 'E': 129, 'M': 131,\n    'H': 137, 'F': 147, 'R': 156, 'Y': 163, 'W': 186\n}\n\ndef spectrum_graph(masses: List[int]) -&gt; DefaultDict[int, List[Dict[str, int]]]:\n    # Reverse mapping of weights to amino acids\n    weight_to_amino_acid: Dict[int, str] = {weight: aa for aa, weight in amino_acid_weights.items()}\n    \n    graph: DefaultDict[int, List[Dict[str, int]]] = defaultdict(list)\n    \n    # Create graph based on mass differences\n    for i in range(len(masses)):\n        for j in range(i + 1, len(masses)):\n            difference: int = masses[j] - masses[i]\n            if difference in weight_to_amino_acid:\n                graph[masses[i]].append({\"n\": masses[j], \"l\": weight_to_amino_acid[difference]})\n    \n    return graph\n\n# Sample input\nsample_input: str = \"57 71 154 185 301 332 415 429 486\"\nmasses: List[int] = [0] + list(map(int, sample_input.split()))\n\n# Print the spectrum graph\nfor start_mass, edges in spectrum_graph(masses).items():\n    for edge in edges:\n        print(f\"{start_mass}-&gt;{edge['n']}:{edge['l']}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-116",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-116",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "116.1 Sample Dataset",
    "text": "116.1 Sample Dataset\n57 71 154 185 301 332 415 429 486"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-116",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-116",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "116.2 Sample Output",
    "text": "116.2 Sample Output\nGPFNA"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-116",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-116",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "116.3 Solution",
    "text": "116.3 Solution\nfrom typing import Dict, List, Tuple\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\nmass_to_amino_acid: Dict[int, str] = {v: k for k, v in amino_acid_masses.items()}\n\n\ndef create_spectrum_graph(spectrum: List[int]) -&gt; List[List[int]]:\n    adjacency_list: List[List[int]] = []\n    for i in range(len(spectrum)):\n        for j in range(i, len(spectrum)):\n            if spectrum[j] - spectrum[i] in mass_to_amino_acid.keys():\n                adjacency_list.append([spectrum[i], spectrum[j], mass_to_amino_acid[spectrum[j] - spectrum[i]]])\n    return adjacency_list\n\n\ndef calculate_ideal_spectrum(peptide: str) -&gt; List[int]:\n    prefix_mass: List[int] = [0]\n    for i in range(len(peptide)):\n        temp = prefix_mass[i] + amino_acid_masses[peptide[i]]\n        prefix_mass.append(temp)\n    linear_spectrum: List[int] = [0]\n    for i in range(len(peptide)):\n        for j in range(i + 1, len(peptide) + 1):\n            linear_spectrum.append(prefix_mass[j] - prefix_mass[i])\n    linear_spectrum.sort()\n    return linear_spectrum\n\n\ndef find_paths(adjacency_list: List[List[int]]) -&gt; List[str]:\n    node: int = 0\n    peptide_list: List[str] = []\n    tmp_edges: List[List[List[int]]] = []\n    peptide: str = ''\n    tmp_peps: List[str] = []\n\n    while any([len(x) != 0 for x in tmp_edges]) or len(tmp_edges) == 0:\n        next_edges: List[List[int]] = [e for e in adjacency_list if e[0] == node]\n        if len(next_edges) &gt; 1:\n            tmp = next_edges[1:]\n            tmp_edges.append(tmp)\n            tmp_peps.append(peptide)\n\n        next_edge = next_edges[0]\n        peptide += next_edge[2]\n        node = next_edge[1]\n\n        if len([e for e in adjacency_list if e[0] == node]) == 0:\n            tmp = [x for x in tmp_edges if len(x) != 0][-1]\n            next_edge = tmp.pop()\n            node = next_edge[1]\n            peptide_list.append(peptide)\n            tmp_pep = tmp_peps.pop()\n            peptide = tmp_pep + next_edge[2]\n\n    return peptide_list\n\n\ndef decode_ideal_spectrum(spectrum: List[int]) -&gt; str:\n    adjacency_list = create_spectrum_graph(spectrum)\n    all_paths = find_paths(adjacency_list)\n    for peptide in all_paths:\n        if set(spectrum).issubset(calculate_ideal_spectrum(peptide)):\n            return peptide\n\n\nsample_input: str = \"\"\"\n57 71 154 185 301 332 415 429 486\n\"\"\"\n\nspectrum: List[int] = [int(s) for s in sample_input.strip().split()]\nspectrum = [0] + spectrum\n\nprint(decode_ideal_spectrum(spectrum))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-117",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-117",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "117.1 Sample Dataset",
    "text": "117.1 Sample Dataset\nXZZXX"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-117",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-117",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "117.2 Sample Output",
    "text": "117.2 Sample Output\n0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-117",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-117",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "117.3 Solution",
    "text": "117.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131, 'L': 113,\n    'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163, 'X': 4, 'Z': 5\n}\n\n\ndef create_peptide_vector(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = []\n    for i in range(len(peptide)):\n        prefix = peptide[:i+1]\n        mass = sum(amino_acid_masses[aa] for aa in prefix)\n        prefix_masses.append(mass)\n\n    vector: List[int] = [0] * prefix_masses[-1]\n    for mass in prefix_masses:\n        vector[mass - 1] = 1\n    return vector\n\n\nsample_input: str = \"\"\"\nXZZXX\n\"\"\"\npeptide: str = sample_input.strip()\nprint(' '.join(str(x) for x in create_peptide_vector(peptide)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-118",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-118",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "118.1 Sample Dataset",
    "text": "118.1 Sample Dataset\n0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-118",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-118",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "118.2 Sample Output",
    "text": "118.2 Sample Output\nXZZXX"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-118",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-118",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "118.3 Solution",
    "text": "118.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\nmass_to_amino_acid: Dict[int, str] = {v: k for k, v in amino_acid_masses.items()}\nmass_to_amino_acid[4] = 'X'\nmass_to_amino_acid[5] = 'Z'\n\n\ndef convert_peptide_vector_to_sequence(vector: List[int]) -&gt; str:\n    prefix_masses: List[int] = [i + 1 for i, v in enumerate(vector) if v == 1]\n\n    peptide: str = mass_to_amino_acid[prefix_masses[0]]\n    for i in range(1, len(prefix_masses)):\n        mass = prefix_masses[i] - prefix_masses[i - 1]\n        peptide += mass_to_amino_acid[mass]\n\n    return peptide\n\n\nsample_input: str = \"\"\"\n0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 1\n\"\"\"\nvector: List[int] = [int(x) for x in sample_input.strip().split()]\n\nprint(convert_peptide_vector_to_sequence(vector))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-119",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-119",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "119.1 Sample Dataset",
    "text": "119.1 Sample Dataset\n0 0 0 4 -2 -3 -1 -7 6 5 3 2 1 9 3 -8 0 3 1 2 1 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-119",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-119",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "119.2 Sample Output",
    "text": "119.2 Sample Output\nXZZXX"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-119",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-119",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "119.3 Solution",
    "text": "119.3 Solution\nfrom typing import Dict, List, Tuple\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\nmass_to_amino_acid: Dict[int, str] = {v: k for k, v in amino_acid_masses.items()}\n\n\ndef sequence_peptide(spectral_vector: List[int]) -&gt; str:\n    spectral_vector = [0] + spectral_vector\n\n    adjacency_list: List[List[int]] = []\n    for i in range(len(spectral_vector)):\n        for j in range(i, len(spectral_vector)):\n            if (j - i) in mass_to_amino_acid.keys():\n                adjacency_list.append([i, j])\n\n    adjacency_dict: Dict[int, List[List[Union[int, str]]]] = {}\n    for i in range(len(spectral_vector)):\n        for j in range(i, len(spectral_vector)):\n            if (j - i) in mass_to_amino_acid.keys():\n                edge = [i, mass_to_amino_acid[j - i]]\n                if j not in adjacency_dict:\n                    adjacency_dict[j] = [edge]\n                else:\n                    adjacency_dict[j].append(edge)\n\n    scores: Dict[int, List[Union[float, str]]] = {0: [0, '-']}\n    for node in adjacency_dict.keys():\n        scores[node] = [-float('inf'), '-']\n        edges = adjacency_dict[node]\n        for edge in edges:\n            if edge[0] != 0:\n                scores[edge[0]] = [-float('inf'), '-']\n\n    for node in adjacency_dict.keys():\n        max_score: float = -float('inf')\n        best_edge: Union[str, List[Union[int, str]]] = '-'\n        for parent in adjacency_dict[node]:\n            score = scores[parent[0]][0]\n            if score &gt; max_score:\n                max_score = score\n                best_edge = parent\n        scores[node] = [max_score + spectral_vector[node], best_edge]\n\n    node: int = list(scores.keys())[-1]\n    peptide: str = ''\n    while node != 0:\n        peptide = scores[node][1][1] + peptide\n        node = scores[node][1][0]\n\n    return peptide\n\n\nsample_input: str = \"\"\"\n0 0 0 4 -2 -3 -1 -7 6 5 3 2 1 9 3 -8 0 3 1 2 1 0\n\"\"\"\n\nspectral_vector: List[int] = [int(x) for x in sample_input.split()]\n\nprint(sequence_peptide(spectral_vector))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-120",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-120",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "120.1 Sample Dataset",
    "text": "120.1 Sample Dataset\n0 0 0 4 -2 -3 -1 -7 6 5 3 2 1 9 3 -8 0 3 1 2 1 8\nXZZXZXXXZXZZXZXXZ"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-120",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-120",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "120.2 Sample Output",
    "text": "120.2 Sample Output\nZXZXX"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-120",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-120",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "120.3 Solution",
    "text": "120.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163,\n    'X': 4, 'Z': 5  # Added 'X' and 'Z' with arbitrary masses\n}\n\ndef create_peptide_vector(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = [0]\n    for amino_acid in peptide:\n        prefix_masses.append(prefix_masses[-1] + amino_acid_masses[amino_acid])\n    vector: List[int] = [0] * prefix_masses[-1]\n    for mass in prefix_masses[1:]:\n        vector[mass - 1] = 1\n    return vector\n\ndef identify_peptide(spectral_vector: List[int], proteome: str) -&gt; str:\n    max_score: float = float('-inf')\n    best_peptide: str = \"\"\n\n    for i in range(len(proteome)):\n        for j in range(i + 1, len(proteome) + 1):\n            peptide: str = proteome[i:j]\n            peptide_vector: List[int] = create_peptide_vector(peptide)\n            \n            if len(peptide_vector) &gt; len(spectral_vector):\n                break\n            \n            if len(peptide_vector) == len(spectral_vector):\n                score: float = sum(s * v for s, v in zip(spectral_vector, peptide_vector))\n                if score &gt; max_score:\n                    max_score = score\n                    best_peptide = peptide\n\n    return best_peptide\n\nsample_input: str = \"\"\"\n0 0 0 4 -2 -3 -1 -7 6 5 3 2 1 9 3 -8 0 3 1 2 1 8\nXZZXZXXXZXZZXZXXZ\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nspectral_vector: List[int] = [int(x) for x in input_lines[0].strip().split()]\nproteome: str = input_lines[1].strip()\nprint(identify_peptide(spectral_vector, proteome))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-121",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-121",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "121.1 Sample Dataset",
    "text": "121.1 Sample Dataset\n-1 5 -4 5 3 -1 -4 5 -1 0 0 4 -1 0 1 4 4 4\n-4 2 -2 -4 4 -5 -1 4 -1 2 5 -3 -1 3 2 -3\nXXXZXZXXZXZXXXZXXZX\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-121",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-121",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "121.2 Sample Output",
    "text": "121.2 Sample Output\nXZXZ"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-121",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-121",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "121.3 Solution",
    "text": "121.3 Solution\nfrom typing import Dict, List, Set, Tuple\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163,\n    'X': 4, 'Z': 5  # Added 'X' and 'Z' with arbitrary masses\n}\n\ndef is_number(n: str) -&gt; bool:\n    try:\n        float(n)\n    except ValueError:\n        return False\n    return True\n\ndef create_peptide_vector(peptide: str) -&gt; List[int]:\n    prefix_masses: List[int] = [0]\n    for amino_acid in peptide:\n        prefix_masses.append(prefix_masses[-1] + amino_acid_masses[amino_acid])\n    vector: List[int] = [0] * prefix_masses[-1]\n    for mass in prefix_masses[1:]:\n        vector[mass - 1] = 1\n    return vector\n\ndef identify_peptide(spectral_vector: List[int], proteome: str) -&gt; Tuple[str, float]:\n    max_score: float = float('-inf')\n    best_peptide: str = ''\n\n    for i in range(len(proteome)):\n        for j in range(i + 1, len(proteome) + 1):\n            peptide: str = proteome[i:j]\n            peptide_vector: List[int] = create_peptide_vector(peptide)\n            \n            if len(peptide_vector) &gt; len(spectral_vector):\n                break\n            \n            if len(peptide_vector) == len(spectral_vector):\n                score: float = sum(s * v for s, v in zip(spectral_vector, peptide_vector))\n                if score &gt; max_score:\n                    max_score = score\n                    best_peptide = peptide\n\n    return best_peptide, max_score\n\ndef search_peptide_spectrum_matches(spectral_vectors: List[List[int]], proteome: str, threshold: float) -&gt; Set[str]:\n    psm_set: Set[str] = set()\n    for vector in spectral_vectors:\n        peptide, score = identify_peptide(vector, proteome)\n        if score &gt;= threshold:\n            psm_set.add(peptide)\n    return psm_set\n\nsample_input: str = \"\"\"\n-1 5 -4 5 3 -1 -4 5 -1 0 0 4 -1 0 1 4 4 4\n-4 2 -2 -4 4 -5 -1 4 -1 2 5 -3 -1 3 2 -3\nXXXZXZXXZXZXXXZXXZX\n5\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\n\nspectral_vectors: List[List[int]] = []\nidx: int = 0\nwhile idx &lt; len(input_lines) and (is_number(input_lines[idx][0]) or is_number(input_lines[idx][:2])):\n    vector: List[int] = [int(x) for x in input_lines[idx].strip().split()]\n    spectral_vectors.append(vector)\n    idx += 1\n\nproteome: str = input_lines[idx].strip()\nthreshold: int = int(input_lines[idx + 1])\n\nresult: Set[str] = search_peptide_spectrum_matches(spectral_vectors, proteome, threshold)\n\nfor peptide in result:\n    print(peptide)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-122",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-122",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "122.1 Sample Dataset",
    "text": "122.1 Sample Dataset\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n1\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-122",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-122",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "122.2 Sample Output",
    "text": "122.2 Sample Output\n0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-122",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-122",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "122.3 Solution",
    "text": "122.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\nmass_values: List[int] = list(amino_acid_masses.values())\n\ndef calculate_spectral_dictionary_size(spectral_vector: List[int], threshold: int, max_score: int) -&gt; int:\n    vector_length: int = len(spectral_vector)\n\n    size_matrix: Dict[int, Dict[int, int]] = {0: {0: 1}}\n    for t in range(1, max_score + 1):\n        size_matrix[0][t] = 0\n\n    for i in range(1, vector_length + 1):\n        size_matrix[i] = {}\n        for t in range(max_score + 1):\n            size_matrix[i][t] = 0\n            for mass in mass_values:\n                if (i - mass) &gt;= 0 and (t - spectral_vector[i - 1]) &gt;= 0 and (t - spectral_vector[i - 1]) &lt;= max_score:\n                    size_matrix[i][t] += size_matrix[i - mass][t - spectral_vector[i - 1]]\n\n    final_size: int = sum(size_matrix[vector_length][t] for t in range(threshold, max_score + 1))\n\n    return final_size\n\nsample_input: str = \"\"\"\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n1\n8\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nspectral_vector: List[int] = [int(x) for x in input_lines[0].strip().split()]\nthreshold: int = int(input_lines[1])\nmax_score: int = int(input_lines[2])\n\nprint(calculate_spectral_dictionary_size(spectral_vector, threshold, max_score))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-123",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-123",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "123.1 Sample Dataset",
    "text": "123.1 Sample Dataset\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n1\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-123",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-123",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "123.2 Sample Output",
    "text": "123.2 Sample Output\n0"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-123",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-123",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "123.3 Solution",
    "text": "123.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163\n}\nmass_values: List[int] = list(amino_acid_masses.values())\n\ndef calculate_spectral_dictionary_probability(spectral_vector: List[int], threshold: int, max_score: int) -&gt; float:\n    vector_length: int = len(spectral_vector)\n\n    probability_matrix: Dict[int, Dict[int, float]] = {0: {0: 1.0}}\n    for t in range(1, max_score + 1):\n        probability_matrix[0][t] = 0.0\n\n    for i in range(1, vector_length + 1):\n        probability_matrix[i] = {}\n        for t in range(max_score + 1):\n            probability_matrix[i][t] = 0.0\n            for mass in mass_values:\n                if (i - mass) &gt;= 0 and (t - spectral_vector[i - 1]) &gt;= 0 and (t - spectral_vector[i - 1]) &lt;= max_score:\n                    probability_matrix[i][t] += probability_matrix[i - mass][t - spectral_vector[i - 1]]\n            probability_matrix[i][t] /= 20\n\n    final_probability: float = sum(probability_matrix[vector_length][t] for t in range(threshold, max_score + 1))\n\n    return final_probability\n\nsample_input: str = \"\"\"\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n1\n8\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\nspectral_vector: List[int] = [int(x) for x in input_lines[0].strip().split()]\nthreshold: int = int(input_lines[1])\nmax_score: int = int(input_lines[2])\n\nprint(calculate_spectral_dictionary_probability(spectral_vector, threshold, max_score))"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-124",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-dataset-124",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "124.1 Sample Dataset",
    "text": "124.1 Sample Dataset\nXXZ\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#sample-output-124",
    "href": "posts/qmd/Rosalind_textbookTrack.html#sample-output-124",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "124.2 Sample Output",
    "text": "124.2 Sample Output\nXX(-1)Z(+2)"
  },
  {
    "objectID": "posts/qmd/Rosalind_textbookTrack.html#solution-124",
    "href": "posts/qmd/Rosalind_textbookTrack.html#solution-124",
    "title": "Rosalind Textbook track 문제풀이",
    "section": "124.3 Solution",
    "text": "124.3 Solution\nfrom typing import Dict, List\n\namino_acid_masses: Dict[str, int] = {\n    'A': 71, 'C': 103, 'E': 129, 'D': 115, 'G': 57, 'F': 147, 'I': 113, 'H': 137, 'K': 128, 'M': 131,\n    'L': 113, 'N': 114, 'Q': 128, 'P': 97, 'S': 87, 'R': 156, 'T': 101, 'W': 186, 'V': 99, 'Y': 163,\n    'X': 4, 'Z': 5  # Added 'X' and 'Z' with arbitrary masses\n}\n\ndef print_score_matrix(score_matrix: Dict[int, Dict[int, Dict[int, float]]], prefix_masses: List[int], spectral_vector: List[int], max_k: int) -&gt; None:\n    for t in range(-2, max_k + 1):\n        if t == -2:\n            formatted_vector = [str(x).rjust(3) for x in spectral_vector]\n            print('   ', *formatted_vector)\n            print(' ')\n            print(' ')\n        elif t == -1:\n            header = [str(i).rjust(3) for i in range(len(spectral_vector))]\n            print('   ', *header)\n        else:\n            for mass in prefix_masses:\n                row = []\n                for j in range(-1, len(spectral_vector)):\n                    if j == -1:\n                        row.append(f\"{mass:&gt;3} \")\n                    else:\n                        score = score_matrix[mass][j][t]\n                        if score &lt; -1e5:\n                            score = 'XX'\n                        row.append(f\"{score:&gt;3}\")\n                print(' '.join(row))\n            print(' ')\n    return None\n\ndef spectral_alignment(peptide: str, spectral_vector: List[int], max_k: int) -&gt; str:\n    spectral_vector.insert(0, 0)\n\n    # Calculate prefix masses\n    prefix_masses = [0]\n    for i in range(len(peptide)):\n        prefix = peptide[:i + 1]\n        mass = sum(amino_acid_masses[aa] for aa in prefix)\n        prefix_masses.append(mass)\n\n    # Create diff array\n    mass_differences = {}\n    for i in range(1, len(prefix_masses)):\n        mass_differences[prefix_masses[i]] = prefix_masses[i] - prefix_masses[i - 1]\n\n    # Initialize scores\n    score_matrix: Dict[int, Dict[int, Dict[int, float]]] = {}\n    for mass in prefix_masses:\n        score_matrix[mass] = {}\n        for j in range(len(spectral_vector)):\n            score_matrix[mass][j] = {t: -float(\"inf\") for t in range(max_k + 1)}\n    score_matrix[0][0][0] = 0\n\n    # Calculate scores\n    for mass in prefix_masses[1:]:\n        for j in range(len(spectral_vector)):\n            for t in range(max_k + 1):\n                if (t == 0) and (mass - mass_differences[mass] &gt;= 0) and (j - mass_differences[mass] &gt;= 0):\n                    score_matrix[mass][j][t] = spectral_vector[j] + score_matrix[mass - mass_differences[mass]][j - mass_differences[mass]][t]\n                elif (t &gt; 0) and (mass - mass_differences[mass] &gt;= 0) and (j - mass_differences[mass] &gt;= 0):\n                    score_matrix[mass][j][t] = spectral_vector[j] + max(score_matrix[mass - mass_differences[mass]][j - mass_differences[mass]][t], \n                                                                         max(score_matrix[mass - mass_differences[mass]][j_star][t - 1] for j_star in range(j)))\n                elif (t &gt; 0) and (mass - mass_differences[mass] &gt;= 0) and (j &gt; 0):\n                    score_matrix[mass][j][t] = spectral_vector[j] + max(score_matrix[mass - mass_differences[mass]][j_star][t - 1] for j_star in range(j))\n\n    # Find max score layer\n    max_score = -float(\"inf\")\n    max_layer = 0\n    for t in range(max_k + 1):\n        current_score = score_matrix[prefix_masses[-1]][len(spectral_vector) - 1][t]\n        if current_score &gt; max_score:\n            max_score = current_score\n            max_layer = t\n\n    # Backtrace\n    layer = max_layer\n    column_index = len(spectral_vector) - 1\n\n    result_peptide = ''\n    for i in range(len(peptide), 0, -1):\n        pre_mass = prefix_masses[i]\n        if (column_index - mass_differences[pre_mass] &gt;= 0) and (\n                score_matrix[pre_mass][column_index][layer] == spectral_vector[column_index] + score_matrix[pre_mass - mass_differences[pre_mass]][column_index - mass_differences[pre_mass]][layer]):\n            column_index -= mass_differences[pre_mass]\n            result_peptide = peptide[i - 1] + result_peptide\n        else:\n            temp_scores = [score_matrix[pre_mass - mass_differences[pre_mass]][j_star][layer - 1] for j_star in range(column_index)]\n            idx_max_score = temp_scores.index(max(temp_scores))\n            modification_amount = column_index - idx_max_score - mass_differences[pre_mass]\n            if modification_amount &gt; 0:\n                result_peptide = peptide[i - 1] + '(+' + str(modification_amount) + ')' + result_peptide\n            else:\n                result_peptide = peptide[i - 1] + '(' + str(modification_amount) + ')' + result_peptide\n            column_index = idx_max_score\n            layer -= 1\n\n    return result_peptide\n\nsample_input: str = \"\"\"\nXXZ\n4 -3 -2 3 3 -4 5 -3 -1 -1 3 4 1 3\n2\n\"\"\"\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\npeptide_sequence: str = input_lines[0]\nspectral_vector_values: List[int] = [int(x) for x in input_lines[1].strip().split()]\nmax_k_value: int = int(input_lines[2])\n\nprint(spectral_alignment(peptide_sequence, spectral_vector_values, max_k_value))"
  },
  {
    "objectID": "posts/qmd/guide_DS_works.html#데이터-검사하기",
    "href": "posts/qmd/guide_DS_works.html#데이터-검사하기",
    "title": "어떻게 데이터 과학은 작동하는가?",
    "section": "5.1 데이터 검사하기",
    "text": "5.1 데이터 검사하기\n다음 단계는 데이터를 깊게 살펴보는 것입니다. 여기에는 두 가지 목적이 있습니다. 첫 번째는 잘못된 데이터를 발견하여 수정하거나 제거하는 것입니다. 다른 하나는 각 행과 열에 익숙해지는 것입니다. 이 단계를 건너뛰고 데이터를 최대한 활용 할 수는 없습니다.\n데이터의 한 열만 살펴보세요. 무엇에 레이블이 붙어 있나요? 값이 레이블에 맞는가요? 그 레이블이 여러분에게 어떤 의미가 있나요? 열의 의미에 대한 문서가 있나요? 어떻게 측정되었는지에 대한 문서가 있나요? 스스로에게 물어보세요.\n각각의 열에 대한 히스토그램을 그려보고 분포가 기능에 대해 알고 있는 것과 일치하는지도 확인 해보세요. 혹시 비정상적인 수치가 있나요? 그런 이상값이 의미가 있나요? 어떤 식으로든 조금이라도 이상해 보인다면 그 이유를 찾아보세요."
  },
  {
    "objectID": "posts/qmd/guide_DS_works.html#데이터-수정하기",
    "href": "posts/qmd/guide_DS_works.html#데이터-수정하기",
    "title": "어떻게 데이터 과학은 작동하는가?",
    "section": "5.2 데이터 수정하기",
    "text": "5.2 데이터 수정하기\n각각의 열을 살펴보면서 혹시 이름과 설명이 오해의 소지가 있거나 잘못된 것을 발견할 수도 있습니다. 혹은 일부 값이 잘못되었다는 사실을 발견할 수도 있습니다. 이 경우 세 가지 선택지가 있습니다. 첫 번째, 수정이 분명해 보이는 경우 값을 수정한다 (예: 키 72 미터를 72 인치로 변환). 두 번째, 수정이 분명하지 않은 경우 값을 삭제하고 누락된 상태로 둘 수 있습니다. 세 번째, 값이 중요한 정보인 경우 전체 행 또는 열을 제거할 수 있습니다. 이렇게 하면 잘못된 데이터로 모델을 학습시키는 것을 방지할 수 있습니다. 잘못된 데이터는 누락된 데이터보다 훨씬 더 큰 피해를 줍니다.\n가끔 바람직하지 않은 값이나 행을 제거하고 싶은 유혹이 있을 수 있습니다. 이러한 데이터는 여러분이 선호하는 이론을 뒷받침하지 않을 수 있습니다. 그러나 이렇게 하지는 마세요. 이것은 비윤리적이며 더 나쁜 것은 잘못된 답을 얻을 수 있다는 것입니다."
  },
  {
    "objectID": "posts/qmd/guide_DS_works.html#결측치-다루기",
    "href": "posts/qmd/guide_DS_works.html#결측치-다루기",
    "title": "어떻게 데이터 과학은 작동하는가?",
    "section": "5.3 결측치 다루기",
    "text": "5.3 결측치 다루기\n거의 모든 데이터 집합에는 누락된 값이 있습니다. 이것은 때로 잘못된 것으로 판명되어 삭제된 것이기도 하고 보통 서로 다른 소스에서 가져온 데이터를 합치는 경우에 생겨다는 경우가 있습니다. 어쨌거나 머신러닝에 사용하기 위해서는 결측치를 수정해야 합니다. 결측치를 수정하는 방법에는 여러 가지가 있습니다. 먼저 샘플을 보고 싶으시다면 Azure에서 결측치 다루기 를 확인하세요. 결론적으로 결측치를 수정하는 최선의 방법은 데이터 마다 다르다는 것입니다."
  },
  {
    "objectID": "posts/qmd/guide_DS_works.html#footnotes",
    "href": "posts/qmd/guide_DS_works.html#footnotes",
    "title": "어떻게 데이터 과학은 작동하는가?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA Pocket Guide to Data science (e2eml.school)↩︎\n유튜브 영상↩︎"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "",
    "text": "Dasgupta, Papadimitriou, Vazirani 의 책 “알고리즘” 에 포함된 연습문제의 모음입니다.\nRosalind 는 프로젝트 오일러, 구글 코드 잼 에서 영감을 얻었습니다. 이 프로젝트의 이름은 DNA 이중나선을 발견하는 데 기여한 로잘린드 프랭클린 에서 따왔습니다. Rosalind 는 프로그래밍 실력을 키우고자 하는 생물학자와 분자생물학의 계산 문제를 접해본 적이 없는 프로그래머들에게 도움이 될 것입니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#problem",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#problem",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "1.1 Problem",
    "text": "1.1 Problem\nThe Fibonacci numbers \\(0,1,1,2,3,5,8,13,21,34,…\\) are generated by the simple rule.\nGiven: A positive integer \\(n≤25\\).\nReturn: The value of Fn.\nSource: Algorithms by Dasgupta, Papadimitriou, Vazirani. McGraw-Hill. 2006."
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "1.2 Sample Dataset",
    "text": "1.2 Sample Dataset\n6"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "1.3 Sample Output",
    "text": "1.3 Sample Output\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "1.4 Solution",
    "text": "1.4 Solution\ndef fibonacci(n: int) -&gt; int:\n    fib: list[int] = [0] * (n + 1)\n    fib[1] = 1\n    \n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    \n    return fib[n]\n\nn: int = 6\nprint(f\"피보나치 수열의 {n}번째 항: {fibonacci(n)}\")\n아주 큰수의 피보나치 수열을 계산하는 경우에는 다음 코드.\nimport gmpy2\nfrom gmpy2 import mpz\n\ndef fibonacci_gmpy2(n: int) -&gt; mpz:\n    a: mpz = gmpy2.mpz(0)\n    b: mpz = gmpy2.mpz(1)\n    \n    for _ in range(n):\n        a, b = b, a + b\n    \n    return a\n\n# 예제 사용\nn: int = 60000\nresult: mpz = fibonacci_gmpy2(n)\n\nprint(f\"피보나치 수열의 {n}번째 항:\")\nprint(result)\nprint(f\"자릿수: {len(str(result))}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-1",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-1",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "2.1 Sample Dataset",
    "text": "2.1 Sample Dataset\n5\n6\n10 20 30 40 50\n40 10 35 15 40 20"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-1",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-1",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "2.2 Sample Output",
    "text": "2.2 Sample Output\n4 1 -1 -1 4 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-1",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-1",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "2.3 Solution",
    "text": "2.3 Solution\nfrom typing import List, Tuple\n\ndef binary_search(arr: List[int], target: int) -&gt; int:\n    low, high = 0, len(arr) - 1\n    \n    while low &lt;= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid + 1  # Adding 1 to convert from 0-based to 1-based indexing\n        elif arr[mid] &lt; target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1  # Target not found\n\ndef parse_input(input_str: str) -&gt; Tuple[int, int, List[int], List[int]]:\n    lines = input_str.strip().split(\"\\n\")\n    n = int(lines[0])\n    m = int(lines[1])\n    array = list(map(int, lines[2].split()))\n    items = list(map(int, lines[3].split()))\n    \n    return n, m, array, items\n\nsample_input = \"\"\"\n5\n6\n10 20 30 40 50\n40 10 35 15 40 20\n\"\"\"\n\nn, m, array, items = parse_input(sample_input)\n\nresults: List[str] = [str(binary_search(array, item)) for item in items]\nprint(' '.join(results))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-2",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-2",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "3.1 Sample Dataset",
    "text": "3.1 Sample Dataset\n6\n6 10 4 5 1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-2",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-2",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "3.2 Sample Output",
    "text": "3.2 Sample Output\n12"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-2",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-2",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "3.3 Solution",
    "text": "3.3 Solution\nfrom typing import List\n\ndef parse_input(input_str: str) -&gt; List[int]:\n    lines = input_str.strip().split(\"\\n\")\n    n = int(lines[0])  # Get the number of elements\n    array = list(map(int, lines[1].split()))\n    return array\n\ndef insertion_sort(array: List[int]) -&gt; int:\n    swaps = 0\n    for i in range(1, len(array)):\n        key = array[i]\n        j = i - 1\n        while j &gt;= 0 and array[j] &gt; key:\n            array[j + 1] = array[j]\n            swaps += 1\n            j -= 1\n        array[j + 1] = key\n    return swaps\n\n# Sample input\nsample_input = \"\"\"\n6\n6 10 4 5 1 2\n\"\"\"\n\narray: List[int] = parse_input(sample_input)\nswap_count: int = insertion_sort(array)\nprint(f\"{swap_count}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-3",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-3",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "4.1 Sample Dataset",
    "text": "4.1 Sample Dataset\n6 7\n1 2\n2 3\n6 3\n5 6\n2 5\n2 4\n4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-3",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-3",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "4.2 Sample Output",
    "text": "4.2 Sample Output\n2 4 2 2 2 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-3",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-3",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "4.3 Solution",
    "text": "4.3 Solution\nfrom typing import List, Tuple\n\ndef parse_input(input_str: str) -&gt; Tuple[int, List[int]]:\n    lines = input_str.strip().split(\"\\n\")\n    nodes, edges = map(int, lines[0].split())\n    edge_list: List[int] = []\n    for line in lines[1:]:\n        edge_list.extend(map(int, line.split()))\n    return nodes, edge_list\n\ndef calculate_degrees(nodes: int, edge_list: List[int]) -&gt; List[int]:\n    degrees: List[int] = [0] * nodes\n    for node in edge_list:\n        degrees[node - 1] += 1\n    return degrees\n\n# Sample input\nsample_input = \"\"\"\n6 7\n1 2\n2 3\n6 3\n5 6\n2 5\n2 4\n4 1\n\"\"\"\n\nnodes: int\nedge_list: List[int]\nnodes, edge_list = parse_input(sample_input)\ndegrees: List[int] = calculate_degrees(nodes, edge_list)\nprint(\" \".join(map(str, degrees)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-4",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-4",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "5.1 Sample Dataset",
    "text": "5.1 Sample Dataset\n5 4\n1 2\n2 3\n4 3\n2 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-4",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-4",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "5.2 Sample Output",
    "text": "5.2 Sample Output\n3 5 5 5 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-4",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-4",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "5.3 Solution",
    "text": "5.3 Solution\nfrom typing import List, Tuple, Dict\n\ndef parse_input(input_str: str) -&gt; Tuple[int, List[List[int]]]:\n    lines = input_str.strip().split(\"\\n\")\n    nodes, edges = map(int, lines[0].split())\n    edge_list: List[List[int]] = []\n    for line in lines[1:]:\n        edge_list.append(list(map(int, line.split())))\n    return nodes, edge_list\n\nsample_input = \"\"\"\n5 4\n1 2\n2 3\n4 3\n2 4\n\"\"\"\n\nnodes: int\nedges_list: List[List[int]]\nnodes, edges_list = parse_input(sample_input)\n\n# Create an adjacency list\nnodes_neighbours: Dict[str, List[str]] = {str(i+1): [] for i in range(nodes)}\nfor edge in edges_list:\n    nodes_neighbours[str(edge[0])].append(str(edge[1]))\n    nodes_neighbours[str(edge[1])].append(str(edge[0]))\n\n# Calculate and print the sum of neighbors' degrees\nfor i in range(1, nodes + 1):\n    sum_of_neighbors_degrees: int = sum(len(nodes_neighbours[str(neighbor)]) for neighbor in nodes_neighbours[str(i)])\n    print(sum_of_neighbors_degrees, end=\" \")"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-5",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-5",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "6.1 Sample Dataset",
    "text": "6.1 Sample Dataset\n4 8\n5 5 5 5 5 5 5 5\n8 7 7 7 1 7 3 7\n7 1 6 5 10 100 1000 1\n5 1 6 7 1 1 10 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-5",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-5",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "6.2 Sample Output",
    "text": "6.2 Sample Output\n5 7 -1 -1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-5",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-5",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "6.3 Solution",
    "text": "6.3 Solution\nfrom typing import List\n\ndef string_to_int_list(string: str) -&gt; List[int]:\n    return list(map(int, string.split()))\n\ndef find_possible_majority(numbers: List[int]) -&gt; int:\n    leader_index = 0\n    leader_count = 1\n    for i in range(len(numbers)):\n        if numbers[leader_index] == numbers[i]:\n            leader_count += 1\n        else:\n            leader_count -= 1\n        if leader_count == 0:\n            leader_index = i\n            leader_count = 1\n    return numbers[leader_index]\n\ndef is_majority(numbers: List[int], candidate: int) -&gt; bool:\n    count = sum(1 for num in numbers if num == candidate)\n    return count &gt; len(numbers) / 2\n\n# Using Moore's voting algorithm\ndef find_majority(numbers: List[int]) -&gt; int:\n    candidate = find_possible_majority(numbers)\n    return candidate if is_majority(numbers, candidate) else -1\n\nsample_input = \"\"\"\n4 8\n5 5 5 5 5 5 5 5\n8 7 7 7 1 7 3 7\n7 1 6 5 10 100 1000 1\n5 1 6 7 1 1 10 1\n\"\"\"\n\n_, *number_lists = sample_input.strip().split(\"\\n\")\nnumber_lists: List[List[int]] = [string_to_int_list(line) for line in number_lists]\nprint(*[find_majority(numbers) for numbers in number_lists])"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-6",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-6",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "7.1 Sample Dataset",
    "text": "7.1 Sample Dataset\n4\n2 4 10 18\n3\n-5 11 12"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-6",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-6",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "7.2 Sample Output",
    "text": "7.2 Sample Output\n-5 2 4 10 11 12 18"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-6",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-6",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "7.3 Solution",
    "text": "7.3 Solution\nfrom typing import List\n\ndef parse_ints(x: str) -&gt; List[int]:\n    return [int(num) for num in x.split()]\n\ndef merge_sorted_lists(list1: List[int], list2: List[int]) -&gt; List[int]:\n    merged = []\n    i, j = 0, 0\n    \n    while i &lt; len(list1) and j &lt; len(list2):\n        if list1[i] &lt; list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    \n    merged.extend(list1[i:])\n    merged.extend(list2[j:])\n    \n    return merged\n\nsample_input = \"\"\"\n4\n2 4 10 18\n3\n-5 11 12\n\"\"\"\n\n_, list1_str, _, list2_str = sample_input.strip().split(\"\\n\")\n\nlist1 = parse_ints(list1_str)\nlist2 = parse_ints(list2_str)\n\nresult = merge_sorted_lists(list1, list2)\nprint(*result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-7",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-7",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "8.1 Sample Dataset",
    "text": "8.1 Sample Dataset\n4 5\n2 -3 4 10 5\n8 2 4 -2 -8\n-5 2 3 2 -4\n5 4 -5 6 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-7",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-7",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "8.2 Sample Output",
    "text": "8.2 Sample Output\n-1\n2 4\n-1\n1 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-7",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-7",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "8.3 Solution",
    "text": "8.3 Solution\nfrom typing import List, Tuple, Optional\n\ndef parse_ints(x: str) -&gt; List[int]:\n    return [int(num) for num in x.split()]\n\ndef two_sum(target: int, numbers: List[int]) -&gt; Optional[Tuple[int, int]]:\n    complement_indices = {}\n    for i, num in enumerate(numbers, start=1):\n        if num in complement_indices:\n            return complement_indices[num], i\n        complement_indices[target - num] = i\n    return None\n\ndef process_input(input_str: str) -&gt; Tuple[int, int, List[List[int]]]:\n    lines = input_str.strip().split(\"\\n\")\n    k, n = parse_ints(lines[0])\n    arrays = [parse_ints(line) for line in lines[1:]]\n    return k, n, arrays\n\nsample_input = \"\"\"\n4 5\n2 -3 4 10 5\n8 2 4 -2 -8\n-5 2 3 2 -4\n5 4 -5 6 8\n\"\"\"\n\nk, n, arrays = process_input(sample_input)\n\nfor arr in arrays:\n    result = two_sum(0, arr)\n    if result:\n        print(*result)\n    else:\n        print(-1)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-8",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-8",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "9.1 Sample Dataset",
    "text": "9.1 Sample Dataset\n4 5\n2 -3 4 10 5\n8 -6 4 -2 -8\n-5 2 3 2 -4\n2 4 -5 6 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-8",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-8",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "9.2 Sample Output",
    "text": "9.2 Sample Output\n-1\n1 2 4\n1 2 3\n-1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-8",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-8",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "9.3 Solution",
    "text": "9.3 Solution\nfrom typing import List, Tuple, Optional\n\ndef parse_ints(x: str) -&gt; List[int]:\n    return [int(num) for num in x.split()]\n\ndef process_input(input_str: str) -&gt; Tuple[int, int, List[List[int]]]:\n    lines = input_str.strip().split(\"\\n\")\n    k, n = parse_ints(lines[0])\n    arrays = [parse_ints(line) for line in lines[1:]]\n    return k, n, arrays\n\ndef three_sum(n: int, a: List[int]) -&gt; List[int]:\n    h = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            s = a[i] + a[j]\n            if s in h:\n                return [h[s] + 1, i + 1, j + 1]\n        h[-a[i]] = i\n    return [-1]\n\nsample_input = \"\"\"\n4 5\n2 -3 4 10 5\n8 -6 4 -2 -8\n-5 2 3 2 -4\n2 4 -5 6 8\n\"\"\"\n\nk, n, arrays = process_input(sample_input)\n\nfor arr in arrays:\n    print(*three_sum(n, arr))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-9",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-9",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "10.1 Sample Dataset",
    "text": "10.1 Sample Dataset\n6 6\n4 6\n6 5\n4 3\n3 5\n2 1\n1 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-9",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-9",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "10.2 Sample Output",
    "text": "10.2 Sample Output\n0 -1 2 1 3 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-9",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-9",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "10.3 Solution",
    "text": "10.3 Solution\nfrom io import StringIO\nfrom typing import List, Dict, Union, Iterator\nfrom collections import deque\n\ndef parse_ints(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(handle: Iterator[str]) -&gt; str:\n    line = next(handle).strip()\n    while not line:\n        line = next(handle).strip()\n    return line\n\ndef parse_graph(handle: Iterator[str], directed: bool = False, weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    nodes, n_edges = parse_ints(read_non_empty_line(handle))\n    \n    graph = {n: [] for n in range(1, nodes + 1)}\n    \n    for _ in range(n_edges):\n        edge = parse_ints(read_non_empty_line(handle))\n        if weighted:\n            f, t, w = edge\n            graph[f].append({\"n\": t, \"w\": w})\n            if not directed:\n                graph[t].append({\"n\": f, \"w\": w})\n        else:\n            f, t = edge\n            graph[f].append(t)\n            if not directed:\n                graph[t].append(f)\n\n    return graph\n\ndef bfs(graph: Dict[int, List[int]], start: int = 1) -&gt; List[int]:\n    n = max(graph.keys())\n    distances = [-1] * (n + 1)\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:\n                queue.append(neighbor)\n                distances[neighbor] = distances[node] + 1\n    \n    return distances[1:]\n\n# Sample input\nsample_input = \"\"\"\n6 6\n4 6\n6 5\n4 3\n3 5\n2 1\n1 4\n\"\"\"\n\ngraph = parse_graph(StringIO(sample_input), directed=True)\nprint(*bfs(graph))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-10",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-10",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "11.1 Sample Dataset",
    "text": "11.1 Sample Dataset\n12 13\n1 2\n1 5\n5 9\n5 10\n9 10\n3 4\n3 7\n3 8\n4 8\n7 11\n8 11\n11 12\n8 12"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-10",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-10",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "11.2 Sample Output",
    "text": "11.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-10",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-10",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "11.3 Solution",
    "text": "11.3 Solution\nfrom typing import List, Dict, Set, Union\n\ndef parse_integers(input_string: str) -&gt; List[int]:\n    return list(map(int, input_string.split()))\n    \ndef parse_graph(input_lines: List[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    graph_info = input_lines[0]\n    if graph_info == \"\":\n        graph_info = input_lines[1]\n    num_nodes, num_edges = parse_integers(graph_info)\n    edge_list = input_lines[1:num_edges+1]\n    adjacency_list: Dict[int, List[Union[int, Dict[str, int]]]] = {}\n\n    for node in range(1, num_nodes + 1):\n        adjacency_list[node] = list()\n\n    for edge in edge_list:\n        if is_weighted:\n            from_node, to_node, weight = parse_integers(edge)\n            adjacency_list[from_node].append({\"node\": to_node, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[to_node].append({\"node\": from_node, \"weight\": weight})\n        else:\n            from_node, to_node = parse_integers(edge)\n            adjacency_list[from_node].append(to_node)\n            if not is_directed:\n                adjacency_list[to_node].append(from_node)\n\n    return adjacency_list\n\ndef find_connected_component(start_node: int, graph: Dict[int, List[int]]) -&gt; Set[int]:\n    def depth_first_search(current_node: int, visited_nodes: Set[int]) -&gt; Set[int]:\n        visited_nodes.add(current_node)\n        for neighbor in graph[current_node]:\n            if neighbor not in visited_nodes:\n                depth_first_search(neighbor, visited_nodes)\n        return visited_nodes\n\n    return depth_first_search(start_node, set())\n\ndef find_all_components(graph: Dict[int, List[int]]) -&gt; List[Set[int]]:\n    unvisited_nodes = set(graph.keys())\n    all_components: List[Set[int]] = list()\n    while unvisited_nodes:\n        component = find_connected_component(next(iter(unvisited_nodes)), graph)\n        unvisited_nodes -= component\n        all_components.append(component)\n    return all_components\n\nsample_input = \"\"\"\n12 13\n1 2\n1 5\n5 9\n5 10\n9 10\n3 4\n3 7\n3 8\n4 8\n7 11\n8 11\n11 12\n8 12\n\"\"\"\n\ngraph: Dict[int, List[int]] = parse_graph(sample_input.strip().split(\"\\n\"))\nprint(len(find_all_components(graph)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-11",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-11",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "12.1 Sample Dataset",
    "text": "12.1 Sample Dataset\n5\n1 3 5 7 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-11",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-11",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "12.2 Sample Output",
    "text": "12.2 Sample Output\n7 5 1 3 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-12",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-12",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "13.1 Sample Dataset",
    "text": "13.1 Sample Dataset\n10\n20 19 35 -18 17 -20 20 1 4 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-12",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-12",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "13.2 Sample Output",
    "text": "13.2 Sample Output\n-20 -18 1 4 4 17 19 20 20 35"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-11",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-11",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "13.3 Solution",
    "text": "13.3 Solution\nfrom typing import List\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef merge(left: List[int], right: List[int]) -&gt; List[int]:\n    merged = []\n    left_index, right_index = 0, 0\n    \n    while left_index &lt; len(left) and right_index &lt; len(right):\n        if left[left_index] &lt; right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n            \n    # Append any remaining elements from both halves\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged\n\ndef merge_sort(array: List[int]) -&gt; List[int]:\n    if len(array) &gt; 1:\n        mid_index = len(array) // 2\n        left_half = merge_sort(array[:mid_index])\n        right_half = merge_sort(array[mid_index:])\n        return merge(left_half, right_half)\n    else:\n        return array\n\nsample_input = \"\"\"\n10\n20 19 35 -18 17 -20 20 1 4 4\n\"\"\"\n\n_, numbers = sample_input.strip().split(\"\\n\")\nprint(*merge_sort(parse_integers(numbers)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-13",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-13",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "14.1 Sample Dataset",
    "text": "14.1 Sample Dataset\n9\n7 2 5 6 1 3 9 4 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-13",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-13",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "14.2 Sample Output",
    "text": "14.2 Sample Output\n4 2 5 6 1 3 7 9 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-12",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-12",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "14.3 Solution",
    "text": "14.3 Solution\nfrom typing import List\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(number) for number in line.split()]\n\ndef partition(array: List[int]) -&gt; List[int]:\n    if len(array) &lt;= 1:\n        return array\n    \n    pivot = array[0]\n    swap_index = 0\n    \n    for current_index in range(1, len(array)):\n        if array[current_index] &lt;= pivot:\n            swap_index += 1\n            array[current_index], array[swap_index] = array[swap_index], array[current_index]\n    \n    array[0], array[swap_index] = array[swap_index], array[0]\n    return array\n\nsample_input = \"\"\"\n9\n7 2 5 6 1 3 9 4 8\n\"\"\"\n\n_, input_numbers = sample_input.strip().split(\"\\n\")\nresult = partition(parse_integers(input_numbers))\nprint(*result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-14",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-14",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "15.1 Sample Dataset",
    "text": "15.1 Sample Dataset\n9\n4 5 6 4 1 2 5 7 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-14",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-14",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "15.2 Sample Output",
    "text": "15.2 Sample Output\n2 1 4 4 4 5 7 6 5"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-13",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-13",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "15.3 Solution",
    "text": "15.3 Solution\nfrom typing import List, Tuple\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(number) for number in line.split()]\n\ndef three_way_partition(array: List[int], start: int = None, end: int = None) -&gt; Tuple[int, int]:\n    if start is None:\n        start = 0\n    if end is None:\n        end = len(array) - 1\n    \n    pivot = array[start]\n    low = start\n    current = start\n    high = end\n\n    while current &lt;= high:\n        if array[current] &lt; pivot:\n            array[current], array[low] = array[low], array[current]\n            current += 1\n            low += 1\n        elif array[current] &gt; pivot:\n            array[current], array[high] = array[high], array[current]\n            high -= 1\n        else:\n            current += 1\n\n    return low, high\n\nsample_input = \"\"\"\n9\n4 5 6 4 1 2 5 7 4\n\"\"\"\n\n_, input_line = sample_input.strip().split(\"\\n\")\nnumbers = parse_integers(input_line)\nthree_way_partition(numbers)\nprint(*numbers)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-15",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-15",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "16.1 Sample Dataset",
    "text": "16.1 Sample Dataset\n2\n\n4 5\n3 4\n4 2\n3 2\n3 1\n1 2\n\n4 4\n1 2\n3 4\n2 4\n4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-15",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-15",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "16.2 Sample Output",
    "text": "16.2 Sample Output\n1 -1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-14",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-14",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "16.3 Solution",
    "text": "16.3 Solution\nfrom typing import List, Dict, Union, Iterator\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    line = next(input_iterator).strip()\n    while not line:\n        line = next(input_iterator).strip()\n    return line\n\ndef create_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    num_nodes, num_edges = parse_integers(read_non_empty_line(input_iterator))\n    \n    graph = {node: [] for node in range(1, num_nodes + 1)}\n    \n    for _ in range(num_edges):\n        edge_data = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            from_node, to_node, weight = edge_data\n            graph[from_node].append({\"node\": to_node, \"weight\": weight})\n            if not is_directed:\n                graph[to_node].append({\"node\": from_node, \"weight\": weight})\n        else:\n            from_node, to_node = edge_data\n            graph[from_node].append(to_node)\n            if not is_directed:\n                graph[to_node].append(from_node)\n\n    return graph\n\ndef depth_first_search(graph: Dict[int, List[Union[int, Dict[str, int]]]], start: int, max_depth: int):\n    def dfs_recursive(current_node: int, current_depth: int, visited: set):\n        if current_depth == max_depth:\n            yield current_node\n        if current_depth &lt; max_depth:\n            for neighbor in graph[current_node]:\n                neighbor_node = neighbor if isinstance(neighbor, int) else neighbor['node']\n                if neighbor_node not in visited:\n                    yield from dfs_recursive(neighbor_node, current_depth + 1, visited | {current_node})\n\n    return dfs_recursive(start, 0, set())\n\ndef has_square_cycle(graph: Dict[int, List[Union[int, Dict[str, int]]]], cycle_length: int) -&gt; int:\n    for start_node in graph:\n        for end_node in depth_first_search(graph, start_node, cycle_length - 1):\n            if end_node in graph[start_node]:\n                return 1\n    return -1\n\ndef parse_multiple_graphs(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; List[Dict[int, List[Union[int, Dict[str, int]]]]]:\n    num_graphs = int(read_non_empty_line(input_iterator))\n    return [create_graph(input_iterator, is_directed, is_weighted) for _ in range(num_graphs)]\n\n# Sample input\nsample_input = \"\"\"\n2\n\n4 5\n3 4\n4 2\n3 2\n3 1\n1 2\n\n4 4\n1 2\n3 4\n2 4\n4 1\n\"\"\".strip().split(\"\\n\")\n\n# Process the input and print results\ngraphs = parse_multiple_graphs(iter(sample_input), is_directed=False)\nresults = [has_square_cycle(graph, 4) for graph in graphs]\nprint(*results)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-16",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-16",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "17.1 Sample Dataset",
    "text": "17.1 Sample Dataset\n2\n\n3 3\n1 2\n3 2\n3 1\n\n4 3\n1 4\n3 1\n1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-16",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-16",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "17.2 Sample Output",
    "text": "17.2 Sample Output\n-1 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-15",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-15",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "17.3 Solution",
    "text": "17.3 Solution\nfrom typing import List, Dict, Union, Iterator\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    line = next(input_iterator).strip()\n    while not line:\n        line = next(input_iterator).strip()\n    return line\n\ndef parse_graph(input_iterator: Iterator[str], directed: bool = False, weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    num_nodes, num_edges = parse_integers(read_non_empty_line(input_iterator))\n    \n    graph = {node: [] for node in range(1, num_nodes + 1)}\n    \n    for _ in range(num_edges):\n        edge = parse_integers(read_non_empty_line(input_iterator))\n        if weighted:\n            from_node, to_node, weight = edge\n            graph[from_node].append({\"node\": to_node, \"weight\": weight})\n            if not directed:\n                graph[to_node].append({\"node\": from_node, \"weight\": weight})\n        else:\n            from_node, to_node = edge\n            graph[from_node].append(to_node)\n            if not directed:\n                graph[to_node].append(from_node)\n\n    return graph\n    \ndef is_bipartite(graph: Dict[int, List[int]]) -&gt; int:\n    color = {1: 0}\n    queue = [1]\n    while queue:\n        current_node = queue.pop(0)\n        for neighbor in graph[current_node]:\n            neighbor_color = (color[current_node] + 1) % 2\n            if neighbor not in color:\n                queue.append(neighbor)\n                color[neighbor] = neighbor_color\n            elif color[neighbor] != neighbor_color:\n                return -1\n    return 1\n\ndef process_multiple_graphs(input_iterator: Iterator[str]) -&gt; List[int]:\n    num_cases = int(read_non_empty_line(input_iterator))\n    results = []\n    for _ in range(num_cases):\n        graph = parse_graph(input_iterator)\n        results.append(is_bipartite(graph))\n    return results\n\nsample_input = \"\"\"\n2\n\n3 3\n1 2\n3 2\n3 1\n\n4 3\n1 4\n3 1\n1 2\n\"\"\".strip().split(\"\\n\")\n\n# Convert the list to an iterator\nsample_input_iterator = iter(sample_input)\n\n# Process multiple graphs\nresults = process_multiple_graphs(sample_input_iterator)\nprint(*results)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-17",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-17",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "18.1 Sample Dataset",
    "text": "18.1 Sample Dataset\n3\n\n2 1\n1 2\n\n4 4\n4 1\n1 2\n2 3\n3 1\n\n4 3\n4 3\n3 2\n2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-17",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-17",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "18.2 Sample Output",
    "text": "18.2 Sample Output\n1 -1 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-16",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-16",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "18.3 Solution",
    "text": "18.3 Solution\nfrom typing import List, Dict, Union, Iterator\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iter: Iterator[str]) -&gt; str:\n    line = next(input_iter).strip()\n    while not line:\n        line = next(input_iter).strip()\n    return line\n\ndef parse_graph(input_iter: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    node_count, edge_count = parse_integers(read_non_empty_line(input_iter))\n    \n    graph = {node: [] for node in range(1, node_count + 1)}\n    \n    for _ in range(edge_count):\n        edge = parse_integers(read_non_empty_line(input_iter))\n        if is_weighted:\n            source, target, weight = edge\n            graph[source].append({\"node\": target, \"weight\": weight})\n            if not is_directed:\n                graph[target].append({\"node\": source, \"weight\": weight})\n        else:\n            source, target = edge\n            graph[source].append(target)\n            if not is_directed:\n                graph[target].append(source)\n\n    return graph\n\ndef graph_nodes(graph):\n    nodes = set()\n    for node, neighbors in graph.items():\n        nodes.add(node)\n        nodes = nodes.union(neighbors)\n    return nodes\n\ndef remove_leaves(graph):\n    nodes = graph_nodes(graph)\n    leaves = nodes - graph.keys()\n    return {n: set(v) - leaves for n, v in graph.items() if len(set(v) - leaves)}\n\ndef is_dag(graph):\n    while graph:\n        new_graph = remove_leaves(graph)\n        if len(graph) == len(new_graph):\n            return -1\n        graph = new_graph\n    return 1\n\ndef parse_multiple_graphs(input_iter: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; List[Dict[int, List[Union[int, Dict[str, int]]]]]:\n    case_count = int(read_non_empty_line(input_iter))\n    graphs = []\n    for _ in range(case_count):\n        graphs.append(parse_graph(input_iter, is_directed, is_weighted))\n    return graphs\n\nsample_input = \"\"\"\n3\n\n2 1\n1 2\n\n4 4\n4 1\n1 2\n2 3\n3 1\n\n4 3\n4 3\n3 2\n2 1\n\"\"\".strip().split(\"\\n\")\n\n# Convert the list to an iterator\ninput_iterator = iter(sample_input)\n\n# Parse multiple graphs\ngraphs = parse_multiple_graphs(input_iterator, is_directed=True)\n\n# Process each graph\nresults = [is_dag(graph) for graph in graphs]\nprint(*results)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-18",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-18",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "19.1 Sample Dataset",
    "text": "19.1 Sample Dataset\n6 10\n3 4 4\n1 2 4\n1 3 2\n2 3 3\n6 3 2\n3 5 5\n5 4 1\n3 2 1\n2 4 2\n2 5 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-18",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-18",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "19.2 Sample Output",
    "text": "19.2 Sample Output\n0 3 2 5 6 -1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-17",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-17",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "19.3 Solution",
    "text": "19.3 Solution\nfrom math import inf\nfrom heapq import heappush, heappop\nfrom typing import List, Dict, Union, Iterator\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iter: Iterator[str]) -&gt; str:\n    line = next(input_iter).strip()\n    while not line:\n        line = next(input_iter).strip()\n    return line\n\ndef parse_graph(input_iter: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    vertex_count, edge_count = parse_integers(read_non_empty_line(input_iter))\n    \n    adjacency_list = {vertex: [] for vertex in range(1, vertex_count + 1)}\n    \n    for _ in range(edge_count):\n        edge = parse_integers(read_non_empty_line(input_iter))\n        if is_weighted:\n            source, destination, weight = edge\n            adjacency_list[source].append({\"vertex\": destination, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[destination].append({\"vertex\": source, \"weight\": weight})\n        else:\n            source, destination = edge\n            adjacency_list[source].append(destination)\n            if not is_directed:\n                adjacency_list[destination].append(source)\n\n    return adjacency_list\n\ndef dijkstra(graph, start_vertex=1):\n    distances = [inf for _ in range(len(graph) + 1)]\n    distances[start_vertex] = 0\n    priority_queue = []\n    heappush(priority_queue, (0, start_vertex))\n    visited = set()\n\n    while priority_queue:\n        current_vertex = heappop(priority_queue)[1]\n        visited.add(current_vertex)\n        for neighbor in graph[current_vertex]:\n            if isinstance(neighbor, dict):\n                next_vertex = neighbor[\"vertex\"]\n                edge_weight = neighbor[\"weight\"]\n            else:\n                next_vertex = neighbor\n                edge_weight = 1  # Assume unit weight for unweighted graphs\n            \n            if next_vertex not in visited:\n                new_distance = distances[current_vertex] + edge_weight\n                if new_distance &lt; distances[next_vertex]:\n                    distances[next_vertex] = new_distance\n                    heappush(priority_queue, (distances[next_vertex], next_vertex))\n\n    return [-1 if distance == inf else distance for distance in distances[1:]]\n\nsample_input = \"\"\"\n6 10\n3 4 4\n1 2 4\n1 3 2\n2 3 3\n6 3 2\n3 5 5\n5 4 1\n3 2 1\n2 4 2\n2 5 3\n\"\"\".strip().split(\"\\n\")\n\n# Convert the list to an iterator\ninput_iterator = iter(sample_input)\n\ngraph = parse_graph(input_iterator, is_directed=True, is_weighted=True)\nprint(*dijkstra(graph))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-19",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-19",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "20.1 Sample Dataset",
    "text": "20.1 Sample Dataset\n9\n2 6 7 1 3 5 4 8 9"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-19",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-19",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "20.2 Sample Output",
    "text": "20.2 Sample Output\n1 2 3 4 5 6 7 8 9"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-18",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-18",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "20.3 Solution",
    "text": "20.3 Solution\nfrom typing import List, Any\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef bubble_up(heap: List[int], index: int) -&gt; None:\n    if index == 0:\n        return\n    parent_index: int = (index - 1) // 2\n    current_index: int = index\n    if heap[parent_index] &gt; heap[current_index]:\n        bubble_up(heap, parent_index)\n    else:\n        heap[parent_index], heap[current_index] = heap[current_index], heap[parent_index]\n        bubble_up(heap, parent_index)\n\ndef build_heap(array: List[int]) -&gt; List[int]:\n    heap: List[int] = []\n    for i, element in enumerate(array):\n        heap.append(element)\n        bubble_up(heap, i)\n    return heap\n\ndef sift_down(heap: List[int], start_index: int, end_index: int) -&gt; None:\n    root_index: int = start_index\n    while root_index * 2 + 1 &lt;= end_index:\n        left_child_index: int = root_index * 2 + 1\n        right_child_index: int = left_child_index + 1\n        swap_index: int = root_index\n        if heap[swap_index] &lt; heap[left_child_index]:\n            swap_index = left_child_index\n        if right_child_index &lt;= end_index and heap[swap_index] &lt; heap[right_child_index]:\n            swap_index = right_child_index\n        if swap_index != root_index:\n            heap[root_index], heap[swap_index] = heap[swap_index], heap[root_index]\n            root_index = swap_index\n        else:\n            return\n\ndef heap_sort(array: List[int]) -&gt; List[int]:\n    heap: List[int] = build_heap(array)\n    last_index: int = len(heap) - 1\n    while last_index &gt; 0:\n        heap[0], heap[last_index] = heap[last_index], heap[0]\n        last_index -= 1\n        sift_down(heap, 0, last_index)\n    return heap\n\nsample_input: str = \"\"\"\n9\n2 6 7 1 3 5 4 8 9\n\"\"\"\n\n_, input_array_str = sample_input.strip().split(\"\\n\")\ninput_array: List[int] = parse_integers(input_array_str)\nsorted_array: List[int] = heap_sort(input_array)\nprint(*sorted_array)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-20",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-20",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "21.1 Sample Dataset",
    "text": "21.1 Sample Dataset\n5\n-6 1 15 8 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-20",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-20",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "21.2 Sample Output",
    "text": "21.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-19",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-19",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "21.3 Solution",
    "text": "21.3 Solution\nfrom typing import List, Tuple\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef merge_and_count_inversions(left: List[int], right: List[int]) -&gt; Tuple[List[int], int]:\n    merged: List[int] = []\n    inversion_count: int = 0\n    left_length: int = len(left)\n    left_index: int = 0\n\n    while left and right:\n        if left[0] &lt;= right[0]:\n            left_index += 1\n            merged.append(left.pop(0))\n        else:\n            inversion_count += left_length - left_index\n            merged.append(right.pop(0))\n\n    merged.extend(left)\n    merged.extend(right)\n    return merged, inversion_count\n\ndef merge_sort_and_count_inversions(arr: List[int]) -&gt; Tuple[List[int], int]:\n    if len(arr) &gt; 1:\n        mid: int = len(arr) // 2\n        left_half, left_inversions = merge_sort_and_count_inversions(arr[:mid])\n        right_half, right_inversions = merge_sort_and_count_inversions(arr[mid:])\n        merged, merge_inversions = merge_and_count_inversions(left_half, right_half)\n        total_inversions: int = left_inversions + right_inversions + merge_inversions\n        return merged, total_inversions\n    else:\n        return arr, 0\n\nsample_input: str = \"\"\"\n5\n-6 1 15 8 10\n\"\"\"\n\n_, input_array_str = sample_input.strip().split(\"\\n\")\ninput_array: List[int] = parse_integers(input_array_str)\n_, inversion_count = merge_sort_and_count_inversions(input_array)\nprint(inversion_count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-21",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-21",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "22.1 Sample Dataset",
    "text": "22.1 Sample Dataset\n9 13\n1 2 10\n3 2 1\n3 4 1\n4 5 3\n5 6 -1\n7 6 -1\n8 7 1\n1 8 8\n7 2 -4\n2 6 2\n6 3 -2\n9 5 -10\n9 4 7"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-21",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-21",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "22.2 Sample Output",
    "text": "22.2 Sample Output\n0 5 5 6 9 7 9 8 x"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-20",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-20",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "22.3 Solution",
    "text": "22.3 Solution\nfrom math import inf, isinf\nfrom typing import List, Dict, Union, Iterator, Set, Tuple\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    line = next(input_iterator).strip()\n    while not line:\n        line = next(input_iterator).strip()\n    return line\n\nEdgeInfo = Dict[str, int]\nGraph = Dict[int, List[Union[int, EdgeInfo]]]\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Graph:\n    vertex_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    adjacency_list: Graph = {vertex: [] for vertex in range(1, vertex_count + 1)}\n    \n    for _ in range(edge_count):\n        edge_data = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            source_vertex, target_vertex, edge_weight = edge_data\n            adjacency_list[source_vertex].append({\"node\": target_vertex, \"weight\": edge_weight})\n            if not is_directed:\n                adjacency_list[target_vertex].append({\"node\": source_vertex, \"weight\": edge_weight})\n        else:\n            source_vertex, target_vertex = edge_data\n            adjacency_list[source_vertex].append(target_vertex)\n            if not is_directed:\n                adjacency_list[target_vertex].append(source_vertex)\n\n    return adjacency_list\n\ndef count_edges(graph: Graph) -&gt; int:\n    return sum(len(neighbors) for neighbors in graph.values())\n\ndef get_all_vertices(graph: Graph) -&gt; Set[int]:\n    all_vertices: Set[int] = set(graph.keys())\n    for neighbors in graph.values():\n        for neighbor in neighbors:\n            if isinstance(neighbor, dict):\n                all_vertices.add(neighbor[\"node\"])\n            else:\n                all_vertices.add(neighbor)\n    return all_vertices\n\ndef bellman_ford(graph: Graph, start_vertex: int = 1) -&gt; List[Union[int, str]]:\n    distances: Dict[int, float] = {vertex: inf for vertex in get_all_vertices(graph)}\n    distances[start_vertex] = 0\n    for _ in range(count_edges(graph) - 1):\n        for current_vertex, neighbors in graph.items():\n            for neighbor in neighbors:\n                if isinstance(neighbor, dict):\n                    target_vertex = neighbor[\"node\"]\n                    edge_weight = neighbor[\"weight\"]\n                    if distances[current_vertex] + edge_weight &lt; distances[target_vertex]:\n                        distances[target_vertex] = distances[current_vertex] + edge_weight\n    return [\"x\" if isinf(distance) else distance for distance in distances.values()]\n\nsample_input: str = \"\"\"\n9 13\n1 2 10\n3 2 1\n3 4 1\n4 5 3\n5 6 -1\n7 6 -1\n8 7 1\n1 8 8\n7 2 -4\n2 6 2\n6 3 -2\n9 5 -10\n9 4 7\n\"\"\".strip().split(\"\\n\")\n\n# Convert the list to an iterator\ninput_iterator = iter(sample_input)\n\n# Parse the graph with correct parameters\ngraph = parse_graph(input_iterator, is_directed=True, is_weighted=True)\n\n# Run Bellman-Ford algorithm\nresult = bellman_ford(graph)\nprint(*result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-22",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-22",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "23.1 Sample Dataset",
    "text": "23.1 Sample Dataset\n2\n\n4 5\n2 4 2\n3 2 1\n1 4 3\n2 1 10\n1 3 4\n\n4 5\n3 2 1\n2 4 2\n4 1 3\n2 1 10\n1 3 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-22",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-22",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "23.2 Sample Output",
    "text": "23.2 Sample Output\n-1 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-21",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-21",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "23.3 Solution",
    "text": "23.3 Solution\nfrom typing import List, Dict, Union, Iterator, Tuple\nfrom math import inf\nfrom heapq import heappush, heappop\nfrom io import StringIO\n\nGraphNode = Union[int, Dict[str, int]]\nGraph = Dict[int, List[GraphNode]]\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iter: Iterator[str]) -&gt; str:\n    line = next(input_iter).strip()\n    while not line:\n        line = next(input_iter).strip()\n    return line\n\ndef parse_graph(input_iter: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Graph:\n    vertex_count, edge_count = parse_integers(read_non_empty_line(input_iter))\n    \n    adj_list: Graph = {vertex: [] for vertex in range(1, vertex_count + 1)}\n    \n    for _ in range(edge_count):\n        edge_data = parse_integers(read_non_empty_line(input_iter))\n        if is_weighted:\n            src, dest, weight = edge_data\n            adj_list[src].append({\"node\": dest, \"weight\": weight})\n            if not is_directed:\n                adj_list[dest].append({\"node\": src, \"weight\": weight})\n        else:\n            src, dest = edge_data\n            adj_list[src].append(dest)\n            if not is_directed:\n                adj_list[dest].append(src)\n\n    return adj_list\n\ndef dijkstra(graph: Graph, start: int = 1) -&gt; List[int]:\n    distances = [inf for _ in range(len(graph) + 1)]\n    distances[start] = 0\n    priority_queue = []\n    heappush(priority_queue, (0, start))\n    visited = set()\n\n    while priority_queue:\n        _, current_node = heappop(priority_queue)\n        if current_node in visited:\n            continue\n        visited.add(current_node)\n        for neighbor in graph[current_node]:\n            if isinstance(neighbor, dict):\n                neighbor_node, edge_weight = neighbor[\"node\"], neighbor[\"weight\"]\n            else:\n                neighbor_node, edge_weight = neighbor, 1\n            if neighbor_node not in visited:\n                new_distance = distances[current_node] + edge_weight\n                if new_distance &lt; distances[neighbor_node]:\n                    distances[neighbor_node] = new_distance\n                    heappush(priority_queue, (new_distance, neighbor_node))\n\n    return [-1 if d == inf else d for d in distances[1:]]\n\ndef extract_first_edges(input_handle: StringIO) -&gt; List[List[int]]:\n    lines = input_handle.read().splitlines()\n    graph_count = int(lines[0])\n    current_line = 1\n    first_edges = []\n    for _ in range(graph_count):\n        while not lines[current_line]:\n            current_line += 1\n        _, edge_count = map(int, lines[current_line].split())\n        first_edges.append(list(map(int, lines[current_line + 1].split())))\n        current_line += int(edge_count) + 1\n    return first_edges\n\ndef calculate_cycle_length(graph: Graph, edge: List[int]) -&gt; int:\n    distance = dijkstra(graph, start=edge[1])[edge[0] - 1]\n    return distance if distance == -1 else distance + edge[2]\n\ndef parse_multiple_graphs(input_str: str, directed: bool = False, weighted: bool = True) -&gt; List[Graph]:\n    input_iter = iter(input_str.splitlines())\n    graph_count = int(next(input_iter))\n    graphs = []\n    for _ in range(graph_count):\n        graphs.append(parse_graph(input_iter, is_directed=directed, is_weighted=weighted))\n    return graphs\n\n# Sample input\nsample_input = \"\"\"\n2\n\n4 5\n2 4 2\n3 2 1\n1 4 3\n2 1 10\n1 3 4\n\n4 5\n3 2 1\n2 4 2\n4 1 3\n2 1 10\n1 3 4\n\"\"\"\n\n# Main execution\ninput_handle = StringIO(sample_input.strip())\nfirst_edges = extract_first_edges(input_handle)\ninput_handle.seek(0)  # Reset the StringIO object to the beginning\ngraphs = parse_multiple_graphs(input_handle.read(), directed=True, weighted=True)\nresults = [calculate_cycle_length(graphs[i], first_edges[i]) for i in range(len(graphs))]\nprint(*results)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-23",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-23",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "24.1 Sample Dataset",
    "text": "24.1 Sample Dataset\n11\n2 36 5 21 8 13 11 20 5 4 1\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-23",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-23",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "24.2 Sample Output",
    "text": "24.2 Sample Output\n13"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-22",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-22",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "24.3 Solution",
    "text": "24.3 Solution\nfrom typing import List, Tuple\nfrom io import StringIO\n\ndef parse_integers(line: str) -&gt; List[int]:\n    \"\"\"Parse a line of space-separated integers into a list of integers.\"\"\"\n    return [int(num) for num in line.split()]\n\ndef three_way_partition(arr: List[int], low: int = 0, high: int = None) -&gt; Tuple[int, int]:\n    \"\"\"Partition the array into three parts based on a pivot.\"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    pivot = arr[low]\n    mid = low\n\n    while mid &lt;= high:\n        if arr[mid] &lt; pivot:\n            arr[low], arr[mid] = arr[mid], arr[low]\n            low += 1\n            mid += 1\n        elif arr[mid] &gt; pivot:\n            arr[mid], arr[high] = arr[high], arr[mid]\n            high -= 1\n        else:\n            mid += 1\n\n    return low, high\n\ndef find_kth_element(arr: List[int], k: int) -&gt; int:\n    \"\"\"Find the k-th element in the array using a three-way partitioning method.\"\"\"\n    def find_kth_recursive(arr: List[int], k: int, low: int, high: int) -&gt; int:\n        left, right = three_way_partition(arr, low, high)\n        \n        if k &lt; left:\n            return find_kth_recursive(arr, k, low, left - 1)\n        elif k &gt; right:\n            return find_kth_recursive(arr, k, right + 1, high)\n        else:\n            return arr[k]\n\n    return find_kth_recursive(arr, k, 0, len(arr) - 1)\n\ndef process_input(input_str: str) -&gt; Tuple[List[int], int]:\n    \"\"\"Process the input string and return the list of integers and the index k.\"\"\"\n    lines = input_str.strip().split('\\n')\n    arr = parse_integers(lines[1])\n    k = int(lines[2])\n    return arr, k\n\nsample_input = \"\"\"\n11\n2 36 5 21 8 13 11 20 5 4 1\n8\n\"\"\"\n\narr, k = process_input(sample_input)\nresult = find_kth_element(arr, k - 1)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-24",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-24",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "25.1 Sample Dataset",
    "text": "25.1 Sample Dataset\n10\n4 -6 7 8 -9 100 12 13 56 17\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-24",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-24",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "25.2 Sample Output",
    "text": "25.2 Sample Output\n-9 -6 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-23",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-23",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "25.3 Solution",
    "text": "25.3 Solution\nfrom typing import List\n\ndef parse_integers(line: str) -&gt; List[int]:\n    \"\"\"Parse a line of space-separated integers into a list of integers.\"\"\"\n    return [int(num) for num in line.split()]\n\ndef heapify_up(heap: List[int], i: int) -&gt; None:\n    \"\"\"Maintain heap property by moving an element up the heap.\"\"\"\n    while i &gt; 0:\n        parent = (i - 1) // 2\n        if heap[parent] &lt; heap[i]:\n            heap[parent], heap[i] = heap[i], heap[parent]\n            i = parent\n        else:\n            break\n\ndef build_max_heap(arr: List[int]) -&gt; List[int]:\n    \"\"\"Build a max heap from an array.\"\"\"\n    heap = []\n    for x in arr:\n        heap.append(x)\n        heapify_up(heap, len(heap) - 1)\n    return heap\n\ndef sift_down(heap: List[int], start: int, end: int) -&gt; None:\n    \"\"\"Maintain heap property by moving an element down the heap.\"\"\"\n    root = start\n    while root * 2 + 1 &lt;= end:\n        left = root * 2 + 1\n        right = left + 1\n        swap = root\n        if heap[swap] &lt; heap[left]:\n            swap = left\n        if right &lt;= end and heap[swap] &lt; heap[right]:\n            swap = right\n        if swap != root:\n            heap[root], heap[swap] = heap[swap], heap[root]\n            root = swap\n        else:\n            return\n\ndef heap_sort(arr: List[int]) -&gt; List[int]:\n    \"\"\"Sort an array using heap sort algorithm.\"\"\"\n    heap = build_max_heap(arr)\n    for i in range(len(heap) - 1, 0, -1):\n        heap[0], heap[i] = heap[i], heap[0]\n        sift_down(heap, 0, i - 1)\n    return heap\n\ndef partial_sort(arr: List[int], k: int) -&gt; List[int]:\n    \"\"\"Find and sort the k smallest elements in the array.\"\"\"\n    heap = build_max_heap(arr[:k])\n    for x in arr[k:]:\n        if x &lt; heap[0]:\n            heap[0] = x\n            sift_down(heap, 0, k - 1)\n    return heap_sort(heap)\n\n# Sample input processing\nsample_input = \"\"\"\n10\n4 -6 7 8 -9 100 12 13 56 17\n3\n\"\"\"\n\n_, arr_str, k_str = sample_input.strip().split(\"\\n\")\narr = parse_integers(arr_str)\nk = int(k_str)\n\n# Perform partial sort and print result\nresult = partial_sort(arr, k)\nprint(*result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-25",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-25",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "26.1 Sample Dataset",
    "text": "26.1 Sample Dataset\n4 5\n1 2\n3 1\n3 2\n4 3\n4 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-25",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-25",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "26.2 Sample Output",
    "text": "26.2 Sample Output\n4 3 1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-24",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-24",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "26.3 Solution",
    "text": "26.3 Solution\nfrom typing import List, Iterator, Dict, Union, Set\nfrom collections import defaultdict\nfrom io import StringIO\n\nGraphNode = Union[int, Dict[str, int]]\nGraph = Dict[int, List[GraphNode]]\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    line = next(input_iterator).strip()\n    while not line:\n        line = next(input_iterator).strip()\n    return line\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Graph:\n    vertex_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    adjacency_list: Graph = {vertex: [] for vertex in range(1, vertex_count + 1)}\n    \n    for _ in range(edge_count):\n        edge_data = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            source, destination, weight = edge_data\n            adjacency_list[source].append({\"node\": destination, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[destination].append({\"node\": source, \"weight\": weight})\n        else:\n            source, destination = edge_data\n            adjacency_list[source].append(destination)\n            if not is_directed:\n                adjacency_list[destination].append(source)\n\n    return adjacency_list\n\ndef get_all_graph_nodes(graph: Graph) -&gt; Set[int]:\n    nodes = set()\n    for node, neighbors in graph.items():\n        nodes.add(node)\n        for neighbor in neighbors:\n            if isinstance(neighbor, dict):\n                nodes.add(neighbor[\"node\"])\n            else:\n                nodes.add(neighbor)\n    return nodes\n\ndef topological_sort(graph: Graph) -&gt; List[int]:\n    def dfs_topological(vertex: int, visited: Dict[int, bool], stack: List[int]):\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            neighbor_node = neighbor[\"node\"] if isinstance(neighbor, dict) else neighbor\n            if not visited[neighbor_node]:\n                dfs_topological(neighbor_node, visited, stack)\n        stack.append(vertex)\n\n    visited = defaultdict(bool)\n    stack = []\n    for node in get_all_graph_nodes(graph):\n        if not visited[node]:\n            dfs_topological(node, visited, stack)\n\n    return stack[::-1]\n\n# Sample input processing\nsample_input = \"\"\"\n4 5\n1 2\n3 1\n3 2\n4 3\n4 2\n\"\"\"\n\ninput_iterator = iter(StringIO(sample_input.strip()).readlines())\ngraph = parse_graph(input_iterator, is_directed=True)\nsorted_nodes = topological_sort(graph)\nprint(*sorted_nodes)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-26",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-26",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "27.1 Sample Dataset",
    "text": "27.1 Sample Dataset\n2\n\n3 3\n1 2\n2 3\n1 3\n\n4 3\n4 3\n3 2\n4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-26",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-26",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "27.2 Sample Output",
    "text": "27.2 Sample Output\n1 1 2 3\n-1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-25",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-25",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "27.3 Solution",
    "text": "27.3 Solution\nfrom typing import List, Iterator, Dict, Set\nfrom collections import defaultdict\nfrom io import StringIO\n\nGraph = Dict[int, List[int]]\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return list(map(int, line.split()))\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    return next(line for line in input_iterator if line.strip())\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False) -&gt; Graph:\n    vertex_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    adjacency_list: Graph = defaultdict(list)\n    \n    for _ in range(edge_count):\n        source, destination = parse_integers(read_non_empty_line(input_iterator))\n        adjacency_list[source].append(destination)\n        if not is_directed:\n            adjacency_list[destination].append(source)\n\n    return adjacency_list\n\ndef parse_multiple_graphs(input_iterator: Iterator[str], is_directed: bool = False) -&gt; List[Graph]:\n    num_cases = int(read_non_empty_line(input_iterator))\n    return [parse_graph(input_iterator, is_directed) for _ in range(num_cases)]\n\ndef graph_nodes(graph: Graph) -&gt; Set[int]:\n    return set(graph.keys()) | set.union(*(set(val) for val in graph.values()))\n\ndef topological_sort(graph: Graph) -&gt; List[int]:\n    def dfs(node: int, visited: Set[int], stack: List[int]):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, stack)\n        stack.append(node)\n\n    visited: Set[int] = set()\n    stack: List[int] = []\n    for node in graph_nodes(graph):\n        if node not in visited:\n            dfs(node, visited, stack)\n\n    return stack[::-1]\n\ndef hdag(graph: Graph) -&gt; List[int]:\n    sorted_nodes = topological_sort(graph)\n    for a, b in zip(sorted_nodes, sorted_nodes[1:]):\n        if b not in graph[a]:\n            return [-1]\n    return [1] + sorted_nodes\n\nsample_input = \"\"\"\n2\n\n3 3\n1 2\n2 3\n1 3\n\n4 3\n4 3\n3 2\n4 1\n\"\"\"\n\ninput_iterator = iter(StringIO(sample_input.strip()).readlines())\ngraphs = parse_multiple_graphs(input_iterator, is_directed=True)\nfor graph in graphs:\n    print(*hdag(graph))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-27",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-27",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "28.1 Sample Dataset",
    "text": "28.1 Sample Dataset\n2\n\n4 5\n1 4 4\n4 2 3\n2 3 1\n3 1 6\n2 1 -7\n\n3 4\n1 2 -8\n2 3 20\n3 1 -1\n3 2 -30"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-27",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-27",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "28.2 Sample Output",
    "text": "28.2 Sample Output\n-1 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-26",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-26",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "28.3 Solution",
    "text": "28.3 Solution\nfrom io import StringIO\nfrom typing import List, Dict, Union, Iterator\nfrom collections import deque\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    line = next(input_iterator).strip()\n    while not line:\n        line = next(input_iterator).strip()\n    return line\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    node_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    adjacency_list = {node: [] for node in range(1, node_count + 1)}\n    \n    for _ in range(edge_count):\n        edge_data = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            source, target, weight = edge_data\n            adjacency_list[source].append({\"node\": target, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[target].append({\"node\": source, \"weight\": weight})\n        else:\n            source, target = edge_data\n            adjacency_list[source].append(target)\n            if not is_directed:\n                adjacency_list[target].append(source)\n\n    return adjacency_list\n\ndef parse_multiple_graphs(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; List[Dict[int, List[Union[int, Dict[str, int]]]]]:\n    test_case_count = int(read_non_empty_line(input_iterator))\n    return [parse_graph(input_iterator, is_directed, is_weighted) for _ in range(test_case_count)]\n\ndef count_edges(graph):\n    edge_count = 0\n    for _, neighbors in graph.items():\n        for _ in neighbors:\n            edge_count += 1\n    return edge_count\n\ndef get_all_nodes(graph):\n    source_nodes = list(graph.keys())\n    target_nodes = [neighbor[\"node\"] for neighbors in graph.values() for neighbor in neighbors]\n    return set(source_nodes) | set(target_nodes)\n\ndef detect_negative_weight_cycle(graph):\n    distances = {node: 10**20 for node in get_all_nodes(graph)}\n    distances[1] = 0\n    for _ in range(count_edges(graph) - 1):\n        for source, neighbors in graph.items():\n            for neighbor in neighbors:\n                distances[neighbor[\"node\"]] = min(distances[source] + neighbor[\"weight\"], distances[neighbor[\"node\"]])\n    for source, neighbors in graph.items():\n        for neighbor in neighbors:\n            if distances[source] + neighbor[\"weight\"] &lt; distances[neighbor[\"node\"]]:\n                return 1\n    return -1\n\nsample_input = \"\"\"\n2\n\n4 5\n1 4 4\n4 2 3\n2 3 1\n3 1 6\n2 1 -7\n\n3 4\n1 2 -8\n2 3 20\n3 1 -1\n3 2 -30\n\"\"\"\n\ninput_iterator = iter(StringIO(sample_input.strip()).readlines())\ngraphs = parse_multiple_graphs(input_iterator, is_directed=True, is_weighted=True)\nprint(*[detect_negative_weight_cycle(graph) for graph in graphs])"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-28",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-28",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "29.1 Sample Dataset",
    "text": "29.1 Sample Dataset\n7\n5 -2 4 7 8 -10 11"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-28",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-28",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "29.2 Sample Output",
    "text": "29.2 Sample Output\n-10 -2 4 5 7 8 11"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-27",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-27",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "29.3 Solution",
    "text": "29.3 Solution\nfrom typing import List\n\ndef parse_integers(input_line: str) -&gt; List[int]:\n    return [int(number) for number in input_line.split()]\n\ndef three_way_partition(array: List[int], start: int = None, end: int = None) -&gt; tuple:\n    if start is None:\n        start = 0\n    if end is None:\n        end = len(array) - 1\n    pivot = array[start]\n    current = start\n    while current &lt;= end:\n        if array[current] &lt; pivot:\n            array[current], array[start] = array[start], array[current]\n            current += 1\n            start += 1\n        elif array[current] &gt; pivot:\n            array[current], array[end] = array[end], array[current]\n            end -= 1\n        else:\n            current += 1\n    return start, end\n\ndef quick_sort(array: List[int]):\n    def quick_sort_recursive(array: List[int], start: int, end: int):\n        if start &lt; end:\n            partition_start, partition_end = three_way_partition(array, start, end)\n            if start &lt; partition_start:\n                quick_sort_recursive(array, start, partition_start - 1)\n            if end &gt; partition_end:\n                quick_sort_recursive(array, partition_end + 1, end)\n\n    quick_sort_recursive(array, 0, len(array) - 1)\n\nsample_input = \"\"\"\n7\n5 -2 4 7 8 -10 11\n\"\"\"\n\n_, input_numbers = sample_input.strip().split(\"\\n\")\nnumbers = parse_integers(input_numbers)  # Convert the input string to a list of integers\nquick_sort(numbers)\nprint(*numbers)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-29",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-29",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "30.1 Sample Dataset",
    "text": "30.1 Sample Dataset\n6 7\n4 1\n1 2\n2 4\n5 6\n3 2\n5 3\n3 5"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-29",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-29",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "30.2 Sample Output",
    "text": "30.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-28",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-28",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "30.3 Solution",
    "text": "30.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict, Set, Union, Iterator\nfrom io import StringIO\n\nGraph = Dict[int, List[Union[int, Dict[str, int]]]]\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    return next(line.strip() for line in input_iterator if line.strip())\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Graph:\n    node_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    graph = {n: [] for n in range(1, node_count + 1)}\n    \n    for _ in range(edge_count):\n        edge = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            source, target, weight = edge\n            graph[source].append({\"n\": target, \"w\": weight})\n            if not is_directed:\n                graph[target].append({\"n\": source, \"w\": weight})\n        else:\n            source, target = edge\n            graph[source].append(target)\n            if not is_directed:\n                graph[target].append(source)\n\n    return graph\n\ndef get_graph_nodes(graph: Graph) -&gt; Set[int]:\n    return set(graph.keys())\n\ndef topological_sort(graph: Graph) -&gt; List[int]:\n    def dfs(node: int, visited: Set[int], stack: List[int]):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, stack)\n        stack.append(node)\n\n    visited: Set[int] = set()\n    stack: List[int] = []\n    for node in get_graph_nodes(graph):\n        if node not in visited:\n            dfs(node, visited, stack)\n\n    return stack[::-1]\n\ndef find_component(start_node: int, graph: Graph) -&gt; Set[int]:\n    def visit(node: int, visited: Set[int]) -&gt; Set[int]:\n        visited.add(node)\n        for neighbor in set(graph[node]) - visited:\n            visit(neighbor, visited)\n        return visited\n\n    return visit(start_node, set())\n\ndef reverse_graph(graph: Graph) -&gt; Graph:\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for child in graph[node]:\n            reversed_graph[child].append(node)\n    return reversed_graph\n\ndef strongly_connected_components(graph: Graph) -&gt; Iterator[Set[int]]:\n    order = topological_sort(graph)\n    reversed_graph = reverse_graph(graph)\n    while order:\n        node = order.pop(0)\n        component = find_component(node, reversed_graph)\n        order = [x for x in order if x not in component]\n        for key in reversed_graph.keys():\n            reversed_graph[key] = [n for n in reversed_graph[key] if n not in component]\n        yield component\n\nsample_input = \"\"\"\n6 7\n4 1\n1 2\n2 4\n5 6\n3 2\n5 3\n3 5\n\"\"\"\n\ninput_iterator = iter(StringIO(sample_input.strip()).readlines())\ngraph = parse_graph(input_iterator, is_directed=True)\nprint(len(list(strongly_connected_components(graph))))"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-30",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-30",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "31.1 Sample Dataset",
    "text": "31.1 Sample Dataset\n2\n\n2 4\n1 2\n-1 2\n1 -2\n-1 -2\n\n3 4\n1 2\n2 3\n-1 -2\n-2 -3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-30",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-30",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "31.2 Sample Output",
    "text": "31.2 Sample Output\n0\n1 1 -2 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-29",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-29",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "31.3 Solution",
    "text": "31.3 Solution\nimport sys\nfrom collections import defaultdict\nfrom io import StringIO\n\ndef parse_integers(line):\n    return list(map(int, line.split()))\n\nclass RecursionLimitManager:\n    def __init__(self, new_limit):\n        self.new_limit = new_limit\n\n    def __enter__(self):\n        self.old_limit = sys.getrecursionlimit()\n        sys.setrecursionlimit(self.new_limit)\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        sys.setrecursionlimit(self.old_limit)\n\ndef reverse_graph(original_graph):\n    reversed_graph = defaultdict(list)\n    for node in original_graph:\n        for neighbor in original_graph[node]:\n            reversed_graph[neighbor].append(node)\n    return reversed_graph\n    \ndef find_strongly_connected_components(graph):\n    node_order = topological_sort(graph)\n    reversed_graph = reverse_graph(graph)\n    while node_order:\n        start_node = node_order.pop(0)\n        component = find_component(start_node, reversed_graph)\n        node_order = [node for node in node_order if node not in component]\n        for key in reversed_graph.keys():\n            reversed_graph[key] = [node for node in reversed_graph[key] if node not in component]\n        yield component\n\ndef find_component_index(node, components):\n    for index, component in enumerate(components):\n        if node in component:\n            return index\n            \ndef condense_graph(original_graph, components):\n    condensed_graph = {}\n    for index, component in enumerate(components):\n        condensed_graph[index] = set(\n            [\n                find_component_index(neighbor, components)\n                for node in component\n                for neighbor in original_graph[node]\n                if neighbor not in component\n            ]\n        )\n    return condensed_graph\n\ndef topological_sort(graph):\n    def depth_first_search(node, visited_nodes, node_stack):\n        visited_nodes[node] = True\n        for neighbor in graph[node]:\n            if not visited_nodes[neighbor]:\n                depth_first_search(neighbor, visited_nodes, node_stack)\n        node_stack.append(node)\n\n    visited_nodes = defaultdict(bool)\n    node_stack = []\n    for node in get_graph_nodes(graph):\n        if not visited_nodes[node]:\n            depth_first_search(node, visited_nodes, node_stack)\n\n    return node_stack[::-1]\n\ndef parse_2sat_instances(input_handle):\n    instance_count = int(next(input_handle))\n    for _ in range(instance_count):\n        yield parse_2sat_instance(input_handle)\n\ndef parse_2sat_instance(input_handle):\n    info = next(input_handle)\n    if info == \"\\n\":\n        info = next(input_handle)\n    variable_count, clause_count = parse_integers(info)\n    clauses = [next(input_handle) for _ in range(clause_count)]\n    implication_graph = {}\n\n    for variable in range(1, variable_count + 1):\n        implication_graph[variable] = list()\n        implication_graph[-variable] = list()\n\n    for clause in clauses:\n        literal1, literal2 = parse_integers(clause)\n        implication_graph[-literal1].append(literal2)\n        implication_graph[-literal2].append(literal1)\n\n    return implication_graph\n\ndef solve_2sat(implication_graph):\n    components = list(find_strongly_connected_components(implication_graph))\n    condensed_graph = condense_graph(implication_graph, components)\n\n    for component_index in topological_sort(condensed_graph):\n        for literal in components[component_index]:\n            if -literal in components[component_index]:\n                return 0, []\n\n    assignment = []\n    for component_index in reversed(topological_sort(condensed_graph)):\n        for literal in components[component_index]:\n            if literal not in assignment and -literal not in assignment:\n                assignment.append(literal)\n\n    return 1, sorted(assignment, key=lambda x: abs(x))\n\nsample_input = \"\"\"\n2\n\n2 4\n1 2\n-1 2\n1 -2\n-1 -2\n\n3 4\n1 2\n2 3\n-1 -2\n-2 -3\n\"\"\"\n\nwith RecursionLimitManager(5000):\n    input_iterator = iter(StringIO(sample_input.strip()).readlines())\n    implication_graphs = parse_2sat_instances(input_iterator)\n    for implication_graph in implication_graphs:\n        is_satisfiable, satisfying_assignment = solve_2sat(implication_graph)\n        print(is_satisfiable, *satisfying_assignment)"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-31",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-31",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "32.1 Sample Dataset",
    "text": "32.1 Sample Dataset\n2\n\n3 2\n3 2\n2 1\n\n3 2\n3 2\n1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-31",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-31",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "32.2 Sample Output",
    "text": "32.2 Sample Output\n3 -1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-30",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-30",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "32.3 Solution",
    "text": "32.3 Solution\nfrom collections import defaultdict\nfrom typing import List, Dict, Union, Iterator\nfrom io import StringIO\n\nGraph = Dict[int, List[Union[int, Dict[str, int]]]]\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return [int(num) for num in line.split()]\n\ndef read_non_empty_line(input_iterator: Iterator[str]) -&gt; str:\n    return next(line.strip() for line in input_iterator if line.strip())\n\ndef parse_graph(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Graph:\n    node_count, edge_count = parse_integers(read_non_empty_line(input_iterator))\n    \n    graph = {node: [] for node in range(1, node_count + 1)}\n    \n    for _ in range(edge_count):\n        edge = parse_integers(read_non_empty_line(input_iterator))\n        if is_weighted:\n            source, target, weight = edge\n            graph[source].append({\"n\": target, \"w\": weight})\n            if not is_directed:\n                graph[target].append({\"n\": source, \"w\": weight})\n        else:\n            source, target = edge\n            graph[source].append(target)\n            if not is_directed:\n                graph[target].append(source)\n\n    return graph\n\ndef parse_multiple_graphs(input_iterator: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; List[Graph]:\n    test_case_count = int(read_non_empty_line(input_iterator))\n    return [parse_graph(input_iterator, is_directed, is_weighted) for _ in range(test_case_count)]\n\ndef bfs(graph: Graph, start_node=1) -&gt; List[int]:\n    node_count = len(graph)\n    distances = [-1 for _ in range(node_count + 1)]\n    distances[start_node] = 0\n    queue = [start_node]\n    \n    while queue:\n        current_node = queue.pop(0)\n        for neighbor in graph[current_node]:\n            if distances[neighbor] == -1:\n                queue.append(neighbor)\n                distances[neighbor] = distances[current_node] + 1\n    return distances[1:]\n\ndef find_good_start_node(graph: Graph) -&gt; int:\n    for node in graph:\n        distances = bfs(graph, node)\n        all_nodes_reachable = [distance &gt;= 0 for distance in distances]\n        if all(all_nodes_reachable):\n            return node\n    return -1\n\nsample_input = \"\"\"\n2\n\n3 2\n3 2\n2 1\n\n3 2\n3 2\n1 2\n\"\"\"\n\ninput_iterator = iter(StringIO(sample_input.strip()).readlines())\n\ngraphs = parse_multiple_graphs(input_iterator, is_directed=True)\nprint(*[find_good_start_node(g) for g in graphs])"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-32",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-32",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "33.1 Sample Dataset",
    "text": "33.1 Sample Dataset\n2\n\n3 2\n3 2\n2 1\n\n3 2\n3 2\n1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-32",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-32",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "33.2 Sample Output",
    "text": "33.2 Sample Output\n1 -1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-31",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-31",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "33.3 Solution",
    "text": "33.3 Solution\nimport sys\nfrom collections import defaultdict\n\ndef parse_integers(string):\n    return list(map(int, string.split()))\n\ndef create_graph(input_stream, is_directed=False, is_weighted=False):\n    while True:\n        try:\n            graph_info = next(input_stream).strip()\n            if graph_info:\n                break\n        except StopIteration:\n            return None\n\n    try:\n        vertex_count, edge_count = parse_integers(graph_info)\n    except ValueError:\n        return None\n\n    edge_list = []\n    for _ in range(edge_count):\n        try:\n            edge = next(input_stream).strip()\n            if edge:\n                edge_list.append(edge)\n        except StopIteration:\n            break\n\n    adjacency_list = {v: [] for v in range(1, vertex_count + 1)}\n\n    for edge in edge_list:\n        if is_weighted:\n            source, target, weight = parse_integers(edge)\n            adjacency_list[source].append({\"vertex\": target, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[target].append({\"vertex\": source, \"weight\": weight})\n        else:\n            source, target = parse_integers(edge)\n            adjacency_list[source].append(target)\n            if not is_directed:\n                adjacency_list[target].append(source)\n\n    return adjacency_list\n\ndef parse_multiple_graphs(input_stream, is_directed=False, is_weighted=False):\n    try:\n        graph_count = int(next(input_stream).strip())\n    except (StopIteration, ValueError):\n        return []\n\n    graph_list = []\n    for _ in range(graph_count):\n        graph = create_graph(input_stream, is_directed=is_directed, is_weighted=is_weighted)\n        if graph is not None:\n            graph_list.append(graph)\n        else:\n            break\n    return graph_list\n\ndef reverse_graph(graph):\n    reversed_graph = defaultdict(list)\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            reversed_graph[neighbor].append(vertex)\n    return reversed_graph\n\ndef get_all_vertices(graph):\n    vertex_set = set()\n    for vertex, neighbors in graph.items():\n        vertex_set.add(vertex)\n        vertex_set.update(neighbors)\n    return vertex_set\n\ndef topological_sort(graph):\n    def dfs(vertex, visited, stack):\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n        stack.append(vertex)\n\n    visited = defaultdict(bool)\n    stack = []\n    for vertex in get_all_vertices(graph):\n        if not visited[vertex]:\n            dfs(vertex, visited, stack)\n\n    return stack[::-1]\n\ndef find_connected_component(start_vertex, graph):\n    def dfs(vertex, visited):\n        visited.add(vertex)\n        for neighbor in set(graph[vertex]) - visited:\n            dfs(neighbor, visited)\n        return visited\n\n    return dfs(start_vertex, set())\n\ndef strongly_connected_components(graph):\n    vertex_order = topological_sort(graph)\n    reversed_graph = reverse_graph(graph)\n    while vertex_order:\n        start_vertex = vertex_order.pop(0)\n        component = find_connected_component(start_vertex, reversed_graph)\n        vertex_order = [v for v in vertex_order if v not in component]\n        for vertex in reversed_graph.keys():\n            reversed_graph[vertex] = [v for v in reversed_graph[vertex] if v not in component]\n        yield component\n\ndef hamiltonian_dag(graph):\n    sorted_vertices = topological_sort(graph)\n    for v1, v2 in zip(sorted_vertices, sorted_vertices[1:]):\n        if v2 not in graph[v1]:\n            return [-1]\n    return [1] + sorted_vertices\n\ndef find_component_index(vertex, components):\n    for index, component in enumerate(components):\n        if vertex in component:\n            return index\n\ndef condense_graph(graph, components):\n    condensed_graph = {}\n    for i, component in enumerate(components):\n        condensed_graph[i] = set(\n            find_component_index(neighbor, components)\n            for vertex in component\n            for neighbor in graph[vertex]\n            if neighbor not in component\n        )\n    return condensed_graph\n\ndef is_semi_connected(graph):\n    components = list(strongly_connected_components(graph))\n    condensed_graph = condense_graph(graph, components)\n    return -1 if hamiltonian_dag(condensed_graph) == [-1] else 1\n\nsample_input = \"\"\"\n2\n\n3 2\n3 2\n2 1\n\n3 2\n3 2\n1 2\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\ninput_iterator = iter(input_lines)\ngraphs = parse_multiple_graphs(input_iterator, is_directed=True)\nprint(*[is_semi_connected(g) for g in graphs])"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-33",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-dataset-33",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "34.1 Sample Dataset",
    "text": "34.1 Sample Dataset\n5 6\n2 3 4\n4 3 -2\n1 4 1\n1 5 -3\n2 4 -2\n5 4 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-33",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#sample-output-33",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "34.2 Sample Output",
    "text": "34.2 Sample Output\n0 x -4 -2 -3"
  },
  {
    "objectID": "posts/qmd/Rosalind_algorithmicHeights.html#solution-32",
    "href": "posts/qmd/Rosalind_algorithmicHeights.html#solution-32",
    "title": "Rosalind Algorithmic Heights 문제풀이",
    "section": "34.3 Solution",
    "text": "34.3 Solution\nfrom math import inf\nfrom typing import List, Dict, Set, Iterator, Union, Optional\nfrom collections import defaultdict\n\ndef parse_integers(line: str) -&gt; List[int]:\n    return list(map(int, line.split()))\n\ndef create_graph(input_stream: Iterator[str], is_directed: bool = False, is_weighted: bool = False) -&gt; Dict[int, List[Union[int, Dict[str, int]]]]:\n    graph_info = next(input_stream)\n    if graph_info == \"\\n\":\n        graph_info = next(input_stream)\n    \n    vertex_count, edge_count = parse_integers(graph_info)\n    edge_list = [next(input_stream) for _ in range(edge_count)]\n    adjacency_list: Dict[int, List[Union[int, Dict[str, int]]]] = {v: [] for v in range(1, vertex_count + 1)}\n\n    for edge in edge_list:\n        if is_weighted:\n            source, target, weight = parse_integers(edge)\n            adjacency_list[source].append({\"vertex\": target, \"weight\": weight})\n            if not is_directed:\n                adjacency_list[target].append({\"vertex\": source, \"weight\": weight})\n        else:\n            source, target = parse_integers(edge)\n            adjacency_list[source].append(target)\n            if not is_directed:\n                adjacency_list[target].append(source)\n\n    return adjacency_list\n\ndef get_all_vertices(graph: Dict[int, List[Union[int, Dict[str, int]]]]) -&gt; Set[int]:\n    vertex_set: Set[int] = set()\n    for vertex, neighbors in graph.items():\n        vertex_set.add(vertex)\n        vertex_set.update([n if isinstance(n, int) else n[\"vertex\"] for n in neighbors])\n    return vertex_set\n\ndef topological_sort(graph: Dict[int, List[int]]) -&gt; List[int]:\n    def depth_first_search(vertex: int, visited: Dict[int, bool], stack: List[int]) -&gt; None:\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                depth_first_search(neighbor, visited, stack)\n        stack.append(vertex)\n\n    visited: Dict[int, bool] = defaultdict(bool)\n    stack: List[int] = []\n    for vertex in get_all_vertices(graph):\n        if not visited[vertex]:\n            depth_first_search(vertex, visited, stack)\n\n    return stack[::-1]\n\ndef simplify_graph(graph: Dict[int, List[Dict[str, int]]]) -&gt; Dict[int, List[int]]:\n    return {k: [x[\"vertex\"] for x in v] for k, v in graph.items()}\n\ndef shortest_distances_acyclic_graph(graph: Dict[int, List[Dict[str, int]]]) -&gt; List[Union[str, int]]:\n    vertex_count = len(graph)\n    distances = [inf for _ in range(vertex_count + 1)]\n    distances[1] = 0\n    topological_order = topological_sort(simplify_graph(graph))\n    \n    for current_vertex in topological_order:\n        seen_vertices = set()\n        for edge in reversed(graph[current_vertex]):\n            neighbor = edge[\"vertex\"]\n            if neighbor not in seen_vertices:\n                seen_vertices.add(neighbor)\n                if distances[current_vertex] + edge[\"weight\"] &lt; distances[neighbor]:\n                    distances[neighbor] = distances[current_vertex] + edge[\"weight\"]\n    \n    return [\"x\" if d == inf else d for d in distances[1:]]\n\nsample_input = \"\"\"\n5 6\n2 3 4\n4 3 -2\n1 4 1\n1 5 -3\n2 4 -2\n5 4 1\n\"\"\"\n\ninput_lines: List[str] = sample_input.strip().split(\"\\n\")\ninput_iterator: Iterator[str] = iter(input_lines)\nresult = shortest_distances_acyclic_graph(create_graph(input_iterator, is_directed=True, is_weighted=True))\nprint(*result)"
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html",
    "href": "posts/qmd/learn_Mojo_lang.html",
    "title": "Mojo 프로그래밍 언어",
    "section": "",
    "text": "Python 은 세계에서 가장 널리 사용되는 프로그래밍 언어 중 하나로 사용자 친화적인 성격 덕분에 다양한 분야에서 활발하게 활용되고 있습니다. 웹 개발자, 데이터 과학자, 마케터, 그리고 AI 전문가들까지, 여러 분야의 전문가들이 Python 을 선호하는 이유는 초보자도 쉽게 배울 수 있고 읽기와 쓰기가 쉽기 때문입니다.\n그러나 Python 은 C++ 이나 Rust 와 비교했을 때 실행 속도가 느리고 배포 과정이 복잡하다는 단점이 있습니다. 반면, C++ 은 속도가 빠르지만 배우고 사용하기 어렵다는 문제점이 있죠. 이런 문제를 해결하기 위해 등장한 언어가 바로 Mojo입니다."
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#mojo의-특징",
    "href": "posts/qmd/learn_Mojo_lang.html#mojo의-특징",
    "title": "Mojo 프로그래밍 언어",
    "section": "0.1 Mojo🔥의 특징",
    "text": "0.1 Mojo🔥의 특징\nMojo 는 Python 과 유사한 구문을 제공하면서도 병렬 처리를 최적화한 컴파일러 인프라인 MLIR 을 사용하여 성능을 크게 향상시킵니다. 특히, Mojo 를 사용하면 AI 모델을 병렬 처리하여 더 빠르고 효율적으로 실행할 수 있습니다. 실제로 Mojo 는 Python 보다 약 35,000배 빠른 속도를 자랑합니다. 또한 Mojo 는 Python 과 완벽한 호환성을 목표로 하고 있어, 기존의 Python 코드를 거의 그대로 사용할 수 있으며 추가적인 강력한 기능도 제공합니다.\n따라서, 현재 사용 중인 모든 Python 패키지와 라이브러리는 Mojo 에서 문제없이 동작합니다. 특히 Mojo 는 AI 하드웨어를 프로그래밍하는 데 사용할 수 있는데, 이는 기존의 언어로는 구현하기 어려운 복잡한 AI 하드웨어의 구조를 쉽게 처리할 수 있도록 도와줍니다.\nC++ 이나 CUDA 와 같은 기존의 고성능 프로그래밍 언어는 배우기 어렵다는 단점이 있지만, Mojo 는 이러한 복잡성을 없애고 누구나 쉽게 AI 하드웨어를 프로그래밍할 수 있게 합니다. 더불어, 사전 및 사후 처리 작업을 통해 모델을 쉽게 확장하거나 커스텀 연산을 적용할 수 있어 다양한 AI 작업에서 큰 유연성을 제공합니다. 커널 퓨전, 그래프 재작성, 형상 함수 등 고급 기능을 통해 더욱 효율적인 AI 프로그래밍이 가능합니다.\nMojo 는 Python 의 단점을 보완하면서도, 그 친숙한 구문과 강력한 성능을 결합하여 차세대 AI 프로그래밍을 이끄는 도구로 자리 잡고 있습니다.\n\n\n\n\n\n\nNote\n\n\n\nMojo 프로젝트는 이제 막 초기 단계에 있지만, 그 가능성과 전망은 매우 인상적입니다. 아직 시작 단계이지만, Mojo 가 앞으로 가져올 변화와 잠재력을 생각하면 기대감이 큽니다. Mojo 가 제공하는 풍부한 기능과 강력한 성능 향상은 그 자체로 큰 매력이며, 이것이 인공지능과 머신러닝 분야에 어떤 혁신을 가져올지 기대됩니다."
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#새-프로젝트-만들기",
    "href": "posts/qmd/learn_Mojo_lang.html#새-프로젝트-만들기",
    "title": "Mojo 프로그래밍 언어",
    "section": "1.1 1. 새 프로젝트 만들기",
    "text": "1.1 1. 새 프로젝트 만들기\n새로운 Mojo 프로젝트를 생성하기 위해 콘다 (Conda) 기반의 가상 환경 관리자이자 패키지 관리자인 magic 을 사용하겠습니다.\n\n다음 명령어로 macOS 또는 우분투 리눅스에서 magic 을 설치합니다:\ncurl -ssL https://magic.modular.com/94d3e79d-46f1-4fa6-9d1b-ee5b81f4b079 | bash\n그런 다음 터미널에 출력된 source 명령을 실행합니다.\nhello-world 라는 Mojo 프로젝트를 생성합니다:\nmagic init hello-world --format mojoproject\n이렇게 하면 hello-world 라는 디렉터리가 생성되고 Mojo 프로젝트 종속성이 설치됩니다 (Mojo 프로젝트의 유일한 종속성은 max 패키지로 MAX와 번들 로 제공됩니다.).\n프로젝트 가상 환경에서 셸을 시작합니다:\ncd hello-world && magic shell\n\n이제 가상 환경이 활성화되어 Mojo를 사용해 볼 수 있습니다. 예를 들어 다음과 같이 Mojo 버전을 확인할 수 있습니다:\nmojo --version"
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#repl에서-코드-실행하기",
    "href": "posts/qmd/learn_Mojo_lang.html#repl에서-코드-실행하기",
    "title": "Mojo 프로그래밍 언어",
    "section": "1.2 2. REPL에서 코드 실행하기",
    "text": "1.2 2. REPL에서 코드 실행하기\n명령 프롬프트에서 Mojo 코드를 작성하고 실행할 수 있는 Mojo REPL을 사용해 보겠습니다:\n\nREPL 세션을 시작하려면 mojo 를 입력합니다.\nREPL을 종료하려면 :quit 을 입력하고 Enter 키를 누르거나 Ctrl + D 를 누릅니다.\n\nREPL에서 원하는 만큼 코드를 작성할 수 있습니다. 새 줄을 시작하고 코드 작성을 계속하려면 Enter키를 누르고, Mojo가 코드를 실행하게 하려면 Enter키를 두 번 누릅니다. REPL은 코드가 저장되지 않으므로 주로 짧은 실험에 유용합니다. 따라서 실제 프로그램을 작성하려면 .mojo 소스 파일에 코드를 작성하는 편이 좋습니다."
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#mojo-파일-실행하기",
    "href": "posts/qmd/learn_Mojo_lang.html#mojo-파일-실행하기",
    "title": "Mojo 프로그래밍 언어",
    "section": "1.3 3. Mojo 파일 실행하기",
    "text": "1.3 3. Mojo 파일 실행하기\n이제 Mojo 코드를 파일로 작성하고 mojo로 실행해 보겠습니다:\n\nhello.mojo(또는 hello.🔥) 라는 이름의 파일을 만들고 다음 코드를 추가합니다:\nfn main():\n print(“Hello, world!”)\n이 정도면 충분합니다. 파일을 저장하고 터미널로 돌아갑니다.\n이제 mojo 명령어로 실행합니다:\nmojo hello.mojo"
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#실행-가능한-바이너리-빌드",
    "href": "posts/qmd/learn_Mojo_lang.html#실행-가능한-바이너리-빌드",
    "title": "Mojo 프로그래밍 언어",
    "section": "1.4 4. 실행 가능한 바이너리 빌드",
    "text": "1.4 4. 실행 가능한 바이너리 빌드\n마지막으로 동일한 코드를 실행 파일로 빌드하고 실행해 보겠습니다:\n\nbuild 명령어로 실행 파일을 만듭니다:\nmojo build hello.mojo\n실행 파일은 .mojo 파일과 동일한 이름을 사용하지만 -o 옵션을 사용해 변경할 수도 있습니다.\n그런 다음 실행 파일을 실행합니다:\n./hello\n\nbuild 명령어는 정적으로 컴파일된 바이너리 파일을 생성하므로 실행에 필요한 모든 코드와 라이브러리가 포함되어 있습니다. 그리고 가상 환경을 비활성화 하려면 exit를 입력합니다.\nexit"
  },
  {
    "objectID": "posts/qmd/learn_Mojo_lang.html#github-에서-예제-실행하기",
    "href": "posts/qmd/learn_Mojo_lang.html#github-에서-예제-실행하기",
    "title": "Mojo 프로그래밍 언어",
    "section": "1.5 5. GitHub 에서 예제 실행하기",
    "text": "1.5 5. GitHub 에서 예제 실행하기\nGitHub 의 Mojo 코드 예제에는 Magic 구성 파일이 포함되어 있으므로 간단히 리포지토리를 복제하고 magic 으로 코드를 실행할 수 있습니다. 예를 들어\n\nMojo 리포지토리를 복제합니다:\ngit clone https://github.com/modularml/mojo.git\n나이틀리(nightly) 빌드를 설치한 경우에만 nightly 브랜치로 체크 아웃하세요:\ngit checkout nightly\n예제로 이동합니다:\ncd mojo/examples\n코드를 실행합니다:\nmagic run mojo hello_interop.mojo"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html",
    "href": "posts/qmd/guide_RFantibody.html",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "",
    "text": "RFantibody는 구조 기반으로 새로운 항체와 나노바디를 디자인 할 수 있는 소프트웨어입니다. 구체적으로 RFantibody는 아래 세 가지 독립적인 소프트웨어들로 구성되어 있습니다.\n이런 RFantibody 파이프라인에 대한 자세한 내용은 공개 논문에서 확인할 수 있습니다. 또한 RFantibody는 MIT 라이선스로 비영리 및 영리 사용자 모두에게 무료입니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#docker와-gpu",
    "href": "posts/qmd/guide_RFantibody.html#docker와-gpu",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.1 Docker와 GPU",
    "text": "1.1 Docker와 GPU\nRFantibody는 Docker 컨테이너에서 실행되도록 설계되었습니다. Docker 컨테이너는 호스트 운영 체제 위에 별도의 운영 체제를 실행해서 다음과 같은 장점을 제공합니다.\n\n설치 간소화: Docker 소프트웨어 제품군만 있으면 됩니다.\n호스트 시스템 독립성: 컨테이너 내부에서 실행되므로 어디에서 실행하든 기본적으로 동일하게 작동합니다.\n\nDocker를 설치하는 방법은 공식 홈페이지를 참고하세요. 이미 Docker가 설치되어 있는지 여부는 터미널에서 which docker 로 확인할 수 있습니다. 이 명령이 경로를 반환하면 Docker를 사용할 수 있으며 실행할 준비가 된 것입니다.\n또한 RFantibody를 실행하려면 NVIDIA GPU가 필요합니다. 다음을 실행하여 NVIDIA GPU를 사용할 수 있는지 확인할 수 있습니다. nvidia-smi 이 명령이 성공적으로 실행되면 호환되는 GPU가 있는 것이며 RFantibody를 실행할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#가중치-다운로드",
    "href": "posts/qmd/guide_RFantibody.html#가중치-다운로드",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.2 가중치 다운로드",
    "text": "1.2 가중치 다운로드\n먼저 Git을 사용하여 RFantibody 저장소 클론하고 다운로드된 디렉토리로 이동합니다. 그런 모델의 가중치를 RFantibody/weights 디렉토리에 다운로드합니다.\ngit clone https://github.com/partrita/RFantibody\ncd RFantibody/\nbash include/download_weights.sh"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#rfantibody-docker-컨테이너-빌드-및-실행",
    "href": "posts/qmd/guide_RFantibody.html#rfantibody-docker-컨테이너-빌드-및-실행",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.3 RFantibody Docker 컨테이너 빌드 및 실행",
    "text": "1.3 RFantibody Docker 컨테이너 빌드 및 실행\nDocker 컨테이너를 시작할 올바른 권한이 있는지 확인하려면 다음을 실행해야 합니다.\nsudo usermod -aG docker $USER\n이 명령을 실행한 후 변경 사항이 적용되도록 터미널 세션을 다시 시작해야 합니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#docker-이미지-빌드-및-시작하기",
    "href": "posts/qmd/guide_RFantibody.html#docker-이미지-빌드-및-시작하기",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.4 Docker 이미지 빌드 및 시작하기",
    "text": "1.4 Docker 이미지 빌드 및 시작하기\nRFantibody가 다운로드된 디렉토리에서 다음 명령을 실행하여 RFantibody용 Docker 이미지를 빌드합니다.\ndocker build -t rfantibody .\n방금 빌드한 이미지를 기반으로 Docker 컨테이너를 시작하려면 다음 명령을 실행합니다.\ndocker run --name rfantibody --gpus all -v .:/home -it rfantibody\n이렇게 하면 현재 폴더를 Docker 컨테이너의 /home 폴더와 연결 할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#python-환경-설정",
    "href": "posts/qmd/guide_RFantibody.html#python-환경-설정",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.5 Python 환경 설정",
    "text": "1.5 Python 환경 설정\nRFantibody 컨테이너에서 다음 스크립트를 실행해 Python 의존성 라이브러리를 설치합니다. 구체적으로 다음이 설치 됩니다.\n\nPython 환경 빌드 준비를 위해 Deep Graph Library를 다운로드합니다.\nPoetry를 사용하여 Python 환경을 빌드합니다.\nUSalign 실행 파일을 빌드합니다.\n\nbash /home/include/setup.sh"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#hlt-파일-형식",
    "href": "posts/qmd/guide_RFantibody.html#hlt-파일-형식",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "1.6 HLT 파일 형식",
    "text": "1.6 HLT 파일 형식\nRFantibody는 각 단계 간에 PDB 파일 구조를 전달해야 합니다. 그리고 PDB 파일 구조에는 다음이 포함되어 있어야 합니다.\n\n현재 디자인 중인 항체-표적 복합체 구조 정보\n어떤 사슬이 중쇄(Heavy chain), 경쇄(Light chain) 및 표적 사슬(Target chain)인지 여부\n어떤 잔기가 어떤 CDR 루프에 있는지 여부\n\n파이프라인 단계 간에 이 정보를 전달할 수 있도록 HLT 파일이라고 하는 새로운 파일 형식을 정의해야 합니다. HLT 파일은 기본적으로 .pdb 파일이지만 다음과 같은 수정사항이 있습니다.\n\n중쇄는 사슬 ID ’H’로 표시됩니다.\n경쇄는 사슬 ID ’L’로 표시됩니다.\n표적 사슬은 (표적 사슬이 여러 개라도) 사슬 ID ’T’로 표시됩니다.\n파일의 사슬 순서는 중쇄, 경쇄, 표적 순입니다.\n파일 끝에는 각 CDR 루프 기반 절대(사슬별이 아닌) 아미노산 인덱스를 나타내는 PDB Remark가 있습니다.\n\n\n1.6.1 HLT 파일로 변환하기\nRFantibody는 입력으로 HLT 파일 변환을 수행하는 스크립트를 /scripts/util/chothia2HLT.py에 제공합니다.\n# rfantibody 컨테이너 내부에서\npoetry run python /home/scripts/util/chothia2HLT.py  \\\n    -i /home/scripts/examples/rfdiffusion/example_inputs/8tlm_chothia.pdb \\\n    -o /home/scripts/examples/rfdiffusion/example_inputs/8tlm \\\n    -H A -L B -T C\n이 스크립트는 Chothia 주석이 달린 .pdb 파일을 예상합니다. 이러한 파일의 훌륭한 소스는 PDB의 모든 항체 및 나노항체의 Chothia 주석 구조를 제공하고 몇 달마다 업데이트되는 SabDab입니다.\n또한 RFantibody 공개 논문에서 사용된 HLT 형식의 항체 및 나노바디 프레임워크는 다음 위치에 포함되어 있습니다.\n\n나노바디 프레임워크: /scripts/examples/example_inputs/h-NbBCII10.pdb\n항체 프레임워크: /scripts/examples/example_inputs/hu-4D5-8_Fv.pdb"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#한번에-실행-하기",
    "href": "posts/qmd/guide_RFantibody.html#한번에-실행-하기",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "2.1 한번에 실행 하기",
    "text": "2.1 한번에 실행 하기\n실행 방법은 아래와 같습니다.\n# rfantibody 컨테이너 내부에서\nbash /home/scripts/examples/rfdiffusion/example_9gox.sh\n텍스트 에디터로 해당 스크립트를 열어보면 아래와 같습니다. 상단의 스크립트의 변수를 원하는 값으로 수정해서 사용하도록 하세요.\n#!/bin/bash\n\n# Define common variables\nNAME=\"9gox\"\nPDB_ANTIBODY=\"CCR8_subset.pdb\"\nPDB_ANTIGEN=\"9gox_CLC.pdb\"\nHOTSPOT=\"A175, S176, G179, V180, L181\"\nDESIGN_LOOPS=\"H1:7,H2:5,H3:5-8\"\nNUM_DESIGNS=2\nSEQS_PER_STRUCT=2\n\n# Define directory structure\nBASE_DIR=\"/home/scripts\"\nINPUT_DIR=\"${BASE_DIR}/examples\"\nOUTPUT_DIR=\"${INPUT_DIR}\"\nRF_DIFFUSION_OUTPUT=\"${OUTPUT_DIR}/rfdiffusion/example_outputs/${NAME}\"\nPROTEINMPNN_OUTPUT=\"${OUTPUT_DIR}/proteinmpnn/example_outputs/${NAME}\"\nRF2_OUTPUT=\"${OUTPUT_DIR}/rf2/example_outputs/${NAME}\"\n\n# [이후 코드 생략]"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#fine-tuned-rfdiffusion",
    "href": "posts/qmd/guide_RFantibody.html#fine-tuned-rfdiffusion",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "2.2 Fine-tuned RFdiffusion",
    "text": "2.2 Fine-tuned RFdiffusion\nRFantibody의 첫 번째 단계인 항체 맞춤형 RFdiffusion 버전을 사용하는 방법을 살펴보겠습니다. 이 단계는 항체와 표적 단백질의 도킹 구조 파일을 생성합니다. 다음은 RFdiffusion을 실행하는 예제 명령입니다.\n# rfantibody 컨테이너 내부에서\npoetry run python  /home/rfantibody/scripts/rfdiffusion_inference.py \\\n  --config-path src/rfantibody/rfdiffusion/config/inference \\\n  --config-name antibody \\\n  antibody.target_pdb=/home/scripts/examples/example_inputs/rsv_site3.pdb \\\n  antibody.framework_pdb=/home/scripts/examples/example_inputs/hu-4D5-8_Fv.pdb \\\n  inference.ckpt_override_path=/home/weights/RFdiffusion_Ab.pt \\\n  'ppi.hotspot_res=[T305,T456]' \\\n  'antibody.design_loops=[L1:8-13,L2:7,L3:9-11,H1:7,H2:6,H3:5-13]' \\\n  inference.num_designs=20 \\\n  inference.output_prefix=/home/scripts/examples/example_outputs/ab_des\n위 명령어에 대해 좀 더 자세히 설명해보겠습니다.\n\nantibody.target_pdb: 항체를 디자인하려는 표적 구조의 경로입니다. 일반적으로 파이프라인 실행의 계산 비용을 줄이기 위해 잘린 표적 구조입니다. 절단 전략은 여기에서 자세히 설명합니다.\nantibody.framework_pdb: 디자인에 사용하려는 HLT 형식의 항체 프레임워크 경로입니다. RFdiffusion은 루프로 주석이 달린 프레임워크 영역의 구조와 서열만 디자인합니다. 이렇게 하면 이미 최적화된 프레임워크의 도킹 및 루프를 디자인할 수 있습니다.\ninference.ckpt_override_path: 추론에 사용할 RFdiffusion 모델 가중치 세트의 경로입니다.\nppi.hotspot_res: 에피토프를 정의하는 핫스팟 잔기 목록입니다. 일반 RFdiffusion과 동일한 형식으로 제공됩니다. 핫스팟 선택에 대한 자세한 내용은 여기에서 설명합니다.\nantibody.design_loops: 각 CDR 루프를 허용된 루프 길이 범위에 매핑하는 사전입니다. 각 루프의 길이는 이 범위에서 균일하게 샘플링되며 다른 루프에 대해 샘플링된 길이와 독립적으로 샘플링됩니다. CDR 루프가 프레임워크에 있지만 사전에 없는 경우 이 CDR 루프는 디자인 중에 서열 및 구조가 고정됩니다. CDR 루프가 사전에 포함되어 있지만 길이 범위가 제공되지 않은 경우 이 CDR 루프는 서열 및 구조가 디자인되지만 프레임워크 구조에 제공된 루프 길이로만 디자인됩니다.\ninference.num_designs: 생성해야 하는 디자인 수입니다.\ninference.output_prefix: 생성할 .pdb 파일 출력의 접두사입니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#proteinmpnn",
    "href": "posts/qmd/guide_RFantibody.html#proteinmpnn",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "2.3 ProteinMPNN",
    "text": "2.3 ProteinMPNN\n두 번째 단계는 윗 단계 RFdiffusion에서 생성된 구조 파일을 가져와 CDR 루프에 서열을 할당하는 것입니다. ProteinMPNN은 다음 명령을 사용하여 HLT 형식의 .pdb 파일 디렉토리에서 실행될 수 있습니다.\n# rfantibody 컨테이너 내부에서\npoetry run python /home/scripts/proteinmpnn_interface_design.py \\\n    -pdbdir /home/scripts/examples/example_outputs/ab \\\n    -outpdbdir /home/scripts/examples/example_outputs/ab"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#rosettafold2",
    "href": "posts/qmd/guide_RFantibody.html#rosettafold2",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "2.4 RoseTTAFold2",
    "text": "2.4 RoseTTAFold2\n마지막 단계는 항체 맞춤형 RoseTTAFold2를 사용해 방금 디자인한 서열의 구조를 예측하는 것입니다. 그런 다음 해당 항체와 타겟 단백질이 결합될 것이라고 확신하는지 평가합니다. 간단하게 다음 명령을 통해 실행할 수 있습니다.\n# rfantibody 컨테이너 내부에서\npoetry run python /home/scripts/rf2_predict.py \\\n    input.pdb_dir=/path/to/inputdir \\\n    output.pdb_dir=/path/to/outputdir"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#fine-tuned-rfdiffusion-1",
    "href": "posts/qmd/guide_RFantibody.html#fine-tuned-rfdiffusion-1",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "3.1 Fine-tuned RFdiffusion",
    "text": "3.1 Fine-tuned RFdiffusion\n첫 번째 단계인 RFdiffusion를 통해 아래 그림과 같이 타겟 단백질에 결합하는 항체 VH, VL 구조를 형성 할 수 있습니다.\n\n\n\n\n\n다만 생성된 항체 구조에는 아미노산 residue에 대한 정보는 없고 Carbon alpha에 대한 위치 정보만 들어 있습니다. 따라서 다음 단계인 ProteinMPNN을 통해 구조에 맞는 아미노산 서열을 생성해야 합니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#proteinmpnn-1",
    "href": "posts/qmd/guide_RFantibody.html#proteinmpnn-1",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "3.2 ProteinMPNN",
    "text": "3.2 ProteinMPNN\nProteinMPNN을 실행하면 아래 예시와 같은 서열 정보가 포함된 .pdb파일이 만들어집니다. 이렇게 만들어진 서열이 진짜 앞에서 생성한 구조 파일에 적합한지 평가를 위해 다음 단계인 Protein folding이 필요합니다.\n&gt;ab_0_dldesign_0_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGASISSGIINWVRQAPGQGLEWMGRVDRSGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS\n&gt;ab_0_dldesign_1_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGDSISSGIINWVRQAPGQGLEWMGRVDRAGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS\n&gt;ab_0_dldesign_2_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGDSISSGIINWVRQAPGQGLEWMGRVDRSGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS\n&gt;ab_0_dldesign_3_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGASISSGIINWVRQAPGQGLEWMGRVDRSGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS\n&gt;ab_0_dldesign_4_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGASISSGIINWVRQAPGQGLEWMGRVDRSGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS\n&gt;ab_0_dldesign_5_H\nQVQLVQSGAEVKKPGSSVKVSCKAVGASISSGIINWVRQAPGQGLEWMGRVDRAGGAYYAQKFQGRVTIT\nADESTSTAYMELRSEDTAVYYCALEVNGYLTGWGQGTLVTVSSAS"
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#rosettafold2-1",
    "href": "posts/qmd/guide_RFantibody.html#rosettafold2-1",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "3.3 RoseTTAFold2",
    "text": "3.3 RoseTTAFold2\nRoseTTAFold2의 결과를 확인해보면 아래와 같이 아미노산의 서열이 들어가 있는 것을 확인 할 수 있습니다.\n\n\n\n\n\n이렇게 항체와 타겟 단백질의 결합 구조 파일을 생성하는 것으로 De novo antibody discovery가 완료되었습니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#표적-부위-선택",
    "href": "posts/qmd/guide_RFantibody.html#표적-부위-선택",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.1 표적 부위 선택",
    "text": "4.1 표적 부위 선택\n단백질의 모든 부위가 항체에 결합할 수 있는 것은 아닙니다. 즉, 결합에 적합한 후보가 되려면 해당 부위에 결합제가 상호작용할 수 있는 최소 3개 이상의 소수성 잔기가 있어야 합니다. 그리고 전하를 띤 극성 아미노산에 대한 결합은 여전히 상당히 어렵습니다. 또한 당화가 일어나는 부위에 대한 결합도 어렵습니다. 그리고 구조가 유연한 루프에 대한 결합도 역사적으로 어려운 부위이지만 RFdiffusion을 사용한 논문도 존재합니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#나노바디-도킹-문제",
    "href": "posts/qmd/guide_RFantibody.html#나노바디-도킹-문제",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.2 나노바디 도킹 문제",
    "text": "4.2 나노바디 도킹 문제\nde novo 나노바디 설계를 해보면 많은 경우 CDR이 아닌 측면으로 도킹하는 것을 볼 수 있습니다. 이는 오류가 아니며 실제로 나노바디가 종종 이런 측면으로 결합하기 때문입니다. 따라서 핫스팟과 CDR 길이를 조정한다면 항체와 비슷한 도킹 결과를 얻을 수 있습니다. 다만 항체와 유사한 도킹을 원한다면 항체 프레임워크를 사용하여 설계하는 편이 더 좋은 접근법입니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#표적-단백질-잘라내기",
    "href": "posts/qmd/guide_RFantibody.html#표적-단백질-잘라내기",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.3 표적 단백질 잘라내기",
    "text": "4.3 표적 단백질 잘라내기\nRFdiffusion과 RF2의 계산 시간은 시스템의 잔기 수 N에 대해 \\(O(N^2)\\)로 증가합니다. RFantibody 파이프라인의 모든 단계는 잘라낸 표적 단백질을 허용하도록 설계되었고 따라서 표적 단백질의 크기가 큰 경우 계산량을 줄이기 위해 불필요한 서열은 잘라내는 것이 좋습니다. 물론 표적 단백질의 어느 부분을 잘라낼 것인가는 사용자에 따라 의견이 다를 것입니다. 일반적으로는 2차 구조를 형성하는 부위는 피하고 링커로 연결된 지점을 잘라내는 것이 추천됩니다. 그러나 바이러스 스파이크 단백질과 같은 단백질은 이런 점이 덜 명확할 수 있습니다. 그러니 PyMol을 사용해 직접 눈으로 보고 표적 단백질을 잘라내는 것을 추천합니다. 또한 원하는 표적 부위(핫스팟) 주변 10Å의 단백질은 남겨두는 것을 권장합니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#결합-위치핫스팟-고르기",
    "href": "posts/qmd/guide_RFantibody.html#결합-위치핫스팟-고르기",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.4 결합 위치(핫스팟) 고르기",
    "text": "4.4 결합 위치(핫스팟) 고르기\n결합 위치(핫스팟)은 항체가 표적 단백질에 상호작용하는 부분입니다. RFantibody 모델의 학습 과정에서 핫스팟은 항체의 CDR 잔기와 Cβ 거리가 8Å 미만인 부위로 지정되었습니다. RFantibody는 일반 RFdiffusion보다 선택된 핫스팟에 더 민감한 것으로 나타났고 부적절한 핫스팟이 지정된 경우 도킹되지 않은 항체를 생성합니다. 따라서 수천 개의 항체를 생성하기 전에 소수의 항체 생성을 실험해보고 지정한 핫스팟이 적절한지 판단해보세요."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#항체-설계-규모에-대하여",
    "href": "posts/qmd/guide_RFantibody.html#항체-설계-규모에-대하여",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.5 항체 설계 규모에 대하여",
    "text": "4.5 항체 설계 규모에 대하여\n논문에서 보고된 일부 표적 단백질의 경우 단지 95개만 설계했었어도 VHH 결합체를 식별할 수 있었습니다. 그러나 일반적으로는 1만개 정도의 항체 서열을 생성해야 할 것으로 예상합니다. 왜냐하면 현재 신뢰할 수 있는 in silico 필터링 지표가 없기 때문입니다. 현재는 긍정적이든 부정적이든 항체 설계를 통해 얻은 데이터가 부족하고 앞으로 더 많은 실험 데이터가 커뮤니티에 공유 되어야 합니다. 그러면 더 신뢰할 수 있는 in silico 필터를 만들 수 있을 것입니다. 그러면 더 높은 성공률을 통해 저렴한 항체 설계를 할 수 있을 것입니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#cdr-길이-선택",
    "href": "posts/qmd/guide_RFantibody.html#cdr-길이-선택",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.6 CDR 길이 선택",
    "text": "4.6 CDR 길이 선택\n우리의 설계 캠페인에 사용된 루프 범위는 RFdiffusion 예제 파일에 제공되어 있습니다. 이 범위는 각 루프의 자연 발생 길이 빈도를 살펴보고 대부분의 밀도를 포함하도록 결정했습니다. 또한 비교적 짧은 H3 루프를 선택하려고 했는데, 이는 설계와 예측이 더 쉬우면서도 효과적으로 결합할 수 있는 충분한 길이를 제공할 것이라고 판단했기 때문입니다. 단백질의 소수성 포켓을 표적으로 할 때는 길이가 긴 H3 서열이 유용할 것입니다. 따라서 이런 경우에는 예제에서 제공하는 것보다 H3 범위를 늘려야 합니다."
  },
  {
    "objectID": "posts/qmd/guide_RFantibody.html#in-silico-필터링-전략",
    "href": "posts/qmd/guide_RFantibody.html#in-silico-필터링-전략",
    "title": "RFantibody로 de novo antibody discovery",
    "section": "4.7 in silico 필터링 전략",
    "text": "4.7 in silico 필터링 전략\n다음과 같은 최소한의 필터링 기준을 권장합니다\n\nRF2 pAE &lt; 10\nRMSD(디자인과 RF2 예측결과의 차이) &lt; 2Å\nRosetta ddG &lt; -20\n\n현재 RFantibody 파이프라인의 가장 큰 문제는 효과적인 in silico 필터가 없다는 것입니다. 그러니 더 많은 실험을 통해 데이터를 수집할 필요가 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_readPaper.html",
    "href": "posts/qmd/guide_readPaper.html",
    "title": "학술 논문을 효율적으로 읽는 법",
    "section": "",
    "text": "데이터 과학 분야에서 머신 러닝, 딥 러닝, 새로운 데이터베이스 및 데이터 엔지니어링과 같은 분야에서 사용되는 기술들은 매우 복잡합니다. 게다가 새로운 기술들이 매주 쏟아져 나오고 있어서 최신 동향을 따라잡고 필요한 정보를 얻기 위해서는 꾸준히 논문을 읽고 공부해야 합니다. 다만, 논문을 읽는 것은 쉬운 일이 아닙니다. 왜냐하면 논문은 독자들이 전문적인 지식을 갖추고 있다고 가정하고 쓰여지기 때문입니다. 그러나 논문을 읽는 것은 연습과 노력을 통해 향상될 수 있는 기술로 꾸준한 연습과 학습을 통해 논문을 이해하고 최신 지식을 습득하는 능력을 키워나갈 수 있습니다. 따라서 논문을 읽는 것을 두려워하지 말고 꾸준히 도전하고 연습하여 능력을 향상시켜 나가는 것이 중요합니다."
  },
  {
    "objectID": "posts/qmd/guide_readPaper.html#논문-검색",
    "href": "posts/qmd/guide_readPaper.html#논문-검색",
    "title": "학술 논문을 효율적으로 읽는 법",
    "section": "5.1 논문 검색",
    "text": "5.1 논문 검색\n\narXiv: 주로 과학, 수학, 공학, 컴퓨터 과학, 물리학, 통계학 등 다양한 분야의 논문을 자유롭게 다운로드하고 읽을 수 있습니다.\nPubMed: 미국 국립보건원 국립의학도서관 (NIH/NLM) 에서 제공하는 PubMed Central®(PMC) 은 생명과학 및 의학 관련 논문 전문 보관소입니다. PubMed 는 의학 및 생명 과학 분야의 논문을 검색하고 접근하기에 매우 유용한 도구입니다.\nGoogle Scholar: 구글의 검색 엔진을 활용하여 학술 문헌을 검색하는 도구입니다. 간단한 검색어를 입력하면 다양한 분야의 논문, 학위 논문, 책, 초록 등을 검색할 수 있습니다.\nSci-hub: 유료 학술 논문에 무료로 접근할 수 있게 해주는 웹사이트입니다. 저작권 문제로 논란의 여지가 있지만, 많은 연구자들이 이용하고 있습니다.\nSciencehubmutalaid: 연구자들이 서로 논문을 공유하는 사이트로 주로 유료 학술 논문을 위주로 읽고 싶은 논문에 대해서 요청을 하면 권한이 있는 다른 사람이 찾아 주고는 합니다.\nSCICSPACE: 논문 검색, 요약, 및 시각화 기능을 제공하는 플랫폼으로 LLM 기술을 사용해 문헌 조사 과정을 간소화하고 효율적으로 만듭니다."
  },
  {
    "objectID": "posts/qmd/guide_readPaper.html#참고-문헌-관리",
    "href": "posts/qmd/guide_readPaper.html#참고-문헌-관리",
    "title": "학술 논문을 효율적으로 읽는 법",
    "section": "5.2 참고 문헌 관리",
    "text": "5.2 참고 문헌 관리\n\nZotero: 오픈 소스 참고 문헌 관리 소프트웨어로, 웹 브라우저와 통합되어 온라인 자료를 쉽게 수집하고 관리할 수 있습니다.\nMendeley: 참고 문헌 관리와 학술 소셜 네트워크 기능을 결합한 도구로, PDF 주석 기능과 협업 기능이 강점입니다.\nPaperPile: 클라우드 기반의 참고 문헌 관리 도구로, Google Docs 와의 통합이 뛰어나 온라인 작업 환경에 적합합니다.\nEndnote: 광범위한 참고 문헌 관리 기능을 제공하는 소프트웨어로, 문헌 수집, 조직화, 인용 및 서지 작성을 효율적으로 수행할 수 있습니다. Microsoft Word 와의 통합이 뛰어나며, 다양한 인용 스타일을 지원합니다."
  },
  {
    "objectID": "posts/qmd/guide_readPaper.html#footnotes",
    "href": "posts/qmd/guide_readPaper.html#footnotes",
    "title": "학술 논문을 효율적으로 읽는 법",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHubbard, K. E., & Dunbar, S. D. (2017). Perceptions of scientific research literature and strategies for reading papers depend on academic career stage. PloS one, 12(12), e0189753.↩︎\nShout out to Chris at CoffeeCycle! Simply the best coffee in San Diego.↩︎\nKeshav, S. (2007). How to read a paper. ACM SIGCOMM Computer Communication Review, 37(3), 83–84.↩︎"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#맘바mamba는-또-뭐죠",
    "href": "posts/qmd/setup_miniforge.html#맘바mamba는-또-뭐죠",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "3.1 맘바(mamba)는 또 뭐죠?",
    "text": "3.1 맘바(mamba)는 또 뭐죠?\n콘다의 다른 단점에 패키지 설치 속도가 느리다는 점이 었습니다. 그래서 C++으로 작성된 맘바라는 도구가 새로 나오게 되었죠.\n\n파이썬 생태계에는 항상 새로운 도구가 우후죽순 나오죠. 그것이 장점이자 단점 입니다."
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#설치하기",
    "href": "posts/qmd/setup_miniforge.html#설치하기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "3.2 설치하기",
    "text": "3.2 설치하기\n공식문서에서 각각의 OS에 맞는 설치 방법을 찾아 볼 수 있습니다. 저는 리눅스를 사용하기에 아래 명령어로 설치 하였습니다."
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#리눅스와-맥",
    "href": "posts/qmd/setup_miniforge.html#리눅스와-맥",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "3.3 리눅스와 맥",
    "text": "3.3 리눅스와 맥\nwget \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\"\nbash Mambaforge-$(uname)-$(uname -m).sh"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#윈도우즈",
    "href": "posts/qmd/setup_miniforge.html#윈도우즈",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "3.4 윈도우즈",
    "text": "3.4 윈도우즈\nGithub repo를 참고하세요."
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#가상환경-만들기",
    "href": "posts/qmd/setup_miniforge.html#가상환경-만들기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.1 가상환경 만들기",
    "text": "4.1 가상환경 만들기\n맘바포지의 (base) 환경에 왠만하면 아무런 패키지를 설치하지 않을 것을 권장합니다. 따라서 새로운 가상환경인 ipynb를 만들어 주피터랩을 사용해 보겠습니다.\nmamba create -n ipynb python=3.11 pip r-base r-essentials\n기존 conda 명령어에서 mamba로 바꾸기만 하면 됩니다. python=3.11을 통해 파이썬 버전을 지정할 수 있고, PYPI 패키지를 설치하기 위해 pip도 같이 설치해줍니다. 저는 R을 사용하기 위해 r-base, r-essential 도 설치해주었습니다."
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#가상환경-활성화-하기",
    "href": "posts/qmd/setup_miniforge.html#가상환경-활성화-하기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.2 가상환경 활성화 하기",
    "text": "4.2 가상환경 활성화 하기\n생성된 가상환경은 mamba env list명령어를 통해 리스트로 볼 수 있습니다. 위에서 만든 가상환경을 활성화 하려면 다음 명령어를 입력합니다.\nmamba activate ipynb"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#anaconda에서-제공하는-패키지",
    "href": "posts/qmd/setup_miniforge.html#anaconda에서-제공하는-패키지",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.3 Anaconda에서 제공하는 패키지",
    "text": "4.3 Anaconda에서 제공하는 패키지\nAnaconda.org에서 제공하는 파이썬과 R 패키지는 다음 명령어를 사용해 쉽게 설치할 수 있습니다. miniforge에서 사용하는 기본 채널은 conda-forge입니다. 그래서 해당 채널을 원하지 않는 경우에는 검색을 해보고 conda install명령어를 복사해서 사용합니다.\n\n\n\n\n\n\nNote\n\n\n\nAnaconda.org를 살펴보면 동일한 이름의 패키지도 다양한 채널을 가지고 있습니다. 서로 다른 채널을 섞어서 사용하면 의존성 문제가 발생할 수 있기 때문에 가능하다면 동일한 채널의 패키지들로 구성하세요.\n\n\n\n4.3.1 설치하기\nmamba install [패키지]\n\n\n4.3.2 제거하기\n설치한 패키지를 제거하고 싶다면 아래 명령어를 사용합니다.\nmamba remove [패키지]"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#pypi에서-제공하는-파이썬-패키지",
    "href": "posts/qmd/setup_miniforge.html#pypi에서-제공하는-파이썬-패키지",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.4 PyPI에서 제공하는 파이썬 패키지",
    "text": "4.4 PyPI에서 제공하는 파이썬 패키지\n대부분의 경우 conda 명령어로 해결할 수 있지만 가끔 PyPI에서만 제공하는 패키지를 써야할 경우도 있습니다. 그럴 때는 먼저 PYPI에서 패키지 검색을 해보시고 아래 명령어를 사용하는 것을 권장합니다.\n\n\n\n\n\n\nNote\n\n\n\n이 부분이 약간이 까다로운 부분입니다. 파이썬의 내장 패키지인 pip을 사용하다보면 실수로 global(프로젝트 폴더가 아닌 전체를 의미)에 설치를 하는 경우가 생기기 때문이죠.\n\n\n\n\n\n\n\n\nWarning\n\n\n\npip 명령어는 가장 마지막 수단이 되어야 합니다. 항상 mamba install을 최우선으로 고려하세요."
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#cran에서-제공하는-r-패키지",
    "href": "posts/qmd/setup_miniforge.html#cran에서-제공하는-r-패키지",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.5 CRAN에서 제공하는 R 패키지",
    "text": "4.5 CRAN에서 제공하는 R 패키지\n다시 한번 Anaconda.org에서 제공하는 방법을 사용하는 것이 최선입니다만, 만약 그게 어렵다면 R 콘솔에 들어가서 install.packages(\"[패키지 이름]\") 으로 설치할 수 있습니다.\n\n4.5.1 설치\n\n먼저 conda 가상 환경에서 pip 설치\n\nmamba install pip -y\n\npip install대신 다음 명령어를 사용하기\n\npython -m pip install [패키지]\n\n\n4.5.2 제거하기\n설치한 패키지를 제거하고 싶다면 아래 명령어를 사용합니다.\npython -m pip uninstall [패키지]\n\n## 설치된 패키지 제거하기\n\n설치한 패키지를 제거하고 싶다면 아래 명령어를 사용합니다.\n\n```bash\nmamba remove r-tidyverse"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#가상환경-비활성화하기",
    "href": "posts/qmd/setup_miniforge.html#가상환경-비활성화하기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.6 가상환경 비활성화하기",
    "text": "4.6 가상환경 비활성화하기\n일반적으로는 그냥 터미널을 꺼버리고는 합니다만, 실수를 방지하기 위해 다음 명령어를 습관적으로 써주는 것이 좋습니다.\nmamba deactivate"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#가상환경-제거하기",
    "href": "posts/qmd/setup_miniforge.html#가상환경-제거하기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.7 가상환경 제거하기",
    "text": "4.7 가상환경 제거하기\n필요없는 가상 환경은 다음과 같이 제거 합니다.\nmamba env remove -n ipynb"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#의존성-정보를-파일로-저장하기",
    "href": "posts/qmd/setup_miniforge.html#의존성-정보를-파일로-저장하기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.8 의존성 정보를 파일로 저장하기",
    "text": "4.8 의존성 정보를 파일로 저장하기\n배포 혹은 프로젝트간의 전환을 위해 의존성을 파일로 저장해야하는 경우가 생깁니다. 그럴 때에는 아래와 같이 env.yaml파일을 생성하면 됩니다.\nmamba env export &gt; env.yaml"
  },
  {
    "objectID": "posts/qmd/setup_miniforge.html#의존성-파일로-부터-가상환경-만들기",
    "href": "posts/qmd/setup_miniforge.html#의존성-파일로-부터-가상환경-만들기",
    "title": "miniforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구",
    "section": "4.9 의존성 파일로 부터 가상환경 만들기",
    "text": "4.9 의존성 파일로 부터 가상환경 만들기\n위 명령어로 생성된 파일을 가지고 다음 명령어를 사용해 새로운 가상환경을 만들 수 있습니다. 생성된 가상환경의 이름은 env.yaml 파일 속에 적혀있는 것과 동일합니다.\nmamba env create -f env.yaml"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html",
    "href": "posts/qmd/learn_coding_practice.html",
    "title": "코딩테스트 기초",
    "section": "",
    "text": "코딩테스트 기초 테스트의 출처는 https://school.programmers.co.kr 입니다."
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-출력하기",
    "title": "코딩테스트 기초",
    "section": "1.1 문자열 출력하기",
    "text": "1.1 문자열 출력하기\n문자열 str 이 주어질 때, str 을 출력하는 코드를 작성해 보세요.\n\n1.1.1 파이썬\nstr: str = input()\nprint(str)\n\n\n1.1.2 러스트\nuse std::io;\n\nfn main() {\n    let mut s = String::new();\n    io::stdin().read_line(&mut s).unwrap();\n    println!(\"{}\", s.trim());\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#a-와-b-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#a-와-b-출력하기",
    "title": "코딩테스트 기초",
    "section": "1.2 a 와 b 출력하기",
    "text": "1.2 a 와 b 출력하기\n정수 a 와 b 가 주어집니다. 각 수를 입력받아 출력하는 코드를 작성해 보세요.\n\n1.2.1 파이썬\na, b = map(int, input().strip().split(\" \"))\nprint(f\"a = {a}\")\nprint(f\"b = {b}\")\n\n\n1.2.2 러스트\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let numbers: Vec&lt;i32&gt; = input\n        .trim()\n        .split_whitespace()\n        .map(|s| s.parse().expect(\"Parse error\"))\n        .collect();\n\n    let a = numbers[0];\n    let b = numbers[1];\n\n    println!(\"a = {}\", a);\n    println!(\"b = {}\", b);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-반복해서-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-반복해서-출력하기",
    "title": "코딩테스트 기초",
    "section": "1.3 문자열 반복해서 출력하기",
    "text": "1.3 문자열 반복해서 출력하기\n문자열 str 과 정수 n 이 주어집니다. str 이 n 번 반복된 문자열을 만들어 출력하는 코드를 작성해 보세요.\n\n1.3.1 파이썬\nstr, n = input().strip().split(\"\")\nn = int(n)\nprint(str*n)\n\n\n1.3.2 러스트\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let parts: Vec&lt;&str&gt; = input.trim().split_whitespace().collect();\n\n    if parts.len() != 2 {\n        println!(\"Invalid input format\");\n        return;\n    }\n\n    let str_part = parts[0];\n    let n: usize = parts[1].parse().expect(\"Failed to parse number\");\n\n    println!(\"{}\", str_part.repeat(n));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#대소문자-바꿔서-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#대소문자-바꿔서-출력하기",
    "title": "코딩테스트 기초",
    "section": "1.4 대소문자 바꿔서 출력하기",
    "text": "1.4 대소문자 바꿔서 출력하기\n영어 알파벳으로 이루어진 문자열 str 이 주어집니다. 각 알파벳을 대문자는 소문자로 소문자는 대문자로 변환해서 출력하는 코드를 작성해 보세요.\n\n1.4.1 파이썬\nstr = input()\nprint(str.swapcase())\n\n\n1.4.2 러스트\nuse std::io::{self, BufRead};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().lock().read_line(&mut input).unwrap();\n\n    let swapped = input.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n        } else if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n        } else {\n            c\n        }\n    }).collect::&lt;String&gt;();\n\n    print!(\"{}\", swapped);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#특수문자-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#특수문자-출력하기",
    "title": "코딩테스트 기초",
    "section": "1.5 특수문자 출력하기",
    "text": "1.5 특수문자 출력하기\n!@#$%^&*(\\'\"&lt;&gt;?:; 과 같이 출력하도록 코드를 작성해 주세요.\n\n1.5.1 파이썬\nprint(\"!@#$%^&*(\\\\'\\\"&lt;&gt;?:;\")\n\n\n1.5.2 러스트\nfn main() {\n    println!(\"!@#$%^&*(\\\\'\\\"&lt;&gt;?:;\");\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#덧셈식-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#덧셈식-출력하기",
    "title": "코딩테스트 기초",
    "section": "2.1 덧셈식 출력하기",
    "text": "2.1 덧셈식 출력하기\n두 정수 a, b 가 주어질 때 계산식을 출력하는 코드를 작성해 보세요.\n\n2.1.1 파이썬\na, b = map(int, input().strip().split(\" \"))\nprint(f\"{a} + {b} = {a + b}\")\n\n\n2.1.2 러스트\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let numbers: Vec&lt;i32&gt; = input\n        .trim()\n        .split_whitespace()\n        .map(|s| s.parse().expect(\"Parse error\"))\n        .collect();\n\n    if numbers.len() != 2 {\n        println!(\"Invalid input: expected two numbers\");\n        return;\n    }\n\n    let a = numbers[0];\n    let b = numbers[1];\n\n    println!(\"{} + {} = {}\", a, b, a + b);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-붙여서-출력하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-붙여서-출력하기",
    "title": "코딩테스트 기초",
    "section": "2.2 문자열 붙여서 출력하기",
    "text": "2.2 문자열 붙여서 출력하기\n두 개의 문자열 str1, str2 가 공백으로 구분되어 입력으로 주어집니다.  str1 과 str2 을 이어서 출력하는 코드를 작성해 보세요.\n\n2.2.1 파이썬\nstr1, str2 = input().strip().split()\nprint(f\"{str1}{str2}\")\n\n\n2.2.2 러스트\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let parts: Vec&lt;&str&gt; = input.trim().split_whitespace().collect();\n\n    if parts.len() != 2 {\n        println!(\"Invalid input: expected two strings\");\n        return;\n    }\n\n    let str1 = parts[0];\n    let str2 = parts[1];\n\n    println!(\"{}{}\", str1, str2);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-돌리기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-돌리기",
    "title": "코딩테스트 기초",
    "section": "2.3 문자열 돌리기",
    "text": "2.3 문자열 돌리기\n문자열 str 이 주어집니다. 문자열을 시계방향으로 90 도 돌려서 출력하는 코드를 작성해 보세요.\n\n2.3.1 파이썬\nstr: str = input()\nfor i in str:\n    print(i)\n\n\n2.3.2 러스트\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let input = stdin.lock().lines().next().unwrap().unwrap();\n\n    for c in input.chars() {\n        println!(\"{}\", c);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#홀짝-구분하기",
    "href": "posts/qmd/learn_coding_practice.html#홀짝-구분하기",
    "title": "코딩테스트 기초",
    "section": "2.4 홀짝 구분하기",
    "text": "2.4 홀짝 구분하기\n자연수 n 이 입력으로 주어졌을 때 만약 n 이 짝수이면 “n is even”을, 홀수이면 “n is odd”를 출력하는 코드를 작성해 보세요.\n\n2.4.1 파이썬\na: int = int(input())\n\nif a % 2 == 0:\n    print(f\"{a} is even\")\nelse:\n    print(f\"{a} is odd\")\n\n\n2.4.2 러스트\nuse std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let a: i32 = input.trim().parse().expect(\"Please enter a valid integer\");\n\n    if a % 2 == 0 {\n        println!(\"{} is even\", a);\n    } else {\n        println!(\"{} is odd\", a);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-겹쳐쓰기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-겹쳐쓰기",
    "title": "코딩테스트 기초",
    "section": "2.5 문자열 겹쳐쓰기",
    "text": "2.5 문자열 겹쳐쓰기\n문자열 my_string, overwrite_string 과 정수 s 가 주어집니다. 문자열 my_string 의 인덱스 s 부터 overwrite_string 의 길이만큼을 문자열 overwrite_string 으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n2.5.1 파이썬\ndef solution(my_string: str, overwrite_string: str, s: int) -&gt; str:\n    prefix = my_string[:s]\n    middle = overwrite_string\n    suffix = my_string[s + len(overwrite_string):]\n    return prefix + middle + suffix\n\n\n2.5.2 러스트\nfn solution(my_string: &str, overwrite_string: &str, s: usize) -&gt; String {\n    let prefix = &my_string[..s];\n    let middle = overwrite_string;\n    let suffix = &my_string[s + overwrite_string.len()..];\n\n    format!(\"{}{}{}\", prefix, middle, suffix)\n}\n\nfn main() {\n    // Example usage\n    let result = solution(\"Hello World\", \"Rust\", 6);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-섞기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-섞기",
    "title": "코딩테스트 기초",
    "section": "3.1 문자열 섞기",
    "text": "3.1 문자열 섞기\n길이가 같은 두 문자열 str1 과 str2 가 주어집니다. 두 문자열의 각 문자가 앞에서부터 서로 번갈아가면서 한 번씩 등장하는 문자열을 만들어 return 하는 solution 함수를 완성해 주세요\n\n3.1.1 파이썬\ndef solution(str1: str, str2: str) -&gt; str:\n    answer: str = ''\n    for i in range(len(str1)):\n        answer += str1[i] + str2[i]\n    return answer\n\n\n3.1.2 러스트\nfn solution(str1: &str, str2: &str) -&gt; String {\n    let mut answer = String::new();\n\n    for (c1, c2) in str1.chars().zip(str2.chars()) {\n        answer.push(c1);\n        answer.push(c2);\n    }\n\n    answer\n}\n\nfn main() {\n    // Example usage\n    let result = solution(\"abc\", \"def\");\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자-리스트를-문자열로-변환하기",
    "href": "posts/qmd/learn_coding_practice.html#문자-리스트를-문자열로-변환하기",
    "title": "코딩테스트 기초",
    "section": "3.2 문자 리스트를 문자열로 변환하기",
    "text": "3.2 문자 리스트를 문자열로 변환하기\n문자들이 담겨있는 배열 arr 가 주어집니다. arr 의 원소들을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n3.2.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[str]) -&gt; str:\n    return ''.join(arr)\n\n\n3.2.2 러스트\nfn solution(arr: &[String]) -&gt; String {\n    arr.join(\"\")\n}\n\nfn main() {\n    // Example usage\n    let arr = vec![\n        String::from(\"Hello\"),\n        String::from(\" \"),\n        String::from(\"World\"),\n    ];\n    let result = solution(&arr);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-곱하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-곱하기",
    "title": "코딩테스트 기초",
    "section": "3.3 문자열 곱하기",
    "text": "3.3 문자열 곱하기\n문자열 my_string 과 정수 k 가 주어질 때, my_string 을 k 번 반복한 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n3.3.1 파이썬\ndef solution(my_string: str, k: int) -&gt; str:\n    return my_string*k\n\n\n3.3.2 러스트\nfn solution(my_string: &str, k: usize) -&gt; String {\n    my_string.repeat(k)\n}\n\nfn main() {\n    // Example usage\n    let result = solution(\"Hello\", 3);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#더-크게-합치기",
    "href": "posts/qmd/learn_coding_practice.html#더-크게-합치기",
    "title": "코딩테스트 기초",
    "section": "3.4 더 크게 합치기",
    "text": "3.4 더 크게 합치기\n연산 \\(⊕\\) 는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다. \\(12 ⊕ 3 = 123\\), \\(3 ⊕ 12 = 312\\) . 양의 정수 a 와 b 가 주어졌을 때, \\(a⊕b\\) 와 \\(b⊕a\\) 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요. 단, \\(a⊕b\\) 와 \\(b⊕a\\) 가 같다면 \\(a⊕b\\) 를 return 합니다.\n\n3.4.1 파이썬\ndef solution(a: int, b: int) -&gt; int:\n    ab = int(str(a) + str(b))\n    ba = int(str(b) + str(a))\n    return max(ab, ba)\n\n\n3.4.2 러스트\nfn solution(a: i32, b: i32) -&gt; i32 {\n    let ab = format!(\"{}{}\", a, b).parse::&lt;i32&gt;().unwrap();\n    let ba = format!(\"{}{}\", b, a).parse::&lt;i32&gt;().unwrap();\n    ab.max(ba)\n}\n\nfn main() {\n    // Example usage\n    let result = solution(12, 34);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#두-수의-연산값-비교하기",
    "href": "posts/qmd/learn_coding_practice.html#두-수의-연산값-비교하기",
    "title": "코딩테스트 기초",
    "section": "3.5 두 수의 연산값 비교하기",
    "text": "3.5 두 수의 연산값 비교하기\n연산 \\(⊕\\) 는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다. \\(12⊕3=123\\), \\(3⊕12=312\\) 양의 정수 a 와 b 가 주어졌을 때, \\(a⊕b\\) 와 \\(2*a*b\\) 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요. 단, \\(a⊕b\\) 와 \\(2*a*b\\) 가 같으면 \\(a⊕b\\) 를 return 합니다.\n\n3.5.1 파이썬\ndef solution(a: int, b: int) -&gt; int:\n    concat_op = int(str(a) + str(b))\n    multiply_op = 2 * a * b\n    return max(concat_op, multiply_op)\n\n\n3.5.2 러스트\nfn solution(a: i32, b: i32) -&gt; i32 {\n    let concat_op = format!(\"{}{}\", a, b).parse::&lt;i32&gt;().unwrap();\n    let multiply_op = 2 * a * b;\n    concat_op.max(multiply_op)\n}\n\nfn main() {\n    // Example usage\n    let result = solution(2, 91);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#n-의-배수",
    "href": "posts/qmd/learn_coding_practice.html#n-의-배수",
    "title": "코딩테스트 기초",
    "section": "4.1 n 의 배수",
    "text": "4.1 n 의 배수\n정수 num 과 n 이 매개 변수로 주어질 때, num 이 n 의 배수이면 1 을 return n 의 배수가 아니라면 0 을 return 하도록 solution 함수를 완성해주세요.\n\n4.1.1 파이썬\ndef solution(num: int, n: int) -&gt; int:\n    if num % n == 0:\n        return 1\n    else:\n        return 0\n\n\n4.1.2 러스트\nfn solution(num: i32, n: i32) -&gt; i32 {\n    if num % n == 0 {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let num = 10;\n    let n = 2;\n    let result = solution(num, n);\n    println!(\"Result for num={} and n={}: {}\", num, n, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#공배수",
    "href": "posts/qmd/learn_coding_practice.html#공배수",
    "title": "코딩테스트 기초",
    "section": "4.2 공배수",
    "text": "4.2 공배수\n정수 number 와 n, m 이 주어집니다. number 가 n 의 배수이면서 m 의 배수이면 1 을 아니라면 0 을 return 하도록 solution 함수를 완성해주세요.\n\n4.2.1 파이썬\ndef solution(number: int, n: int, m:int) -&gt; int:\n    if number % n == 0 and number % m == 0:\n        return 1\n    else:\n        return 0\n\n\n4.2.2 러스트\nfn solution(number: i32, n: i32, m: i32) -&gt; i32 {\n    if number % n == 0 && number % m == 0 {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let result1 = solution(12, 3, 4);\n    println!(\"Result 1: {}\", result1);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#홀짝에-따른-다른-값-반환하기",
    "href": "posts/qmd/learn_coding_practice.html#홀짝에-따른-다른-값-반환하기",
    "title": "코딩테스트 기초",
    "section": "4.3 홀짝에 따른 다른 값 반환하기",
    "text": "4.3 홀짝에 따른 다른 값 반환하기\n양의 정수 n 이 매개변수로 주어질 때, n 이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return 하고 n 이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return 하는 solution 함수를 작성해 주세요.\n\n4.3.1 파이썬\ndef solution(n:int) -&gt; int:\n    if n % 2 == 1:  # n이 홀수인 경우\n        return sum(range(1, n+1, 2))\n    else:  # n이 짝수인 경우\n        return sum(i**2 for i in range(2, n+1, 2))\n\n\n4.3.2 러스트\nfn solution(n: i32) -&gt; i32 {\n    if n % 2 == 1 {\n        // If `n` is odd, sum all odd numbers from 1 to `n`\n        (1..=n).step_by(2).sum()\n    } else {\n        // If `n` is even, sum the squares of all even numbers from 2 to `n`\n        (2..=n).step_by(2).map(|i| i * i).sum()\n    }\n}\n\nfn main() {\n    let result1 = solution(7); // Example with an odd number\n    println!(\"Result 1: {}\", result1);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#조건-문자열",
    "href": "posts/qmd/learn_coding_practice.html#조건-문자열",
    "title": "코딩테스트 기초",
    "section": "4.4 조건 문자열",
    "text": "4.4 조건 문자열\n문자열에 따라 다음과 같이 두 수의 크기를 비교하려고 합니다.\n\n두 수가 n 과 m 이라면\n\n“&gt;”, “=” : n &gt;= m\n“&lt;”, “=” : n &lt;= m\n“&gt;”, “!” : n &gt; m\n“&lt;”, “!” : n &lt; m\n\n\n두 문자열 ineq 와 eq 가 주어집니다. ineq 는 “&lt;”와 “&gt;”중 하나고, eq 는 “=”와 “!”중 하나입니다. 그리고 두 정수 n 과 m 이 주어질 때, n 과 m 이 ineq 와 eq 의 조건에 맞으면 1 을 아니면 0 을 return 하도록 solution 함수를 완성해주세요.\n\n4.4.1 파이썬\ndef solution(ineq:str, eq:str, n:int, m:int) -&gt; int:\n    if ineq == \"&gt;\" and eq == \"=\":\n        return 1 if n &gt;= m else 0\n    elif ineq == \"&lt;\" and eq == \"=\":\n        return 1 if n &lt;= m else 0\n    elif ineq == \"&gt;\" and eq == \"!\":\n        return 1 if n &gt; m else 0\n    elif ineq == \"&lt;\" and eq == \"!\":\n        return 1 if n &lt; m else 0\n\n\n4.4.2 러스트\nfn solution(ineq: char, eq: char, n: i32, m: i32) -&gt; i32 {\n    match (ineq, eq) {\n        ('&gt;', '=') =&gt; if n &gt;= m { 1 } else { 0 },\n        ('&lt;', '=') =&gt; if n &lt;= m { 1 } else { 0 },\n        ('&gt;', '!') =&gt; if n &gt; m { 1 } else { 0 },\n        ('&lt;', '!') =&gt; if n &lt; m { 1 } else { 0 },\n        _ =&gt; panic!(\"Invalid input combination\"),\n    }\n}\n\nfn main() {\n    println!(\"Result 1: {}\", solution('&gt;', '=', 20, 15));\n    println!(\"Result 2: {}\", solution('&lt;', '=', 10, 20));"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#flag-에-따라-다른-값-반환하기",
    "href": "posts/qmd/learn_coding_practice.html#flag-에-따라-다른-값-반환하기",
    "title": "코딩테스트 기초",
    "section": "4.5 flag 에 따라 다른 값 반환하기",
    "text": "4.5 flag 에 따라 다른 값 반환하기\n두 정수 a, b 와 boolean 변수 flag 가 매개변수로 주어질 때, flag 가 true 면 a + b 를 false 면 a - b 를 return 하는 solution 함수를 작성해 주세요.\n\n4.5.1 파이썬\ndef solution(a: int, b:int, flag:bool) -&gt; int:\n    return a + b if flag else a - b\n\n\n4.5.2 러스트\nfn solution(a: i32, b: i32, flag: bool) -&gt; i32 {\n    if flag {\n        a + b\n    } else {\n        a - b\n    }\n}\n\nfn main() {\n    println!(\"Result 1: {}\", solution(5, 3, true));\n    println!(\"Result 2: {}\", solution(10, 7, false));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#코드-처리하기",
    "href": "posts/qmd/learn_coding_practice.html#코드-처리하기",
    "title": "코딩테스트 기초",
    "section": "5.1 코드 처리하기",
    "text": "5.1 코드 처리하기\n문자열 code 가 주어집니다. code 를 앞에서부터 읽으면서 만약 문자가 “1”이면 mode 를 바꿉니다. mode 에 따라 code 를 읽어가면서 문자열 ret 을 만들어냅니다. mode 는 0 과 1 이 있으며, idx 를 0 부터 code의 길이 - 1 까지 1 씩 키워나가면서 code[idx] 의 값에 따라 다음과 같이 행동합니다.\n\nmode 가 0 일 때\n\ncode[idx] 가 “1”이 아니면 idx 가 짝수일 때만 ret 의 맨 뒤에 code[idx] 를 추가합니다.\ncode[idx] 가 “1”이면 mode 를 0 에서 1 로 바꿉니다.\n\nmode 가 1 일 때\n\ncode[idx] 가 “1”이 아니면 idx 가 홀수일 때만 ret 의 맨 뒤에 code[idx] 를 추가합니다.\ncode[idx] 가 “1”이면 mode 를 1 에서 0 으로 바꿉니다.\n\n\n문자열 code 를 통해 만들어진 문자열 ret 를 return 하는 solution 함수를 완성해 주세요.\n단, 시작할 때 mode 는 0 이며, return 하려는 ret 가 만약 빈 문자열이라면 대신 “EMPTY”를 return 합니다.\n\n5.1.1 파이썬\ndef solution(code: str) -&gt; str:\n    ret = ''\n    mode = 0  # 시작할 때 mode는 0입니다.\n\n    for idx, char in enumerate(code):\n        if char == '1':\n            mode = 1 - mode  # mode를 전환합니다.\n        else:\n            if (mode == 0 and idx % 2 == 0) or (mode == 1 and idx % 2 == 1):\n                ret += char\n\n    if ret == '':\n        return 'EMPTY'\n    return ret\n\n\n5.1.2 러스트\nfn solution(code: &str) -&gt; String {\n    let mut ret = String::new();\n    let mut mode = 0; // Start with mode 0\n\n    for (idx, char) in code.chars().enumerate() {\n        if char == '1' {\n            mode = 1 - mode; // Toggle the mode\n        } else {\n            if (mode == 0 && idx % 2 == 0) || (mode == 1 && idx % 2 == 1) {\n                ret.push(char);\n            }\n        }\n    }\n\n    if ret.is_empty() {\n        \"EMPTY\".to_string()\n    } else {\n        ret\n    }\n}\n\nfn main() {\n    println!(\"Result 1: {}\", solution(\"012345\"));\n    println!(\"Result 2: {}\", solution(\"1101010\"));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#등차수열의-특정한-항만-더하기",
    "href": "posts/qmd/learn_coding_practice.html#등차수열의-특정한-항만-더하기",
    "title": "코딩테스트 기초",
    "section": "5.2 등차수열의 특정한 항만 더하기",
    "text": "5.2 등차수열의 특정한 항만 더하기\n두 정수 a, d 와 길이가 n 인 boolean 배열 included 가 주어집니다. 첫째항이 a, 공차가 d 인 등차수열에서 included[i] 가 i + 1 항을 의미할 때, 이 등차수열의 1 항부터 n 항까지 included 가 true 인 항들만 더한 값을 return 하는 solution 함수를 작성해 주세요.\n\n5.2.1 파이썬\nfrom typing import List\n\ndef solution(a:int, d:int, included: List[bool]) -&gt; int:\n    answer = 0\n\n    for i in range(len(included)):\n        if included[i]:\n            # (i+1)번째 항 계산\n            term = a + i * d\n            answer += term\n\n    return answer\n\n\n5.2.2 러스트\nfn solution(a: i32, d: i32, included: Vec&lt;bool&gt;) -&gt; i32 {\n    let mut answer = 0;\n\n    for (i, &is_included) in included.iter().enumerate() {\n        if is_included {\n            // Calculate the (i+1)th term\n            let term = a + (i as i32) * d;\n            answer += term;\n        }\n    }\n\n    answer\n}\n\nfn main() {\n    let result1 = solution(3, 4, vec![true, false, false, true, true]);\n    println!(\"Result 1: {}\", result1);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#마지막-두-원소",
    "href": "posts/qmd/learn_coding_practice.html#마지막-두-원소",
    "title": "코딩테스트 기초",
    "section": "6.1 마지막 두 원소",
    "text": "6.1 마지막 두 원소\n정수 리스트 num_list가 주어질 때, 마지막 원소가 그전 원소보다 크면 마지막 원소에서 그전 원소를 뺀 값을 마지막 원소가 그전 원소보다 크지 않다면 마지막 원소를 두 배한 값을 추가하여 return하도록 solution 함수를 완성해주세요.\n\n6.1.1 파이썬\nfrom typing import List\ndef solution(num_list: List[int]) -&gt; List[int]:\n    # 마지막 원소와 그 전 원소 추출\n    last = num_list[-1]\n    second_last = num_list[-2]\n\n    # 결과 리스트를 복사하여 추가할 값 결정\n    result = num_list.copy()\n\n    if last &gt; second_last:\n        # 마지막 원소가 그 전 원소보다 크면 차를 추가\n        result.append(last - second_last)\n    else:\n        # 그렇지 않으면 마지막 원소의 두 배를 추가\n        result.append(last * 2)\n\n    return result\n\n\n6.1.2 러스트"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수-조작하기-1",
    "href": "posts/qmd/learn_coding_practice.html#수-조작하기-1",
    "title": "코딩테스트 기초",
    "section": "6.2 수 조작하기 1",
    "text": "6.2 수 조작하기 1\n정수 n과 문자열 control이 주어집니다. control은 “w”, “a”, “s”, “d”의 4개의 문자로 이루어져 있으며, control의 앞에서부터 순서대로 문자에 따라 n의 값을 바꿉니다.\n\n“w” : n이 1 커집니다.\n“s” : n이 1 작아집니다.\n“d” : n이 10 커집니다.\n“a” : n이 10 작아집니다.\n\n위 규칙에 따라 n을 바꿨을 때 가장 마지막에 나오는 n의 값을 return 하는 solution 함수를 완성해 주세요.\n\n6.2.1 파이썬\ndef solution(n: int, control:str) -&gt; int:\n    # control 문자열을 순회하면서 n의 값을 조작합니다.\n    for char in control:\n        if char == 'w':\n            n += 1\n        elif char == 's':\n            n -= 1\n        elif char == 'd':\n            n += 10\n        elif char == 'a':\n            n -= 10\n\n    return n\n\n\n6.2.2 러스트\nfn solution(mut n: i32, control: &str) -&gt; i32 {\n    for char in control.chars() {\n        match char {\n            'w' =&gt; n += 1,\n            's' =&gt; n -= 1,\n            'd' =&gt; n += 10,\n            'a' =&gt; n -= 10,\n            _ =&gt; (), // Ignore any other characters\n        }\n    }\n    n\n}\n\nfn main() {\n    let initial_n = 0;\n    let control_string = \"wsdawsdassw\";\n    let result = solution(initial_n, control_string);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수-조작하기-2",
    "href": "posts/qmd/learn_coding_practice.html#수-조작하기-2",
    "title": "코딩테스트 기초",
    "section": "6.3 수 조작하기 2",
    "text": "6.3 수 조작하기 2\n정수 배열 numLog가 주어집니다. 처음에 numLog[0]에서 부터 시작해 “w”, “a”, “s”, “d”로 이루어진 문자열을 입력으로 받아 순서대로 다음과 같은 조작을 했다고 합시다.\n\n“w” : 수에 1을 더한다.\n“s” : 수에 1을 뺀다.\n“d” : 수에 10을 더한다.\n“a” : 수에 10을 뺀다.\n\n그리고 매번 조작을 할 때마다 결괏값을 기록한 정수 배열이 numLog입니다. 즉, numLog[i]는 numLog[0]로부터 총 i번의 조작을 가한 결과가 저장되어 있습니다.\n주어진 정수 배열 numLog에 대해 조작을 위해 입력받은 문자열을 return 하는 solution 함수를 완성해 주세요.\n\n6.3.1 파이썬\nfrom typing import List\ndef solution(numLog:List[int]) -&gt; str:\n    # 조작 문자열을 저장할 변수\n    answer = ''\n\n    # numLog 배열의 길이\n    n = len(numLog)\n\n    # 각 인접 원소 간의 차이를 확인하고 조작 문자열 생성\n    for i in range(1, n):\n        diff = numLog[i] - numLog[i - 1]\n        if diff == 1:\n            answer += 'w'\n        elif diff == -1:\n            answer += 's'\n        elif diff == 10:\n            answer += 'd'\n        elif diff == -10:\n            answer += 'a'\n\n    return answer\n\n\n6.3.2 러스트\nfn solution(num_log: &[i32]) -&gt; String {\n    let mut answer = String::new();\n\n    for i in 1..num_log.len() {\n        let diff = num_log[i] - num_log[i - 1];\n        match diff {\n            1 =&gt; answer.push('w'),\n            -1 =&gt; answer.push('s'),\n            10 =&gt; answer.push('d'),\n            -10 =&gt; answer.push('a'),\n            _ =&gt; (), // Ignore any other differences\n        }\n    }\n\n    answer\n}\n\nfn main() {\n    let num_log = vec![0, 1, 0, 10, 0, 1, 0, 10, 0, -1, -2, -1];\n    let result = solution(&num_log);\n    println!(\"Input: {:?}\", num_log);\n    println!(\"Output: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리-3",
    "href": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리-3",
    "title": "코딩테스트 기초",
    "section": "6.4 수열 구간 쿼리 3",
    "text": "6.4 수열 구간 쿼리 3\n정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [i, j] 꼴입니다.\n각 query마다 순서대로 arr[i]의 값과 arr[j]의 값을 서로 바꿉니다.\n위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.\n\n6.4.1 파이썬\nfrom typing import List\ndef solution(arr:List[int], queries:List[int]) -&gt; List[int]:\n    # 각 쿼리 처리\n    for i, j in queries:\n        # 인덱스 i와 j의 값을 서로 교환\n        arr[i], arr[j] = arr[j], arr[i]\n\n    return arr\n\n\n6.4.2 러스트\nfn solution(mut arr: Vec&lt;i32&gt;, queries: &[(usize, usize)]) -&gt; Vec&lt;i32&gt; {\n    for &(i, j) in queries {\n        arr.swap(i, j);\n    }\n    arr\n}\n\nfn main() {\n    let arr = vec![0, 1, 2, 3, 4];\n    let queries = vec![(0, 3), (1, 2), (1, 4)];\n\n    let result = solution(arr.clone(), &queries);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리2",
    "href": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리2",
    "title": "코딩테스트 기초",
    "section": "6.5 수열 구간 쿼리2",
    "text": "6.5 수열 구간 쿼리2\n정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.\n각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 k보다 크면서 가장 작은 arr[i]를 찾습니다.\n각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 solution 함수를 완성해 주세요. 단, 특정 쿼리의 답이 존재하지 않으면 -1을 저장합니다. ### 파이썬\nfrom typing import List\n\ndef solution(arr:List[int], queries:List[int]) -&gt; List[int]:\n    answer = []\n\n    for s, e, k in queries:\n        # 범위 내의 값을 추출\n        subset = arr[s:e+1]\n\n        # k보다 큰 값을 필터링\n        filtered = [num for num in subset if num &gt; k]\n\n        if filtered:\n            # 필터링된 값 중 가장 작은 값 선택\n            answer.append(min(filtered))\n        else:\n            # k보다 큰 값이 없는 경우 -1\n            answer.append(-1)\n\n    return answer\n\n6.5.1 러스트\nfn solution(arr: &[i32], queries: &[(usize, usize, i32)]) -&gt; Vec&lt;i32&gt; {\n    let mut answer = Vec::new();\n\n    for &(s, e, k) in queries {\n        let subset = &arr[s..=e];\n\n        let min_value = subset.iter()\n            .filter(|&&num| num &gt; k)\n            .min()\n            .copied()\n            .unwrap_or(-1);\n\n        answer.push(min_value);\n    }\n\n    answer\n}\n\nfn main() {\n    let arr = vec![0, 1, 2, 4, 3];\n    let queries = vec![(0, 4, 2), (0, 3, 2), (0, 2, 1)];\n\n    let result = solution(&arr, &queries);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리-4",
    "href": "posts/qmd/learn_coding_practice.html#수열-구간-쿼리-4",
    "title": "코딩테스트 기초",
    "section": "7.1 수열 구간 쿼리 4",
    "text": "7.1 수열 구간 쿼리 4\n정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.\n각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다.\n위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.\n\n7.1.1 파이썬\nfrom typing import List\ndef solution(arr:List[int], queries:List[int]) -&gt; List[int]:\n    for s, e, k in queries:\n        for i in range(s, e + 1):\n            if i % k == 0:\n                arr[i] += 1\n    return arr\n\n\n7.1.2 러스트\nfn solution(mut arr: Vec&lt;i32&gt;, queries: &[(usize, usize, usize)]) -&gt; Vec&lt;i32&gt; {\n    for &(s, e, k) in queries {\n        for i in s..=e {\n            if i % k == 0 {\n                arr[i] += 1;\n            }\n        }\n    }\n    arr\n}\n\nfn main() {\n    let arr = vec![0, 1, 2, 3, 4];\n    let queries = vec![(0, 4, 1), (0, 3, 2), (0, 3, 3)];\n\n            let result = solution(arr.clone(), &queries);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#간단한-논리-연산",
    "href": "posts/qmd/learn_coding_practice.html#간단한-논리-연산",
    "title": "코딩테스트 기초",
    "section": "8.1 간단한 논리 연산",
    "text": "8.1 간단한 논리 연산\nboolean 변수 x1, x2, x3, x4가 매개변수로 주어질 때, 다음의 \\((x1∨x2)∧(x3∨x4)\\) 식의 true/false를 return 하는 solution 함수를 작성해 주세요.\n\n8.1.1 파이썬\ndef solution(x1:bool, x2:bool, x3:bool, x4:bool) -&gt; bool:\n    return (x1 or x2) and (x3 or x4)\n\n\n8.1.2 러스트\nfn solution(x1: bool, x2: bool, x3: bool, x4: bool) -&gt; bool {\n    (x1 || x2) && (x3 || x4)\n}\n\nfn main() {\n    let result = solution(true, false, true, false);\n    println!(\"The result is: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#주사위-게임",
    "href": "posts/qmd/learn_coding_practice.html#주사위-게임",
    "title": "코딩테스트 기초",
    "section": "8.2 주사위 게임",
    "text": "8.2 주사위 게임\n1부터 6까지 숫자가 적힌 주사위가 네 개 있습니다. 네 주사위를 굴렸을 때 나온 숫자에 따라 다음과 같은 점수를 얻습니다.\n\n네 주사위에서 나온 숫자가 모두 p로 같다면 1111 × p점을 얻습니다.\n세 주사위에서 나온 숫자가 p로 같고 나머지 다른 주사위에서 나온 숫자가 q(p ≠ q)라면 (10 × p + q)2 점을 얻습니다.\n주사위가 두 개씩 같은 값이 나오고, 나온 숫자를 각각 p, q(p ≠ q)라고 한다면 (p + q) × |p - q|점을 얻습니다.\n어느 두 주사위에서 나온 숫자가 p로 같고 나머지 두 주사위에서 나온 숫자가 각각 p와 다른 q, r(q ≠ r)이라면 q × r점을 얻습니다.\n네 주사위에 적힌 숫자가 모두 다르다면 나온 숫자 중 가장 작은 숫자 만큼의 점수를 얻습니다.\n\n네 주사위를 굴렸을 때 나온 숫자가 정수 매개변수 a, b, c, d로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요.\n\n8.2.1 파이썬\nfrom collections import Counter\nfrom typing import List\n\ndef solution(a: int, b: int, c: int, d: int) -&gt; int:\n    counts: Counter[int] = Counter([a, b, c, d])\n\n    # 조건 1: 네 주사위의 숫자가 모두 같은 경우\n    if len(counts) == 1:\n        return 1111 * a\n\n    # 조건 2: 세 주사위의 숫자가 같고 나머지 한 주사위의 숫자가 다른 경우\n    if len(counts) == 2:\n        p, q = counts.most_common()\n        if p[1] == 3:  # (숫자, 빈도)\n            return (10 * p[0] + q[0]) ** 2\n        else:  # 두 쌍의 주사위가 같은 경우\n            return (p[0] + q[0]) * abs(p[0] - q[0])\n\n    # 조건 3: 두 주사위가 같은 숫자를 가질 경우, 나머지 두 주사위가 각각 다른 숫자일 경우\n    if len(counts) == 3:\n        for key in counts:\n            if counts[key] == 2:\n                remaining: List[int] = [k for k in counts if counts[k] == 1]\n                return remaining[0] * remaining[1]\n\n    # 조건 4: 모든 주사위의 숫자가 다를 경우\n    if len(counts) == 4:\n        return min(a, b, c, d)\n\n\n8.2.2 러스트\nuse std::collections::HashMap;\n\nfn solution(a: i32, b: i32, c: i32, d: i32) -&gt; i32 {\n    let mut counts = HashMap::new();\n    for &num in &[a, b, c, d] {\n        *counts.entry(num).or_insert(0) += 1;\n    }\n\n    // Condition 1: All four dice have the same number\n    if counts.len() == 1 {\n        return 1111 * a;\n    }\n\n    // Condition 2: Three dice have the same number, and one is different\n    if counts.len() == 2 {\n        let mut pairs: Vec&lt;(&i32, &i32)&gt; = counts.iter().collect();\n        pairs.sort_by(|a, b| b.cmp(a)); // Sort by frequency in descending order\n        let (p_num, p_count) = pairs[0];\n        let (q_num, _) = pairs[1];\n        if *p_count == 3 {\n            return (10 * p_num + q_num) * (10 * p_num + q_num);\n        } else {\n            return (p_num + q_num) * (p_num - q_num).abs();\n        }\n    }\n\n    // Condition 3: Two dice have the same number, and the other two are different\n    if counts.len() == 3 {\n        for (&key, &value) in &counts {\n            if value == 2 {\n                let mut remaining: Vec&lt;i32&gt; = counts\n                    .iter()\n                    .filter(|(_, &v)| v == 1)\n                    .map(|(&k, _)| k)\n                    .collect();\n                return remaining[0] * remaining[1];\n            }\n        }\n    }\n\n    // Condition 4: All four dice have different numbers\n    if counts.len() == 4 {\n        return *[a, b, c, d].iter().min().unwrap();\n    }\n\n    0 // Default return value (shouldn't reach here)\n}\n\nfn main() {\n    let result = solution(2, 2, 3, 4);\n    println!(\"The result is: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#글자-이어-붙여-문자열-만들기",
    "href": "posts/qmd/learn_coding_practice.html#글자-이어-붙여-문자열-만들기",
    "title": "코딩테스트 기초",
    "section": "8.3 글자 이어 붙여 문자열 만들기",
    "text": "8.3 글자 이어 붙여 문자열 만들기\n문자열 my_string과 정수 배열 index_list가 매개변수로 주어집니다. my_string의 index_list의 원소들에 해당하는 인덱스의 글자들을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n8.3.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str, index_list:List[int]) -&gt; str:\n    answer = ''.join(my_string[i] for i in index_list)\n    return answer\n\n\n8.3.2 러스트\nfn solution(my_string: &str, index_list: &[usize]) -&gt; String {\n    index_list.iter()\n        .filter_map(|&i| my_string.chars().nth(i))\n        .collect()\n}\n\nfn main() {\n    let my_string = \"abcdef\";\n    let index_list = vec![0, 2, 4];\n    let result = solution(my_string, &index_list);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#로-나눈-나머지",
    "href": "posts/qmd/learn_coding_practice.html#로-나눈-나머지",
    "title": "코딩테스트 기초",
    "section": "8.4 9로 나눈 나머지",
    "text": "8.4 9로 나눈 나머지\n음이 아닌 정수를 9로 나눈 나머지는 그 정수의 각 자리 숫자의 합을 9로 나눈 나머지와 같은 것이 알려져 있습니다. 이 사실을 이용하여 음이 아닌 정수가 문자열 number로 주어질 때, 이 정수를 9로 나눈 나머지를 return 하는 solution 함수를 작성해주세요.\n\n8.4.1 파이썬\ndef solution(number:str) -&gt; int:\n    digit_sum = sum(int(digit) for digit in number)  # 각 자리 숫자의 합을 구합니다.\n    return digit_sum % 9  # 그 합을 9로 나눈 나머지를 반환합니다.\n\n\n8.4.2 러스트\nfn solution(number: &str) -&gt; i32 {\n    let digit_sum: i32 = number\n        .chars()\n        .filter_map(|c| c.to_digit(10))\n        .map(|d| d as i32)\n        .sum();\n\n    digit_sum % 9\n}\n\nfn main() {\n    let result = solution(\"123\");\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-여러-번-뒤집기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-여러-번-뒤집기",
    "title": "코딩테스트 기초",
    "section": "8.5 문자열 여러 번 뒤집기",
    "text": "8.5 문자열 여러 번 뒤집기\n문자열 my_string과 이차원 정수 배열 queries가 매개변수로 주어집니다. queries의 원소는 [s, e] 형태로, my_string의 인덱스 s부터 인덱스 e까지를 뒤집으라는 의미입니다. my_string에 queries의 명령을 순서대로 처리한 후의 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n8.5.1 파이썬\nfrom typing import List\n\ndef solution(my_string:str, queries:List[int]) -&gt; str:\n    # 문자열을 리스트로 변환하여 수정 가능하게 만듭니다.\n    s = list(my_string)\n\n    # 각 쿼리 처리\n    for s_idx, e_idx in queries:\n        # s_idx부터 e_idx까지 부분 문자열을 뒤집습니다.\n        s[s_idx:e_idx + 1] = s[s_idx:e_idx + 1][::-1]\n\n    # 리스트를 문자열로 변환하여 반환합니다.\n    return ''.join(s)\n\n\n8.5.2 러스트\nfn solution(my_string: &str, queries: &Vec&lt;(usize, usize)&gt;) -&gt; String {\n    let mut s: Vec&lt;char&gt; = my_string.chars().collect();\n\n    for &(s_idx, e_idx) in queries {\n        s[s_idx..=e_idx].reverse();\n    }\n\n    s.into_iter().collect()\n}\n\nfn main() {\n    let my_string = \"rermgorpsam\";\n    let queries = vec![(2, 3), (0, 7), (5, 9), (6, 10)];\n    let result = solution(my_string, &queries);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-만들기-5",
    "href": "posts/qmd/learn_coding_practice.html#배열-만들기-5",
    "title": "코딩테스트 기초",
    "section": "9.1 배열 만들기 5",
    "text": "9.1 배열 만들기 5\n문자열 배열 intStrs와 정수 k, s, l가 주어집니다. intStrs의 원소는 숫자로 이루어져 있습니다.\n배열 intStrs의 각 원소마다 s번 인덱스에서 시작하는 길이 l짜리 부분 문자열을 잘라내 정수로 변환합니다. 이때 변환한 정수값이 k보다 큰 값들을 담은 배열을 return 하는 solution 함수를 완성해 주세요.\n\n9.1.1 파이썬\nfrom typing import List\n\ndef solution(intStrs: List[str], k: int, s: int, l: int) -&gt; List[int]:\n    answer: List[int] = []\n    for string in intStrs:\n        # s번 인덱스부터 l 길이만큼 부분 문자열을 잘라내고 정수로 변환\n        num: int = int(string[s:s+l])\n        # 변환한 정수가 k보다 크면 answer 리스트에 추가\n        if num &gt; k:\n            answer.append(num)\n    return answer\n\n\n9.1.2 러스트\nfn solution(int_strs: Vec&lt;String&gt;, k: i32, s: usize, l: usize) -&gt; Vec&lt;i32&gt; {\n    let mut answer: Vec&lt;i32&gt; = Vec::new();\n    for string in int_strs {\n        // s번 인덱스부터 l 길이만큼 부분 문자열을 잘라내고 정수로 변환\n        if let Ok(num) = string[s..s+l].parse::&lt;i32&gt;() {\n            // 변환한 정수가 k보다 크면 answer 벡터에 추가\n            if num &gt; k {\n                answer.push(num);\n            }\n        }\n    }\n    answer\n}\n\nfn main() {\n    let int_strs = vec![\n        String::from(\"12345\"),\n        String::from(\"67890\"),\n        String::from(\"54321\")\n    ];\n    let k = 340;\n    let s = 1;\n    let l = 3;\n\n    let result = solution(int_strs, k, s, l);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#부분-문자열-이어-붙여-문자열-만들기",
    "href": "posts/qmd/learn_coding_practice.html#부분-문자열-이어-붙여-문자열-만들기",
    "title": "코딩테스트 기초",
    "section": "9.2 부분 문자열 이어 붙여 문자열 만들기",
    "text": "9.2 부분 문자열 이어 붙여 문자열 만들기\n길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n9.2.1 파이썬\nfrom typing import List, Tuple\n\ndef solution(my_strings: List[str], parts: List[Tuple[int, int]]) -&gt; str:\n    answer: str = ''\n    for i in range(len(my_strings)):\n        s, e = parts[i]\n        answer += my_strings[i][s:e+1]\n    return answer\n\n\n9.2.2 러스트\nfn solution(my_strings: Vec&lt;String&gt;, parts: Vec&lt;(usize, usize)&gt;) -&gt; String {\n    let mut answer = String::new();\n    for i in 0..my_strings.len() {\n        let (s, e) = parts[i];\n        answer.push_str(&my_strings[i][s..=e]);\n    }\n    answer\n}\n\nfn main() {\n    let my_strings = vec![\n        String::from(\"progressive\"),\n        String::from(\"hamburger\"),\n        String::from(\"hammer\"),\n        String::from(\"ahocorasick\")\n    ];\n    let parts = vec![(0, 4), (1, 2), (3, 5), (7, 7)];\n\n    let result = solution(my_strings, parts);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-뒤의-n글자",
    "href": "posts/qmd/learn_coding_practice.html#문자열-뒤의-n글자",
    "title": "코딩테스트 기초",
    "section": "9.3 문자열 뒤의 n글자",
    "text": "9.3 문자열 뒤의 n글자\n문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 뒤의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n9.3.1 파이썬\ndef solution(my_string: str, n: int) -&gt; str:\n    return my_string[-n:]\n\n\n9.3.2 러스트\nfn solution(my_string: String, n: usize) -&gt; String {\n    my_string.chars().rev().take(n).rev().collect()\n}\n\nfn main() {\n    let my_string = String::from(\"HelloWorld\");\n    let n = 5;\n    let result = solution(my_string, n);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#접미사-배열",
    "href": "posts/qmd/learn_coding_practice.html#접미사-배열",
    "title": "코딩테스트 기초",
    "section": "9.4 접미사 배열",
    "text": "9.4 접미사 배열\n어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다. 문자열 my_string이 매개변수로 주어질 때, my_string의 모든 접미사를 사전순으로 정렬한 문자열 배열을 return 하는 solution 함수를 작성해 주세요.\n\n9.4.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str) -&gt; List[str]:\n    # 모든 접미사 생성\n    suffixes: List[str] = [my_string[i:] for i in range(len(my_string))]\n\n    # 접미사들을 사전순으로 정렬\n    answer: List[str] = sorted(suffixes)\n\n    return answer\n\n\n9.4.2 러스트\nfn solution(my_string: String) -&gt; Vec&lt;String&gt; {\n    let mut suffixes: Vec&lt;String&gt; = Vec::new();\n\n    // 모든 접미사 생성\n    for i in 0..my_string.len() {\n        suffixes.push(my_string[i..].to_string());\n    }\n\n    // 접미사들을 사전순으로 정렬\n    suffixes.sort();\n\n    suffixes\n}\n\nfn main() {\n    let my_string = String::from(\"banana\");\n    let result = solution(my_string);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#접미사인지-확인하기",
    "href": "posts/qmd/learn_coding_practice.html#접미사인지-확인하기",
    "title": "코딩테스트 기초",
    "section": "9.5 접미사인지 확인하기",
    "text": "9.5 접미사인지 확인하기\n어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다. 문자열 my_string과 is_suffix가 주어질 때, is_suffix가 my_string의 접미사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요.\n\n9.5.1 파이썬\ndef solution(my_string: str, is_suffix: str) -&gt; int:\n    # my_string이 is_suffix로 끝나는지 확인\n    if my_string.endswith(is_suffix):\n        return 1\n    else:\n        return 0\n\n\n9.5.2 러스트\nfn solution(my_string: &str, is_suffix: &str) -&gt; i32 {\n    // my_string이 is_suffix로 끝나는지 확인\n    if my_string.ends_with(is_suffix) {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let my_string = \"banana\";\n    let is_suffix = \"ana\";\n    let result = solution(my_string, is_suffix);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열의-앞-n글자",
    "href": "posts/qmd/learn_coding_practice.html#문자열의-앞-n글자",
    "title": "코딩테스트 기초",
    "section": "10.1 문자열의 앞 n글자",
    "text": "10.1 문자열의 앞 n글자\n문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 앞의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n10.1.1 파이썬\ndef solution(my_string: str, n: int) -&gt; str:\n    return my_string[:n]\n\n\n10.1.2 러스트\nfn solution(my_string: &str, n: usize) -&gt; String {\n    my_string.chars().take(n).collect()\n}\n\nfn main() {\n    let my_string = \"HelloWorld\";\n    let n = 5;\n    let result = solution(my_string, n);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#접두사인지-확인하기",
    "href": "posts/qmd/learn_coding_practice.html#접두사인지-확인하기",
    "title": "코딩테스트 기초",
    "section": "10.2 접두사인지 확인하기",
    "text": "10.2 접두사인지 확인하기\n어떤 문자열에 대해서 접두사는 특정 인덱스까지의 문자열을 의미합니다. 예를 들어, “banana”의 모든 접두사는 “b”, “ba”, “ban”, “bana”, “banan”, “banana”입니다. 문자열 my_string과 is_prefix가 주어질 때, is_prefix가 my_string의 접두사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요.\n\n10.2.1 파이썬\ndef solution(my_string: str, is_prefix:str) -&gt; int:\n    return int(my_string.startswith(is_prefix))\n\n\n10.2.2 러스트\nfn solution(my_string: &str, is_prefix: &str) -&gt; i32 {\n    my_string.starts_with(is_prefix) as i32\n}\n\nfn main() {\n    let test_string = \"Hello, world!\";\n    let test_prefix = \"Hello\";\n    let result = solution(test_string, test_prefix);\n    println!(\"Is '{}' a prefix of '{}'? {}\", test_prefix, test_string, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-뒤집기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-뒤집기",
    "title": "코딩테스트 기초",
    "section": "10.3 문자열 뒤집기",
    "text": "10.3 문자열 뒤집기\n문자열 my_string과 정수 s, e가 매개변수로 주어질 때, my_string에서 인덱스 s부터 인덱스 e까지를 뒤집은 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n10.3.1 파이썬\ndef solution(my_string: str, s:int, e:int) -&gt; str:\n    # 문자열을 리스트로 변환\n    chars = list(my_string)\n\n    # s부터 e까지의 부분을 뒤집기\n    chars[s:e+1] = chars[s:e+1][::-1]\n\n    # 리스트를 다시 문자열로 변환하여 반환\n    return ''.join(chars)\n\n\n10.3.2 러스트\nfn solution(my_string: &str, s: usize, e: usize) -&gt; String {\n    let mut chars: Vec&lt;char&gt; = my_string.chars().collect();\n\n    let slice = &mut chars[s..=e];\n    slice.reverse();\n\n    chars.into_iter().collect()\n}\n\nfn main() {\n    let result = solution(\"abcde\", 1, 3);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#세로-읽기",
    "href": "posts/qmd/learn_coding_practice.html#세로-읽기",
    "title": "코딩테스트 기초",
    "section": "10.4 세로 읽기",
    "text": "10.4 세로 읽기\n문자열 my_string과 두 정수 m, c가 주어집니다. my_string을 한 줄에 m 글자씩 가로로 적었을 때 왼쪽부터 세로로 c번째 열에 적힌 글자들을 문자열로 return 하는 solution 함수를 작성해 주세요.\n\n10.4.1 파이썬\ndef solution(my_string: str, m: int, c: int) -&gt; str:\n    # 결과를 저장할 문자열 초기화\n    result = ''\n\n    # c번째 열의 문자를 세로로 읽기\n    for i in range(0, len(my_string), m):\n        result += my_string[i + c - 1]\n\n    return result\n\n\n10.4.2 러스트\nfn solution(my_string: &str, m: usize, c: usize) -&gt; String {\n    my_string\n        .chars()\n        .skip(c - 1)\n        .step_by(m)\n        .collect()\n}\n\nfn main() {\n    let result = solution(\"ihrhbakrfpndopljhygc\", 4, 2);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#qr-code",
    "href": "posts/qmd/learn_coding_practice.html#qr-code",
    "title": "코딩테스트 기초",
    "section": "10.5 qr code",
    "text": "10.5 qr code\n두 정수 q, r과 문자열 code가 주어질 때, code의 각 인덱스를 q로 나누었을 때 나머지가 r인 위치의 문자를 앞에서부터 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n10.5.1 파이썬\ndef solution(q: int, r: int, code: str) -&gt; str:\n    return ''.join(code[i] for i in range(len(code)) if i % q == r)\n\n\n10.5.2 러스트\nfn solution(q: usize, r: usize, code: &str) -&gt; String {\n    code.chars()\n        .enumerate()\n        .filter(|&(i, _)| i % q == r)\n        .map(|(_, c)| c)\n        .collect()\n}\n\nfn main() {\n    let result = solution(3, 1, \"qjnwezgrpirldywt\");\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자-개수-세기",
    "href": "posts/qmd/learn_coding_practice.html#문자-개수-세기",
    "title": "코딩테스트 기초",
    "section": "11.1 문자 개수 세기",
    "text": "11.1 문자 개수 세기\n알파벳 대소문자로만 이루어진 문자열 my_string이 주어질 때, my_string에서 ’A’의 개수, my_string에서 ’B’의 개수,…, my_string에서 ’Z’의 개수, my_string에서 ’a’의 개수, my_string에서 ’b’의 개수,…, my_string에서 ’z’의 개수를 순서대로 담은 길이 52의 정수 배열을 return 하는 solution 함수를 작성해 주세요.\n\n11.1.1 파이썬\nfrom typing import List\n\ndef solution(my_string:str) -&gt; List[int]:\n    answer = [0] * 52  # 52개의 0으로 초기화된 리스트 생성\n\n    for char in my_string:\n        if char.isupper():\n            # 대문자인 경우\n            index = ord(char) - ord('A')\n        elif char.islower():\n            # 소문자인 경우\n            index = ord(char) - ord('a') + 26\n        else:\n            # 알파벳이 아닌 경우 (이 문제에서는 발생하지 않지만, 안전성을 위해 추가)\n            continue\n\n        answer[index] += 1\n\n    return answer\n\n\n11.1.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;i32&gt; {\n    let mut answer = vec![0; 52]; // Initialize a vector with 52 zeros\n\n    for char in my_string.chars() {\n        let index = if char.is_ascii_uppercase() {\n            // For uppercase letters\n            (char as u8 - b'A') as usize\n        } else if char.is_ascii_lowercase() {\n            // For lowercase letters\n            (char as u8 - b'a') as usize + 26\n        } else {\n            // For non-alphabetic characters (not expected in this problem, but added for safety)\n            continue;\n        };\n\n        answer[index] += 1;\n    }\n\n    answer\n}\n\nfn main() {\n    let test_string = \"Rust is awesome!\";\n    let result = solution(test_string);\n    println!(\"Result for '{}': {:?}\", test_string, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-만들기-1",
    "href": "posts/qmd/learn_coding_practice.html#배열-만들기-1",
    "title": "코딩테스트 기초",
    "section": "11.2 배열 만들기 1",
    "text": "11.2 배열 만들기 1\n정수 n과 k가 주어졌을 때, 1 이상 n이하의 정수 중에서 k의 배수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.\n\n11.2.1 파이썬\nfrom tpying import List\n\ndef solution(n: int, k: int) -&gt; List[int]:\n    return [i for i in range(k, n+1, k)]\n\n\n11.2.2 러스트\nfn solution(n: i32, k: i32) -&gt; Vec&lt;i32&gt; {\n    (k..=n).step_by(k as usize).collect()\n}\n\nfn main() {\n    let n = 10;\n    let k = 3;\n    let result = solution(n, k);\n    println!(\"Result for n={} and k={}: {:?}\", n, k, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#글자-지우기",
    "href": "posts/qmd/learn_coding_practice.html#글자-지우기",
    "title": "코딩테스트 기초",
    "section": "11.3 글자 지우기",
    "text": "11.3 글자 지우기\n문자열 my_string과 정수 배열 indices가 주어질 때, my_string에서 indices의 원소에 해당하는 인덱스의 글자를 지우고 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n11.3.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str, indices: List[int]) -&gt; str:\n    # 문자열을 리스트로 변환\n    chars = list(my_string)\n\n    # indices의 원소에 해당하는 인덱스의 문자를 빈 문자로 대체\n    for index in indices:\n        chars[index] = ''\n\n    # 리스트를 다시 문자열로 결합\n    return ''.join(chars)\n\n\n11.3.2 러스트\nfrom typing import List\n\ndef solution(my_string: str, indices: List[int]) -&gt; str:\n    # 문자열을 리스트로 변환\n    chars = list(my_string)\n\n    # indices의 원소에 해당하는 인덱스의 문자를 빈 문자로 대체\n    for index in indices:\n        chars[index] = ''\n\n    # 리스트를 다시 문자열로 결합\n    return ''.join(chars)"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#카운트-다운",
    "href": "posts/qmd/learn_coding_practice.html#카운트-다운",
    "title": "코딩테스트 기초",
    "section": "11.4 카운트 다운",
    "text": "11.4 카운트 다운\n정수 start_num와 end_num가 주어질 때, start_num에서 end_num까지 1씩 감소하는 수들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.\n\n11.4.1 파이썬\nfrom typing import List\n\ndef solution(start_num: int, end_num: int) -&gt; List[int]:\n    return list(range(start_num, end_num - 1, -1))\n\n\n11.4.2 러스트\nfn solution(start_num: i32, end_num: i32) -&gt; Vec&lt;i32&gt; {\n    (end_num..=start_num).rev().collect()\n}\n\nfn main() {\n    let start_num = 10;\n    let end_num = 5;\n    let result = solution(start_num, end_num);\n    println!(\"Result from {} to {}: {:?}\", start_num, end_num, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#가까운-1-찾기",
    "href": "posts/qmd/learn_coding_practice.html#가까운-1-찾기",
    "title": "코딩테스트 기초",
    "section": "11.5 가까운 1 찾기",
    "text": "11.5 가까운 1 찾기\n정수 배열 arr가 주어집니다. 이때 arr의 원소는 1 또는 0입니다. 정수 idx가 주어졌을 때, idx보다 크면서 배열의 값이 1인 가장 작은 인덱스를 찾아서 반환하는 solution 함수를 완성해 주세요.만약 그러한 인덱스가 없다면 -1을 반환합니다.\n\n11.5.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], idx:int) -&gt; int:\n    for i in range(idx, len(arr)):\n        if arr[i] == 1:\n            return i\n    return -1\n\n\n11.5.2 러스트\nfn solution(arr: &[i32], idx: usize) -&gt; i32 {\n    for (i, &value) in arr.iter().enumerate().skip(idx) {\n        if value == 1 {\n            return i as i32;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let arr = vec![0, 0, 0, 1, 0, 1];\n    let idx = 2;\n    let result = solution(&arr, idx);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#리스트-자르기",
    "href": "posts/qmd/learn_coding_practice.html#리스트-자르기",
    "title": "코딩테스트 기초",
    "section": "12.1 리스트 자르기",
    "text": "12.1 리스트 자르기\n정수 n과 정수 3개가 담긴 리스트 slicer 그리고 정수 여러 개가 담긴 리스트 num_list가 주어집니다. slicer에 담긴 정수를 차례대로 a, b, c라고 할 때, n에 따라 다음과 같이 num_list를 슬라이싱 하려고 합니다.\n\nn = 1 : num_list의 0번 인덱스부터 b번 인덱스까지\nn = 2 : num_list의 a번 인덱스부터 마지막 인덱스까지\nn = 3 : num_list의 a번 인덱스부터 b번 인덱스까지\nn = 4 : num_list의 a번 인덱스부터 b번 인덱스까지 c 간격으로\n\n올바르게 슬라이싱한 리스트를 return하도록 solution 함수를 완성해주세요.\n\n12.1.1 파이썬\nfrom typing import List\n\ndef solution(n: int, slicer: List[int], num_list: List[int]) -&gt; List[int]:\n    a, b, c = slicer\n\n    if n == 1:\n        return num_list[:b+1]\n    elif n == 2:\n        return num_list[a:]\n    elif n == 3:\n        return num_list[a:b+1]\n    elif n == 4:\n        return num_list[a:b+1:c]\n\n\n12.1.2 러스트\nfn solution(n: i32, slicer: &[i32], num_list: &[i32]) -&gt; Vec&lt;i32&gt; {\n    let (a, b, c) = (slicer[0] as usize, slicer[1] as usize, slicer[2] as usize);\n\n    match n {\n        1 =&gt; num_list[..=b].to_vec(),\n        2 =&gt; num_list[a..].to_vec(),\n        3 =&gt; num_list[a..=b].to_vec(),\n        4 =&gt; num_list[a..=b].iter().step_by(c).cloned().collect(),\n        _ =&gt; Vec::new(), // Handle unexpected n values\n    }\n}\n\nfn main() {\n    let slicer = vec![1, 5, 2];\n    let num_list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    println!(\"n = 1: {:?}\", solution(1, &slicer, &num_list));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#첫-번째로-나오는-음수",
    "href": "posts/qmd/learn_coding_practice.html#첫-번째로-나오는-음수",
    "title": "코딩테스트 기초",
    "section": "12.2 첫 번째로 나오는 음수",
    "text": "12.2 첫 번째로 나오는 음수\n정수 리스트 num_list가 주어질 때, 첫 번째로 나오는 음수의 인덱스를 return하도록 solution 함수를 완성해주세요. 음수가 없다면 -1을 return합니다.\n\n12.2.1 파이썬\nfrom typing import List\ndef solution(num_list: List[int]) -&gt; int:\n    for i, num in enumerate(num_list):\n        if num &lt; 0:\n            return i\n    return -1\n\n\n12.2.2 러스트\nfn solution(num_list: &[i32]) -&gt; i32 {\n    for (i, &num) in num_list.iter().enumerate() {\n        if num &lt; 0 {\n            return i as i32;\n        }\n    }\n    -1\n}\n\nfn main() {\n    let num_list = vec![1, 2, 3, -4, 5, 6];\n    println!(\"Result: {}\", solution(&num_list));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-만들기-3",
    "href": "posts/qmd/learn_coding_practice.html#배열-만들기-3",
    "title": "코딩테스트 기초",
    "section": "12.3 배열 만들기 3",
    "text": "12.3 배열 만들기 3\n정수 배열 arr와 2개의 구간이 담긴 배열 intervals가 주어집니다.\nintervals는 항상 [[a1, b1], [a2, b2]]의 꼴로 주어지며 각 구간은 닫힌 구간입니다. 닫힌 구간은 양 끝값과 그 사이의 값을 모두 포함하는 구간을 의미합니다.\n이때 배열 arr의 첫 번째 구간에 해당하는 배열과 두 번째 구간에 해당하는 배열을 앞뒤로 붙여 새로운 배열을 만들어 return 하는 solution 함수를 완성해 주세요.\n\n12.3.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], intervals: List[int]) -&gt; List[int]:\n    result = []\n    for interval in intervals:\n        start, end = interval\n        result.extend(arr[start:end+1])\n    return result\n\n\n12.3.2 러스트\nfn solution(arr: &[i32], intervals: &[[i32; 2]]) -&gt; Vec&lt;i32&gt; {\n    let mut result = Vec::new();\n    for interval in intervals {\n        let start = interval[0] as usize;\n        let end = interval[1] as usize;\n        result.extend_from_slice(&arr[start..=end]);\n    }\n    result\n}\n\nfn main() {\n    let arr = vec![1, 2, 3, 4, 5];\n    let intervals = vec![[1, 3], [0, 4]];\n    let result = solution(&arr, &intervals);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#의-영역",
    "href": "posts/qmd/learn_coding_practice.html#의-영역",
    "title": "코딩테스트 기초",
    "section": "12.4 2의 영역",
    "text": "12.4 2의 영역\n정수 배열 arr가 주어집니다. 배열 안의 2가 모두 포함된 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요.\n단, arr에 2가 없는 경우 [-1]을 return 합니다.\n\n12.4.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; List[int]:\n    # 2의 위치를 모두 찾습니다\n    indices = [i for i, x in enumerate(arr) if x == 2]\n\n    # 2가 없는 경우 [-1]을 반환합니다\n    if not indices:\n        return [-1]\n\n    # 첫 번째 2와 마지막 2의 인덱스를 찾습니다\n    start = indices[0]\n    end = indices[-1]\n\n    # 해당 범위의 부분 배열을 반환합니다\n    return arr[start:end+1]\n\n\n12.4.2 러스트\nfn solution(arr: &[i32]) -&gt; Vec&lt;i32&gt; {\n    // 2의 위치를 모두 찾습니다\n    let indices: Vec&lt;usize&gt; = arr.iter()\n        .enumerate()\n        .filter(|&(_, &x)| x == 2)\n        .map(|(i, _)| i)\n        .collect();\n\n    // 2가 없는 경우 [-1]을 반환합니다\n    if indices.is_empty() {\n        return vec![-1];\n    }\n\n    // 첫 번째 2와 마지막 2의 인덱스를 찾습니다\n    let start = indices[0];\n    let end = indices[indices.len() - 1];\n\n    // 해당 범위의 부분 배열을 반환합니다\n    arr[start..=end].to_vec()\n}\n\nfn main() {\n    let arr = vec![1, 2, 1, 4, 5, 2, 9];\n    let result = solution(&arr);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-조각하기",
    "href": "posts/qmd/learn_coding_practice.html#배열-조각하기",
    "title": "코딩테스트 기초",
    "section": "12.5 배열 조각하기",
    "text": "12.5 배열 조각하기\n정수 배열 arr와 query가 주어집니다.\nquery를 순회하면서 다음 작업을 반복합니다.\n\n짝수 인덱스에서는 arr에서 query[i]번 인덱스를 제외하고 배열의 query[i]번 인덱스 뒷부분을 잘라서 버립니다.\n홀수 인덱스에서는 arr에서 query[i]번 인덱스는 제외하고 배열의 query[i]번 인덱스 앞부분을 잘라서 버립니다.\n\n위 작업을 마친 후 남은 arr의 부분 배열을 return 하는 solution 함수를 완성해 주세요.\n\n12.5.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], query: List[int]) -&gt; List[int]:\n    start, end = 0, len(arr)\n\n    for i, q in enumerate(query):\n        if i % 2 == 0:  # 짝수 인덱스\n            end = start + q + 1\n        else:  # 홀수 인덱스\n            start += q\n\n    return arr[start:end]\n\n\n12.5.2 러스트\nfn solution(arr: &[i32], query: &[i32]) -&gt; Vec&lt;i32&gt; {\n    let mut start = 0;\n    let mut end = arr.len();\n\n    for (i, &q) in query.iter().enumerate() {\n        if i % 2 == 0 {  // 짝수 인덱스\n            end = start + q as usize + 1;\n        } else {  // 홀수 인덱스\n            start += q as usize;\n        }\n    }\n\n    arr[start..end].to_vec()\n}\n\nfn main() {\n    let arr = vec![0, 1, 2, 3, 4, 5];\n    let query = vec![4, 1, 2];\n    let result = solution(&arr, &query);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#n-번째-원소부터",
    "href": "posts/qmd/learn_coding_practice.html#n-번째-원소부터",
    "title": "코딩테스트 기초",
    "section": "13.1 n 번째 원소부터",
    "text": "13.1 n 번째 원소부터\n정수 리스트 num_list와 정수 n이 주어질 때, n 번째 원소부터 마지막 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.\n\n13.1.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int], n:int) -&gt; List[int]:\n    return num_list[n-1:]\n\n\n13.1.2 러스트\nfn solution(num_list: &[i32], n: usize) -&gt; Vec&lt;i32&gt; {\n    num_list[n-1..].to_vec()\n}\n\nfn main() {\n    let num_list = vec![2, 1, 6, 3, 7, 5];\n    let n = 3;\n    let result = solution(&num_list, n);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#순서-바꾸기",
    "href": "posts/qmd/learn_coding_practice.html#순서-바꾸기",
    "title": "코딩테스트 기초",
    "section": "13.2 순서 바꾸기",
    "text": "13.2 순서 바꾸기\n정수 리스트 num_list와 정수 n이 주어질 때, num_list를 n 번째 원소 이후의 원소들과 n 번째까지의 원소들로 나눠 n 번째 원소 이후의 원소들을 n 번째까지의 원소들 앞에 붙인 리스트를 return하도록 solution 함수를 완성해주세요.\n\n13.2.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int], n: int) -&gt; List[int]:\n    return num_list[n:] + num_list[:n]\n\n\n13.2.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;, n: usize) -&gt; Vec&lt;i32&gt; {\n    let mut result = num_list[n..].to_vec();\n    result.extend_from_slice(&num_list[..n]);\n    result\n}\n\nfn main() {\n    let num_list = vec![1, 2, 3, 4, 5];\n    let n = 2;\n    let result = solution(num_list, n);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#왼쪽-오른쪽",
    "href": "posts/qmd/learn_coding_practice.html#왼쪽-오른쪽",
    "title": "코딩테스트 기초",
    "section": "13.3 왼쪽 오른쪽",
    "text": "13.3 왼쪽 오른쪽\n문자열 리스트 str_list에는 “u”, “d”, “l”, “r” 네 개의 문자열이 여러 개 저장되어 있습니다. str_list에서 “l”과 “r” 중 먼저 나오는 문자열이 “l”이라면 해당 문자열을 기준으로 왼쪽에 있는 문자열들을 순서대로 담은 리스트를, 먼저 나오는 문자열이 “r”이라면 해당 문자열을 기준으로 오른쪽에 있는 문자열들을 순서대로 담은 리스트를 return하도록 solution 함수를 완성해주세요. “l”이나 “r”이 없다면 빈 리스트를 return합니다.\n\n13.3.1 파이썬\nfrom typing import List\n\ndef solution(str_list: List[str]) -&gt; List[str]:\n    for i, char in enumerate(str_list):\n        if char == 'l':\n            return str_list[:i]\n        elif char == 'r':\n            return str_list[i+1:]\n    return []\n\n\n13.3.2 러스트\nfn solution(str_list: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    for (i, char) in str_list.iter().enumerate() {\n        if char == \"l\" {\n            return str_list[..i].to_vec();\n        } else if char == \"r\" {\n            return str_list[i+1..].to_vec();\n        }\n    }\n    Vec::new()\n}\n\nfn main() {\n    let str_list = vec![\n        \"u\".to_string(),\n        \"u\".to_string(),\n        \"l\".to_string(),\n        \"r\".to_string()\n    ];\n    let result = solution(str_list);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#n번째-원소까지",
    "href": "posts/qmd/learn_coding_practice.html#n번째-원소까지",
    "title": "코딩테스트 기초",
    "section": "13.4 n번째 원소까지",
    "text": "13.4 n번째 원소까지\n정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.\n\n13.4.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int], n: int) -&gt; List[int]:\n    return num_list[:n]\n\n\n13.4.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;, n: usize) -&gt; Vec&lt;i32&gt; {\n    num_list[..n].to_vec()\n}\n\nfn main() {\n    let num_list = vec![1, 2, 3, 4, 5];\n    let n = 3;\n    let result = solution(num_list, n);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#n개-간격의-원소들",
    "href": "posts/qmd/learn_coding_practice.html#n개-간격의-원소들",
    "title": "코딩테스트 기초",
    "section": "13.5 n개 간격의 원소들",
    "text": "13.5 n개 간격의 원소들\n정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 마지막 원소까지 n개 간격으로 저장되어있는 원소들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.\n\n13.5.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int], n: int) -&gt; List[int]:\n    return num_list[::n]\n\n\n13.5.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;, n: usize) -&gt; Vec&lt;i32&gt; {\n    num_list.iter().step_by(n).cloned().collect()\n}\n\nfn main() {\n    let num_list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let n = 2;\n    let result = solution(num_list, n);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#홀수-vs-짝수",
    "href": "posts/qmd/learn_coding_practice.html#홀수-vs-짝수",
    "title": "코딩테스트 기초",
    "section": "14.1 홀수 vs 짝수",
    "text": "14.1 홀수 vs 짝수\n정수 리스트 num_list가 주어집니다. 가장 첫 번째 원소를 1번 원소라고 할 때, 홀수 번째 원소들의 합과 짝수 번째 원소들의 합 중 큰 값을 return 하도록 solution 함수를 완성해주세요. 두 값이 같을 경우 그 값을 return합니다.\n\n14.1.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int]) -&gt; int:\n    odd_sum = sum(num_list[::2])  # 홀수 번째 원소들의 합\n    even_sum = sum(num_list[1::2])  # 짝수 번째 원소들의 합\n    return max(odd_sum, even_sum)\n\n\n14.1.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;) -&gt; i32 {\n    let odd_sum: i32 = num_list.iter().step_by(2).sum();\n    let even_sum: i32 = num_list.iter().skip(1).step_by(2).sum();\n    odd_sum.max(even_sum)\n}\n\nfn main() {\n    let num_list = vec![4, 2, 6, 1, 7, 6];\n    let result = solution(num_list);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#명씩",
    "href": "posts/qmd/learn_coding_practice.html#명씩",
    "title": "코딩테스트 기초",
    "section": "14.2 5명씩",
    "text": "14.2 5명씩\n최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 names가 주어질 때, 앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름을 담은 리스트를 return하도록 solution 함수를 완성해주세요. 마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다.\n\n14.2.1 파이썬\nfrom typing import List\n\ndef solution(names: List[str]):\n    return names[::5]\n\n\n14.2.2 러스트\nfn solution(names: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    names.into_iter().step_by(5).collect()\n}\n\nfn main() {\n    let names = vec![\n        \"Jane\".to_string(),\n        \"Kim\".to_string(),\n    ];\n\n    let result = solution(names);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#할-일-목록",
    "href": "posts/qmd/learn_coding_practice.html#할-일-목록",
    "title": "코딩테스트 기초",
    "section": "14.3 할 일 목록",
    "text": "14.3 할 일 목록\n오늘 해야 할 일이 담긴 문자열 배열 todo_list와 각각의 일을 지금 마쳤는지를 나타내는 boolean 배열 finished가 매개변수로 주어질 때, todo_list에서 아직 마치지 못한 일들을 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.\n\n14.3.1 파이썬\nfrom typing import List\n\ndef solution(todo_list: List[str], finished: List[bool]) -&gt; List[str]:\n    return [task for task, is_finished in zip(todo_list, finished) if not is_finished]\n\n\n14.3.2 러스트\nfn solution(todo_list: Vec&lt;String&gt;, finished: Vec&lt;bool&gt;) -&gt; Vec&lt;String&gt; {\n    todo_list\n        .into_iter()\n        .zip(finished)\n        .filter(|(_, is_finished)| !is_finished)\n        .map(|(task, _)| task)\n        .collect()\n}\n\nfn main() {\n    let todo_list = vec![\n        \"laundry\".to_string(),\n        \"dishes\".to_string(),\n        \"vacuum\".to_string(),\n        \"groceries\".to_string(),\n    ];\n    let finished = vec![true, false, true, false];\n\n    let result = solution(todo_list, finished);\n    println!(\"Unfinished tasks: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#n보다-커질-때까지-더하기",
    "href": "posts/qmd/learn_coding_practice.html#n보다-커질-때까지-더하기",
    "title": "코딩테스트 기초",
    "section": "14.4 n보다 커질 때까지 더하기",
    "text": "14.4 n보다 커질 때까지 더하기\n정수 배열 numbers와 정수 n이 매개변수로 주어집니다. numbers의 원소를 앞에서부터 하나씩 더하다가 그 합이 n보다 커지는 순간 이때까지 더했던 원소들의 합을 return 하는 solution 함수를 작성해 주세요.\n\n14.4.1 파이썬\nfrom typing import List\n\ndef solution(numbers: List[str], n: int) -&gt; int:\n    total = 0\n    for num in numbers:\n        total += num\n        if total &gt; n:\n            return total\n    return total\n\n\n14.4.2 러스트\nfn solution(numbers: Vec&lt;String&gt;, n: i32) -&gt; i32 {\n    let mut total = 0;\n    for num in numbers {\n        total += num.parse::&lt;i32&gt;().unwrap();\n        if total &gt; n {\n            return total;\n        }\n    }\n    total\n}\n\nfn main() {\n    let numbers = vec![\n        \"1\".to_string(),\n        \"2\".to_string(),\n        \"3\".to_string(),\n        \"4\".to_string(),\n        \"5\".to_string(),\n    ];\n    let n = 8;\n\n    let result = solution(numbers, n);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#수열과-구간-쿼리-1",
    "href": "posts/qmd/learn_coding_practice.html#수열과-구간-쿼리-1",
    "title": "코딩테스트 기초",
    "section": "14.5 수열과 구간 쿼리 1",
    "text": "14.5 수열과 구간 쿼리 1\n정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e] 꼴입니다. 각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 arr[i]에 1을 더합니다. 위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.\n\n14.5.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], queries: List[int]) -&gt; List[int]:\n    for s, e in queries:\n        for i in range(s, e + 1):\n            arr[i] += 1\n    return arr\n\n\n14.5.2 러스트\nfn solution(mut arr: Vec&lt;i32&gt;, queries: Vec&lt;(usize, usize)&gt;) -&gt; Vec&lt;i32&gt; {\n    for (s, e) in queries {\n        for i in s..=e {\n            arr[i] += 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n    let arr = vec![0, 1, 2, 3, 4];\n    let queries = vec![(0, 3), (1, 2)];\n\n    let result = solution(arr, queries);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-1",
    "href": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-1",
    "title": "코딩테스트 기초",
    "section": "15.1 조건에 맞게 수열 변환하기 1",
    "text": "15.1 조건에 맞게 수열 변환하기 1\n정수 배열 arr가 주어집니다. arr의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱합니다. 그 결과인 정수 배열을 return 하는 solution 함수를 완성해 주세요.\n\n15.1.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; List[int]:\n    return [num // 2 if num &gt;= 50 and num % 2 == 0 else num * 2 if num &lt; 50 and num % 2 == 1 else num for num in arr]\n\n\n15.1.2 러스트\nfn solution(arr: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    arr.into_iter().map(|num| {\n        if num &gt;= 50 && num % 2 == 0 {\n            num / 2\n        } else if num &lt; 50 && num % 2 == 1 {\n            num * 2\n        } else {\n            num\n        }\n    }).collect()\n}\n\nfn main() {\n    let arr = vec![10, 51, 50, 49, 48]; // Example input\n    let result = solution(arr);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-2",
    "href": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-2",
    "title": "코딩테스트 기초",
    "section": "15.2 조건에 맞게 수열 변환하기 2",
    "text": "15.2 조건에 맞게 수열 변환하기 2\n정수 배열 arr가 주어집니다. arr의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱하고 다시 1을 더합니다.\n이러한 작업을 x번 반복한 결과인 배열을 arr(x)라고 표현했을 때, arr(x) = arr(x + 1)인 x가 항상 존재합니다. 이러한 x 중 가장 작은 값을 return 하는 solution 함수를 완성해 주세요.\n단, 두 배열에 대한 “=”는 두 배열의 크기가 서로 같으며, 같은 인덱스의 원소가 각각 서로 같음을 의미합니다.\n\n15.2.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; int:\n    x = 0\n    prev_arr = arr.copy()\n\n    while True:\n        new_arr = []\n        for num in prev_arr:\n            if num &gt;= 50 and num % 2 == 0:\n                new_arr.append(num // 2)\n            elif num &lt; 50 and num % 2 == 1:\n                new_arr.append(num * 2 + 1)\n            else:\n                new_arr.append(num)\n\n        if new_arr == prev_arr:\n            return x\n\n        prev_arr = new_arr\n        x += 1\n\n\n15.2.2 러스트\nfn solution(arr: Vec&lt;i32&gt;) -&gt; i32 {\n    let mut x = 0;\n    let mut prev_arr = arr;\n\n    loop {\n        let new_arr: Vec&lt;i32&gt; = prev_arr.iter().map(|&num| {\n            if num &gt;= 50 && num % 2 == 0 {\n                num / 2\n            } else if num &lt; 50 && num % 2 == 1 {\n                num * 2 + 1\n            } else {\n                num\n            }\n        }).collect();\n\n        if new_arr == prev_arr {\n            return x;\n        }\n\n        prev_arr = new_arr;\n        x += 1;\n    }\n}\n\nfn main() {\n    let arr = vec![10, 51, 50, 49, 48]; // Example input\n    let result = solution(arr);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#로-만들기",
    "href": "posts/qmd/learn_coding_practice.html#로-만들기",
    "title": "코딩테스트 기초",
    "section": "15.3 1로 만들기",
    "text": "15.3 1로 만들기\n정수가 있을 때, 짝수라면 반으로 나누고, 홀수라면 1을 뺀 뒤 반으로 나누면, 마지막엔 1이 됩니다. 예를 들어 10이 있다면 다음과 같은 과정으로 1이 됩니다.\n10 / 2 = 5\n(5 - 1) / 2 = 2\n2 / 2 = 1\n위와 같이 3번의 나누기 연산으로 1이 되었습니다.\n정수들이 담긴 리스트 num_list가 주어질 때, num_list의 모든 원소를 1로 만들기 위해서 필요한 나누기 연산의 횟수를 return하도록 solution 함수를 완성해주세요.\n\n15.3.1 파이썬\nfrom typing import List\ndef solution(num_list: List[int]) -&gt; int:\n    def count_operations(num):\n        count = 0\n        while num &gt; 1:\n            if num % 2 == 0:\n                num //= 2\n            else:\n                num = (num - 1) // 2\n            count += 1\n        return count\n\n    return sum(count_operations(num) for num in num_list)\n\n\n15.3.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;) -&gt; i32 {\n    fn count_operations(mut num: i32) -&gt; i32 {\n        let mut count = 0;\n        while num &gt; 1 {\n            if num % 2 == 0 {\n                num /= 2;\n            } else {\n                num = (num - 1) / 2;\n            }\n            count += 1;\n        }\n        count\n    }\n\n    num_list.iter().map(|&num| count_operations(num)).sum()\n}\n\nfn main() {\n    let num_list = vec![12, 15, 7, 8]; // Example input\n    let result = solution(num_list);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#길이에-따른-연산",
    "href": "posts/qmd/learn_coding_practice.html#길이에-따른-연산",
    "title": "코딩테스트 기초",
    "section": "15.4 길이에 따른 연산",
    "text": "15.4 길이에 따른 연산\n정수가 담긴 리스트 num_list가 주어질 때, 리스트의 길이가 11 이상이면 리스트에 있는 모든 원소의 합을 10 이하이면 모든 원소의 곱을 return하도록 solution 함수를 완성해주세요.\n\n15.4.1 파이썬\nimport math\nfrom typing import List\ndef solution(num_list: List[int]) -&gt; int:\n    if len(num_list) &gt;= 11:\n        return sum(num_list)\n    else:\n        return math.prod(num_list)\n\n\n15.4.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;) -&gt; i32 {\n    if num_list.len() &gt;= 11 {\n        num_list.iter().sum()\n    } else {\n        num_list.iter().product()\n    }\n}\n\nfn main() {\n    let num_list1 = vec![1, 2, 3, 4, 5]; // Example input with less than 11 elements\n    let num_list2 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // Example input with 11 elements\n\n    println!(\"Result 1: {}\", solution(num_list1));\n    println!(\"Result 2: {}\", solution(num_list2));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#원하는-문자열-찾기",
    "href": "posts/qmd/learn_coding_practice.html#원하는-문자열-찾기",
    "title": "코딩테스트 기초",
    "section": "15.5 원하는 문자열 찾기",
    "text": "15.5 원하는 문자열 찾기\n알파벳으로 이루어진 문자열 myString과 pat이 주어집니다. myString의 연속된 부분 문자열 중 pat이 존재하면 1을 그렇지 않으면 0을 return 하는 solution 함수를 완성해 주세요. 단, 알파벳 대문자와 소문자는 구분하지 않습니다.\n\n15.5.1 파이썬\ndef solution(myString: str, pat: str) -&gt; int:\n    return int(pat.lower() in myString.lower())\n\n\n15.5.2 러스트\n// Import necessary modules\nuse std::collections::HashMap; // Example import\n\n// Define structs or enums if needed\nstruct MyStruct {\n    field1: i32,\n    field2: String,\n}\n\n// Implement methods for structs if needed\nimpl MyStruct {\n    fn new(value1: i32, value2: String) -&gt; Self {\n        MyStruct {\n            field1: value1,\n            field2: value2,\n        }\n    }\n\n    fn some_method(&self) -&gt; i32 {\n        // Method implementation\n        self.field1\n    }\n}\n\n// Main function\nfn main() {\n    // Your converted code logic here\n    let my_instance = MyStruct::new(42, String::from(\"Hello\"));\n    println!(\"Result: {}\", my_instance.some_method());\n}\n\n// Helper functions\nfn helper_function(param: i32) -&gt; i32 {\n    // Function implementation\n    param * 2\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#대문자로-바꾸기",
    "href": "posts/qmd/learn_coding_practice.html#대문자로-바꾸기",
    "title": "코딩테스트 기초",
    "section": "16.1 대문자로 바꾸기",
    "text": "16.1 대문자로 바꾸기\n알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 대문자로 변환하여 return 하는 solution 함수를 완성해 주세요.\n\n16.1.1 파이썬\ndef solution(myString: str) -&gt; str:\n    return myString.upper()\n\n\n16.1.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.to_uppercase()\n}\n\nfn main() {\n    let example_string = \"Hello, World!\";\n    let result = solution(example_string);\n    println!(\"Original: {}\", example_string);\n    println!(\"Uppercase: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#소문자로-바꾸기",
    "href": "posts/qmd/learn_coding_practice.html#소문자로-바꾸기",
    "title": "코딩테스트 기초",
    "section": "16.2 소문자로 바꾸기",
    "text": "16.2 소문자로 바꾸기\n알파벳으로 이루어진 문자열 myString이 주어집니다. 모든 알파벳을 소문자로 변환하여 return 하는 solution 함수를 완성해 주세요.\n\n16.2.1 파이썬\ndef solution(myString:str) -&gt; str:\n    return myString.lower()\n\n\n16.2.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.to_lowercase()\n}\n\nfn main() {\n    let example_string = \"Hello, World!\";\n    let result = solution(example_string);\n    println!(\"Original: {}\", example_string);\n    println!(\"Lowercase: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열에서-문자열-대소문자-변환",
    "href": "posts/qmd/learn_coding_practice.html#배열에서-문자열-대소문자-변환",
    "title": "코딩테스트 기초",
    "section": "16.3 배열에서 문자열 대소문자 변환",
    "text": "16.3 배열에서 문자열 대소문자 변환\n문자열 배열 strArr가 주어집니다. 모든 원소가 알파벳으로만 이루어져 있을 때, 배열에서 홀수번째 인덱스의 문자열은 모든 문자를 대문자로, 짝수번째 인덱스의 문자열은 모든 문자를 소문자로 바꿔서 반환하는 solution 함수를 완성해 주세요.\n\n16.3.1 파이썬\nfrom typing import List\n\ndef solution(strArr: List[str]) -&gt; List[str]:\n    return [s.lower() if i % 2 == 0 else s.upper() for i, s in enumerate(strArr)]\n\n\n16.3.2 러스트\nfn solution(str_arr: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    str_arr.iter().enumerate().map(|(i, s)| {\n        if i % 2 == 0 {\n            s.to_lowercase()\n        } else {\n            s.to_uppercase()\n        }\n    }).collect()\n}\n\nfn main() {\n    let example_vec = vec![\n        String::from(\"Hello\"),\n        String::from(\"World\"),\n        String::from(\"Rust\"),\n        String::from(\"Programming\")\n    ];\n\n    let result = solution(example_vec.clone());\n\n    println!(\"Original: {:?}\", example_vec);\n    println!(\"Result:   {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#a-강조하기",
    "href": "posts/qmd/learn_coding_practice.html#a-강조하기",
    "title": "코딩테스트 기초",
    "section": "16.4 A 강조하기",
    "text": "16.4 A 강조하기\n문자열 myString이 주어집니다. myString에서 알파벳 “a”가 등장하면 전부 “A”로 변환하고, “A”가 아닌 모든 대문자 알파벳은 소문자 알파벳으로 변환하여 return 하는 solution 함수를 완성하세요.\n\n16.4.1 파이썬\ndef solution(myString: str) -&gt; str:\n    return ''.join(['A' if c.lower() == 'a' else c.lower() for c in myString])\n\n\n16.4.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.chars().map(|c| {\n        if c.to_ascii_lowercase() == 'a' {\n            'A'\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}\n\nfn main() {\n    let example_string = \"AbCdEfG\";\n    let result = solution(example_string);\n    println!(\"Original: {}\", example_string);\n    println!(\"Result:   {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#특정한-문자를-대문자로-바꾸기",
    "href": "posts/qmd/learn_coding_practice.html#특정한-문자를-대문자로-바꾸기",
    "title": "코딩테스트 기초",
    "section": "16.5 특정한 문자를 대문자로 바꾸기",
    "text": "16.5 특정한 문자를 대문자로 바꾸기\n영소문자로 이루어진 문자열 my_string과 영소문자 1글자로 이루어진 문자열 alp가 매개변수로 주어질 때, my_string에서 alp에 해당하는 모든 글자를 대문자로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n16.5.1 파이썬\ndef solution(my_string: str, alp:str) -&gt; str:\n    return my_string.replace(alp, alp.upper())\n\n\n16.5.2 러스트\nfn solution(my_string: &str, alp: &str) -&gt; String {\n    my_string.replace(alp, &alp.to_uppercase())\n}\n\nfn main() {\n    let example_string = \"hello world\";\n    let example_alp = \"o\";\n    let result = solution(example_string, example_alp);\n    println!(\"Original: {}\", example_string);\n    println!(\"Replace '{}' with '{}': {}\", example_alp, example_alp.to_uppercase(), result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#특정-문자열로-끝나는-가장-긴-부분-문자열-찾기",
    "href": "posts/qmd/learn_coding_practice.html#특정-문자열로-끝나는-가장-긴-부분-문자열-찾기",
    "title": "코딩테스트 기초",
    "section": "17.1 특정 문자열로 끝나는 가장 긴 부분 문자열 찾기",
    "text": "17.1 특정 문자열로 끝나는 가장 긴 부분 문자열 찾기\n\n17.1.1 파이썬\ndef solution(myString, pat):\n    for i in range(len(myString), -1, -1):\n        if myString[:i].endswith(pat):\n            return myString[:i]"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열이-몇-번-등장하는지-세기",
    "href": "posts/qmd/learn_coding_practice.html#문자열이-몇-번-등장하는지-세기",
    "title": "코딩테스트 기초",
    "section": "17.2 문자열이 몇 번 등장하는지 세기",
    "text": "17.2 문자열이 몇 번 등장하는지 세기\n\n17.2.1 파이썬\ndef solution(myString, pat):\n    answer = 0\n    for i in range(len(myString) - len(pat) + 1):\n        if myString[i:i+len(pat)] == pat:\n            answer += 1\n    return answer\n\n\n17.2.2 러스트\nfn solution(my_string: &str, pat: &str) -&gt; i32 {\n    let mut answer = 0;\n    let pat_len = pat.len();\n\n    for i in 0..=my_string.len() - pat_len {\n        if &my_string[i..i+pat_len] == pat {\n            answer += 1;\n        }\n    }\n\n    answer\n}\n\nfn main() {\n    let my_string = \"banana\";\n    let pat = \"ana\";\n    let result = solution(my_string, pat);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열에서-ad-제거하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열에서-ad-제거하기",
    "title": "코딩테스트 기초",
    "section": "17.3 문자열에서 ad 제거하기",
    "text": "17.3 문자열에서 ad 제거하기\n\n17.3.1 파이썬\ndef solution(strArr):\n    return [s for s in strArr if \"ad\" not in s]\n\n\n17.3.2 러스트\nfn solution(str_arr: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    str_arr.into_iter().filter(|s| !s.contains(\"ad\")).collect()\n}\n\nfn main() {\n    let str_arr = vec![\n        \"bad\".to_string(),\n        \"good\".to_string(),\n        \"mad\".to_string(),\n        \"glad\".to_string(),\n        \"sad\".to_string(),\n    ];\n    let result = solution(str_arr);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#공백으로-구분하기-1",
    "href": "posts/qmd/learn_coding_practice.html#공백으로-구분하기-1",
    "title": "코딩테스트 기초",
    "section": "17.4 공백으로 구분하기 1",
    "text": "17.4 공백으로 구분하기 1\n단어가 공백 한 개로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.\n\n17.4.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str) -&gt; List[str]:\n    return my_string.split()\n\n\n17.4.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;String&gt; {\n    my_string.split_whitespace().map(String::from).collect()\n}\n\nfn main() {\n    let example_string = \"Hello world Rust programming\";\n    let result = solution(example_string);\n    println!(\"Original string: {}\", example_string);\n    println!(\"Split result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#공백으로-구분하기-2",
    "href": "posts/qmd/learn_coding_practice.html#공백으로-구분하기-2",
    "title": "코딩테스트 기초",
    "section": "17.5 공백으로 구분하기 2",
    "text": "17.5 공백으로 구분하기 2\n단어가 공백 한 개 이상으로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.\n\n17.5.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str) -&gt; List[str]:\n    return my_string.split()\n\n\n17.5.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;String&gt; {\n    my_string.split_whitespace().map(String::from).collect()\n}\n\nfn main() {\n    let example_string = \"Hello world Rust programming\";\n    let result = solution(example_string);\n    println!(\"Original string: {}\", example_string);\n    println!(\"Split result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#x사이의-개수",
    "href": "posts/qmd/learn_coding_practice.html#x사이의-개수",
    "title": "코딩테스트 기초",
    "section": "18.1 x사이의 개수",
    "text": "18.1 x사이의 개수\n문자열 myString이 주어집니다. myString을 문자 “x”를 기준으로 나눴을 때 나눠진 문자열 각각의 길이를 순서대로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.\n\n18.1.1 파이썬\nfrom typing import List\n\ndef solution(myString:str) -&gt; List[int]:\n    return [len(s) for s in myString.split('x')]\n\n\n18.1.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;usize&gt; {\n    my_string.split('x').map(|s| s.len()).collect()\n}\n\nfn main() {\n    let my_string = \"examplexstringxhere\"; // Example input\n    let result = solution(my_string);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-잘라서-정렬하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-잘라서-정렬하기",
    "title": "코딩테스트 기초",
    "section": "18.2 문자열 잘라서 정렬하기",
    "text": "18.2 문자열 잘라서 정렬하기\n문자열 myString이 주어집니다. “x”를 기준으로 해당 문자열을 잘라내 배열을 만든 후 사전순으로 정렬한 배열을 return 하는 solution 함수를 완성해 주세요. 단, 빈 문자열은 반환할 배열에 넣지 않습니다.\n\n18.2.1 파이썬\nfrom typing import List\n\ndef solution(myString: str) -&gt; List[int]:\n    return sorted([s for s in myString.split('x') if s])\n\n\n18.2.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;String&gt; {\n    let mut result: Vec&lt;String&gt; = my_string.split('x')\n        .filter(|s| !s.is_empty())\n        .map(String::from)\n        .collect();\n    result.sort();\n    result\n}\n\nfn main() {\n    let my_string = \"axbxcxxdxe\"; // Example input\n    let result = solution(my_string);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#간단한-식-계산하기",
    "href": "posts/qmd/learn_coding_practice.html#간단한-식-계산하기",
    "title": "코딩테스트 기초",
    "section": "18.3 간단한 식 계산하기",
    "text": "18.3 간단한 식 계산하기\n문자열 binomial이 매개변수로 주어집니다. binomial은 “a op b” 형태의 이항식이고 a와 b는 음이 아닌 정수, op는 ‘+’, ‘-’, ’*’ 중 하나입니다. 주어진 식을 계산한 정수를 return 하는 solution 함수를 작성해 주세요.\n\n18.3.1 파이썬\ndef solution(binomial: str) -&gt; int:\n    a, op, b = binomial.split()\n    a, b = int(a), int(b)\n\n    if op == '+':\n        return a + b\n    elif op == '-':\n        return a - b\n    else:  # op == '*'\n        return a * b\n\n\n18.3.2 러스트\nfn solution(binomial: &str) -&gt; i32 {\n    let parts: Vec&lt;&str&gt; = binomial.split_whitespace().collect();\n    let a: i32 = parts[0].parse().unwrap();\n    let op: &str = parts[1];\n    let b: i32 = parts[2].parse().unwrap();\n\n    match op {\n        \"+\" =&gt; a + b,\n        \"-\" =&gt; a - b,\n        _ =&gt; a * b,  // Assumes '*' for any other operator\n    }\n}\n\nfn main() {\n    let binomial = \"3 + 4\";\n    let result = solution(binomial);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-바꿔서-찾기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-바꿔서-찾기",
    "title": "코딩테스트 기초",
    "section": "18.4 문자열 바꿔서 찾기",
    "text": "18.4 문자열 바꿔서 찾기\n문자 “A”와 “B”로 이루어진 문자열 myString과 pat가 주어집니다. myString의 “A”를 “B”로, “B”를 “A”로 바꾼 문자열의 연속하는 부분 문자열 중 pat이 있으면 1을 아니면 0을 return 하는 solution 함수를 완성하세요.\n\n18.4.1 파이썬\ndef solution(myString: str, pat: str) -&gt; int:\n    # myString의 \"A\"를 \"B\"로, \"B\"를 \"A\"로 바꾸는 함수\n    def swap(s):\n        return ''.join('A' if c == 'B' else 'B' for c in s)\n\n    # myString을 변환하고 pat이 포함되어 있는지 확인\n    return 1 if swap(pat) in myString else 0\n\n\n18.4.2 러스트\nfn swap(s: &str) -&gt; String {\n    s.chars().map(|c| match c {\n        'A' =&gt; 'B',\n        'B' =&gt; 'A',\n        _ =&gt; c,\n    }).collect()\n}\n\nfn solution(my_string: &str, pat: &str) -&gt; i32 {\n    if my_string.contains(&swap(pat)) {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let my_string = \"ABBAA\";\n    let pat = \"AABB\";\n    let result = solution(my_string, pat);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#rny_string",
    "href": "posts/qmd/learn_coding_practice.html#rny_string",
    "title": "코딩테스트 기초",
    "section": "18.5 rny_string",
    "text": "18.5 rny_string\n’m’과 “rn”이 모양이 비슷하게 생긴 점을 활용해 문자열에 장난을 하려고 합니다. 문자열 rny_string이 주어질 때, rny_string의 모든 ’m’을 “rn”으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.\n\n18.5.1 파이썬\ndef solution(rny_string: str) -&gt; str:\n    return rny_string.replace('m', 'rn')\n\n\n18.5.2 러스트\nfn solution(rny_string: &str) -&gt; String {\n    rny_string.replace(\"m\", \"rn\")\n}\n\nfn main() {\n    let input = \"programmer\";\n    let result = solution(input);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#세-개의-구분자",
    "href": "posts/qmd/learn_coding_practice.html#세-개의-구분자",
    "title": "코딩테스트 기초",
    "section": "19.1 세 개의 구분자",
    "text": "19.1 세 개의 구분자\n임의의 문자열이 주어졌을 때 문자 “a”, “b”, “c”를 구분자로 사용해 문자열을 나누고자 합니다.\n예를 들어 주어진 문자열이 “baconlettucetomato”라면 나눠진 문자열 목록은 [\"onlettu\", \"etom\", \"to\"] 가 됩니다.\n문자열 myStr이 주어졌을 때 위 예시와 같이 “a”, “b”, “c”를 사용해 나눠진 문자열을 순서대로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.\n단, 두 구분자 사이에 다른 문자가 없을 경우에는 아무것도 저장하지 않으며, return할 배열이 빈 배열이라면 [\"EMPTY\"]를 return 합니다.\n\n19.1.1 파이썬\nimport re\nfrom typing import List\n\ndef solution(myStr: str) -&gt; List[str]:\n    # 'a', 'b', 'c'를 구분자로 사용하여 문자열을 분할\n    parts = re.split('[abc]', myStr)\n\n    # 빈 문자열을 제거하고 남은 부분들만 저장\n    answer = [part for part in parts if part]\n\n    # 결과 배열이 비어있으면 [\"EMPTY\"] 반환\n    return answer if answer else [\"EMPTY\"]\n\n\n19.1.2 러스트\nuse regex::Regex;\n\nfn solution(my_str: &str) -&gt; Vec&lt;String&gt; {\n    // 'a', 'b', 'c'를 구분자로 사용하여 문자열을 분할\n    let re = Regex::new(\"[abc]\").unwrap();\n    let parts: Vec&lt;&str&gt; = re.split(my_str).collect();\n\n    // 빈 문자열을 제거하고 남은 부분들만 저장\n    let mut answer: Vec&lt;String&gt; = parts.into_iter().filter(|part| !part.is_empty()).map(String::from).collect();\n\n    // 결과 배열이 비어있으면 [\"EMPTY\"] 반환\n    if answer.is_empty() {\n        answer.push(\"EMPTY\".to_string());\n    }\n\n    answer\n}\n\nfn main() {\n    let input = \"baconlettucetomato\"; // Example input\n    let result = solution(input);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열의-원소만큼-추가하기",
    "href": "posts/qmd/learn_coding_practice.html#배열의-원소만큼-추가하기",
    "title": "코딩테스트 기초",
    "section": "19.2 배열의 원소만큼 추가하기",
    "text": "19.2 배열의 원소만큼 추가하기\n아무 원소도 들어있지 않은 빈 배열 X가 있습니다. 양의 정수 배열 arr가 매개변수로 주어질 때, arr의 앞에서부터 차례대로 원소를 보면서 원소가 a라면 X의 맨 뒤에 a를 a번 추가하는 일을 반복한 뒤의 배열 X를 return 하는 solution 함수를 작성해 주세요.\n\n19.2.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; List[int]:\n    answer = []\n    for num in arr:\n        answer.extend([num] * num)\n    return answer\n\n\n19.2.2 러스트\nfn solution(arr: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut answer = Vec::new();\n    for &num in &arr {\n        answer.extend(vec![num; num as usize]);\n    }\n    answer\n}\n\nfn main() {\n    let input = vec![1, 2, 3]; // Example input\n    let result = solution(input);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#빈-배열에-추가-삭제하기",
    "href": "posts/qmd/learn_coding_practice.html#빈-배열에-추가-삭제하기",
    "title": "코딩테스트 기초",
    "section": "19.3 빈 배열에 추가, 삭제하기",
    "text": "19.3 빈 배열에 추가, 삭제하기\n아무 원소도 들어있지 않은 빈 배열 X가 있습니다. 길이가 같은 정수 배열 arr과 boolean 배열 flag가 매개변수로 주어질 때, flag를 차례대로 순회하며 flag[i]가 true라면 X의 뒤에 arr[i]를 arr[i] × 2 번 추가하고, flag[i]가 false라면 X에서 마지막 arr[i]개의 원소를 제거한 뒤 X를 return 하는 solution 함수를 작성해 주세요.\n\n19.3.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], flag: List[bool]) -&gt; List[int]:\n    answer = []\n    for i, f in enumerate(flag):\n        if f:\n            answer.extend([arr[i]] * (arr[i] * 2))\n        else:\n            answer = answer[:-arr[i]] if arr[i] &lt;= len(answer) else []\n    return answer\n\n\n19.3.2 러스트\nfn solution(arr: Vec&lt;i32&gt;, flag: Vec&lt;bool&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut answer = Vec::new();\n    for (i, &f) in flag.iter().enumerate() {\n        if f {\n            answer.extend(vec![arr[i]; (arr[i] * 2) as usize]);\n        } else {\n            let remove_count = arr[i] as usize;\n            if remove_count &lt;= answer.len() {\n                answer.truncate(answer.len() - remove_count);\n            } else {\n                answer.clear();\n            }\n        }\n    }\n    answer\n}\n\nfn main() {\n    let arr = vec![3, 2, 4, 1, 3];\n    let flag = vec![true, false, true, false, false];\n    let result = solution(arr, flag);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-만들기-6",
    "href": "posts/qmd/learn_coding_practice.html#배열-만들기-6",
    "title": "코딩테스트 기초",
    "section": "19.4 배열 만들기 6",
    "text": "19.4 배열 만들기 6\n0과 1로만 이루어진 정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk을 만드려고 합니다.\ni의 초기값을 0으로 설정하고 i가 arr의 길이보다 작으면 다음을 반복합니다.\n\n만약 stk이 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.\nstk에 원소가 있고, stk의 마지막 원소가 arr[i]와 같으면 stk의 마지막 원소를 stk에서 제거하고 i에 1을 더합니다.\nstk에 원소가 있는데 stk의 마지막 원소가 arr[i]와 다르면 stk의 맨 마지막에 arr[i]를 추가하고 i에 1을 더합니다. 위 작업을 마친 후 만들어진 stk을 return 하는 solution 함수를 완성해 주세요. 단, 만약 빈 배열을 return 해야한다면 [-1]을 return 합니다.\n\n\n19.4.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; List[int]:\n    stk = []\n    i = 0\n    while i &lt; len(arr):\n        if not stk:\n            stk.append(arr[i])\n            i += 1\n        elif stk[-1] == arr[i]:\n            stk.pop()\n            i += 1\n        else:\n            stk.append(arr[i])\n            i += 1\n\n    return stk if stk else [-1]\n\n\n19.4.2 러스트\nfn solution(arr: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut stk = Vec::new();\n    let mut i = 0;\n\n    while i &lt; arr.len() {\n        if stk.is_empty() {\n            stk.push(arr[i]);\n            i += 1;\n        } else if *stk.last().unwrap() == arr[i] {\n            stk.pop();\n            i += 1;\n        } else {\n            stk.push(arr[i]);\n            i += 1;\n        }\n    }\n\n    if stk.is_empty() {\n        vec![-1]\n    } else {\n        stk\n    }\n}\n\nfn main() {\n    let arr = vec![1, 1, 3, 3, 0, 1, 1];\n    let result = solution(arr);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#무작위로-k의-수-뽑기",
    "href": "posts/qmd/learn_coding_practice.html#무작위로-k의-수-뽑기",
    "title": "코딩테스트 기초",
    "section": "19.5 무작위로 k의 수 뽑기",
    "text": "19.5 무작위로 k의 수 뽑기\n랜덤으로 서로 다른 k개의 수를 저장한 배열을 만드려고 합니다. 적절한 방법이 떠오르지 않기 때문에 일정한 범위 내에서 무작위로 수를 뽑은 후, 지금까지 나온적이 없는 수이면 배열 맨 뒤에 추가하는 방식으로 만들기로 합니다.\n이미 어떤 수가 무작위로 주어질지 알고 있다고 가정하고, 실제 만들어질 길이 k의 배열을 예상해봅시다.\n정수 배열 arr가 주어집니다. 문제에서의 무작위의 수는 arr에 저장된 순서대로 주어질 예정이라고 했을 때, 완성될 배열을 return 하는 solution 함수를 완성해 주세요.\n단, 완성될 배열의 길이가 k보다 작으면 나머지 값을 전부 -1로 채워서 return 합니다.\n\n19.5.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], k: int) -&gt; List[int]:\n    unique_nums = []\n    seen = set()\n\n    for num in arr:\n        if num not in seen and len(unique_nums) &lt; k:\n            unique_nums.append(num)\n            seen.add(num)\n\n        if len(unique_nums) == k:\n            break\n\n    # k개의 숫자를 채우지 못했다면 -1로 채움\n    while len(unique_nums) &lt; k:\n        unique_nums.append(-1)\n\n    return unique_nums\n\n\n19.5.2 러스트\nuse std::collections::HashSet;\n\nfn solution(arr: Vec&lt;i32&gt;, k: usize) -&gt; Vec&lt;i32&gt; {\n    let mut unique_nums = Vec::new();\n    let mut seen = HashSet::new();\n\n    for &num in &arr {\n        if !seen.contains(&num) && unique_nums.len() &lt; k {\n            unique_nums.push(num);\n            seen.insert(num);\n        }\n\n        if unique_nums.len() == k {\n            break;\n        }\n    }\n\n    // k개의 숫자를 채우지 못했다면 -1로 채움\n    while unique_nums.len() &lt; k {\n        unique_nums.push(-1);\n    }\n\n    unique_nums\n}\n\nfn main() {\n    let arr = vec![0, 1, 1, 2, 2, 3];\n    let k = 3;\n    let result = solution(arr, k);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열의-길이를-2의-거듭제곱으로-만들기",
    "href": "posts/qmd/learn_coding_practice.html#배열의-길이를-2의-거듭제곱으로-만들기",
    "title": "코딩테스트 기초",
    "section": "20.1 배열의 길이를 2의 거듭제곱으로 만들기",
    "text": "20.1 배열의 길이를 2의 거듭제곱으로 만들기\n정수 배열 arr이 매개변수로 주어집니다. arr의 길이가 2의 정수 거듭제곱이 되도록 arr 뒤에 정수 0을 추가하려고 합니다. arr에 최소한의 개수로 0을 추가한 배열을 return 하는 solution 함수를 작성해 주세요.\n\n20.1.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int]) -&gt; List[int]:\n    n = len(arr)\n    target_length = 1\n\n    while target_length &lt; n:\n        target_length *= 2\n\n    return arr + [0] * (target_length - n)\n\n\n20.1.2 러스트\nfn solution(arr: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let n = arr.len();\n    let mut target_length = 1;\n\n    while target_length &lt; n {\n        target_length *= 2;\n    }\n\n    let mut result = arr.clone();\n    result.extend(vec![0; target_length - n]);\n    result\n}\n\nfn main() {\n    let arr = vec![1, 2, 3]; // Example input\n    let result = solution(arr);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열-비교하기",
    "href": "posts/qmd/learn_coding_practice.html#배열-비교하기",
    "title": "코딩테스트 기초",
    "section": "20.2 배열 비교하기",
    "text": "20.2 배열 비교하기\n이 문제에서 두 정수 배열의 대소관계를 다음과 같이 정의합니다.\n\n두 배열의 길이가 다르다면, 배열의 길이가 긴 쪽이 더 큽니다.\n배열의 길이가 같다면 각 배열에 있는 모든 원소의 합을 비교하여 다르다면 더 큰 쪽이 크고, 같다면 같습니다.\n\n두 정수 배열 arr1과 arr2가 주어질 때, 위에서 정의한 배열의 대소관계에 대하여 arr2가 크다면 -1, arr1이 크다면 1, 두 배열이 같다면 0을 return 하는 solution 함수를 작성해 주세요.\n\n20.2.1 파이썬\nfrom typing import List\n\ndef solution(arr1: List[int], arr2: List[int]) -&gt; int:\n    if len(arr1) != len(arr2):\n        return -1 if len(arr2) &gt; len(arr1) else 1\n\n    sum1, sum2 = sum(arr1), sum(arr2)\n    if sum1 != sum2:\n        return -1 if sum2 &gt; sum1 else 1\n\n    return 0\n\n\n20.2.2 러스트\nfn solution(arr1: Vec&lt;i32&gt;, arr2: Vec&lt;i32&gt;) -&gt; i32 {\n    if arr1.len() != arr2.len() {\n        return if arr2.len() &gt; arr1.len() { -1 } else { 1 };\n    }\n\n    let sum1: i32 = arr1.iter().sum();\n    let sum2: i32 = arr2.iter().sum();\n    if sum1 != sum2 {\n        return if sum2 &gt; sum1 { -1 } else { 1 };\n    }\n\n    0\n}\n\nfn main() {\n    let arr1 = vec![1, 2, 3]; // Example input\n    let arr2 = vec![3, 2, 1]; // Example input\n    let result = solution(arr1, arr2);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-묶기",
    "href": "posts/qmd/learn_coding_practice.html#문자열-묶기",
    "title": "코딩테스트 기초",
    "section": "20.3 문자열 묶기",
    "text": "20.3 문자열 묶기\n문자열 배열 strArr이 주어집니다. strArr의 원소들을 길이가 같은 문자열들끼리 그룹으로 묶었을 때 가장 개수가 많은 그룹의 크기를 return 하는 solution 함수를 완성해 주세요.\n\n20.3.1 파이썬\nfrom collections import Counter\nfrom typing import List\n\ndef solution(strArr: List[str]) -&gt; int:\n    length_counts = Counter(len(s) for s in strArr)\n    return max(length_counts.values())\n\n\n20.3.2 러스트\nuse std::collections::HashMap;\n\nfn solution(str_arr: Vec&lt;&str&gt;) -&gt; usize {\n    let mut length_counts = HashMap::new();\n\n    for s in &str_arr {\n        let len = s.len();\n        *length_counts.entry(len).or_insert(0) += 1;\n    }\n\n    *length_counts.values().max().unwrap_or(&0)\n}\n\nfn main() {\n    let str_arr = vec![\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\"];\n    let result = solution(str_arr);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열의-길이에-따라-다른-연산하기",
    "href": "posts/qmd/learn_coding_practice.html#배열의-길이에-따라-다른-연산하기",
    "title": "코딩테스트 기초",
    "section": "20.4 배열의 길이에 따라 다른 연산하기",
    "text": "20.4 배열의 길이에 따라 다른 연산하기\n정수 배열 arr과 정수 n이 매개변수로 주어집니다. arr의 길이가 홀수라면 arr의 모든 짝수 인덱스 위치에 n을 더한 배열을, arr의 길이가 짝수라면 arr의 모든 홀수 인덱스 위치에 n을 더한 배열을 return 하는 solution 함수를 작성해 주세요.\n\n20.4.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], n: str) -&gt; List[int]:\n    if len(arr) % 2 == 1:  # 배열의 길이가 홀수인 경우\n        return [num + n if i % 2 == 0 else num for i, num in enumerate(arr)]\n    else:  # 배열의 길이가 짝수인 경우\n        return [num + n if i % 2 == 1 else num for i, num in enumerate(arr)]\n\n\n20.4.2 러스트\nuse std::collections::HashMap;\n\nfn solution(str_arr: Vec&lt;&str&gt;) -&gt; usize {\n    let mut length_counts = HashMap::new();\n\n    for s in &str_arr {\n        let len = s.len();\n        *length_counts.entry(len).or_insert(0) += 1;\n    }\n\n    *length_counts.values().max().unwrap_or(&0)\n}\n\nfn main() {\n    let str_arr = vec![\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\"];\n    let result = solution(str_arr);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#뒤에서-5등까지",
    "href": "posts/qmd/learn_coding_practice.html#뒤에서-5등까지",
    "title": "코딩테스트 기초",
    "section": "20.5 뒤에서 5등까지",
    "text": "20.5 뒤에서 5등까지\n정수로 이루어진 리스트 num_list가 주어집니다. num_list에서 가장 작은 5개의 수를 오름차순으로 담은 리스트를 return하도록 solution 함수를 완성해주세요.\n\n20.5.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int]) -&gt; List[int]:\n    return sorted(num_list)[:5]\n\n\n20.5.2 러스트\nfn solution(mut num_list: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    num_list.sort();\n    num_list.into_iter().take(5).collect()\n}\n\nfn main() {\n    let num_list = vec![10, 3, 5, 8, 2, 7, 1, 4, 6, 9]; // Example input\n    let result = solution(num_list);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#뒤에서-5등-위로",
    "href": "posts/qmd/learn_coding_practice.html#뒤에서-5등-위로",
    "title": "코딩테스트 기초",
    "section": "21.1 뒤에서 5등 위로",
    "text": "21.1 뒤에서 5등 위로\n수로 이루어진 리스트 num_list가 주어집니다. num_list에서 가장 작은 5개의 수를 제외한 수들을 오름차순으로 담은 리스트를 return하도록 solution 함수를 완성해주세요. ### 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int]) -&gt; List[int]:\n    return sorted(num_list)[5:]\n\n21.1.1 러스트\nfn solution(mut num_list: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    num_list.sort();\n    num_list.split_off(5)\n}\n\nfn main() {\n    let num_list = vec![12, 4, 15, 46, 38, 1, 14, 56, 32, 10];\n    let result = solution(num_list);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#전국-대회-선발-고사",
    "href": "posts/qmd/learn_coding_practice.html#전국-대회-선발-고사",
    "title": "코딩테스트 기초",
    "section": "21.2 전국 대회 선발 고사",
    "text": "21.2 전국 대회 선발 고사\n0번부터 n - 1번까지 n명의 학생 중 3명을 선발하는 전국 대회 선발 고사를 보았습니다. 등수가 높은 3명을 선발해야 하지만, 개인 사정으로 전국 대회에 참여하지 못하는 학생들이 있어 참여가 가능한 학생 중 등수가 높은 3명을 선발하기로 했습니다.\n각 학생들의 선발 고사 등수를 담은 정수 배열 rank와 전국 대회 참여 가능 여부가 담긴 boolean 배열 attendance가 매개변수로 주어집니다. 전국 대회에 선발된 학생 번호들을 등수가 높은 순서대로 각각 a, b, c번이라고 할 때 10000 × a + 100 × b + c를 return 하는 solution 함수를 작성해 주세요.\n\n21.2.1 파이썬\nfrom typing import List\n\ndef solution(rank: List[int], attendance: List[bool]) -&gt; int:\n    # 참석 가능한 학생들의 등수와 번호를 저장\n    available = [(r, i) for i, r in enumerate(rank) if attendance[i]]\n\n    # 등수를 기준으로 정렬\n    available.sort()\n\n    # 상위 3명 선택\n    top_3 = available[:3]\n\n    # 결과 계산\n    return 10000 * top_3[0][1] + 100 * top_3[1][1] + top_3[2][1]\n\n\n21.2.2 러스트\nfn solution(rank: Vec&lt;i32&gt;, attendance: Vec&lt;bool&gt;) -&gt; i32 {\n    let mut available: Vec&lt;(i32, usize)&gt; = rank.iter()\n        .enumerate()\n        .filter(|&(i, _)| attendance[i])\n        .map(|(i, &r)| (r, i))\n        .collect();\n\n    available.sort_by_key(|&(r, _)| r);\n\n    let top_3: Vec&lt;&(i32, usize)&gt; = available.iter().take(3).collect();\n\n    10000 * top_3[0].1 as i32 + 100 * top_3[1].1 as i32 + top_3[2].1 as i32\n}\n\nfn main() {\n    let rank = vec![3, 1, 2, 4];\n    let attendance = vec![true, false, true, true];\n\n    let result = solution(rank, attendance);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#정수-부분",
    "href": "posts/qmd/learn_coding_practice.html#정수-부분",
    "title": "코딩테스트 기초",
    "section": "21.3 정수 부분",
    "text": "21.3 정수 부분\n실수 flo가 매개 변수로 주어질 때, flo의 정수 부분을 return하도록 solution 함수를 완성해주세요.\n\n21.3.1 파이썬\ndef solution(flo: float) -&gt; int:\n    return int(flo)\n\n\n21.3.2 러스트\nfn solution(flo: f64) -&gt; i32 {\n    flo as i32\n}\n\nfn main() {\n    let test_cases = vec![1.42, 69.32, 3.14, 0.0, -1.5];\n\n    for flo in test_cases {\n        let result = solution(flo);\n        println!(\"입력: {}, 결과: {}\", flo, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열-정수의-합",
    "href": "posts/qmd/learn_coding_practice.html#문자열-정수의-합",
    "title": "코딩테스트 기초",
    "section": "21.4 문자열 정수의 합",
    "text": "21.4 문자열 정수의 합\n한 자리 정수로 이루어진 문자열 num_str이 주어질 때, 각 자리수의 합을 return하도록 solution 함수를 완성해주세요. ### 파이썬\ndef solution(num_str: str) -&gt; int:\n    return sum(int(digit) for digit in num_str)\n\n21.4.1 러스트\nfn solution(num_str: &str) -&gt; i32 {\n    num_str.chars()\n        .filter_map(|c| c.to_digit(10))\n        .map(|d| d as i32)\n        .sum()\n}\n\nfn main() {\n    let test_cases = vec![\"123\", \"456\", \"789\", \"0\", \"9999\"];\n\n    for num_str in test_cases {\n        let result = solution(num_str);\n        println!(\"입력: {}, 결과: {}\", num_str, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열을-정수로-변환하기",
    "href": "posts/qmd/learn_coding_practice.html#문자열을-정수로-변환하기",
    "title": "코딩테스트 기초",
    "section": "21.5 문자열을 정수로 변환하기",
    "text": "21.5 문자열을 정수로 변환하기\n숫자로만 이루어진 문자열 n_str이 주어질 때, n_str을 정수로 변환하여 return하도록 solution 함수를 완성해주세요. ### 파이썬\ndef solution(n_str:str) -&gt; int:\n    return int(n_str)\n\n21.5.1 러스트\nfn solution(n_str: &str) -&gt; i32 {\n    n_str.parse().unwrap()\n}\n\nfn main() {\n    let test_cases = vec![\"123\", \"456\", \"789\", \"0\", \"9999\"];\n\n    for n_str in test_cases {\n        let result = solution(n_str);\n        println!(\"입력: {}, 결과: {}\", n_str, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#떼기",
    "href": "posts/qmd/learn_coding_practice.html#떼기",
    "title": "코딩테스트 기초",
    "section": "22.1 0 떼기",
    "text": "22.1 0 떼기\n정수로 이루어진 문자열 n_str이 주어질 때, n_str의 가장 왼쪽에 처음으로 등장하는 0들을 뗀 문자열을 return하도록 solution 함수를 완성해주세요. ### 파이썬\ndef solution(n_str:str) -&gt; str:\n    return str(int(n_str))\n\n22.1.1 러스트\nfn solution(n_str: &str) -&gt; String {\n    n_str.parse::&lt;i32&gt;().unwrap().to_string()\n}\n\nfn main() {\n    let test_cases = vec![\"00123\", \"0456\", \"000789\", \"0\", \"0000\"];\n\n    for n_str in test_cases {\n        let result = solution(n_str);\n        println!(\"입력: {}, 결과: {}\", n_str, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#두-수의-합",
    "href": "posts/qmd/learn_coding_practice.html#두-수의-합",
    "title": "코딩테스트 기초",
    "section": "22.2 두 수의 합",
    "text": "22.2 두 수의 합\n0 이상의 두 정수가 문자열 a, b로 주어질 때, a + b의 값을 문자열로 return 하는 solution 함수를 작성해 주세요. ### 파이썬\ndef solution(a: str, b: str) -&gt; str:\n    return str(int(a) + int(b))\n\n22.2.1 러스트\nfn solution(a: &str, b: &str) -&gt; String {\n    (a.parse::&lt;i32&gt;().unwrap() + b.parse::&lt;i32&gt;().unwrap()).to_string()\n}\n\nfn main() {\n    let test_cases = vec![(\"123\", \"456\"), (\"100\", \"200\"), (\"0\", \"0\"), (\"999\", \"1\")];\n\n    for (a, b) in test_cases {\n        let result = solution(a, b);\n        println!(\"입력: ({} + {}), 결과: {}\", a, b, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#문자열로-변환",
    "href": "posts/qmd/learn_coding_practice.html#문자열로-변환",
    "title": "코딩테스트 기초",
    "section": "22.3 문자열로 변환",
    "text": "22.3 문자열로 변환\n정수 n이 주어질 때, n을 문자열로 변환하여 return하도록 solution 함수를 완성해주세요. ### 파이썬\ndef solution(n: int) -&gt; str:\n    return str(n)\n\n22.3.1 러스트\nfn solution(n: i32) -&gt; String {\n    n.to_string()\n}\n\nfn main() {\n    let test_cases = vec![123, 456, 789, 0, -42];\n\n    for n in test_cases {\n        let result = solution(n);\n        println!(\"입력: {}, 결과: {}\", n, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#배열의-원소-삭제하기",
    "href": "posts/qmd/learn_coding_practice.html#배열의-원소-삭제하기",
    "title": "코딩테스트 기초",
    "section": "22.4 배열의 원소 삭제하기",
    "text": "22.4 배열의 원소 삭제하기\n정수 배열 arr과 delete_list가 있습니다. arr의 원소 중 delete_list의 원소를 모두 삭제하고 남은 원소들은 기존의 arr에 있던 순서를 유지한 배열을 return 하는 solution 함수를 작성해 주세요. ### 파이썬\nfrom typing import List\ndef solution(arr: List[int], delete_list: List[int]) -&gt; List[int]:\n    return [x for x in arr if x not in delete_list]\n\n22.4.1 러스트\nfn solution(arr: Vec&lt;i32&gt;, delete_list: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    arr.into_iter().filter(|&x| !delete_list.contains(&x)).collect()\n}\n\nfn main() {\n    let arr = vec![1, 2, 3, 4, 5];\n    let delete_list = vec![2, 4];\n\n    let result = solution(arr, delete_list);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#부분-문자열인지-확인하기",
    "href": "posts/qmd/learn_coding_practice.html#부분-문자열인지-확인하기",
    "title": "코딩테스트 기초",
    "section": "22.5 부분 문자열인지 확인하기",
    "text": "22.5 부분 문자열인지 확인하기\n부분 문자열이란 문자열에서 연속된 일부분에 해당하는 문자열을 의미합니다. 예를 들어, 문자열 “ana”, “ban”, “anana”, “banana”, “n”는 모두 문자열 “banana”의 부분 문자열이지만, “aaa”, “bnana”, “wxyz”는 모두 “banana”의 부분 문자열이 아닙니다.\n문자열 my_string과 target이 매개변수로 주어질 때, target이 문자열 my_string의 부분 문자열이라면 1을, 아니라면 0을 return 하는 solution 함수를 작성해 주세요.\n\n22.5.1 파이썬\ndef solution(my_string: str, target: str) -&gt; int:\n    return int(target in my_string)\n\n\n22.5.2 러스트\nfn solution(my_string: &str, target: &str) -&gt; i32 {\n    my_string.contains(target) as i32\n}\n\nfn main() {\n    let test_cases = vec![\n        (\"abcdef\", \"ab\"),\n        (\"hello world\", \"bye\"),\n        (\"Python\", \"on\"),\n        (\"Rust\", \"rust\"),\n    ];\n\n    for (my_string, target) in test_cases {\n        let result = solution(my_string, target);\n        println!(\"my_string: '{}', target: '{}', 결과: {}\", my_string, target, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#부분-문자열",
    "href": "posts/qmd/learn_coding_practice.html#부분-문자열",
    "title": "코딩테스트 기초",
    "section": "23.1 부분 문자열",
    "text": "23.1 부분 문자열\n어떤 문자열 A가 다른 문자열 B안에 속하면 A를 B의 부분 문자열이라고 합니다. 예를 들어 문자열 “abc”는 문자열 “aabcc”의 부분 문자열입니다.\n문자열 str1과 str2가 주어질 때, str1이 str2의 부분 문자열이라면 1을 부분 문자열이 아니라면 0을 return하도록 solution 함수를 완성해주세요. ### 파이썬\ndef solution(str1: str, str2: str) -&gt; int:\n    return 1 if str1 in str2 else 0\n\n23.1.1 러스트\nfn solution(str1: &str, str2: &str) -&gt; i32 {\n    if str2.contains(str1) { 1 } else { 0 }\n}\n\nfn main() {\n    let test_cases = vec![\n        (\"abc\", \"abcdef\"),\n        (\"hello\", \"world\"),\n        (\"rust\", \"Rust is great\"),\n        (\"\", \"empty\"),\n    ];\n\n    for (str1, str2) in test_cases {\n        let result = solution(str1, str2);\n        println!(\"str1: '{}', str2: '{}', 결과: {}\", str1, str2, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#꼬리-문자열",
    "href": "posts/qmd/learn_coding_practice.html#꼬리-문자열",
    "title": "코딩테스트 기초",
    "section": "23.2 꼬리 문자열",
    "text": "23.2 꼬리 문자열\n문자열들이 담긴 리스트가 주어졌을 때, 모든 문자열들을 순서대로 합친 문자열을 꼬리 문자열이라고 합니다. 꼬리 문자열을 만들 때 특정 문자열을 포함한 문자열은 제외시키려고 합니다. 예를 들어 문자열 리스트 [\"abc\", \"def\", \"ghi\"]가 있고 문자열 “ef”를 포함한 문자열은 제외하고 꼬리 문자열을 만들면 “abcghi”가 됩니다.\n문자열 리스트 str_list와 제외하려는 문자열 ex가 주어질 때, str_list에서 ex를 포함한 문자열을 제외하고 만든 꼬리 문자열을 return하도록 solution 함수를 완성해주세요. ### 파이썬\nfrom typing import List\n\ndef solution(str_list: List[str], ex: str) -&gt; str:\n    return ''.join([s for s in str_list if ex not in s])\n\n23.2.1 러스트\nfn solution(str_list: Vec&lt;String&gt;, ex: &str) -&gt; String {\n    str_list.into_iter()\n        .filter(|s| !s.contains(ex))\n        .collect()\n}\n\nfn main() {\n    let str_list = vec![\"hello\".to_string(), \"world\".to_string(), \"example\".to_string(), \"rust\".to_string()];\n    let ex = \"ex\";\n    let result = solution(str_list, ex);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#정수-찾기",
    "href": "posts/qmd/learn_coding_practice.html#정수-찾기",
    "title": "코딩테스트 기초",
    "section": "23.3 정수 찾기",
    "text": "23.3 정수 찾기\n정수 리스트 num_list와 찾으려는 정수 n이 주어질 때, num_list안에 n이 있으면 1을 없으면 0을 return하도록 solution 함수를 완성해주세요. ### 파이썬\nfrom typing import List\ndef solution(num_list: List[int], n: int) -&gt; int:\n    return int(n in num_list)\n\n23.3.1 러스트\nfn solution(num_list: Vec&lt;i32&gt;, n: i32) -&gt; i32 {\n    num_list.contains(&n) as i32\n}\n\nfn main() {\n    let test_cases = vec![\n        (vec![1, 2, 3, 4, 5], 3),\n        (vec![15, 98, 23, 45, 67], 20),\n        (vec![0, 0, 0], 0),\n        (vec![-1, -2, -3], -2),\n    ];\n\n    for (num_list, n) in test_cases {\n        let result = solution(num_list.clone(), n);\n        println!(\"num_list: {:?}, n: {}, 결과: {}\", num_list, n, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#주사위-게임-1",
    "href": "posts/qmd/learn_coding_practice.html#주사위-게임-1",
    "title": "코딩테스트 기초",
    "section": "23.4 주사위 게임 1",
    "text": "23.4 주사위 게임 1\n1부터 6까지 숫자가 적힌 주사위가 두 개 있습니다. 두 주사위를 굴렸을 때 나온 숫자를 각각 a, b라고 했을 때 얻는 점수는 다음과 같습니다.\n\na와 b가 모두 홀수라면 \\(a2 + b2\\) 점을 얻습니다.\na와 b 중 하나만 홀수라면 \\(2 × (a + b)\\) 점을 얻습니다.\na와 b 모두 홀수가 아니라면 \\(|a - b|\\) 점을 얻습니다.\n\n두 정수 a와 b가 매개변수로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요. ### 파이썬\ndef solution(a: int, b: int) -&gt; int:\n    if a % 2 == 1 and b % 2 == 1:\n        return a**2 + b**2\n    elif a % 2 == 1 or b % 2 == 1:\n        return 2 * (a + b)\n    else:\n        return abs(a - b)\n\n23.4.1 러스트\nfn solution(a: i32, b: i32) -&gt; i32 {\n    if a % 2 == 1 && b % 2 == 1 {\n        a.pow(2) + b.pow(2)\n    } else if a % 2 == 1 || b % 2 == 1 {\n        2 * (a + b)\n    } else {\n        (a - b).abs()\n    }\n}\n\nfn main() {\n    let test_cases = vec![(3, 5), (2, 4), (3, 4), (7, 7), (6, 6)];\n\n    for (a, b) in test_cases {\n        let result = solution(a, b);\n        println!(\"a: {}, b: {}, result: {}\", a, b, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#날짜-비교하기",
    "href": "posts/qmd/learn_coding_practice.html#날짜-비교하기",
    "title": "코딩테스트 기초",
    "section": "23.5 날짜 비교하기",
    "text": "23.5 날짜 비교하기\n정수 배열 date1과 date2가 주어집니다. 두 배열은 각각 날짜를 나타내며 \\([year, month, day]\\) 꼴로 주어집니다. 각 배열에서 year는 연도를, month는 월을, day는 날짜를 나타냅니다. 만약 date1이 date2보다 앞서는 날짜라면 1을, 아니면 0을 return 하는 solution 함수를 완성해 주세요.\n\n23.5.1 파이썬\nfrom typing import List\n\ndef solution(date1:List[int], date2:List[int]) -&gt; int:\n    for i in range(3):\n        if date1[i] &lt; date2[i]:\n            return 1\n        elif date1[i] &gt; date2[i]:\n            return 0\n    return 0\n\n\n23.5.2 러스트\nfn solution(date1: Vec&lt;i32&gt;, date2: Vec&lt;i32&gt;) -&gt; i32 {\n    for i in 0..3 {\n        if date1[i] &lt; date2[i] {\n            return 1;\n        } else if date1[i] &gt; date2[i] {\n            return 0;\n        }\n    }\n    0\n}\n\nfn main() {\n    let test_cases = vec![\n        (vec![2021, 12, 28], vec![2021, 12, 29]),\n        (vec![1024, 10, 24], vec![1024, 10, 24]),\n        (vec![2022, 1, 1], vec![2021, 12, 31]),\n    ];\n\n    for (date1, date2) in test_cases {\n        let result = solution(date1.clone(), date2.clone());\n        println!(\"date1: {:?}, date2: {:?}, result: {}\", date1, date2, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#커피-심부름",
    "href": "posts/qmd/learn_coding_practice.html#커피-심부름",
    "title": "코딩테스트 기초",
    "section": "24.1 커피 심부름",
    "text": "24.1 커피 심부름\n팀의 막내인 철수는 아메리카노와 카페 라테만 판매하는 카페에서 팀원들의 커피를 사려고 합니다. 아메리카노와 카페 라테의 가격은 차가운 것과 뜨거운 것 상관없이 각각 4500, 5000원입니다. 각 팀원에게 마실 메뉴를 적어달라고 하였고, 그 중에서 메뉴만 적은 팀원의 것은 차가운 것으로 통일하고 “아무거나”를 적은 팀원의 것은 차가운 아메리카노로 통일하기로 하였습니다.\n각 직원이 적은 메뉴가 문자열 배열 order로 주어질 때, 카페에서 결제하게 될 금액을 return 하는 solution 함수를 작성해주세요. order의 원소는 아래의 것들만 들어오고, 각각의 의미는 다음과 같습니다. ### 파이썬\nfrom typing import List\ndef solution(order: List[str]) -&gt; int:\n    total = 0\n    for drink in order:\n        if 'cafelatte' in drink:\n            total += 5000\n        else:\n            total += 4500\n    return total\n\n24.1.1 러스트\nfn solution(order: Vec&lt;String&gt;) -&gt; i32 {\n    let mut total = 0;\n    for drink in order {\n        if drink.contains(\"cafelatte\") {\n            total += 5000;\n        } else {\n            total += 4500;\n        }\n    }\n    total\n}\n\nfn main() {\n    let test_orders = vec![\n        vec![\"cafelatte\".to_string(), \"americano\".to_string(), \"cafelatte\".to_string()],\n        vec![\"americano\".to_string(), \"americano\".to_string()],\n        vec![\"cafelatte\".to_string(), \"americano\".to_string(), \"espresso\".to_string()],\n    ];\n\n    for order in test_orders {\n        let total = solution(order.clone());\n        println!(\"Order: {:?}, Total: {}\", order, total);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#그림-확대",
    "href": "posts/qmd/learn_coding_practice.html#그림-확대",
    "title": "코딩테스트 기초",
    "section": "24.2 그림 확대",
    "text": "24.2 그림 확대\n직사각형 형태의 그림 파일이 있고, 이 그림 파일은 1 × 1 크기의 정사각형 크기의 픽셀로 이루어져 있습니다. 이 그림 파일을 나타낸 문자열 배열 picture과 정수 k가 매개변수로 주어질 때, 이 그림 파일을 가로 세로로 k배 늘린 그림 파일을 나타내도록 문자열 배열을 return 하는 solution 함수를 작성해 주세요.\n\n24.2.1 파이썬\nfrom typing import List\n\ndef solution(picture: List[str], k: int) -&gt; List[str]:\n    result = []\n    for row in picture:\n        expanded_row = ''.join([char * k for char in row])\n        for _ in range(k):\n            result.append(expanded_row)\n    return result\n\n\n24.2.2 러스트\nfn solution(picture: Vec&lt;String&gt;, k: usize) -&gt; Vec&lt;String&gt; {\n    let mut result = Vec::new();\n    for row in picture {\n        let expanded_row: String = row.chars().flat_map(|c| std::iter::repeat(c).take(k)).collect();\n        for _ in 0..k {\n            result.push(expanded_row.clone());\n        }\n    }\n    result\n}\n\nfn main() {\n    let picture = vec![\"abc\".to_string(), \"def\".to_string()];\n    let k = 2;\n    let result = solution(picture, k);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-3",
    "href": "posts/qmd/learn_coding_practice.html#조건에-맞게-수열-변환하기-3",
    "title": "코딩테스트 기초",
    "section": "24.3 조건에 맞게 수열 변환하기 3",
    "text": "24.3 조건에 맞게 수열 변환하기 3\n정수 배열 arr와 자연수 k가 주어집니다. 만약 k가 홀수라면 arr의 모든 원소에 k를 곱하고, k가 짝수라면 arr의 모든 원소에 k를 더합니다. 이러한 변환을 마친 후의 arr를 return 하는 solution 함수를 완성해 주세요.\n\n24.3.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[int], k: int) -&gt; List[int]:\n    if k % 2 == 1: # k가 홀수인 경우\n        return [num * k for num in arr]\n    else: # k가 짝수인 경우\n        return [num + k for num in arr]\n\n\n24.3.2 러스트\nfn solution(arr: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; {\n    if k % 2 == 1 {\n        arr.into_iter().map(|num| num * k).collect()\n    } else {\n        arr.into_iter().map(|num| num + k).collect()\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#l로-만들기",
    "href": "posts/qmd/learn_coding_practice.html#l로-만들기",
    "title": "코딩테스트 기초",
    "section": "24.4 l로 만들기",
    "text": "24.4 l로 만들기\n알파벳 소문자로 이루어진 문자열 myString이 주어집니다. 알파벳 순서에서 “l”보다 앞서는 모든 문자를 “l”로 바꾼 문자열을 return 하는 solution 함수를 완성해 주세요. ### 파이썬\ndef solution(myString: str) -&gt; str:\n    return ''.join(['l' if c &lt; 'l' else c for c in myString])\n\n24.4.1 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.chars().map(|c| if c &lt; 'l' { 'l' } else { c }).collect()\n}\n\nfn main() {\n    let test_cases = vec![\"abcdevwxyz\", \"jjnnllkkmm\", \"task\"];\n\n    for case in test_cases {\n        let result = solution(case);\n        println!(\"Input: {}, Output: {}\", case, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#특별한-이차원-배열-1",
    "href": "posts/qmd/learn_coding_practice.html#특별한-이차원-배열-1",
    "title": "코딩테스트 기초",
    "section": "24.5 특별한 이차원 배열 1",
    "text": "24.5 특별한 이차원 배열 1\n정수 n이 매개변수로 주어질 때, 다음과 같은 \\(n × n\\) 크기의 이차원 배열 arr를 return 하는 solution 함수를 작성해 주세요. - \\(arr[i][j] (0 ≤ i, j &lt; n)의 값은 i = j라면 1, 아니라면 0입니다.\\)\n\n24.5.1 파이썬\nfrom typing import List\n\ndef solution(n: int) -&gt; List[List[int]]:\n    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n\n\n24.5.2 러스트\nfn solution(n: usize) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    (0..n).map(|i|\n        (0..n).map(|j|\n            if i == j { 1 } else { 0 }\n        ).collect()\n    ).collect()\n}\n\nfn main() {\n    let test_cases = vec![3, 5, 2];\n\n    for n in test_cases {\n        let result = solution(n);\n        println!(\"n = {}:\", n);\n        for row in &result {\n            println!(\"{:?}\", row);\n        }\n        println!();\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#정수를-나선형으로-배치하기",
    "href": "posts/qmd/learn_coding_practice.html#정수를-나선형으로-배치하기",
    "title": "코딩테스트 기초",
    "section": "25.1 정수를 나선형으로 배치하기",
    "text": "25.1 정수를 나선형으로 배치하기\n양의 정수 n이 매개변수로 주어집니다. \\(n × n\\) 배열에 1부터 n2 까지 정수를 인덱스 \\([0][0]\\)부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 solution 함수를 작성해 주세요.\n\n25.1.1 파이썬\nfrom typing import List\n\ndef solution(n:int) -&gt; List[int]:\n    # n x n 크기의 2차원 배열 초기화\n    answer = [[0 for _ in range(n)] for _ in range(n)]\n\n    # 시작 위치와 방향 설정\n    x, y = 0, 0\n    dx, dy = 0, 1  # 처음에는 오른쪽으로 이동\n\n    # 1부터 n^2까지 숫자 채우기\n    for i in range(1, n*n + 1):\n        answer[x][y] = i\n\n        # 다음 위치 계산\n        nx, ny = x + dx, y + dy\n\n        # 방향 전환이 필요한 경우\n        if nx &lt; 0 or nx &gt;= n or ny &lt; 0 or ny &gt;= n or answer[nx][ny] != 0:\n            # 방향 전환 (시계 방향)\n            dx, dy = dy, -dx\n            nx, ny = x + dx, y + dy\n\n        x, y = nx, ny\n\n    return answer\n\n\n25.1.2 러스트\nfn solution(n: usize) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {\n    let mut answer = vec![vec![0; n]; n]; // Initialize a 2D array with zeros\n    let (mut x, mut y) = (0, 0); // Starting position\n    let (mut dx, mut dy) = (0, 1); // Initial direction: right\n\n    for i in 1..=n * n {\n        answer[x][y] = i; // Fill the current cell\n\n        // Calculate the next position\n        let (nx, ny) = (x as isize + dx, y as isize + dy);\n\n        // Check if we need to change direction\n        if nx &lt; 0 || nx &gt;= n as isize || ny &lt; 0 || ny &gt;= n as isize || answer[nx as usize][ny as usize] != 0 {\n            // Change direction (clockwise)\n            let (new_dx, new_dy) = (dy, -dx);\n            dx = new_dx;\n            dy = new_dy;\n        }\n\n        // Update position\n        x = (x as isize + dx) as usize;\n        y = (y as isize + dy) as usize;\n    }\n\n    answer\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#특별한-이차원-배열-2",
    "href": "posts/qmd/learn_coding_practice.html#특별한-이차원-배열-2",
    "title": "코딩테스트 기초",
    "section": "25.2 특별한 이차원 배열 2",
    "text": "25.2 특별한 이차원 배열 2\n\\(n × n\\) 크기의 이차원 배열 arr이 매개변수로 주어질 때, arr이 다음을 만족하면 1을 아니라면 0을 return 하는 solution 함수를 작성해 주세요.\n\n\\(0 ≤ i, j &lt; n인 정수 i, j에 대하여 arr[i][j] = arr[j][i]\\)\n\n\n25.2.1 파이썬\nfrom typing import List\n\ndef solution(arr: List[List[int]]) -&gt; int:\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if arr[i][j] != arr[j][i]:\n                return 0\n    return 1\n\n\n25.2.2 러스트\nfn solution(arr: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let n = arr.len();\n    for i in 0..n {\n        for j in 0..n {\n            if arr[i][j] != arr[j][i] {\n                return 0;\n            }\n        }\n    }\n    1\n}\n\nfn main() {\n    let test_cases = vec![\n        vec![vec![5, 192, 33], vec![192, 72, 95], vec![33, 95, 999]],\n        vec![vec![19, 498, 258, 587], vec![63, 93, 7, 754], vec![258, 7, 1000, 723], vec![587, 754, 723, 81]],\n    ];\n\n    for (index, case) in test_cases.iter().enumerate() {\n        let result = solution(case.to_vec());\n        println!(\"Test case {}: {}\", index + 1, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#정사각형으로-만들기",
    "href": "posts/qmd/learn_coding_practice.html#정사각형으로-만들기",
    "title": "코딩테스트 기초",
    "section": "25.3 정사각형으로 만들기",
    "text": "25.3 정사각형으로 만들기\n이차원 정수 배열 arr이 매개변수로 주어집니다. arr의 행의 수가 더 많다면 열의 수가 행의 수와 같아지도록 각 행의 끝에 0을 추가하고, 열의 수가 더 많다면 행의 수가 열의 수와 같아지도록 각 열의 끝에 0을 추가한 이차원 배열을 return 하는 solution 함수를 작성해 주세요. ### 파이썬\nfrom typing import List\n\ndef solution(arr: List[List[int]]) -&gt; List[List[int]]:\n    rows = len(arr)\n    cols = len(arr[0])\n    max_size = max(rows, cols)\n\n    result = []\n    for row in arr:\n        new_row = row + [0] * (max_size - len(row))\n        result.append(new_row)\n\n    while len(result) &lt; max_size:\n        result.append([0] * max_size)\n\n    return result\n\n25.3.1 러스트\nfn solution(arr: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let rows = arr.len();\n    let cols = arr[0].len();\n    let max_size = rows.max(cols);\n\n    let mut result = Vec::new();\n    for row in arr {\n        let mut new_row = row;\n        new_row.resize(max_size, 0);\n        result.push(new_row);\n    }\n\n    result.resize_with(max_size, || vec![0; max_size]);\n\n    result\n}\n\nfn main() {\n    let test_cases = vec![\n        vec![vec![1, 2], vec![3, 4]],\n        vec![vec![1], vec![2]],\n        vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\n    ];\n\n    for (i, case) in test_cases.iter().enumerate() {\n        let result = solution(case.to_vec());\n        println!(\"Test case {}:\", i + 1);\n        for row in result {\n            println!(\"{:?}\", row);\n        }\n        println!();\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_practice.html#이차원-배열-대각선-순회하기",
    "href": "posts/qmd/learn_coding_practice.html#이차원-배열-대각선-순회하기",
    "title": "코딩테스트 기초",
    "section": "25.4 이차원 배열 대각선 순회하기",
    "text": "25.4 이차원 배열 대각선 순회하기\n2차원 정수 배열 board와 정수 k가 주어집니다. \\(i + j &lt;= k\\)를 만족하는 모든 \\((i, j)\\)에 대한 board[i][j]의 합을 return 하는 solution 함수를 완성해 주세요.\n\n25.4.1 파이썬\nfrom typing import List\n\ndef solution(board: List[List[int]], k: int) -&gt; int:\n    answer = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if i + j &lt;= k:\n                answer += board[i][j]\n    return answer\n\n\n25.4.2 러스트\nfn solution(board: Vec&lt;Vec&lt;i32&gt;&gt;, k: i32) -&gt; i32 {\n    let mut answer = 0;\n    for i in 0..board.len() {\n        for j in 0..board[0].len() {\n            if (i as i32 + j as i32) &lt;= k {\n                answer += board[i][j];\n            }\n        }\n    }\n    answer\n}\n\nfn main() {\n    let board = vec![\n        vec![0, 1, 2],\n        vec![1, 2, 3],\n        vec![2, 3, 4],\n    ];\n    let k = 2;\n    let result = solution(board, k);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html",
    "href": "posts/qmd/learn_STAT_clinical_trial.html",
    "title": "임상 통계학",
    "section": "",
    "text": "책 “강승호, 신약개발에 필요한 임상통계학, 자유 아카데미, 2022” 을 읽고 요약 정리한 것으로 많은 설명은 perplexity 를 사용해 덧붙였습니다. 책 전체 내용을 요약하지는 않았기 때문에 더 자세한 내용에 관심이 있으다면 책을 한번 읽어보시길 바랍니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상적-유의성과-통계적-유의성",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상적-유의성과-통계적-유의성",
    "title": "임상 통계학",
    "section": "1.1 임상적 유의성과 통계적 유의성",
    "text": "1.1 임상적 유의성과 통계적 유의성\n임상적 유의성과 통계적 유의성은 임상 연구에서 중요한 개념이지만 서로 다른 의미를 가집니다.\n\n통계적 유의성: 연구 결과가 우연에 의해 발생할 가능성이 낮다는 것을 의미합니다. 일반적으로 p- 값이 미리 정해진 유의수준 (보통 5%) 보다 작을 때 통계적으로 유의하다고 판단합니다. 통계적 유의성은 데이터의 변동성을 고려하여 결과가 우연이 아닐 확률을 평가합니다.1\n임상적 유의성: 통계적으로 유의한 결과가 실제 임상 환경에서 환자에게 의미 있는 변화를 가져오는지를 임상의가 평가합니다. 즉, 통계적으로 유의한 차이가 임상적으로도 중요한 차이인지 판단하는 것입니다. 예를 들어, 고혈압 치료제의 경우, 통계적으로 유의한 혈압 감소가 실제로 환자의 건강에 긍정적인 영향을 미칠 만큼 충분히 큰지 평가해야 합니다.2\n\n따라서, 통계적으로 유의한 결과가 항상 임상적으로 유의한 것은 아닙니다. 다만 통계적 유의성은 객관적인 자료를 통해 설명되지만 임상적 유의성은 임상의 주관이 들어가게 되는 차이가 있습니다. 하지만 무엇보다도 허가 기관으로 부터 품목 허가를 받기 위해서는 위의 두가지 유의성이 모두 적절히 설명되어야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#통계분석계획-statistical-analysis-plan-sap-과-맹검-검토-blind-review-의-필요성",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#통계분석계획-statistical-analysis-plan-sap-과-맹검-검토-blind-review-의-필요성",
    "title": "임상 통계학",
    "section": "1.2 통계분석계획 (Statistical Analysis Plan, SAP) 과 맹검 검토 (Blind review) 의 필요성",
    "text": "1.2 통계분석계획 (Statistical Analysis Plan, SAP) 과 맹검 검토 (Blind review) 의 필요성\n\n1.2.1 통계분석계획의 필요성\n사전에 작성된 임상 시험 계획서의 통계 분석법이 적절하지 않은 경우가 많습니다. 따라서 통계 분석 계획은 임상 시험을 통해 자료를 모두 수집한 뒤 분석법을 수정할 수 있는 마지막 기회입니다.\n\n규제 요구사항 충족: 규제 기관은 임상시험의 신뢰성과 타당성을 평가하기 위해 통계분석계획을 요구합니다. 이는 허가 심사 과정에서 중요한 근거 자료로 사용됩니다.3\n\n\n\n1.2.2 맹검 검토의 필요성\n\n편향 최소화: 맹검 검토는 분석자가 시험 데이터를 해석할 때 발생할 수 있는 편향 (연구자의 사전 지식이나 기대가 결과에 영향) 을 최소화합니다.4\n객관성 확보: 맹검 검토는 연구 결과가 의도하지 않은 외부 요인에 의해 왜곡되지 않도록 보장해 임상시험의 객관성을 높입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험에-자주-쓰이는-시험-디자인",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험에-자주-쓰이는-시험-디자인",
    "title": "임상 통계학",
    "section": "1.3 임상 시험에 자주 쓰이는 시험 디자인",
    "text": "1.3 임상 시험에 자주 쓰이는 시험 디자인\n\n1.3.1 평행 설계 (Parallel Design)\n| group A  | group B  | group C  |\n| -------- | -------- | -------- |\n| patient1 | patient2 | patiant3 |\n| -------- | -------- | -------- |\n| patient4 | patient5 | patiant6 |\n평행 설계는 임상시험 참가자들을 두 개 이상의 그룹으로 무작위로 배정하여, 각 그룹이 서로 다른 치료를 받도록 하는 방식입니다. 각 그룹은 시험 기간 동안 동일한 치료를 계속 받습니다.\n\n장점: 이 설계는 단순하고 이해하기 쉬우며, 각 그룹 간의 비교가 명확합니다. 또한, 교차 설계에 비해 참가자가 적게 필요할 수 있습니다.\n적용: 주로 만성 질환의 장기 치료 효과를 평가할 때 사용됩니다.5\n\n\n\n1.3.2 교차 설계 (Cross-over Design)\npatient1 —-&gt; treatment A —-&gt; wash out —&gt; treatment B\npartien2 —-&gt; treatment B —-&gt; wash out —-&gt; treatment A\n교차 설계는 참가자들이 두 개 이상의 치료를 순차적으로 받도록 하는 방식입니다. 각 참가자는 모든 치료를 받으며, 치료 사이에 세척 기간 (washout period) 을 두어 이전 치료의 영향을 최소화합니다.\n\n장점: 각 참가자가 자신의 대조군 역할을 하므로, 개인 간 변동을 줄일 수 있습니다. 이는 통계적 검정력을 높이고, 필요한 참가자 수를 줄일 수 있습니다.\n적용: 주로 급성 질환이나 일시적인 증상에 대한 치료 효과를 평가할 때 사용됩니다. 그러나 질병의 자연 경과가 빠르게 변하거나, 치료의 장기적 효과가 있는 경우에는 부적합할 수 있습니다\n\n\n\n1.3.3 요인 설계?\n| patient  | treatment A | treatment B | treatment A+B | no treatment |\n| -------- | ----------- | ----------- | ------------- | ------------ |\n| patient1 | yes         |             |               |              |\n| patient2 |             | yes         |               |              |\n| partien3 |             |             | yes           |              |"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#우위성-검정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#우위성-검정",
    "title": "임상 통계학",
    "section": "1.4 우위성 검정",
    "text": "1.4 우위성 검정\n우위성 검정 (Superiority Test) 은 임상시험에서 시험약이 대조약보다 더 나은 효과를 보임을 증명하기 위해 수행되는 통계적 검정입니다. 이 검정은 새로운 치료법이나 약물이 기존의 표준 치료법보다 효과적이라는 것을 입증하는 데 사용됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#우위성-검정의-주요-특징",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#우위성-검정의-주요-특징",
    "title": "임상 통계학",
    "section": "1.5 우위성 검정의 주요 특징",
    "text": "1.5 우위성 검정의 주요 특징\n\n목적: 시험약이 대조약보다 통계적으로 유의하게 더 나은 효과를 보이는지를 확인하는 것입니다. 이는 새로운 치료가 기존 치료보다 임상적으로 의미 있는 개선을 제공하는지를 평가합니다.\n설계: 일반적으로 무작위 대조시험 (Randomized Controlled Trial, RCT) 에서 수행되며, 두 그룹 간의 효과 차이를 비교합니다. 이 과정에서 통계적 유의성을 확보하기 위해 적절한 표본 크기와 설계가 필요합니다.\n결과 해석: 통계적으로 유의한 결과가 도출되면, 이는 시험약이 대조약보다 우수하다는 증거로 해석됩니다. 그러나 통계적 유의성이 임상적 유의성을 항상 보장하는 것은 아니므로, 임상적 의미도 함께 고려해야 합니다.\n\n우위성 검정은 신약 개발 및 임상시험에서 중요한 역할을 하며, 새로운 치료법의 도입을 위한 과학적 근거를 제공합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#동등성-검정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#동등성-검정",
    "title": "임상 통계학",
    "section": "1.6 동등성 검정",
    "text": "1.6 동등성 검정\n동등성 검정 (Equivalence Test) 은 두 치료제 사이에 임상적으로 의미 있는 차이가 없음을 증명하기 위해 수행되는 통계적 검정입니다. 이는 주로 두 치료제가 서로 동등한 효과를 가진다는 것을 입증하려는 경우에 사용됩니다.\n\n목적: 두 치료제 간의 효과 차이가 사전에 정의된 허용 가능한 범위 내에 있음을 증명하는 것입니다. 이는 두 치료제가 임상적으로 동등한 효과를 나타낸다는 것을 보여주려는 것입니다.\n설계: 동등성 검정에서는 양측 신뢰구간을 사용하여 두 치료제 간의 차이가 사전에 설정된 동등성 경계 내에 있는지를 평가합니다. 신뢰구간이 동등성 경계 내에 완전히 포함되면 두 치료제가 동등하다고 결론지을 수 있습니다.6\n결과 해석: 동등성 검정의 결과는 두 치료제가 통계적으로 유의한 차이가 없다는 것을 의미하며, 이는 임상적으로도 의미 있는 차이가 없다는 것을 나타냅니다. 이는 새로운 치료제가 기존 치료제와 유사한 효과를 제공함을 입증하는 데 사용됩니다.\n\n동등성 검정은 제네릭 의약품의 승인이나 기존 치료제와의 비교 연구에서 자주 사용됩니다. 이를 통해 새로운 치료제의 효과가 기존 치료제와 동등함을 입증함으로써, 임상적 유용성을 확보할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-검정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-검정",
    "title": "임상 통계학",
    "section": "1.7 비열등성 검정",
    "text": "1.7 비열등성 검정\n비열등성 검정 (Non-inferiority Test) 은 임상시험에서 실험적 치료가 대조약보다 열등하지 않음을 증명하기 위해 수행되는 통계적 검정입니다. 이는 특히 위약 대조가 비윤리적이거나 실용적이지 않은 경우에 사용되며, 시험약이 대조약과 비교하여 임상적으로 의미 있는 차이가 없음을 입증하려는 목적을 가집니다.\n\n목적: 비열등성 검정은 새로운 치료제가 기존의 활성 대조약보다 열등하지 않다는 것을 입증하는 데 목적이 있습니다. 이를 통해 새로운 치료제가 기존 치료와 유사한 효과를 제공하면서도 다른 장점 (예: 부작용 감소, 비용 절감 등) 을 가질 수 있음을 보여줍니다.\n설계: 비열등성 검정에서는 비열등성 마진 (non-inferiority margin) 을 사전에 정의해야 합니다. 이 마진은 두 치료제 간의 허용 가능한 최대 효과 차이를 나타내며, 신뢰구간이 이 마진 내에 있으면 비열등하다고 결론지을 수 있습니다.7\n결과 해석: 비열등성 검정의 결과는 실험적 치료가 대조약보다 통계적으로 유의하게 열등하지 않다는 것을 의미합니다. 이를 통해, 실험적 치료가 위약보다 효과적임을 간접적으로 증명할 수 있습니다.\n\n비열등성 검정은 특히 새로운 치료법이 기존 치료법과 유사한 효과를 가지면서도 다른 임상적 이점을 제공할 때 유용합니다. 이는 임상시험에서 중요한 설계 전략으로 활용됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험에서-심사기관의-가장-큰-관심사",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험에서-심사기관의-가장-큰-관심사",
    "title": "임상 통계학",
    "section": "1.8 임상 시험에서 심사기관의 가장 큰 관심사",
    "text": "1.8 임상 시험에서 심사기관의 가장 큰 관심사\n약효가 없는 신약을 허가해주는 것 (False positive; 제 1 종 오류) 이 약효가 있는 신약을 허가하지 않는 것 (제 2 종 오류) 보다 큰 문제이다. 따라서 임상 시험에서 제 1 종 오류의 비율이 5% 이하로 통제되었는지를 가장 관심 있게 본다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#차-유효성-평가-변수-primary-endpoint",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#차-유효성-평가-변수-primary-endpoint",
    "title": "임상 통계학",
    "section": "2.1 1 차 유효성 평가 변수 (Primary endpoint)",
    "text": "2.1 1 차 유효성 평가 변수 (Primary endpoint)\n1 차 유효성 평가 변수 (Primary Endpoint) 는 임상시험의 성공 여부를 판단하는 데 사용되는 주요 변수입니다. 이는 임상시험의 목표를 달성했는지를 평가하는 핵심 기준으로, 임상시험계획서에 명확하게 명시되어야 하며, 선택한 이유에 대한 설명도 포함되어야 합니다. 일반적으로 하나의 1 차 유효성 평가 변수가 설정되며, 이는 표본 크기를 계산하는 데도 사용될 수 있습니다. 이러한 변수는 임상시험의 결과를 해석하고, 시험약의 효과를 평가하는 데 중요한 역할을 합니다.\n\n목적: 임상시험의 주요 목표를 달성했는지를 평가하는 핵심 지표입니다. 이는 임상시험의 성공 여부를 판단하는 데 가장 중요한 변수로, 시험의 설계 단계에서 명확하게 정의되어야 합니다.\n특징: 일반적으로 하나의 1 차 유효성 평가 변수가 설정되며, 표본 크기 계산과 통계적 검정의 주요 기준으로 사용됩니다.\n예시: 암 치료제의 경우, 무진행 생존기간 (Progression-Free Survival) 이나 전체 생존기간 (Overall Survival) 이 1 차 유효성 평가 변수가 될 수 있습니다.\n\n\n2.1.1 1 차 유효성 평가 변수 (Primary Endpoint) 의 예시\n\n무진행 생존기간 (Progression-Free Survival, PFS): 이는 암 치료제 임상시험에서 자주 사용되는 1 차 유효성 평가 변수로, 환자가 질병의 진행 없이 생존한 기간을 측정합니다. PFS 는 치료의 효과를 평가하는 중요한 지표로 활용됩니다.10\n최적 전체 반응 (Best Overall Response, BOR): 이 변수는 치료 후 종양의 크기 변화나 반응을 평가하는 데 사용됩니다. BOR 은 암 치료의 효과를 정량화하는 데 중요한 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#차-유효성-평가-변수-secondary-endpoint",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#차-유효성-평가-변수-secondary-endpoint",
    "title": "임상 통계학",
    "section": "2.2 2 차 유효성 평가 변수 (Secondary Endpoint)",
    "text": "2.2 2 차 유효성 평가 변수 (Secondary Endpoint)\n2 차 유효성 평가 변수 (Secondary Endpoint) 는 임상시험에서 보조적으로 시험약의 효과를 측정하는 변수입니다. 이는 1 차 유효성 평가 변수 외에 추가적인 정보를 제공하며, 치료의 부가적인 효과나 안전성을 평가하는 데 사용됩니다. 2 차 유효성 평가 변수는 임상시험의 보조적인 목표를 달성했는지를 평가하며 일반적으로 2 차 유효성 평가 변수는 다음과 같은 6 가지 유형으로 나뉩니다:\n\n증상 개선: 치료가 환자의 증상을 얼마나 개선하는지를 평가합니다.\n삶의 질: 치료가 환자의 전반적인 삶의 질에 미치는 영향을 측정합니다.\n부작용 발생률: 치료와 관련된 부작용의 빈도와 심각성을 평가합니다.\n생체표지자 변화: 치료가 특정 생체표지자에 미치는 영향을 측정합니다.\n경제적 평가: 치료의 비용 효과성을 평가합니다.\n장기적 효과: 치료의 장기적인 효과와 안전성을 평가합니다.\n\n\n목적: 1 차 유효성 평가 변수 외에 추가적인 정보를 제공하며, 치료의 부가적인 효과나 안전성을 평가하는 데 사용됩니다. 이는 임상시험의 보조적인 목표를 달성했는지를 평가합니다.\n특징: 여러 개의 2 차 유효성 평가 변수가 설정될 수 있으며, 1 차 유효성 평가 변수에 비해 상대적으로 중요도가 낮습니다. 그러나, 2 차 유효성 평가 변수는 치료의 전체적인 효과를 이해하는 데 중요한 역할을 합니다.\n예시: 위의 암 치료제 사례에서, 삶의 질 (Quality of Life) 이나 부작용 발생률 등이 2 차 유효성 평가 변수가 될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#주요-편향-유형",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#주요-편향-유형",
    "title": "임상 통계학",
    "section": "3.1 주요 편향 유형",
    "text": "3.1 주요 편향 유형\n\n선정 편향 (Selection Bias): 연구 대상자를 선택하는 과정에서 발생하는 편향으로, 연구 결과가 모집단 전체를 대표하지 못하게 합니다. 무작위 배정 (randomization) 을 통해 최소화할 수 있습니다.\n정보 편향 (Information Bias): 데이터를 수집하거나 측정하는 과정에서 발생하는 오류로, 잘못된 정보가 수집되어 결과에 영향을 미칩니다. 맹검 (blinding) 과 표준화된 측정 방법을 통해 줄일 수 있습니다.\n관찰자 편향 (Observer Bias): 연구자가 결과를 해석하거나 측정할 때 주관적인 판단이 개입되는 경우 발생합니다. 이중 맹검 (double-blind) 설계를 통해 최소화할 수 있습니다.\n출판 편향 (Publication Bias): 긍정적인 결과가 부정적인 결과보다 더 자주 출판되는 경향이 있어, 연구 결과의 전반적인 해석에 영향을 미칩니다.\n회귀 편향 (Regression Bias): 극단적인 값이 평균으로 회귀하는 경향으로 인해 발생하는 편향입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#편향-최소화-전략",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#편향-최소화-전략",
    "title": "임상 통계학",
    "section": "3.2 편향 최소화 전략",
    "text": "3.2 편향 최소화 전략\n\n무작위 배정: 연구 대상자를 무작위로 배정하여 선정 편향을 줄입니다.\n맹검: 연구자와 참가자가 어떤 치료를 받는지 모르게 하여 관찰자와 정보 편향을 줄입니다.\n표준화된 프로토콜: 데이터 수집과 측정 방법을 표준화하여 정보 편향을 줄입니다.\n완전한 데이터 보고: 긍정적, 부정적 결과 모두를 보고하여 출판 편향을 줄입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#편향의-발생을-막는-임상-디자인",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#편향의-발생을-막는-임상-디자인",
    "title": "임상 통계학",
    "section": "3.3 편향의 발생을 막는 임상 디자인",
    "text": "3.3 편향의 발생을 막는 임상 디자인\n편향을 방지하기 위한 임상시험 디자인 방법 중 하나는 맹검 (blinding) 입니다. 맹검은 연구자가 의도치 않게 결과에 영향을 미치는 것을 방지하기 위해 피험자와 연구자 모두에게 특정 정보를 숨기는 방법입니다. 맹검에는 여러 유형이 있으며, 그 중 흔히 사용되는 두 가지는 다음과 같습니다:\n\n3.3.1 맹검\n\n단일 맹검 (Single-Blind)\n\n\n설명: 피험자만이 자신이 어떤 치료를 받고 있는지 모르는 경우입니다. 연구자나 시험자는 어떤 치료가 피험자에게 투여되는지 알고 있습니다.\n목적: 피험자가 자신이 받는 치료에 대해 알지 못하게 하여, 심리적 요인이나 기대가 결과에 미치는 영향을 최소화합니다.\n\n\n이중 맹검 (Double-Blind)\n\n\n설명: 피험자와 연구자 모두가 어떤 치료가 투여되고 있는지 모르는 경우입니다.\n목적: 피험자와 연구자 모두의 편향을 방지하여, 연구 결과의 객관성과 신뢰성을 높입니다. 이는 편향을 최소화하는 가장 강력한 방법 중 하나로 간주됩니다.11\n\n이러한 맹검 방법은 임상시험에서 편향을 줄이고, 결과의 타당성을 높이는 데 중요한 역할을 합니다.\n\n\n3.3.2 무작위 배정\n무작위 배정 (Randomization) 은 임상시험에서 편향을 줄이고 결과의 신뢰성을 높이기 위해 피험자를 무작위로 배정하는 방법입니다. 무작위 배정의 주요 유형과 각각의 특징은 다음과 같습니다:\n\n단순 무작위 배정 (Simple Randomization)\n\n\n설명: 난수발생기를 사용하여 피험자를 무작위로 배정하는 방법입니다.\n장점: 가장 기본적이고 이해하기 쉬운 방법입니다.\n단점: 불균등한 배정이 발생할 수 있는 가능성이 있어, 특히 작은 표본 크기에서 그룹 간 불균형이 생길 수 있습니다.\n\n\n블록 무작위 배정 (Block Randomization)\n\n\n설명: 피험자들을 몇 개의 블록으로 나누고, 각 블록 내에서 단순 무작위 배정을 수행하는 방법입니다.\n장점: 각 치료군에 균등한 수의 피험자가 배정되도록 보장하여, 시간 경과에 따른 외부 요인의 영향을 최소화할 수 있습니다. 이는 특히 중간 분석이 필요한 경우에 유리합니다.\n\n\n층화 무작위 배정 (Stratified Randomization)\n\n\n설명: 피험자들을 특정 특성 (예: 질병의 중증도, 연령 등) 에 따라 층으로 나눈 후, 각 층 내에서 블록 무작위 배정을 수행하는 방법입니다.\n장점: 중요한 인구통계학적 또는 임상적 특성에 따라 피험자를 균등하게 배정하여, 이러한 특성들이 결과에 미치는 영향을 최소화할 수 있습니다.\n단점: 층의 수가 많아질수록 복잡성이 증가하며, 각 층에 충분한 수의 피험자가 필요합니다. 이는 시험 설계와 관리에 있어 추가적인 부담이 될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#검정력-power",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#검정력-power",
    "title": "임상 통계학",
    "section": "4.1 검정력 (Power)",
    "text": "4.1 검정력 (Power)\n\n정의: 검정력은 실제로 효과가 존재할 때, 연구가 그 효과를 발견할 수 있는 확률을 의미합니다. 이는 1 - 제 2종 오류 확률(β) 로 정의됩니다.\n의미: 검정력이 높을수록 연구가 실제 효과를 발견할 가능성이 높아집니다. 일반적으로 80% 이상의 검정력이 목표로 설정됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#제-1-종-오류와-제-2-종-오류",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#제-1-종-오류와-제-2-종-오류",
    "title": "임상 통계학",
    "section": "4.2 제 1 종 오류와 제 2 종 오류",
    "text": "4.2 제 1 종 오류와 제 2 종 오류\n\n제 1 종 오류 (Type I Error, α): 실제로 효과가 없는데도 효과가 있다고 잘못 결론 내리는 오류입니다. 일반적으로 α는 5% 이하로 설정됩니다.\n제 2 종 오류 (Type II Error, β): 실제로 효과가 있는데도 효과가 없다고 잘못 결론 내리는 오류입니다. β가 낮을수록 검정력이 높아집니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#제-1-종-오류와-제-2-종-오류-간의-트레이드-오프",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#제-1-종-오류와-제-2-종-오류-간의-트레이드-오프",
    "title": "임상 통계학",
    "section": "4.3 제 1 종 오류와 제 2 종 오류 간의 트레이드 오프",
    "text": "4.3 제 1 종 오류와 제 2 종 오류 간의 트레이드 오프\n\n트레이드 오프: 표본의 크기가 동일한 경우, 제 1 종 오류 (α) 를 줄이면 제 2 종 오류 (β) 가 증가하는 경향이 있습니다. 이는 연구 설계에서 두 오류 간의 균형을 맞추는 것이 중요함을 의미합니다.\n해결 방법: 이 트레이드 오프를 해결하기 위해서는 표본의 크기를 증가시키는 것이 일반적인 방법입니다. 표본 크기를 늘리면 제 2 종 오류를 줄여 검정력을 높일 수 있습니다. 다시 말해 임상 시험에서 제 1 종 오류는 5% 이하로 고정되어 있기 때문에 제 2 종 오류를 줄여서 검정력을 높이기 위해서는 표본의 크기를 늘리는 수 밖에 없다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기를-늘리지-않고-검정력을-높이는-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기를-늘리지-않고-검정력을-높이는-방법",
    "title": "임상 통계학",
    "section": "4.4 표본의 크기를 늘리지 않고 검정력을 높이는 방법",
    "text": "4.4 표본의 크기를 늘리지 않고 검정력을 높이는 방법\n표본의 크기를 늘리지 않고 검정력을 높이는 방법에는 다음은 두 가지 방법이 있습니다.\n\n환자 선정을 엄격하게 해서 동질적인 환자를 모집:\n\n설명: 연구에 포함되는 환자군을 더 동질적으로 만들기 위해 엄격한 선정 기준을 적용합니다. 이는 환자 간 변동성을 줄여 결과의 변동성을 감소시킵니다.\n장점: 동질적인 환자군을 통해 통계적 검정력이 높아질 수 있습니다.\n단점: 환자 모집에 시간이 더 걸릴 수 있으며, 신약의 적응증이 줄어들 수 있습니다.\n\n시험약의 약효 크기를 높임:\n\n설명: 시험약의 효과 크기를 증가시키면, 통계적으로 유의한 결과를 얻을 가능성이 높아집니다.\n장점: 더 큰 효과 크기는 검정력을 증가시킵니다.\n단점: 임상 시험이 이미 진행 중인 경우에는 이 방법을 적용하기 어려울 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#허가-기관에서-권장하는-검정력",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#허가-기관에서-권장하는-검정력",
    "title": "임상 통계학",
    "section": "4.5 허가 기관에서 권장하는 검정력",
    "text": "4.5 허가 기관에서 권장하는 검정력\n허가 기관에서 권장하는 검정력은 일반적으로 80% 에서 90% 사이입니다. ICH E9 가이드라인에 따르면 이정도 수준의 검정력은 임상시험의 의미 있는 결과를 도출하는 데 필수적입니다.12"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기를-결정하는-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기를-결정하는-방법",
    "title": "임상 통계학",
    "section": "4.6 표본의 크기를 결정하는 방법",
    "text": "4.6 표본의 크기를 결정하는 방법\n표본의 크기를 결정하는 방법은 임상시험의 설계에서 중요한 요소로, 1 차 유효성 평가 변수에 의해 크게 영향을 받습니다. 특히, 통계 분석법이 two-sample t-test 인 경우, 표본 크기 결정은 다음과 같은 요소들을 고려합니다:\n\n효과 크기 (Effect Size): 두 그룹 간의 차이를 측정하는 데 사용됩니다. 효과 크기가 클수록 필요한 표본 크기는 작아질 수 있습니다.\n유의 수준 (Significance Level, α): 일반적으로 5% 로 설정되며, 이는 제 1 종 오류의 허용 확률을 의미합니다.\n검정력 (Power, 1-β): 일반적으로 80% 에서 90% 로 설정되며, 이는 실제 효과가 있을 때 이를 발견할 수 있는 확률입니다.\n표준 편차 (Standard Deviation): 모집단의 변동성을 나타내며, 변동성이 클수록 더 많은 표본이 필요합니다.\n\n이러한 요소들은 표본 크기를 결정하는 데 중요한 역할을 하며, 연구의 목표와 설계에 따라 신중하게 고려되어야 합니다. 표본 크기를 적절히 설정함으로써 연구의 신뢰성과 타당성을 높일 수 있습니다.\n1 차 유효성 평가 변수에 의해 결정된다. 통계 분석법이 two-sample t-test 인 경우는 다음과 같다.\n\\[ n = \\frac{Z_{alpha/2} + Z_{beta} * 2 * \\delta^2}{ (\\mu_1 - \\mu_2)^2}\\]"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기-계산에-사용된-값의-정확도",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#표본의-크기-계산에-사용된-값의-정확도",
    "title": "임상 통계학",
    "section": "4.7 표본의 크기 계산에 사용된 값의 정확도",
    "text": "4.7 표본의 크기 계산에 사용된 값의 정확도\n표본의 크기를 계산할 때 사용되는 값들은 일반적으로 임상시험이 끝나야 정확히 알 수 있는 미지의 값이기 때문에, 초기에는 추정치를 사용하여 계산합니다. 이러한 추정치는 과거의 연구 데이터나 파일럿 연구의 결과를 바탕으로 추정됩니다. 이로 인해, 표본 크기 계산은 항상 어느 정도의 불확실성을 내포하고 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#그룹간-표본-크기",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#그룹간-표본-크기",
    "title": "임상 통계학",
    "section": "4.8 그룹간 표본 크기",
    "text": "4.8 그룹간 표본 크기\n\n동일한 표본 크기: 두 그룹 간의 표본 크기를 동일하게 설정하면, 통계적 검정력이 최대화됩니다. 이는 두 그룹의 비교가 더 균형 잡히고, 결과의 해석이 용이해지기 때문입니다.\n비대칭 표본 크기: 실질적인 이유 (예: 모집의 어려움, 비용 제한 등) 로 인해 두 그룹의 표본 크기가 동일하지 않을 수 있습니다. 비대칭 표본 크기는 연구의 검정력을 감소시킬 수 있으며, 이를 보완하기 위해서는 더 많은 총 표본이 필요할 수 있습니다.\n\n결론적으로, 표본 크기를 설계할 때는 가능한 한 두 그룹의 크기를 동일하게 유지하는 것이 이상적입니다. 그러나, 연구의 실질적인 제약을 고려하여 비대칭적인 크기를 사용할 수도 있으며, 이 경우 검정력에 미치는 영향을 충분히 고려해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험이-실패하는-이유",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상-시험이-실패하는-이유",
    "title": "임상 통계학",
    "section": "4.9 임상 시험이 실패하는 이유",
    "text": "4.9 임상 시험이 실패하는 이유\n임상시험이 실패하는 이유는 다양하며 다음은 임상시험 실패의 일반적인 원인들입니다:\n\n시험약의 효과가 감소되는 편향이 발생한 경우: 연구 설계나 실행 과정에서 편향이 발생하면 시험약의 실제 효과가 왜곡되어 나타날 수 있습니다.\n시험약의 용량 선정이 잘못된 경우: 적절한 용량을 선택하지 못하면, 약효가 충분히 나타나지 않거나 안전성 문제가 발생할 수 있습니다. 용량이 너무 낮으면 약효가 줄어들고, 너무 높으면 부작용이 증가할 수 있습니다.\n검정력이 부족한 경우: 충분한 표본 크기를 확보하지 못하면 검정력이 부족하게 되어, 실제로 효과가 있는 경우에도 이를 발견하지 못할 수 있습니다.\n환자 모집단을 잘못 선택한 경우: 시험약이 특정 환자군에서만 효과가 있을 수 있는데, 잘못된 모집단을 선택하면 약효를 제대로 평가하지 못할 수 있습니다.\n1 차 유효성 평가 변수를 잘못 선택한 경우: 적절한 1 차 유효성 평가 변수를 선택하지 못하면, 시험의 주요 목표를 정확히 평가하지 못할 수 있습니다.\n우연에 의해 실패한 경우: 검정력 80% 라는 의미는, 실제로 효과가 있을 때 이를 발견할 확률이 80% 라는 뜻이며, 이는 우연에 의해 실패할 확률이 20% 임을 의미합니다.\n시험약의 약효가 없는 경우: 시험약 자체에 효과가 없으면 임상시험은 실패할 수밖에 없습니다. 이는 시험약의 기전이 잘못 이해되었거나, 예상과 달리 효과가 없는 경우에 해당합니다.\n\n이러한 요인들은 임상시험 설계와 실행 단계에서 신중하게 고려되어야 하며, 각 요인을 최소화하기 위한 전략이 필요합니다. 이를 통해 임상시험의 성공 가능성을 높일 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#기관별-약효의-크기",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#기관별-약효의-크기",
    "title": "임상 통계학",
    "section": "5.1 기관별 약효의 크기",
    "text": "5.1 기관별 약효의 크기\n다기관 임상시험에서 약효가 존재한다고 판단되면, 각 기관별로 약효의 크기에 대한 교호작용 검정을 수행합니다. 이는 각 기관에서의 약효가 일관되게 나타나는지를 평가하는 과정입니다. 교호작용 검정은 특정 기관에서의 약효 차이가 시험의 전반적인 결과에 미치는 영향을 평가해 결과의 해석에 중요한 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#교호-작용-검정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#교호-작용-검정",
    "title": "임상 통계학",
    "section": "5.2 교호 작용 검정",
    "text": "5.2 교호 작용 검정\n교호작용 검정은 통계학적으로 두 변수 간의 상호작용이 존재하는지를 평가하는 방법입니다. 통계학적으로 교호작용이 존재한다면, 이는 두 가지 종류로 나뉩니다:\n\n양적인 교호작용: 두 변수 간의 상호작용이 효과의 크기에 영향을 미치지만, 효과의 방향은 동일하게 유지됩니다. 예를 들어, 약물 A 와 B 가 함께 사용될 때 효과가 더 커지지만, 두 약물이 모두 긍정적인 효과를 나타내는 경우입니다.\n질적인 교호작용: 두 변수 간의 상호작용이 효과의 방향을 변화시킵니다. 예를 들어, 약물 A 가 단독으로는 긍정적인 효과를 나타내지만, 약물 B 와 함께 사용될 때는 부정적인 효과를 나타내는 경우입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상-설계-단계에서-보정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상-설계-단계에서-보정",
    "title": "임상 통계학",
    "section": "6.1 임상 설계 단계에서 보정",
    "text": "6.1 임상 설계 단계에서 보정\n층화 무작위 배정:14 - 공변량에 대해 층화하여 무작위 배정을 실시합니다. 이는 치료군과 대조군 간 공변량 분포의 불균형을 줄여 편향을 감소시키며 검정력 향상에도 기여합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#분석-단계에서-보정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#분석-단계에서-보정",
    "title": "임상 통계학",
    "section": "6.2 분석 단계에서 보정",
    "text": "6.2 분석 단계에서 보정\n기저치 공변량 보정을 주 분석에서 실시했는지 명확히 기술해야 합니다. 탐색적 분석의 결과는 신중하게 해석해야 하며, 이에 근거한 결론은 일반적으로 받아들여지기 어렵습니다. 1 차 유효성 평가변수의 형태에 따라 다른 통계적 방법을 사용합니다.\n\n연속형 변수: 공분산분석 (ANCOVA) 을 사용합니다.\n이진형 또는 범주형 변수: 로지스틱 회귀분석을 적용합니다.\n시간형 변수 (생존시간): Cox 비례위험모형 (proportional hazard mode) 을 활용합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#보정할-기저치-공변량의-기준",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#보정할-기저치-공변량의-기준",
    "title": "임상 통계학",
    "section": "6.3 보정할 기저치 공변량의 기준",
    "text": "6.3 보정할 기저치 공변량의 기준\n\n1 차 유효성 평가변수와의 상관관계: 1 차 유효성 평가변수와 상관관계가 있는 기저치 공변량을 선택하는 것이 중요합니다.15\n층화 무작위배정 변수: 층화 무작위배정에 사용된 변수는 보정 대상으로 고려해야 합니다.\n무작위 배정 이전 변수: 무작위 배정 이후에 관찰되는 변수는 보정 대상에서 제외해야 합니다.\n교호작용 부재: 교호작용이 존재하지 않는 변수를 선택하는 것이 바람직합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#무작위-배정-후-관측된-불균형-기저치-공변량-보정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#무작위-배정-후-관측된-불균형-기저치-공변량-보정",
    "title": "임상 통계학",
    "section": "6.4 무작위 배정 후 관측된 불균형 기저치 공변량 보정",
    "text": "6.4 무작위 배정 후 관측된 불균형 기저치 공변량 보정\n원칙적으로 무작위 배정 후 관측된 불균형 기저치 공변량은 보정하지 않는 것이 바람직합니다. 이에 대한 근거는 다음과 같습니다:\n\n편향 가능성: 사후에 관찰된 불균형을 보정하는 것은 새로운 편향을 도입할 수 있습니다.16\n통계적 타당성: 원래 사전에 명시되지 않은 공변량을 무작위배정 이후에 보정하는 것은 통계적으로 부적절할 수 있습니다.\n연구 계획의 중요성: 임상시험 계획서의 통계 부분에서 주 분석에 포함될 임상시험대상자 집단을 사전에 정의하는 것이 중요합니다.\n객관성 유지: 무작위 배정 후 관찰된 불균형을 보정하면 연구의 객관성이 훼손될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#itt-intention-to-treat-분석-16",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#itt-intention-to-treat-분석-16",
    "title": "임상 통계학",
    "section": "7.1 ITT (Intention to Treat) 분석 17",
    "text": "7.1 ITT (Intention to Treat) 분석 17\n\n무작위 배정된 모든 참가자를 원래 배정된 그룹대로 분석에 포함시킵니다.\n프로토콜 위반, 중도 탈락, 치료 비순응 등에 관계없이 모든 참가자를 포함합니다.\n실제 임상 현장의 상황을 더 잘 반영하여 치료의 실제 효과를 추정할 수 있습니다.\n무작위 배정의 이점을 유지하고 편향을 최소화합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#pp-per-protocol-분석-17",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#pp-per-protocol-분석-17",
    "title": "임상 통계학",
    "section": "7.2 PP (Per Protocol) 분석 18",
    "text": "7.2 PP (Per Protocol) 분석 18\nPP(Per Protocol) 분석은 임상시험에서 중요한 분석 방법 중 하나입니다. PP 분석의 주요 특징은 다음과 같습니다:\n\nPP 분석은 full analysis set(전체 분석 집합) 의 부분집합으로 임상시험계획서를 보다 잘 준수한 피험자들만을 포함하는 분석 집합입니다.\n주요 프로토콜 위반, 치료 비순응, 그룹 전환, 측정 누락 등의 사유로 제외된 피험자들은 분석에서 제외됩니다 19\n이상적인 조건에서의 치료 효과를 식별하는 것이 목적이며,” 환자들이 완전히 순응할 경우 효과가 어떻게 나타나는가?” 라는 질문에 답하고자 합니다.20"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#itt-분석과의-차이",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#itt-분석과의-차이",
    "title": "임상 통계학",
    "section": "7.3 ITT 분석과의 차이",
    "text": "7.3 ITT 분석과의 차이\n\nPP 분석은 치료를 완료하지 않은 환자들을 제외하므로 치료 차이를 더 잘 반영할 수 있습니다.\nITT 분석이 두 치료법을 비슷하게 보이게 하는 경향이 있는 반면, PP 분석은 치료 차이를 더 명확히 보여줄 수 있습니다.\nITT 는 보수적인 추정치를 제공하지만, 실제 임상 상황을 더 잘 반영합니다.\nPP 는 이상적인 조건에서의 효과를 보여주지만, 선택 편향의 위험이 있습니다.\nPP 분석은 임상시험 결과를 해석하는 데 중요한 역할을 하지만, 선택 편향의 위험이 있으므로 ITT 분석과 함께 고려되어야 합니다. 특히 비열등성 시험에서는 ITT 와 PP 분석 모두가 중요하며, 두 분석 결과가 유사한 결론을 도출할 때 연구 결과의 신뢰성이 높아집니다.\nITT 가 일반적으로 우선적으로 권장되는 분석 방법입니다.21"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상시험-자료가-불완전해지는-이유",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상시험-자료가-불완전해지는-이유",
    "title": "임상 통계학",
    "section": "7.4 임상시험 자료가 불완전해지는 이유",
    "text": "7.4 임상시험 자료가 불완전해지는 이유\n임상시험에서 자료가 불완전해지는 이유는 다양하지만 크게 4 가지 주요 이유에 대해 자세히 살펴보겠습니다:\n\n7.4.1 선정기준 위반\n\n일부 피험자가 연구 시작 후 선정기준에 부합하지 않는 것으로 밝혀질 수 있습니다.\n이는 초기 스크리닝 과정에서의 오류나 피험자 상태의 변화로 인해 발생할 수 있습니다.\n이러한 경우, 해당 피험자의 데이터를 포함시킬지 여부에 대한 결정이 필요합니다.\n\n\n\n7.4.2 윤리적 사유 또는 단순 실수로 인한 치료법 변경\n\n피험자의 안전이나 윤리적 고려사항으로 인해 원래 계획된 치료법을 변경해야 할 수 있습니다.\n의료진의 실수로 인해 잘못된 치료가 제공될 수도 있습니다.\n이러한 변경은 데이터의 일관성을 해치고 결과 해석을 복잡하게 만들 수 있습니다.\n\n\n\n7.4.3 임상시험계획서 위반 또는 낮은 순응도\n\n일부 피험자가 임상시험계획서를 정확히 따르지 않거나 처방된 치료에 대한 순응도가 낮을 수 있습니다.\n이는 약물 복용 누락, 방문 일정 미준수, 금지된 병용 약물 사용 등의 형태로 나타날 수 있습니다.\n이러한 위반은 치료 효과의 정확한 평가를 어렵게 만듭니다.\n\n\n\n7.4.4 1 차 유효성 평가변수의 결측치 발생\n\n피험자가 추적 관찰에서 이탈하거나, 특정 검사를 거부하거나, 데이터 수집 과정에서 오류가 발생할 수 있습니다.\n결측치는 통계 분석의 정확성과 신뢰성을 저하시킬 수 있습니다.\n결측 데이터 처리 방법 (예: 다중 대체법, 마지막 관찰값 전달법 등) 의 선택이 중요해집니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#다중-검정의-문제",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#다중-검정의-문제",
    "title": "임상 통계학",
    "section": "8.1 다중 검정의 문제",
    "text": "8.1 다중 검정의 문제\n\n8.1.1 Familywise Type I 오류율 증가\n\n개별 검정의 유의수준을 5% 로 설정하더라도, 여러 검정을 수행하면 전체적인 Type I 오류율 (familywise error rate) 이 5% 이상으로 증가합니다.\n이는 실제로 효과가 없는 경우에도 우연히 유의한 결과를 얻을 확률이 높아짐을 의미합니다.\n\n\n\n8.1.2 거짓 양성 결과 증가\n\n검정 횟수가 증가할수록 최소한 하나의 거짓 양성 결과를 얻을 확률이 높아집니다.\n예를 들어, 20 개의 독립적인 검정을 5% 유의수준에서 수행할 경우, 최소 하나의 거짓 양성 결과를 얻을 확률은 64% 에 달합니다.\n\n\n\n8.1.3 연구 결과의 신뢰성 저하\n\n다중 검정으로 인해 우연히 유의한 결과를 얻을 가능성이 높아지면, 연구 결과의 전반적인 신뢰성이 저하됩니다.\n\n\n\n8.1.4 임상적 영향\n\n약효가 없는 약물이 시판 허가를 받을 확률이 증가합니다.\n이는 환자 안전과 공중 보건에 부정적인 영향을 미칠 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#다중-검정-문제의-해결-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#다중-검정-문제의-해결-방법",
    "title": "임상 통계학",
    "section": "8.2 다중 검정 문제의 해결 방법",
    "text": "8.2 다중 검정 문제의 해결 방법\n다중 검정 문제를 해결하는 여러 방법과 그 장단점에 대해 설명하겠습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#bonferroni-method",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#bonferroni-method",
    "title": "임상 통계학",
    "section": "8.3 Bonferroni method",
    "text": "8.3 Bonferroni method\n장점: - 간단하고 직관적인 방법 - FWER(Family-Wise Error Rate) 을 효과적으로 통제\n단점: - 매우 보수적인 방법으로, 가설의 수가 많아지면 개별 검정의 유의수준이 작아져 귀무가설을 잘 기각하지 못함 22 - Type II 오류 (false negative) 가 증가하여 검정력이 감소함"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#holm-method",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#holm-method",
    "title": "임상 통계학",
    "section": "8.4 Holm method",
    "text": "8.4 Holm method\n장점: - Bonferroni 방법보다 덜 보수적 - FWER 을 통제하면서도 더 많은 귀무가설을 기각시킬 수 있음 - Type II 오류를 줄이고 검정력을 증가시킴 23\n단점: - Bonferroni 방법에 비해 계산이 복잡함"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#hochberg-method",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#hochberg-method",
    "title": "임상 통계학",
    "section": "8.5 Hochberg method",
    "text": "8.5 Hochberg method\n이 방법은 Holm 방법과 유사하지만 역순으로 진행됩니다.\n장점: - Holm 방법보다 더 강력한 검정력을 제공할 수 있음 - FWER 을 통제하면서도 더 많은 유의한 결과를 찾을 수 있음\n단점: - 특정 조건 (검정 통계량들이 독립적이거나 양의 의존성을 가질 때) 에서만 FWER 을 정확히 통제함"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#prospective-alpha-allocation-scheme",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#prospective-alpha-allocation-scheme",
    "title": "임상 통계학",
    "section": "8.6 Prospective alpha allocation scheme",
    "text": "8.6 Prospective alpha allocation scheme\n이 방법은 사전에 각 가설에 대한 유의수준을 할당합니다.\n장점: - 연구자가 각 가설의 중요도에 따라 유의수준을 조정할 수 있음 - 유연한 접근 방식 제공\n단점: - 주관적인 판단이 개입될 수 있음 - 사전 계획이 필요하여 유연성이 제한될 수 있음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#the-fixed-sequence-method",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#the-fixed-sequence-method",
    "title": "임상 통계학",
    "section": "8.7 The fixed-sequence method",
    "text": "8.7 The fixed-sequence method\n이 방법은 사전에 정해진 순서대로 가설을 검정합니다.\n장점: - 중요한 가설을 우선적으로 검정할 수 있음 - FWER 을 효과적으로 통제함\n단점: - 순서가 고정되어 있어 유연성이 떨어짐 - 초기 가설이 기각되지 않으면 후속 가설을 검정할 수 없음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#the-fallback-method",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#the-fallback-method",
    "title": "임상 통계학",
    "section": "8.8 The fallback method",
    "text": "8.8 The fallback method\n이 방법은 fixed-sequence method 의 변형으로, 이전 가설이 기각되지 않아도 다음 가설을 검정할 수 있습니다.\n장점: - Fixed-sequence method 보다 유연함 - 모든 가설에 대해 검정 기회를 제공함\n단점: - 계산이 복잡할 수 있음 - 초기 가설의 중요성이 여전히 강조됨"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#gate-keeping",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#gate-keeping",
    "title": "임상 통계학",
    "section": "8.9 Gate keeping",
    "text": "8.9 Gate keeping\n이 방법은 가설을 그룹으로 나누고, 특정 그룹의 가설이 기각되어야 다음 그룹의 가설을 검정할 수 있게 합니다.\n장점: - 구조화된 접근 방식으로 가설의 우선순위를 반영할 수 있음 - FWER 을 효과적으로 통제함\n단점: - 복잡한 구조를 설계해야 함 - 초기 그룹의 가설이 기각되지 않으면 후속 그룹의 가설을 검정할 수 없음\n이러한 다양한 방법들은 각각의 장단점이 있으며, 연구 상황과 목적에 따라 적절한 방법을 선택해야 합니다.\n다중 검정 문제를 해결하기 위한 여러 방법이 있습니다:\n\nBonferroni 교정: 유의수준을 검정 횟수로 나누어 조정합니다.\nHolm-Bonferroni 방법: 단계적으로 유의수준을 조정합니다.\nFalse Discovery Rate (FDR) 제어: 거짓 발견 비율을 제어합니다.\n사전에 주요 결과 변수 지정: 분석 계획 단계에서 주요 결과 변수를 미리 지정합니다.\n통합 검정 방법 사용: 여러 결과를 하나의 통계량으로 통합하여 분석합니다.\n\n\n8.9.1 다중 검정 문제를 해결하는 방법과 각각의 장단점\n\nBonferroni method: 장단점?\nHolm method: 장단점?\nHochberg method:\nProspective alpha allocation scheme\nThe fixed-sequence method\nThe fallback method\nGate keeping"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#확증적-하위군-분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#확증적-하위군-분석",
    "title": "임상 통계학",
    "section": "9.1 확증적 하위군 분석",
    "text": "9.1 확증적 하위군 분석\n확증적 하위군 분석은 매우 드문 경우에 수행되며, 다음 두 가지 조건이 임상시험 계획서에 명확히 명시되어 있어야 합니다:\n\n분석할 하위군이 사전에 정의되어 있어야 함\n다중성 문제를 해결하기 위한 통계적 방법이 명시되어 있어야 함\n\n이러한 조건을 충족시키는 확증적 하위군 분석은 신뢰성 있는 결과를 제공할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#탐색적-하위군-분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#탐색적-하위군-분석",
    "title": "임상 통계학",
    "section": "9.2 탐색적 하위군 분석",
    "text": "9.2 탐색적 하위군 분석\n탐색적 하위군 분석은 다음과 같은 특징을 가집니다:\n\n시험약의 효능 존재 여부를 직접적으로 검증하지 않습니다.\n주로 치료제와 공변량 사이의 교호작용 존재 여부를 판단하는 데 중점을 둡니다.\n이 분석은 향후 연구를 위한 가설을 생성하거나 특정 하위군에서의 치료 효과를 탐색하는 데 유용합니다.\n\n탐색적 하위군 분석의 결과는 주의해서 해석해야 하며, 일반적으로 확증적 증거로 간주되지 않습니다 [1]."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#주의사항",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#주의사항",
    "title": "임상 통계학",
    "section": "9.3 주의사항",
    "text": "9.3 주의사항\n하위군 분석, 특히 탐색적 분석을 수행할 때는 다음 사항에 주의해야 합니다:\n\n다중성 문제: 여러 하위군을 동시에 분석할 경우 제 1 종 오류 (false positive) 가능성이 증가합니다.\n검정력 감소: 하위군으로 나누면 각 그룹의 표본 크기가 작아져 통계적 검정력이 감소할 수 있습니다.\n해석의 주의: 특히 탐색적 분석 결과는 추가 연구의 필요성을 제시하는 정도로 해석해야 합니다 [1]."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#assay-sensitivity-의-개념",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#assay-sensitivity-의-개념",
    "title": "임상 통계학",
    "section": "10.1 Assay sensitivity 의 개념",
    "text": "10.1 Assay sensitivity 의 개념\n변별력있는 시험. 과거 임상 결과의 재현성에 대한 문제를 피하기 위한 선행요건. 3 가지 간접적인 방법이 있다.\n\nHESDE\n현재 비열등성 임상과 과거 임상의 유효성 입증\n현재 비열등성 임상을 높은 수준으로 관리\n\n\n과거 임상시험의 결과가 재현되지 않을 수도 있는가? 그렇다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-마진을-결정하는-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-마진을-결정하는-방법",
    "title": "임상 통계학",
    "section": "10.2 비열등성 마진을 결정하는 방법",
    "text": "10.2 비열등성 마진을 결정하는 방법\nFDA 권고에 따르면 통계적 마진과 임상적 마진이 있다. 1. 통계적 마진 2. 임상적 마진: 통계적 마진보다 작아야 한다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-시험은-보통-2-개의-그룹이지만-위약을-쓸-수-있다면-3-개의-그룹으로도-진행할-수-있다",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-시험은-보통-2-개의-그룹이지만-위약을-쓸-수-있다면-3-개의-그룹으로도-진행할-수-있다",
    "title": "임상 통계학",
    "section": "10.3 비열등성 시험은 보통 2 개의 그룹이지만 위약을 쓸 수 있다면 3 개의 그룹으로도 진행할 수 있다",
    "text": "10.3 비열등성 시험은 보통 2 개의 그룹이지만 위약을 쓸 수 있다면 3 개의 그룹으로도 진행할 수 있다\n비열등성 임상시험은 위약군 없이 진행되며, 두 가지 주요 목적이 있습니다:\n\n시험약이 대조약보다 나쁘지 않음을 증명\n시험약이 위약보다 약효가 우위에 있음을 보여 시판허가를 받는 것 (더 중요한 목적)"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#assay-sensitivity-의-개념-1",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#assay-sensitivity-의-개념-1",
    "title": "임상 통계학",
    "section": "10.4 Assay sensitivity 의 개념",
    "text": "10.4 Assay sensitivity 의 개념\nAssay sensitivity 는 변별력 있는 시험을 의미하며, 과거 임상 결과의 재현성 문제를 피하기 위한 선행요건입니다. 이를 확보하기 위한 3 가지 간접적인 방법이 있습니다:\n\nHESDE (Historical Evidence of Sensitivity to Drug Effects): 과거의 임상시험 데이터를 활용하여 약물 효과에 대한 민감도를 평가하는 방법.\n현재 비열등성 임상과 과거 임상의 유효성 입증: 현재 진행 중인 비열등성 임상시험과 과거 임상시험 결과를 비교하는 접근법.\n현재 비열등성 임상을 높은 수준으로 관리: 현재 진행 중인 비열등성 임상시험의 품질을 높이는 데 중점\n\n\n가장 주의할 점은 과거 임상시험의 결과가 다시 재현되지 않을 수도 있다는 것입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-마진-결정-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-마진-결정-방법",
    "title": "임상 통계학",
    "section": "10.5 비열등성 마진 결정 방법",
    "text": "10.5 비열등성 마진 결정 방법\nFDA 권고에 따르면 비열등성 마진을 결정하는 데 두 가지 접근 방식이 있습니다:\n\n통계적 마진: 과거 임상시험 데이터를 기반으로 통계적 분석을 통해 결정.\n임상적 마진: 마진은 임상적 중요성과 실용성을 고려하여 결정되며, 통계적 마진보다 작아야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-시험에서-주의할-점",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#비열등성-시험에서-주의할-점",
    "title": "임상 통계학",
    "section": "10.6 비열등성 시험에서 주의할 점",
    "text": "10.6 비열등성 시험에서 주의할 점\n\n비열등성 시험에서는 눈가림 (blinding) 이 우월성 시험만큼 편향을 방지하지 못할 수 있습니다.\n비열등성 마진을 명시하는 것은 매우 중요하며, 임상시험 계획서에 명확히 정의되어야 합니다.\n통계적 처벌 없이 동일한 임상시험에서 비열등성과 우월성을 모두 평가할 수 있습니다. 따라서 가능하다면 임상시험 계획서에 두 가지 가설을 모두 포함하는 것이 좋습니다.24\n비열등성 시험은 일반적으로 2 개의 그룹 (시험약과 대조약) 으로 진행됩니다. 그러나 윤리적으로 허용되고 과학적으로 필요한 경우, 위약을 포함한 3 개의 그룹으로도 진행할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#결측치-제거의-문제점",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#결측치-제거의-문제점",
    "title": "임상 통계학",
    "section": "11.1 결측치 제거의 문제점",
    "text": "11.1 결측치 제거의 문제점\n단순히 결측치를 제거하는 것은 다음과 같은 심각한 문제를 야기할 수 있습니다:\n\nITT(Intent-to-Treat) 원칙 위배: 모든 무작위 배정된 대상자를 분석에 포함해야 함, 결측치 제거는 이 원칙을 위배하여 임상시험의 무작위화 이점을 손상시킴\n검정력 감소: 표본 크기 감소로 인한 통계적 검정력 저하, 따라서 중요한 치료 효과를 발견하지 못할 위험 증가.\n편향 발생: 결측 데이터가 무작위가 아닌 경우, 남은 데이터가 전체 모집단을 대표하지 못할 수 있으며 따라서 치료 효과 추정치의 왜곡 가능성이 증가.\n\n\n\n\n\n\n\nNote\n\n\n\nComplete Case Analysis(완전 사례 분석) 는 SAS 에서 가장 간단하게 사용할 수 있는 결측치 처리 방법입니다. FDA 에서 요구하는 기본적인 분석 방법으로 PROC 문에서 NOMISS 옵션을 사용해 사용 가능합니다. 결측치가 있는 관측치를 모두 제외하고 분석하는 것이며 단점으로는 데이터 손실로 인한 검정력 감소와 편향 가능성이 증가합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#결측치의-분류",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#결측치의-분류",
    "title": "임상 통계학",
    "section": "11.2 결측치의 분류",
    "text": "11.2 결측치의 분류\n결측치의 유형을 정확히 파악하는 것은 어렵지만, 적절한 처리 방법을 선택하는 데 중요합니다. 결측치는 발생 메커니즘에 따라 3 가지로 분류됩니다:\n\nMCAR (Missing Completely At Random): 결측 발생이 완전히 무작위적이며 구별하기 쉽지만 실제 발생 비율은 매우 낮음. 예: 실험실 샘플의 우발적인 파손\nMAR (Missing At Random): 결측 발생이 관찰된 다른 변수와 관련되어 있지만, 결측된 변수 자체의 값과는 무관. 예: 특정 연령대에서 설문 응답률이 낮은 경우\nMNAR (Missing Not At Random): 결측 발생이 결측된 변수의 값 자체와 관련, 대부분의 임상시험 결측치가 이 범주에 해당. 예: 부작용으로 인한 중도 탈락\n\n\nMCAR 의 경우 완전 사례 분석을 통해 결측치를 제외하여도 편향되지 않을 수 있지만, MAR 과 MNAR 의 경우 더 복잡한 방법 (예: 다중대체법, 혼합모형 등) 이 필요할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#결측치-처리방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#결측치-처리방법",
    "title": "임상 통계학",
    "section": "11.3 결측치 처리방법",
    "text": "11.3 결측치 처리방법\n\nLOCF (Last Observation Carried Forward): 마지막 관찰값을 이후 결측치에 대입\nBOCF (Baseline Observation Carried Forward): 기준선 관찰값을 결측치에 대입\nUnconditional and Conditional Mean Imputation:\n\nUnconditional: 전체 평균으로 대체\nConditional: 특정 조건 하의 평균으로 대체\n\nBest or Worst Case Imputation: 최선 또는 최악의 시나리오 값으로 대체\nRegression Method: 회귀 모델을 사용하여 결측치 예측\nHot-deck Imputation: 유사한 특성을 가진 다른 관측치의 값으로 대체\nSingle Imputation: 단일 값으로 모든 결측치 대체"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#marmissing-at-random-의-결측치-처리",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#marmissing-at-random-의-결측치-처리",
    "title": "임상 통계학",
    "section": "11.4 MAR(Missing At Random) 의 결측치 처리",
    "text": "11.4 MAR(Missing At Random) 의 결측치 처리\n\nMultiple Imputation: 여러 번의 대체를 통해 불확실성 반영\nImputation 하지 않는 방법: 혼합 모형 또는 가중 GEE 등 사용\n\nMAR 은 결측치가 무작위로 발생하지만, 결측 여부가 다른 관측된 변수와 관련이 있는 경우를 말합니다. MAR 상황에서는 다음과 같은 결측치 처리 방법을 고려할 수 있습니다:\n\n다중 대체법 (Multiple Imputation)\n\nMAR 가정 하에서 가장 널리 사용되는 방법입니다.\n결측치의 불확실성을 고려하여 여러 번 대체를 수행합니다.\n3 단계로 진행됩니다:\n\nImputation step: 자료의 분포를 토대로 결측치를 대체\nAnalysis step: 대체된 데이터셋을 분석\nPooling step: 여러 분석 결과를 종합\n\n\n최대 우도법 (Maximum Likelihood Estimation)\n\n관측된 데이터를 기반으로 결측 데이터의 분포를 추정합니다.\nEM 알고리즘 등을 사용하여 모수를 추정할 수 있습니다.\n\n가중치 기반 방법 (Weighted Estimation)\n\n결측 확률의 역수를 가중치로 사용하여 편향을 보정합니다.\n\n핫덱 대체법 (Hot-deck Imputation)\n\n유사한 특성을 가진 다른 관측치의 값으로 결측치를 대체합니다.\n\n회귀 대체법 (Regression Imputation)\n\n다른 변수들을 사용하여 결측값을 예측하는 회귀 모델을 구축합니다.\n\nK-NN 알고리즘\n\n가장 유사한 특성을 가진 k 개의 이웃 데이터를 기반으로 결측치를 추정합니다.\n\n\nMAR 상황에서는 단순한 삭제나 평균 대체 등의 방법보다 위의 방법들이 더 적절할 수 있습니다. 특히 다중 대체법은 MAR 가정 하에서 편향을 줄이고 불확실성을 고려할 수 있어 널리 사용됩니다. 결측치 처리 방법 선택 시에는 데이터의 특성, 결측 메커니즘, 분석 목적 등을 종합적으로 고려해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#mnar-missing-not-at-random-의-결측치-처리",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#mnar-missing-not-at-random-의-결측치-처리",
    "title": "임상 통계학",
    "section": "11.5 MNAR (Missing Not At Random) 의 결측치 처리",
    "text": "11.5 MNAR (Missing Not At Random) 의 결측치 처리\nMNAR(Missing Not At Random) 상황에서의 결측치 처리는 매우 복잡하고 어려운 문제입니다. MNAR 의 경우 결측 메커니즘이 관찰되지 않은 데이터와 관련이 있어, 단순한 대체 방법으로는 편향된 결과를 초래할 수 있습니다. MNAR 상황에서 고려할 수 있는 결측치 처리 방법은 다음과 같습니다:\n\n패턴 혼합 모델 (Pattern Mixture Models)\n\n결측 패턴에 따라 데이터를 그룹화하고, 각 그룹에 대해 별도의 모델을 적용합니다.\n결측 메커니즘을 명시적으로 모델링할 수 있습니다.\n\n선택 모델 (Selection Models)\n\n결측 확률과 관심 변수 간의 관계를 모델링합니다.\n결측 메커니즘에 대한 가정을 명시적으로 포함합니다.\n\n공유 파라미터 모델 (Shared Parameter Models)\n\n결측 과정과 관심 변수를 동시에 모델링합니다.\n두 과정 사이의 의존성을 포착할 수 있습니다.\n\n민감도 분석 (Sensitivity Analysis)\n\n다양한 가정 하에서 여러 분석을 수행하여 결과의 안정성을 평가합니다.\nMNAR 상황에서 특히 중요한 접근 방법입니다.\n\n다중 대체법의 변형 (Modified Multiple Imputation)\n\n표준 다중 대체법을 수정하여 MNAR 메커니즘을 고려합니다.\n대체 모델에 추가적인 파라미터를 포함시킬 수 있습니다.\n\n보조 변수 활용 (Auxiliary Variables)\n\n결측 메커니즘과 관련된 추가 변수를 모델에 포함시켜 MAR 가정에 더 가깝게 만듭니다.\n\n\nMNAR 상황에서는 단일 방법으로 완벽한 해결책을 제공하기 어렵습니다. 따라서 여러 방법을 조합하고, 결과의 안정성을 평가하는 것이 중요합니다. 또한, 도메인 전문가와의 협력을 통해 결측 메커니즘에 대한 이해를 깊이 있게 하는 것이 필수적입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#결측치-처리의-최선책",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#결측치-처리의-최선책",
    "title": "임상 통계학",
    "section": "11.6 결측치 처리의 최선책",
    "text": "11.6 결측치 처리의 최선책\n\n결측치 발생 최소화: 연구 설계 및 수행 단계에서 예방\n결측치 처리 방법을 계획서에 명기: 사전에 방법 결정 및 문서화\n민감도 분석 수행: 여러 방법으로 분석하여 결과의 견고성 확인\n결측치 발생 이유 보고: 결측 패턴 및 원인에 대한 상세한 보고"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#신뢰구간을-사용해-생동성-입증",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#신뢰구간을-사용해-생동성-입증",
    "title": "임상 통계학",
    "section": "12.1 신뢰구간을 사용해 생동성 입증",
    "text": "12.1 신뢰구간을 사용해 생동성 입증\n생물학적 동등성을 입증하기 위해 주로 TOST(Two One-Sided Test procedure) 를 사용합니다. TOST 는 두 제제의 생체이용률이 통계적으로 동등함을 입증하는 데 특화된 방법으로 명확한 기준 제시합니다 (일반적으로 80-125% 범위의 신뢰구간을 사용하여 동등성 여부를 판단할 수 있어, 결과 해석이 명확). TOST 방법에 대해서 간략히 설명하면 아래와 같습니다.\n\n두 제제의 약동학적 파라미터 (예: AUC, Cmax) 의 비율에 대한 90% 신뢰구간을 계산합니다.\n일반적으로 이 신뢰구간이 80-125% 범위 내에 들어가면 생물학적 동등성이 입증된 것으로 간주합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#생동성시험에서-이상-발생-사유",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#생동성시험에서-이상-발생-사유",
    "title": "임상 통계학",
    "section": "12.2 생동성시험에서 이상 발생 사유",
    "text": "12.2 생동성시험에서 이상 발생 사유\n\n생산과정의 문제\n\n제조 공정의 차이\n원료 약물의 품질 차이\n제형 설계의 문제\n\n환자 집단에 대한 세부적인 교호작용 존재\n\n특정 환자 그룹에서 약물 흡수나 대사의 차이\n유전적 다형성에 의한 약물 반응의 차이\n식이나 다른 약물과의 상호작용"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#동등성-시험이란",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#동등성-시험이란",
    "title": "임상 통계학",
    "section": "13.1 동등성 시험이란?",
    "text": "13.1 동등성 시험이란?\n동등성 시험은 바이오시밀러가 오리지널 의약품과 임상적으로 의미 있는 차이가 없음을 증명하는 과정입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#동등성-마진의-결정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#동등성-마진의-결정",
    "title": "임상 통계학",
    "section": "13.2 동등성 마진의 결정",
    "text": "13.2 동등성 마진의 결정\n동등성 마진은 1 차 유효성 평가변수에서 바이오시밀러와 오리지널 의약품 간 허용 가능한 차이의 범위를 나타냅니다. 이 마진 내의 차이는 임상적으로 의미 있지 않다고 간주됩니다. 동등성 마진 결정에 대한 구체적인 기준은 약전에 명확하게 명시되어 있지 않습니다. 그러나:\n\nFDA 는 과거 임상 결과를 바탕으로 일반적으로 12% 의 마진을 요구합니다.\n마진 설정은 해당 약물의 특성, 적응증, 과거 임상 데이터 등을 종합적으로 고려하여 결정됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#adaptive-design-의-문제점",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#adaptive-design-의-문제점",
    "title": "임상 통계학",
    "section": "14.1 Adaptive design 의 문제점",
    "text": "14.1 Adaptive design 의 문제점\n\n편향발생: 중간 결과에 따른 설계 변경이 연구 결과에 영향을 미칠 수 있습니다.\n다중검정: 반복적인 분석으로 인해 제 1 종 오류가 증가할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#adaptive-design-의-성공조건",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#adaptive-design-의-성공조건",
    "title": "임상 통계학",
    "section": "14.2 Adaptive design 의 성공조건",
    "text": "14.2 Adaptive design 의 성공조건\n\n무작위배정 코드를 엄격하게 관리: 배정 정보의 기밀성을 유지합니다.\n자료관리 수준을 높인다: 데이터의 품질과 신뢰성을 확보합니다.\n독립적 자료모니터 위원회를 통해 운영한다: 객관성과 투명성을 보장합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#독립적-자료-모니터링-위원회",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#독립적-자료-모니터링-위원회",
    "title": "임상 통계학",
    "section": "15.1 독립적 자료 모니터링 위원회",
    "text": "15.1 독립적 자료 모니터링 위원회\n독립적 자료 모니터링 위원회 (Independent Data Monitoring Committee, IDMC) 설립을 통해 임상시험의 객관성과 안전성을 높일 수 있으며, 이는 임상시험 결과의 신뢰도 향상에 기여합니다. 설립 절차는 아래와 같습니다.\n\n헌장 작성:\n\nIDMC 의 설립 목적, 역할, 책임을 명확히 정의한 헌장을 작성합니다.\n대상 임상시험을 구체적으로 명시합니다.\n위원회의 구성, 운영 방식, 의사결정 과정 등을 상세히 기술합니다.\n\n위원 선정:\n\n임상시험과 이해관계가 없는 독립적인 전문가들로 구성합니다.\n통계학자, 임상의, 윤리 전문가 등 다양한 분야의 전문가를 포함시킵니다.\n\n운영 절차 수립:\n\n회의 주기, 데이터 검토 방법, 보고 체계 등을 명확히 정립합니다.\n비밀 유지 및 이해상충 관리 방안을 마련합니다.\n\n스폰서와의 관계 정립:\n\nIDMC 의 독립성을 보장하기 위한 스폰서와의 관계를 명확히 합니다.\n데이터 접근 권한, 의사결정의 자율성 등을 보장받습니다.\n\n규제 기관 승인:\n\n필요한 경우, 규제 기관의 승인을 받습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#동시-대조군이란",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#동시-대조군이란",
    "title": "임상 통계학",
    "section": "16.1 동시 대조군이란?",
    "text": "16.1 동시 대조군이란?\n동시 대조군은 같은 임상시험 내에서 시험약과 대조약을 각각 다른 그룹에 동시에 투여하는 방식을 말합니다.동시 대조군은 임상시험의 신뢰성과 타당성을 높이는 데 중요한 역할을 합니다.\n주요 특징: - 시간적 일치: 시험약 그룹과 대조군 그룹이 동일한 시간대에 임상시험에 참여합니다. - 환경적 동질성: 두 그룹이 동일한 임상 환경에서 시험을 받습니다. - 무작위 배정: 참가자들을 무작위로 시험약 그룹과 대조군 그룹에 배정합니다.\n장점: - 시간에 따른 변화 요인을 통제할 수 있습니다. - 두 그룹 간의 직접적인 비교가 가능합니다. - 편향을 최소화할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#대조군의-목적과-필요성",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#대조군의-목적과-필요성",
    "title": "임상 통계학",
    "section": "16.2 대조군의 목적과 필요성",
    "text": "16.2 대조군의 목적과 필요성\n대조군은 시험약에 의해 피험자에게 생긴 결과와 다른 요소에 의한 결과를 구별하기 위해 필요합니다. 주요 목적은 다음과 같습니다:\n\n시험약의 실제 효과 평가: 대조군을 통해 시험약의 순수한 효과를 분리하여 평가할 수 있습니다.\n편향 감소: 대조군 설정은 다양한 편향을 줄이는 데 도움이 됩니다.\n자연치유 효과 구분: 일부 질병은 시간이 지나면 자연적으로 호전될 수 있습니다. 대조군을 통해 이러한 자연치유 효과와 시험약의 효과를 구분할 수 있습니다.\n위약효과 고려: 위약효과 (placebo effect) 는 실제 약물 효과가 아닌 심리적 요인에 의한 증상 개선을 말합니다. 대조군을 사용함으로써 이러한 위약효과와 실제 약물 효과를 구분할 수 있습니다.\n외부 요인의 영향 평가: 임상시험 기간 동안 발생할 수 있는 환경적 변화나 기타 외부 요인의 영향을 평가할 수 있습니다.\n통계적 비교 가능: 대조군은 시험약 그룹과의 통계적 비교를 가능하게 하여, 결과의 유의성을 평가할 수 있게 합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#대조군-선택의-고려사항",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#대조군-선택의-고려사항",
    "title": "임상 통계학",
    "section": "16.3 대조군 선택의 고려사항",
    "text": "16.3 대조군 선택의 고려사항\n임상시험에서 대조군을 선택할 때는 다음 세 가지 주요 사항을 고려해야 합니다:\n\n현재 표준치료법이 있는지 여부:\n\n표준치료법이 있는 경우: 일반적으로 이를 대조군으로 사용합니다.\n표준치료법이 없는 경우: 위약 대조군이나 무처치 대조군을 고려할 수 있습니다.\n중요성: 현재의 의료 표준을 반영하여 새로운 치료법의 상대적 효과를 평가할 수 있습니다.\n\n특정 대조군 선택에 대한 적절성:\n\n연구 목적과의 부합성: 선택된 대조군이 연구 질문에 적절히 답할 수 있어야 합니다.\n통계적 고려: 대조군은 시험약과의 유의미한 비교를 가능하게 해야 합니다.\n실행 가능성: 선택된 대조군이 실제 임상 환경에서 구현 가능해야 합니다.\n중요성: 적절한 대조군 선택은 연구 결과의 신뢰성과 해석 가능성을 높입니다.\n\n윤리적 적절성:\n\n위약 사용의 윤리성: 심각한 질병에서 위약 사용이 윤리적으로 적절한지 검토해야 합니다.\n최선의 이용 가능한 치료: 대조군 참가자들에게도 최선의 치료가 제공되어야 합니다.\n위험 - 이익 균형: 대조군 참가자들에게 과도한 위험이 가해지지 않아야 합니다.\n중요성: 윤리적 고려는 참가자의 안전과 권리를 보호하고, 연구의 사회적 수용성을 확보합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#대조군선택이-영향을-주는-8-가지",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#대조군선택이-영향을-주는-8-가지",
    "title": "임상 통계학",
    "section": "16.4 대조군선택이 영향을 주는 8 가지",
    "text": "16.4 대조군선택이 영향을 주는 8 가지\n\n임상결과 해석: 대조군의 특성에 따라 시험약의 효과를 해석하는 방식이 달라집니다. 예를 들어, 위약 대조군과 비교하면 절대적 효과를, 활성 대조군과 비교하면 상대적 효과를 평가할 수 있습니다.\n임상의 윤리성: 특히 중증 질환에서 표준치료가 있는 경우, 위약 대조군 사용은 윤리적 문제를 야기할 수 있습니다. 환자의 안전과 복지를 고려한 대조군 선택이 필요합니다.\n분석의 편향 여부: 적절한 대조군 선택은 연구 결과의 편향을 최소화하는 데 중요합니다. 예를 들어, 역사적 대조군 사용은 시간에 따른 변화로 인한 편향을 초래할 수 있습니다.\n환자 종류와 모집의 속도: 대조군의 유형에 따라 참여 가능한 환자군이 달라지며, 이는 환자 모집 속도에 영향을 줍니다. 예를 들어, 위약 대조군 사용은 일부 환자의 참여를 제한할 수 있습니다.\n연구할 평가 변수의 종류: 대조군 선택은 평가할 수 있는 변수의 범위에 영향을 줍니다. 활성 대조군을 사용하면 안전성 프로필 비교가 가능하지만, 위약 대조군에서는 이러한 비교가 제한적일 수 있습니다.\n임상 결과의 신뢰성: 적절한 대조군 선택은 연구 결과의 신뢰성을 높입니다. 예를 들어, 무작위 배정된 동시 대조군은 역사적 대조군보다 더 신뢰할 수 있는 결과를 제공합니다.\n시판허가의 여부: 규제 기관의 요구사항에 부합하는 대조군 선택은 시판 허가 획득에 중요합니다. 일부 상황에서는 특정 유형의 대조군 사용이 필수적일 수 있습니다.\n잘못된 결론: 부적절한 대조군 선택은 잘못된 결론으로 이어질 수 있습니다. 예를 들어, 활성 대조군의 효과가 일관되지 않은 경우, 비열등성 시험 결과의 해석이 어려워질 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#위약-동시-대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#위약-동시-대조군",
    "title": "임상 통계학",
    "section": "17.1 위약 동시 대조군",
    "text": "17.1 위약 동시 대조군\n위약 동시 대조군은 임상시험에서 시험약의 효과를 객관적으로 평가하기 위해 사용되는 중요한 대조군으로 치료 효과가 없는 위약 (시험약과 물리적으로 동일하지만 유효성분이 없는 약물) 을 투여하는 환자군입니다. 시험약 그룹과 위약 그룹이 같은 임상시험 기간 동안 동시에 평가되며 참가자들은 무작위로 시험약 그룹 또는 위약 그룹에 배정됩니다. 또한 이중맹검 (참가자와 연구자 모두 누가 위약을 받는지 모르는 상태) 으로 진행됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#무처치-no-treatment-동시-대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#무처치-no-treatment-동시-대조군",
    "title": "임상 통계학",
    "section": "17.2 무처치 (no-treatment) 동시 대조군",
    "text": "17.2 무처치 (no-treatment) 동시 대조군\n\n어떠한 치료도 받지 않는 대조군으로 자연 경과를 관찰하는 데 유용합니다. 다만 윤리적 문제로 사용이 제한될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#용량반응-동시대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#용량반응-동시대조군",
    "title": "임상 통계학",
    "section": "17.3 용량반응 동시대조군",
    "text": "17.3 용량반응 동시대조군\n\n피험자들이 다양한 용량에 무작위 배정됨\n약물의 최적 용량을 찾는 데 도움\n용량 - 반응 관계를 평가할 수 있음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#활성동시대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#활성동시대조군",
    "title": "임상 통계학",
    "section": "17.4 활성동시대조군",
    "text": "17.4 활성동시대조군\n\n이미 효과가 입증된 표준 치료를 받는 대조군\n새로운 치료법의 상대적 효과를 평가\n윤리적 문제를 최소화할 수 있음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#외부-대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#외부-대조군",
    "title": "임상 통계학",
    "section": "17.5 외부 대조군",
    "text": "17.5 외부 대조군\n\n현재 진행 중인 임상시험 외부의 대조군\n과거 데이터나 다른 연구의 대조군 사용\n비용 효율적이지만 편향 위험이 높음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#다중-대조군",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#다중-대조군",
    "title": "임상 통계학",
    "section": "17.6 다중 대조군",
    "text": "17.6 다중 대조군\n\n여러 유형의 대조군을 동시에 사용\n다양한 관점에서 치료 효과를 평가\n복잡하지만 포괄적인 결과를 얻을 수 있음"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#시간의-경과에-따른-질병의-변화",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#시간의-경과에-따른-질병의-변화",
    "title": "임상 통계학",
    "section": "18.1 시간의 경과에 따른 질병의 변화",
    "text": "18.1 시간의 경과에 따른 질병의 변화\n발생할 수 있는 편향: 시간이 지남에 따라 자연적으로 발생하는 질병의 변화가 중재 효과로 오인될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#평균으로의-회귀",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#평균으로의-회귀",
    "title": "임상 통계학",
    "section": "18.2 평균으로의 회귀",
    "text": "18.2 평균으로의 회귀\n발생할 수 있는 편향: 극단적인 측정값이 후속 측정에서 평균으로 회귀하는 현상으로, 이를 중재 효과로 잘못 해석할 수 있습니다.\n여러 편향이 시험군과 위약군에 모두 같은 양으로 발생 –&gt; 군간 비교만 편향을 제외한 효과를 추정할 수 있는 방법\n이는 대조군을 포함한 연구 설계의 중요성을 강조합니다. 대조군이 있으면 이러한 편향들이 양 군에 동일하게 작용하므로, 군간 비교를 통해 실제 중재 효과를 더 정확히 추정할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#항암제-임상-시험에서-단일군-전후-비교-디자인",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#항암제-임상-시험에서-단일군-전후-비교-디자인",
    "title": "임상 통계학",
    "section": "18.3 항암제 임상 시험에서 단일군 전후 비교 디자인",
    "text": "18.3 항암제 임상 시험에서 단일군 전후 비교 디자인\n항암제 개발의 초기 단계에서는 윤리적 문제나 실행 가능성 때문에 단일군 전후 비교가 사용될 수 있습니다. 그러나 이는 예비적인 결과로 간주되며, 후속 연구에서는 보다 엄격한 연구 설계가 필요합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#가교시험",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#가교시험",
    "title": "임상 통계학",
    "section": "19.1 가교시험",
    "text": "19.1 가교시험\n가교시험은 다른 지역에서 이미 시판허가를 받은 신약을 새로운 지역에 도입할 때 수행하는 소규모 임상시험입니다. 주요 목적은 다음과 같습니다:\n\n새로운 지역의 인구집단에 대한 약물의 안전성과 유효성 확인\n기존 임상 데이터의 외삽 가능성 평가\n지역 특이적 요인 (유전적, 환경적, 문화적 차이 등) 의 영향 평가"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#다지역-임상시험의-장점과-단점",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#다지역-임상시험의-장점과-단점",
    "title": "임상 통계학",
    "section": "19.2 다지역 임상시험의 장점과 단점",
    "text": "19.2 다지역 임상시험의 장점과 단점\n장점: 1. 시간 단축: 여러 지역에서 동시에 진행되어 전체 개발 기간 단축 2. 비용 효율성: 한 번의 대규모 시험으로 여러 지역의 승인 가능 3. 다양한 인구집단 포함: 결과의 일반화 가능성 증가\n단점: 1. 복잡한 관리: 여러 국가의 규제 요구사항 충족 필요 2. 지역 간 차이로 인한 해석의 어려움 3. 높은 초기 비용"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#다지역-임상시험에서-발생하는-통계적-이슈",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#다지역-임상시험에서-발생하는-통계적-이슈",
    "title": "임상 통계학",
    "section": "19.3 다지역 임상시험에서 발생하는 통계적 이슈",
    "text": "19.3 다지역 임상시험에서 발생하는 통계적 이슈\n\n지역 간 이질성: 치료 효과의 일관성 평가 필요\n표본 크기 산정: 전체 및 지역별 적절한 표본 크기 결정\n하위그룹 분석: 지역별 효과 차이 분석\n통계적 방법론 선택: 지역 간 차이를 고려한 적절한 분석 방법 선택"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#효과가-각-지역에서-일정한지-확인하는-통계",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#효과가-각-지역에서-일정한지-확인하는-통계",
    "title": "임상 통계학",
    "section": "19.4 효과가 각 지역에서 일정한지 확인하는 통계",
    "text": "19.4 효과가 각 지역에서 일정한지 확인하는 통계\n\n기술통계: 각 지역별 효과 크기, 표준편차 등 기본적인 통계량을 제공합니다.\nForest plot: 각 지역의 효과 크기와 신뢰구간을 시각적으로 표현하여 지역 간 차이를 쉽게 파악할 수 있게 합니다.\n공변량 보정을 포함하는 모형에 기반한 추정: 지역 외 다른 요인들의 영향을 고려하여 더 정확한 지역별 효과를 추정합니다.\n치료제와 지역간의 교호작용 검정: 치료 효과가 지역에 따라 유의미하게 다른지 통계적으로 검증합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#각-지역에-피험자-할당-방법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#각-지역에-피험자-할당-방법",
    "title": "임상 통계학",
    "section": "19.5 각 지역에 피험자 할당 방법",
    "text": "19.5 각 지역에 피험자 할당 방법\n\n비례할당: 각 지역의 인구 비율에 따라 피험자를 할당합니다. 대표성을 확보할 수 있습니다.\n균등할당: 모든 지역에 동일한 수의 피험자를 할당합니다. 지역 간 비교가 용이합니다.\n시험약 효과의 일부 보존: 전체 효과의 일정 비율을 각 지역에서 입증할 수 있도록 할당합니다.\n지역유의성: 각 지역에서 독립적으로 통계적 유의성을 확보할 수 있도록 할당합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#증거의-수준",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#증거의-수준",
    "title": "임상 통계학",
    "section": "20.1 증거의 수준",
    "text": "20.1 증거의 수준\n시험약 효과에 대한 신뢰구간은 치료 효과의 불확실성을 나타내는 중요한 지표입니다. 희귀질환의 경우, 환자 수가 적어 넓은 신뢰구간이 허용될 수 있으나, 임상적 의미를 신중히 해석해야 합니다.\n희귀질환 임상시험에서의 주요 고려사항에 대해 설명하겠습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#약리적-고려",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#약리적-고려",
    "title": "임상 통계학",
    "section": "20.2 약리적 고려",
    "text": "20.2 약리적 고려\n희귀질환 치료제 개발에서는 질병의 특성과 약물의 작용 기전을 세밀히 고려해야 합니다. 희귀질환의 병태생리학적 특성을 반영한 맞춤형 약리 연구가 필요하며, 약물 상호작용과 부작용에 대한 면밀한 관찰이 중요합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#평가변수의-선택",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#평가변수의-선택",
    "title": "임상 통계학",
    "section": "20.3 평가변수의 선택",
    "text": "20.3 평가변수의 선택\n희귀질환의 특성을 반영하는 적절한 평가변수 선택이 중요합니다. 질병 특이적 바이오마커나 환자 보고 결과 (PRO) 를 활용할 수 있습니다. 또한, 대리 평가변수 (surrogate endpoint) 를 사용하여 시험 기간을 단축하고 효율성을 높일 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#대조군의-선택",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#대조군의-선택",
    "title": "임상 통계학",
    "section": "20.4 대조군의 선택",
    "text": "20.4 대조군의 선택\n희귀질환의 특성상 위약 대조군 설정이 윤리적 문제를 야기할 수 있습니다. 따라서 표준 치료군이나 역사적 대조군 사용을 고려할 수 있습니다. 경우에 따라 환자 자신을 대조군으로 사용하는 N-of-1 시험 설계도 가능합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#방법론-및-통계학적-고려사항",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#방법론-및-통계학적-고려사항",
    "title": "임상 통계학",
    "section": "20.5 방법론 및 통계학적 고려사항",
    "text": "20.5 방법론 및 통계학적 고려사항\n\n유연한 유의수준 적용: 전통적인 0.05 유의수준 대신 더 유연한 기준을 적용할 수 있습니다. FDA 에서는 희귀질환 임상시험에서 p-value 0.05 이상도 고려할 수 있다고 언급하고 있습니다.\n적응적 임상시험 설계: 중간 분석 결과에 따라 시험 설계를 조정하는 적응적 설계를 통해 효율성을 높일 수 있습니다. 이는 FDA 에서도 권장하는 방법입니다.\n베이지안 접근법: 사전 정보를 활용하여 적은 표본으로도 의미 있는 결론을 도출할 수 있는 베이지안 통계 방법을 고려할 수 있습니다. 특히 항암제 개발에서 이 방법론의 도입이 증가하고 있습니다.\n다중 평가변수 분석: 여러 평가변수를 종합적으로 분석하여 치료 효과를 평가하는 방법을 고려할 수 있습니다. 이는 희귀질환의 복잡한 특성을 반영하는 데 도움이 될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#용어-정리",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#용어-정리",
    "title": "임상 통계학",
    "section": "21.1 용어 정리",
    "text": "21.1 용어 정리\n\n이상반응: 시험약과의 연관성을 반드시 규명할 수 없거나, 피험자에 발생한 예상치 못한 의학적 발생을 말합니다. 이는 임상시험 중 관찰된 모든 바람직하지 않은 의학적 사건을 포함합니다.\n약물 이상반응: 의약품과 인과관계가 있다고 의심되는 유해하고 의도하지 않은 반응을 의미합니다. 이는 시험약과의 연관성이 있다고 판단되는 이상반응을 지칭합니다.\n예상하지 못한 약물이상반응: 의약품의 허가사항이나 임상시험계획서에 기술되지 않은 성질이나 중증도의 이상반응을 말합니다. 이는 새로운 안전성 정보로 간주될 수 있습니다.\n중대한 이상반응 또는 이상약물 반응: 사망, 생명을 위협하는 상황, 입원 또는 입원 기간 연장, 지속적인 장애나 기능 저하, 선천적 기형 등을 초래하는 반응을 의미합니다. 이는 즉각적인 보고와 평가가 필요한 중요한 안전성 정보입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#시험약의-안전성을-평가하는데-필요한-표본의-크기",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#시험약의-안전성을-평가하는데-필요한-표본의-크기",
    "title": "임상 통계학",
    "section": "21.2 시험약의 안전성을 평가하는데 필요한 표본의 크기",
    "text": "21.2 시험약의 안전성을 평가하는데 필요한 표본의 크기\n시험약의 안전성 평가를 위한 표본 크기 결정은 매우 중요한 과정으로 아래 두 가지 참고할 만한 규칙이 있습니다. 다만 이런 규칙은 임상시험 설계 시 필요한 최소 표본 크기에 도움을 주는 것이며 실제 임상시험에서는 더 많은 요인들을 고려하여 표본 크기를 결정해야 합니다.\n\nrule of 3: 이 규칙은 드문 이상반응을 탐지하는 데 유용합니다. 어떤 약물 이상반응의 실제 발생률이 n 명 중 한 명일 때, 3n 명의 환자를 관찰하면 적어도 95% 의 확률로 한 명 이상에서 해당 이상반응을 관찰할 수 있다는 것입니다. 이는 드문 이상반응의 발생 가능성을 추정하는 데 도움이 됩니다.26\n300 명 규칙: 300 명에게 시험약을 투여했을 때 특정 약물 이상반응이 관찰되지 않았다면, 95% 의 신뢰도로 해당 이상반응의 실제 발생률이 1% 미만이라고 말할 수 있습니다. 이는 상대적으로 흔하지 않은 이상반응의 발생률 상한을 추정하는 데 유용합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#개별-환자에서의-인과관계",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#개별-환자에서의-인과관계",
    "title": "임상 통계학",
    "section": "21.3 개별 환자에서의 인과관계",
    "text": "21.3 개별 환자에서의 인과관계\n개별 환자에서 약물 이상반응과 시험약 간의 인과관계를 평가할 때는 다음 조건들을 고려합니다. 이 조건들이 많이 만족될수록 인과관계의 가능성이 높아집니다:\n\n시간적 연관성: 약물 투여와 이상반응 발생 사이의 시간적 관계가 적절한지 평가합니다.\n용량관계: 약물 용량 증가에 따라 이상반응의 심각도나 빈도가 증가하는지 확인합니다.\n시험약 재투여 혹은 투여중지: 약물 중단 시 이상반응이 사라지거나, 재투여 시 다시 나타나는지 관찰합니다.\n생물학적 개연성: 약물의 작용 기전과 이상반응 발생 사이에 생물학적으로 설명 가능한 연관성이 있는지 검토합니다.\n특이성: 해당 이상반응이 특정 약물에 특징적인 것인지 평가합니다.\n일치성: 다른 연구나 보고에서도 유사한 이상반응이 관찰되었는지 확인합니다.\n설명 방법이 없는 경우: 다른 요인으로는 이상반응을 설명할 수 없는 경우, 약물과의 인과관계 가능성이 높아집니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#안전성-자료-평가법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#안전성-자료-평가법",
    "title": "임상 통계학",
    "section": "21.4 안전성 자료 평가법",
    "text": "21.4 안전성 자료 평가법\n안전성 자료 평가는 임상시험에서 수집된 안전성 정보를 체계적으로 분석하고 해석하는 과정입니다. 주요 평가 방법은 다음과 같습니다:\n\n빈도 분석 : 이상반응의 발생 빈도를 계산하고 비교합니다. 치료군과 대조군 간의 이상반응 발생률 차이를 통계적으로 분석합니다.\n중증도 평가 : 이상반응의 중증도를 등급화하여 분석합니다. 일반적으로 CTCAE(Common Terminology Criteria for Adverse Events) 기준을 사용합니다.\n시간 - 사건 분석 : Kaplan-Meier 곡선이나 Cox 비례위험모형을 이용하여 이상반응 발생까지의 시간을 분석합니다.\n인과관계 평가 : 개별 이상반응과 시험약 간의 인과관계를 평가합니다. 앞서 언급한 7 가지 기준 (시간적 연관성, 용량관계 등) 을 고려합니다.\n하위그룹 분석 : 연령, 성별, 기저질환 등 환자 특성에 따른 안전성 프로파일 차이를 분석합니다.\n누적 분석 : 장기 안전성을 평가하기 위해 이상반응의 누적 발생률을 분석합니다.\n비교 위험도 분석 : 상대위험도 (Relative Risk) 나 오즈비 (Odds Ratio) 를 계산하여 치료군과 대조군의 위험을 비교합니다.\n신호 탐지 : 예상치 못한 이상반응 패턴을 식별하기 위해 데이터 마이닝 기법을 사용할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상에서-통계",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상에서-통계",
    "title": "임상 통계학",
    "section": "22.1 임상에서 통계",
    "text": "22.1 임상에서 통계\n\n전수조사와 표본 조사: 전수조사는 모든 대상을 조사하는 방법이지만 현실적으로 어려워 일부만 조사하는 표본 조사를 주로 사용합니다.\n추정:\n\n점추정: 단일 값으로 모수를 추정합니다.\n구간추정 (신뢰구간): 모수가 속할 것으로 예상되는 구간을 제시합니다.\n\n가설검정: 귀무가설의 기각 여부를 통계적으로 판단합니다.\n제 1 종 오류, 2 종 오류, 검정력:\n\n제 1 종 오류: 귀무가설이 참일 때 이를 기각할 확률\n제 2 종 오류: 대립가설이 참일 때 귀무가설을 기각하지 못할 확률\n검정력: 1 - 제 2 종 오류 확률"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#어떤-통계검정방법이-가장-좋은-방법인가",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#어떤-통계검정방법이-가장-좋은-방법인가",
    "title": "임상 통계학",
    "section": "22.2 어떤 통계검정방법이 가장 좋은 방법인가?",
    "text": "22.2 어떤 통계검정방법이 가장 좋은 방법인가?\n제 1 종 오류를 5% 이하로 유지하면서 검정력을 최대화하는 방법이 가장 좋은 방법으로 간주됩니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#양측-검정과-단측검정",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#양측-검정과-단측검정",
    "title": "임상 통계학",
    "section": "22.3 양측 검정과 단측검정",
    "text": "22.3 양측 검정과 단측검정\n\n양측검정: 효과의 방향성을 모를 때 사용합니다.\n단측검정: 효과의 방향성을 예측할 수 있을 때 사용합니다. 예를 들어, 시험약이 위약보다 우월한 경우를 검정할 때 사용합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#통계적-유의성과-임상정-유의성",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#통계적-유의성과-임상정-유의성",
    "title": "임상 통계학",
    "section": "22.4 통계적 유의성과 임상정 유의성",
    "text": "22.4 통계적 유의성과 임상정 유의성\n\n통계적 유의성만 있는 경우: 효과가 작아도 표본 크기가 큰 경우 발생할 수 있습니다.\n임상적 유의성만 있는 경우: 효과가 크더라도 통계적으로 유의하지 않을 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#임상결과해석에-신뢰구간이-더-중요한-이유",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#임상결과해석에-신뢰구간이-더-중요한-이유",
    "title": "임상 통계학",
    "section": "22.5 임상결과해석에 신뢰구간이 더 중요한 이유",
    "text": "22.5 임상결과해석에 신뢰구간이 더 중요한 이유\n신뢰구간은 통계적 유의성과 임상적 유의성을 동시에 평가할 수 있어 가설검정보다 더 많은 정보를 제공합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#표준편차와-표준오차의-차이",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#표준편차와-표준오차의-차이",
    "title": "임상 통계학",
    "section": "22.6 표준편차와 표준오차의 차이",
    "text": "22.6 표준편차와 표준오차의 차이\n\n표준편차: 자료의 퍼짐 정도를 나타내는 지표입니다.\n표준오차: 추정량의 정확도를 나타내는 지표로, 여러 공식이 존재할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#실험계획법",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#실험계획법",
    "title": "임상 통계학",
    "section": "22.7 실험계획법",
    "text": "22.7 실험계획법\n\n무작위 배정: 편향을 줄이기 위해 사용합니다.\n반복: 정확도를 높이기 위해 사용합니다.\n블록화: 외부 요인의 영향을 통제하기 위해 사용합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#two-sample-t-test",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#two-sample-t-test",
    "title": "임상 통계학",
    "section": "22.8 Two-sample t-test",
    "text": "22.8 Two-sample t-test\n두 독립적인 집단의 평균을 비교하는 방법입니다. 이 검정은 두 집단이 서로 독립적이며, 각 집단의 데이터가 정규분포를 따른다고 가정합니다. 검정 통계량은 두 집단의 평균 차이를 표준오차로 나눈 값으로 계산됩니다.27 예시: 새로운 혈압 강하제의 효과를 평가하기 위해, 치료군과 대조군의 혈압 감소 정도를 비교합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#paired-t-test",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#paired-t-test",
    "title": "임상 통계학",
    "section": "22.9 Paired t-test",
    "text": "22.9 Paired t-test\n동일한 대상의 전후 비교 등에 사용되는 방법입니다. 이 검정은 각 개체에 대해 두 번의 측정이 이루어질 때 사용됩니다. 예를 들어, 치료 전후의 효과를 비교할 때 유용합니다. 두 측정값의 차이가 정규분포를 따른다고 가정합니다.28 예시: 동일한 환자 그룹에서 특정 약물 복용 전후의 콜레스테롤 수치 변화를 비교합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#one-way-anova",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#one-way-anova",
    "title": "임상 통계학",
    "section": "22.10 One-way ANOVA",
    "text": "22.10 One-way ANOVA\n세 개 이상의 집단을 비교할 때 사용하는 방법으로, 사후 검정 방법에는 Scheffe, Tukey-Kramer, Dunnett’s 방법 등이 있습니다. 이 방법은 분산분석 (ANOVA) 의 한 형태로, 여러 집단 간의 평균 차이를 동시에 비교할 수 있습니다.29 예시: 세 가지 다른 용량 (저용량, 중간용량, 고용량) 의 약물 효과를 비교하여 최적의 용량을 결정합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#공분산-분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#공분산-분석",
    "title": "임상 통계학",
    "section": "22.11 공분산 분석",
    "text": "22.11 공분산 분석\n공변량의 영향을 보정하여 집단 간 차이를 분석하는 방법입니다. 이 방법은 실험 처리 효과와 함께 연속형 변수 (공변량) 의 영향을 동시에 고려할 수 있어, 더 정확한 처리 효과 추정이 가능합니다. 예시: 새로운 당뇨병 치료제의 효과를 평가할 때, 환자의 나이와 체중을 공변량으로 고려하여 분석합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#랜덤화-블록-설계",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#랜덤화-블록-설계",
    "title": "임상 통계학",
    "section": "22.12 랜덤화 블록 설계",
    "text": "22.12 랜덤화 블록 설계\n임상 시험의 효율을 높이기 위해 사용되는 실험 설계 방법입니다. 이 방법은 알려진 변동 요인을 블록으로 구분하여 처리하므로, 처리 효과를 더 정확히 추정할 수 있습니다. 예시: 항암제 임상시험에서 환자의 암 병기를 블록으로 사용하여 각 병기 내에서 치료군과 대조군에 균등하게 배정합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#회귀분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#회귀분석",
    "title": "임상 통계학",
    "section": "22.13 회귀분석",
    "text": "22.13 회귀분석\n변수 간의 관계를 모델링하는 방법입니다. 독립변수와 종속변수 간의 관계를 수학적 모델로 표현하여, 변수 간의 관계를 이해하고 예측에 활용할 수 있습니다. 예시: 환자의 나이, 체중, 운동량 등이 혈압에 미치는 영향을 모델링합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#범주형-자료-분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#범주형-자료-분석",
    "title": "임상 통계학",
    "section": "22.14 범주형 자료 분석",
    "text": "22.14 범주형 자료 분석\n카테고리 데이터를 분석하는 방법입니다. 주로 카이제곱 검정, Fisher 의 정확 검정 등이 사용되며, 범주형 변수 간의 관계나 분포의 차이를 분석합니다. 예시: 흡연 여부 (흡연자/비흡연자) 와 폐암 발생 (있음/없음) 사이의 관계를 분석합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#오즈비-odds-ratio",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#오즈비-odds-ratio",
    "title": "임상 통계학",
    "section": "22.15 오즈비 (odds ratio)",
    "text": "22.15 오즈비 (odds ratio)\n두 사건의 발생 확률의 비율을 나타내는 지표입니다. 주로 case-control 연구에서 위험 요인과 질병 발생의 관련성을 평가하는 데 사용됩니다. 예시: 특정 유전자 변이가 있는 사람이 없는 사람에 비해 특정 질병에 걸릴 확률이 몇 배 높은지 계산합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#로지스틱-회귀분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#로지스틱-회귀분석",
    "title": "임상 통계학",
    "section": "22.16 로지스틱 회귀분석",
    "text": "22.16 로지스틱 회귀분석\n이진 결과변수에 대한 회귀분석 방법으로, 오즈비 계산이 가능합니다. 종속변수가 이진형 (예: 성공/실패) 일 때 사용되며, 독립변수와 종속변수의 확률 간의 관계를 모델링합니다. 예시: 환자의 나이, 성별, 혈압 등의 요인이 심장병 발생 확률에 미치는 영향을 모델링합니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#생존분석",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#생존분석",
    "title": "임상 통계학",
    "section": "22.17 생존분석",
    "text": "22.17 생존분석\n특정 사건 (예: 사망, 재발) 까지의 시간을 분석하는 방법입니다. Kaplan-Meier 곡선과 Log-rank 검정이 자주 사용됩니다. 예시: 새로운 항암제 치료를 받은 환자군과 기존 치료를 받은 환자군의 5 년 생존율을 비교합니다.\n\n생존함수와 위험함수: 생존함수는 특정 시점까지 사건이 발생하지 않을 확률을, 위험함수는 특정 시점에서의 순간적인 사건 발생 확률을 나타냅니다. 위험함수가 커지면 사망 가능성이 높아집니다.\nKaplan-Meier 곡선: 시간에 따른 생존 확률을 그래프로 나타내는 방법으로, 중도 탈락한 데이터를 처리할 수 있어 자주 사용됩니다.\nLog-rank test: 두 개 이상의 생존함수가 통계적으로 유의한 차이가 있는지 검정하는 방법입니다. 전체 관찰 기간에 걸친 생존 기간을 비교합니다.30"
  },
  {
    "objectID": "posts/qmd/learn_STAT_clinical_trial.html#footnotes",
    "href": "posts/qmd/learn_STAT_clinical_trial.html#footnotes",
    "title": "임상 통계학",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://m.medigatenews.com/news/3671926126↩︎\nhttp://www.jcr.kr/Upload/Post_Case/1450158131_phpkvoj7J_-2.pdf↩︎\nhttp://www.docdocdoc.co.kr/news/articleView.html?idxno=1062297↩︎\nhttps://pipetcpt.github.io/book-stat/analysis.html↩︎\nhttps://pipetcpt.github.io/book-stat/design.html↩︎\nhttps://support.minitab.com/ko-kr/minitab/help-and-how-to/statistics/equivalence-tests/how-to/2-sample-equivalence-test/before-you-start/example/↩︎\nhttp://www.kmdianews.com/news/articleView.html?idxno=28425↩︎\nhttps://ko.wikipedia.org/wiki/%EC%9E%84%EC%83%81%EC%8B%9C%ED%97%98↩︎\nhttps://pipetcpt.github.io/book-stat/design.html↩︎\nhttp://www.hitnews.co.kr/news/articleView.html?idxno=46635↩︎\nhttps://ko.wikipedia.org/wiki/%EC%9E%84%EC%83%81%EC%8B%9C%ED%97%98↩︎\nhttps://ekja.org/upload/pdf/kjae-68-106_ko.pdf↩︎\nhttps://pipetcpt.github.io/book-stat/analysis.html↩︎\nhttps://3months.tistory.com/506↩︎\nhttps://rimint02.tistory.com/m/153↩︎\nhttps://blog.naver.com/PostView.naver?blogId=julcho&isHttpsRedirect=true&logNo=40207295594↩︎\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC5654877/↩︎\nhttps://en.wikipedia.org/wiki/Intention-to-treat_analysis↩︎\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC3159210/↩︎\nhttps://www.clinfo.eu/itt-vs-pp↩︎\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC3159210/↩︎\nhttps://greatjoy.tistory.com/78↩︎\nhttps://syj9700.tistory.com/6↩︎\nhttp://www.kmdianews.com/news/articleView.html?idxno=28425↩︎\nhttp://www.mediclic.co.kr/info/bio↩︎\nhttps://pipetcpt.github.io/book-stat/design.html↩︎\nhttps://www.statology.org/two-sample-t-test/↩︎\nhttps://en.wikipedia.org/wiki/Student’s_t-test↩︎\nhttps://www.jmp.com/en_ca/statistics-knowledge-portal/t-test/two-sample-t-test.html)↩︎\nhttps://www.graphpad.com/quickcalcs/ttest1/↩︎"
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html",
    "href": "posts/qmd/tool_DockQ.html",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "",
    "text": "DockQ 는 단백질, DNA 및 저분자 화합물 도킹 모델에 대한 품질을 측정하는 도구입니다. DockQ 점수는 0 에서 1 까지의 범위로 측정되며 품질은 아래와 같이 정의됩니다."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#pixi-를-사용하는-방법",
    "href": "posts/qmd/tool_DockQ.html#pixi-를-사용하는-방법",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "1.1 pixi 를 사용하는 방법",
    "text": "1.1 pixi 를 사용하는 방법\ngit clone https://github.com/bjornwallner/DockQ/\ncd DockQ\npixi init .\npixi add \"python=3.9.1\"\npixi add \"numpy=1.23.4\"\npixi shell"
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#uv-를-사용하는-방법",
    "href": "posts/qmd/tool_DockQ.html#uv-를-사용하는-방법",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "1.2 uv 를 사용하는 방법",
    "text": "1.2 uv 를 사용하는 방법\ngit clone https://github.com/bjornwallner/DockQ/\ncd DockQ\nuv venv venv\nsource venv/bin/activate\n(venv) uv pip install numpy==1.23.4\n(venv) uv pip install ."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#명령어-예시",
    "href": "posts/qmd/tool_DockQ.html#명령어-예시",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "2.1 명령어 예시",
    "text": "2.1 명령어 예시\n하나 이상의 인터페이스가 있는 모델/원형 단백질 복합체에서 DockQ 를 실행하면 각 인터페이스에 대한 결과를 얻을 수 있습니다. 결과는 모든 인터페이스에서 평균을 최대화하도록 계산됩니다:\npixi run DockQ examples/1A2K_r_l_b.model.pdb examples/1A2K_r_l_b.pdb\n플래그 --short 를 사용하면 더 간결한 출력을 볼 수 있습니다."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#단백질---단백질-결합-스코어링",
    "href": "posts/qmd/tool_DockQ.html#단백질---단백질-결합-스코어링",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "2.2 단백질 - 단백질 결합 스코어링",
    "text": "2.2 단백질 - 단백질 결합 스코어링\n기본적으로 DockQ 는 원본 인터페이스와 모델에 있는 인터페이스 간에 최적의 매핑을 찾으려고 시도합니다.\n가장 간단한 경우는 호모다이머가 모델링된 경우입니다. 그런 다음 원본의 인터페이스 AB(원래 체인 A 와 B 사이) 를 모델 AB 인터페이스와 비교할 수 있지만 체인의 순서를 변경하면 일반적으로 결과가 변경 되므로 BA 와도 비교할 수 있습니다. DockQ homodimer_model.pdb homodimer_native.pdb 명령어를 입력하면 소프트웨어가 가장 높은 DockQ 점수를 가진 매핑 (AB -&gt; AB 또는 AB -&gt; BA) 값을 출력합니다.\n사용자가 특정 매핑을 적용하려면 --mapping 플래그를 사용할 수 있습니다. 이는 예를 들어 모델/원형에 많은 수의 상동 (homologous) 사슬이 포함되어 있는 경우 계산 속도를 높일 수 있어 유용합니다.\n\n2.2.1 완전 매핑\n사용자는 원본 체인과 모델 체인 간의 전체 매핑을 정의합니다: --mapping MODELCHAINS:NATIVECHAINS. 예를 들어, 앞의 경우 두 가지 가능한 매핑이 있을 수 있습니다:\n\n--mapping AB:AB(원본 체인 A 는 모델 체인 A 에, 원본 체인 B 는 모델 B 에 해당)\n--mapping AB:BA(원본 체인 A 는 모델 체인 B 에, 원본 체인 B 는 모델 A 에 해당)\n\n콜론 : 앞의 쌍은 모델에서 체인 순서를 정의하고, 뒤의 쌍은 원본에서 순서를 정의합니다.\n\n\n2.2.2 부분 매핑\n사용자가 매핑의 일부를 수정하고 나머지는 DockQ 가 최적화하도록 하려는 경우 와일드카드를 사용할 수 있습니다. 예를 들어, 테트라머에 모델에 ABCD 체인이 있고 원본에는 WXYZ 체인이 있는 경우 아래 명령어를 사용합니다.\n--mapping A*:W*\n여기서 와일드카드 * 는 DockQ 가 A -&gt; W 를 고정된 상태로 유지하면서 BCD 와 XYZ 사이의 매핑을 최적화해야 함을 나타냅니다. 두개의 체인을 고정하는 경우는 아래 명령어를 사용합니다.\n--mapping AD*:WY*\n\n\n2.2.3 원본 인터페이스의 하위 집합으로 검색 제한하기\n사용자가 원본 인터페이스 중 하나 이상의 특정 인터페이스에 관심이 있고 나머지는 무시해야 하는 경우 다음 명령어를 사용합니다.\n--mapping *:WX\n그러면 DockQ 가 모델에서 네이티브의 WX 인터페이스와 가장 잘 일치하는 인터페이스를 찾습니다. 여러 원본 인터페이스를 사용하는 경우 명령어는 아래와 같습니다.\n--mapping *:WXY"
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#단백질---저분자-화합물-결합-스코어링",
    "href": "posts/qmd/tool_DockQ.html#단백질---저분자-화합물-결합-스코어링",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "2.3 단백질 - 저분자 화합물 결합 스코어링",
    "text": "2.3 단백질 - 저분자 화합물 결합 스코어링\n단백질과 동일한 방식으로 PDB 또는 mmCIF 파일의 저분자를 스코어링하고 매핑을 최적화할 수 있습니다. --small_molecules 플래그를 추가하기만 하면 됩니다:\n# 헤모글로빈 사슬(네이티브의 사슬 A와 B)과 HEM 및 PO4 그룹(사슬 E, F, G)의 도킹을 비교합니다.\n$ DockQ examples/1HHO_hem.cif examples/2HHB_hem.cif --small_molecule --mapping :ABEFG --short\n\n\n\n\n\n\nNote\n\n\n\n저분자에 대해서는 LRMSD 값만 출력됩니다.\n\n\n참고로 저분자 화합물은 PDB/mmCIF 파일에 포함되어야 합니다. 또한 별도의 체인 식별자가 있어야 합니다 (mmCIF 파일에서는 label_asym_id 필드가 사용됩니다)."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#단백질---dnarna-결합-스코어링",
    "href": "posts/qmd/tool_DockQ.html#단백질---dnarna-결합-스코어링",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "2.4 단백질 - DNA/RNA 결합 스코어링",
    "text": "2.4 단백질 - DNA/RNA 결합 스코어링\nDNA 와 관련된 인터페이스는 단백질 인터페이스와 마찬가지로 똑같이 점수가 매겨집니다. 단백질-DNA 또는 DNA-DNA 인터페이스에 대해서는 단백질-단백질 인터페이스와 동일한 방식으로 DockQ 점수가 계산됩니다. 이중 나선 사슬의 경우 두 개의 DockQ 점수가 출력됩니다."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#파이썬-모듈로-dockq-사용하기",
    "href": "posts/qmd/tool_DockQ.html#파이썬-모듈로-dockq-사용하기",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "3.1 파이썬 모듈로 DockQ 사용하기",
    "text": "3.1 파이썬 모듈로 DockQ 사용하기\nDockQ 를 설치한 후에는 파이썬 코드에서 모듈로 사용할 수도 있습니다.\nfrom DockQ.DockQ import load_PDB, run_on_all_native_interfaces\n\nmodel = load_PDB(\"examples/1A2K_r_l_b.model.pdb\")\nnative = load_PDB(\"examples/1A2K_r_l_b.pdb\")\n\n# model:native 체인에 대한 인터페이스를 딕셔너리 형태로 매핑\nchain_map = {\"A\":\"A\", \"B\":\"B\"}\n# 결과는 딕셔너리 형태로 반환.\nrun_on_all_native_interfaces(model, native, chain_map=chain_map)"
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#단일-수용체-또는-리간드에-여러-사슬-병합하기",
    "href": "posts/qmd/tool_DockQ.html#단일-수용체-또는-리간드에-여러-사슬-병합하기",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "3.2 단일 수용체 또는 리간드에 여러 사슬 병합하기",
    "text": "3.2 단일 수용체 또는 리간드에 여러 사슬 병합하기\n여러 개의 사슬 (예를 들면 항체의 중쇄와 경쇄 사슬) 을 단일 수용체 또는 리간드로 병합하려면 이슈 #33 을 참고하세요."
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#인용하기",
    "href": "posts/qmd/tool_DockQ.html#인용하기",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "4.1 인용하기",
    "text": "4.1 인용하기\nDockQ 를 사용하는 경우 아래 프리프린트를 인용하세요.https://doi.org/10.1101/2024.05.28.596225"
  },
  {
    "objectID": "posts/qmd/tool_DockQ.html#pixi-의존성-파일",
    "href": "posts/qmd/tool_DockQ.html#pixi-의존성-파일",
    "title": "DockQ로 도킹 모델 품질 측정하기",
    "section": "4.2 pixi 의존성 파일",
    "text": "4.2 pixi 의존성 파일\n[tool.pixi.project]\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"]\n\n[tool.pixi.pypi-dependencies]\ndockq = { path = \".\", editable = true }\n\n[tool.pixi.dependencies]\nnumpy = \"1.23.4.*\"\npython = \"3.9.1.*\"\nbiopython = \"&gt;=1.84,&lt;2\"\njupyterlab = \"&gt;=4.2.4,&lt;5\""
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html",
    "href": "posts/qmd/guide_lab_protocols.html",
    "title": "실험실 프로토콜 모음",
    "section": "",
    "text": "이곳에는 실험 방법에 대한 간략한 정보가 있습니다. 계속해서 자주 사용하는 프로토콜들을 정리할 예정입니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#왜-이름이-miniprep-인가요",
    "href": "posts/qmd/guide_lab_protocols.html#왜-이름이-miniprep-인가요",
    "title": "실험실 프로토콜 모음",
    "section": "2.1 왜 이름이 miniprep 인가요?",
    "text": "2.1 왜 이름이 miniprep 인가요?\n다양한 회사에서 plasmid DNSA 를 정제하는 하는 키트를 생산하고 있는데, 시작하는 E.coli 배양액의 양에 따라서 다음과 같이 miniprep, midiprep, maxiprep 라고 공통적으로 부르고 있습니다. 이름에서 알 수 있듯 양이 적으면 mini 많으면 maxi 입니다.\nminiprep 은 (상대적으로) 빠르고 작은 규모로 plasmid DNA 를 뽑아 낼 수 있기에 많이 사용되고 있습니다. 원리는 alkaline lysis method 를 사용하고 있는데 간단히 이야기 하면 염기성 용액으로 셀을 깨주고, 빠르게 중화시켜 Plasmid DNA 만 선택해 내는 방법 입니다. 보통의 경우 miniprep 으로 약 50µg 의 plasmid DNA 를 얻을 수 있습니다.\n\nminiprep 에 사용되는 다양한 키트가 있지만, 여기에서는 Qiagen Spin Miniprep 키트 기준으로 설명합니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#준비물",
    "href": "posts/qmd/guide_lab_protocols.html#준비물",
    "title": "실험실 프로토콜 모음",
    "section": "2.2 준비물",
    "text": "2.2 준비물\n\n하룻밤 키운 E.coli 배양액 (1-5ml)\n차가운 P1 버퍼 (50 mM Tris-HCl pH 8.0, 10 mM EDTA, 100 µg/ml RNaseA) RNaseA 가 들어있습니다, 항상 냉장 보관하세요.\nP2 버퍼 (200 mM NaOH, 1% SDS)\nN3 버퍼 (4.2 M Gu-HCl, 0.9 M potassium acetate, pH 4.8)\nPB 버퍼 (5 M Gu-HCl, 30% ethanol)\nPE 버퍼 (10 mM Tris-HCl pH 7.5, 80% ethanol)\nEB 버퍼 (10 mM Tris·Cl, pH 8.5; DW 로 대체하셔도 됩니다.)\nQIAprep spin column (키트에 포함되어 있음)\nCentrifuge\n멸균된 1.5-ml microcentrifuge 튜브"
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#방법",
    "href": "posts/qmd/guide_lab_protocols.html#방법",
    "title": "실험실 프로토콜 모음",
    "section": "2.3 방법",
    "text": "2.3 방법\n\nmicrocentrifuge 튜브에 1.5 ml 의 배양액을 넣어 줍니다.\n최대 속도로 Centrifuge for 1 min at room temperature, gently aspirate out the supernatant and discard it.\n충분한 크기의 cell pellet 이 생길때 까지 반복합니다.\n250 µl 의 차가운 Buffer P1 를 넣어주고, Resuspend pelleted bacterial cells\nAdd 250 μl Buffer P2 and 조심스럽게 invert the tube 4–6 times to mix.\nAdd 300 µl of Buffer N3.\n\n\n\n\n\n\n\nNote\n\n\n\nProceed to the next step within immediately !\n\n\n\nClose the tube tightly and invert the tube 4 - 6 times . The solution should become cloudy.\nCentrifuge for 10 min at 13,000 rpm (~17,900 x g) in a table-top microcentrifuge. A compact white pellet will form. Apply the supernatants from step 4 to the QIAprep spin column by decanting or pipetting.\nCentrifuge for 30–60 s. Discard the flow-through. Spinning for 60 seconds produces good results.\nWash QIAprep spin column by adding 0.75 ml Buffer PE and centrifuging for 30–60 s.\nDiscard the flow-through, and centrifuge for an additional 1 min to remove residual wash buffer.\n\n\n\n\n\n\n\nImportant\n\n\n\nIMPORTANT: Residual wash buffer will inhibit subsequent enzymatic reactions.\n\n\n\nPlace the QIAprep column in a clean 1.5 ml microcentrifuge tube. To elute DNA, add 50 μl Buffer EB (10 mM Tris·Cl, pH 8.5) or water to the center of each QIAprep spin column, let stand for 1 min, and centrifuge for 1 min.\n\n\n\n\n\n\n\nNote\n\n\n\n\n만약 높은 농도로 elution 받고 싶다면 add 30 μL 의 DW 를 컬럼 가운데에 넣고, incubate at room temperature on the bench for 5 mins and then centrifuge for 1 min.\n한번에 10 개 이상의 miniprep 을 한다면 vacuum manifold 방법을 사용하는게 빠릅니다.\ncell lysate 를 column 에 두번 거치면 수율이 약 20% 증가됩니다.\n시퀀싱 경과가 안나오는 이유는 대체로 염에 의한 오염으로, Washing 하는 과정을 충분하게 해야합니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#원리",
    "href": "posts/qmd/guide_lab_protocols.html#원리",
    "title": "실험실 프로토콜 모음",
    "section": "3.1 원리",
    "text": "3.1 원리\n이름에서 알 수 있듯이 효소가 사용됩니다. 항원의 농도는 기질 전환 정도에 달라집니다 항체나 항원이 고체상에 흡착되어있으며 이렇게 해야지만 결합하지 않은 free 항원들을 세척으로 없앨 수 있습니다. 실험동물을 immunization 한 후 얻은 serum 이나 fusion 을 통해 얻은 하이브리도마의 culture supernatant 안에 원하는 항체가 생성되어있는지 확인할 수 있습니다. 방사능을 사용하지 않으면서 검사할 수 있고 샌드위치와 경쟁적 ELISA 방법이 가장 많이 사용됩니다. Dirent ELISA 도 사용되는데 항원이 고체상에 고정됩니다. 이 방법은 항원특이적 항체 검출시에 용이합니다. 효소로는 간단한 기질을 넣어주었을때 색이 나는 반응을 이용합니다. 대표적으로는 alkaline phosphatase 와 HRP(horseradish peroxidase) 가 사용됩니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#종류",
    "href": "posts/qmd/guide_lab_protocols.html#종류",
    "title": "실험실 프로토콜 모음",
    "section": "3.2 종류",
    "text": "3.2 종류\n\nDirect ELISA: 항원과 반응하는 항체에 바로 효소를 결합시킨다.\nIndirect ELISA: 항원과 결합하는 항체 (1 차항체) 에는 효소가 없고, 그 항체와 결합하는 항체 (2 차항체) 에는 효소가 결합되어있다. 일반적으로 isotype 에 대한 항체에 효소가 결합된 형태로 판매되고 있다. 자신이 이용하는 일차항체의 isotype 에 맞는 효소결합항체를 구입하여 사용하면된다.항체를 정량 및 정성적으로 분석 할때 사용한다.\nSandwich ELISA: 항원에 대한 항체를 먼저 well 에 결합시키고 그 항체에 대한 항원 (시료) 을 결합시킨다. 그 후 직접적이나 간접법으로 조사한다. 항원을 정성 및 정량적으로 분석한다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#ab1-파일을-열기-위한-프로그램",
    "href": "posts/qmd/guide_lab_protocols.html#ab1-파일을-열기-위한-프로그램",
    "title": "실험실 프로토콜 모음",
    "section": "4.1 ab1 파일을 열기 위한 프로그램",
    "text": "4.1 ab1 파일을 열기 위한 프로그램\n저는 개인적으로 ApE 를 선호하지만, 다음과 같이 다양한 프로그램이 있습니다. 마음에 드시는 것을 선택하시면 됩니다.\n\n4Peaks (Mac)\nSnapGene Viewer (Mac/Windows)\nFinchTV(Mac/PC)\nSequence Scanner (Windows)\nChromas (Windows)\nApE(Mac/Windows)"
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#참고-사항",
    "href": "posts/qmd/guide_lab_protocols.html#참고-사항",
    "title": "실험실 프로토콜 모음",
    "section": "4.2 참고 사항",
    "text": "4.2 참고 사항\n\n믿을 수 있는 DNA 서열은 trace 크로마토그램이 서로 겹쳐있지 않아야 합니다\nDNA 서열은 500-700 개 까지는 믿을 만합니다: 생거 시퀀싱에는 한계로 인해서 한 번에 약 600 개 정도 까지의 결과값만 신뢰할 수 있습니다. 최근에는 약 1000 개까지도 신뢰할 만합니다.\nDNA 처음 20-30 개의 서열은 신뢰도가 낮습니다. 그래서 Primer 가 붙는 위치를 원하는 서열의 앞쪽 50 개 정도로 선택하는게 좋습니다.\nDNA 시퀀싱을 보낼 샘플은 깨끗해야 합니다. 항상 깨끗한 튜브에 깔끔하게 준비한 DNA 샘플을 보내세요. 시퀀싱 반응이 되지 않더라도 업체는 돈을 받습니다. 그리고 생각보다 시퀀싱 반응은 오염에 민감합니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#sds-page-gel-만들기",
    "href": "posts/qmd/guide_lab_protocols.html#sds-page-gel-만들기",
    "title": "실험실 프로토콜 모음",
    "section": "5.1 SDS-PAGE Gel 만들기",
    "text": "5.1 SDS-PAGE Gel 만들기\n준비물 : - 2X running gel buffer : 750 mM Tris-HCl, pH8.8 상온보관 - 1x stacking gel solution : 62.5mM Tris-HCl, pH6.8, 4% acrylamide 냉장보관 - 30% acrylamide stock solution (29:1): 냉장보관 - 10% Ammonium persulfate : 냉장보관\n\n\n\n\n\n\nNote\n\n\n\nAcrylamide 의 quality 는 해상도에 영향을 줍니다. 따라서 high quality 를 사용하시는 편이 좋고 가급적 빠른 시간내 소비하는 것이 좋습니다.\n\n\n\n2x running gel buffer 5ml + 20% acrylamide stock 5ml + 10% APS 100ul 섞어 줍니다.\nTEMED 10 ul 넣고 천천히 섞어줍니다.\nGel cast 에 기포가 생기지 않게 조심히 부어 줍니다.\n100% Ethanol 을 위에 조심스럽게 넣습니다. 양은 500ul 정도 입니다.\n30 분후 Gel 이 굳은 걸 확인하고 DW 로 gel 윗 부분을 한번 씻어줍니다.\n1x stacking gel solution 1ml + 10% APS 10ul 를 섞어 줍니다.\nTEMED 1ul 를 마지막으로 넣어 천천히 섞어 줍니다.\n5 번 과정을 끝낸 running gel 위에 붇고 comb 을 꼽아 줍니다.\n20 분후 comb 을 뽑고 실험에 사용합니다.\n\n\n\n\n\n\n\nNote\n\n\n\n\nGel 이 굳는 시간은 전적으로 APS 의 첨가량에 따라 달라지며 시간이 촉박한 경우 APS 의 양을 늘려 줍니다. Gel 이 완전히 굳지 않았을 경우에 해상도는 떨어집니다. 이러한 점에서 오랜 시간 굳히는 방법보다는 APS 의 양을 늘려 빨리 굳히는 편이 좋습니다.\nSDS 는 sample buffer 와 running buffer 에 들어있으므로 gel 에 넣지 않아도 해상도에 문제가 없습니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#standard-protocol-insert-vector-dna-ligation",
    "href": "posts/qmd/guide_lab_protocols.html#standard-protocol-insert-vector-dna-ligation",
    "title": "실험실 프로토콜 모음",
    "section": "6.1 Standard Protocol: Insert + Vector DNA Ligation",
    "text": "6.1 Standard Protocol: Insert + Vector DNA Ligation\n대부분의 경우 3 insert : 1 vector 비율을 추천한다. 또한 ligation 반응 시 총 DNA 의 양은 100ng 정도가 권장 된다.\n\nCombine the following in a PCR or Eppendorf tube:\n\n25ng Vector DNA\n75ng Insert DNA\nLigase Buffer (1μL/10μL reaction for 10X buffer, and 2μL/10μL reaction for 5X buffer) 0.5-1μL T4 DNA Ligase\nDW 를 넣어 total 10μL\n만약 DNA 농도가 너무 낮다면 total volume 을 증가 시켜서 진행한다.\n항상 Vector 만 넣은 control 실험을 하고 다양한 vector : insert 비율을 시도 한다.\n\nRT 에서 2 시간 혹은 16°C 에서 overnight 반응 시킨다.\n\n“high concentration” ligase 를 사용하는 경우 RT 5 분이면 충분하다.\n\ntransformation 을 진행한다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#vectorinsert-비율에-대하여",
    "href": "posts/qmd/guide_lab_protocols.html#vectorinsert-비율에-대하여",
    "title": "실험실 프로토콜 모음",
    "section": "6.2 Vector:Insert 비율에 대하여",
    "text": "6.2 Vector:Insert 비율에 대하여\n보통 3:1 비율로 넣어줄 경우 충분하지만 안될 경우 vector: insert 비율을 조절 해 줄 필요가 있다. 자동으로 계산해주는 도구 이 있으니 참고한다.\n\n\n\n\n\n\nTip\n\n\n\nligation 단계는 실험의 성공 여부를 알기 힘들기 때문에 항상 아래와 같은 컨트롤 넣어서 실험을 하는 것을 추천합니다.\n\n\n\n\n\n\n\n\n\n\nControl\nLigase\nInterpretation\n\n\n\n\nUncut vector\n-\nChecks viability of competent cells and verifies the antibiotic resistance of the plasmid\n\n\nCut vector\n-\nBackground due to uncut vector\n\n\nCut vector\n+\nBackground due to vector re-circularization - most useful for phosphatase treated vector\n\n\nInsert or water\n+\nAny colonies indicate contamination of intact plasmid in ligation or transformation reagents"
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#목적",
    "href": "posts/qmd/guide_lab_protocols.html#목적",
    "title": "실험실 프로토콜 모음",
    "section": "7.1 목적",
    "text": "7.1 목적\n복잡한 전체 genome 중에 연구하고자 하는 유전자가 희귀유전자를 분석하고 연구하는데 가장 큰 문제점이였다. PCR 은 특정 DNA sequence 의 copy 수를 기하급수적으로 증폭시킴으로써 증폭된 DNA 를 여러 가지 실험에 이용할 수 있고, 실험 결과를 토대로 분자생물학, 의학, 이학, 농학, 수의학, 식품과학, 환경과학 연구에 응용할 수 있음"
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#pcr-구성-요소",
    "href": "posts/qmd/guide_lab_protocols.html#pcr-구성-요소",
    "title": "실험실 프로토콜 모음",
    "section": "7.2 PCR 구성 요소",
    "text": "7.2 PCR 구성 요소\n\nDNA, RNA template: 증폭 대상이 되는 DNA, RNA\nPCR Primers: 증폭할 부분을 잡는 짧은 염기서열.\nTaq polymerase: 열에 특별히 강한 유전자 합성효소 (Taq polymerase: Thermus aquaticus 라는 온천에 사는 세균의 DNA polymerase, 72℃가 최적온도, 94℃에서도 안정함)\ndNTP (dATP, dCTP, dGTP, dTTP): 유전자를 합성하는 재료가 되는 각 nucleotide\nMgCl+2: dNTP 와 복합체를 형성하여 효소활성, primer annealing 등에 관여"
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#pcr-의-단계",
    "href": "posts/qmd/guide_lab_protocols.html#pcr-의-단계",
    "title": "실험실 프로토콜 모음",
    "section": "7.3 PCR 의 단계",
    "text": "7.3 PCR 의 단계\n\nDNA 의 변성 (denaturation)\n\n90℃∼96℃로 가열하여 두가닥 DNA 를 단일가닥 DNA 로 분리.\n일반적으로 94℃사용: 높은 온도일수록 단일가닥 DNA 로 잘 이행되지만 온도가 너무 높으면 Taq DNA polymerase 역시 activity(활성) 가 낮아짐.\n첫 Cycle 에서는 확실한 변성을 위하여 약 5 분간 지속시킴.\n이 후의 cycle 에서는 약 1 분간 변성시킴.\n\nPrimer 의 결합 (annealing)\n\n50℃∼65℃에서 진행.\n30sec~1min.\n염기 간의 결합은 G, C 의경우 세군데 에서 수소결합이 일어나고 A, T 는 두군데에서 결합이 일어나므로 G+C 비율에 따라 결합 온도 결정.\nPrimer design 시에 Annealing temperature 를 고려해야 함.\n일반적으로 GC content 가 50% 가 되는 primer 쌍을 이용하는 것이 바람직.\n\nDNA 의 합성 (polymerization, extension)\n\n70℃∼74℃에서 시행.\n1min ~ 1min 30sec.\nTaq DNA polymerase 의 합성 속도: 2,000∼4,000 nucleotides/min, 1 kb 마다 1 분 정도의 시간 필요. 원하는 PCR 산물의 크기가 크 거나 반응요소의 농도가 낮을 때에는 시간을 연장할 수 있음.\nCycle 이 계속되면서 효소 활성이 감소할 수 있고 DNA 산물은 점점 많이 존재하게 되므로 cycle 후반부에는 반응시간을 조금씩 늘려가는 것도 좋은 방법의 하나이며 마지막 cycle 에는 약 10 분 정도 시간을 충분히 주어서 효소의 활성이 충분히 발휘되도록 함."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#pcr-유의-사항",
    "href": "posts/qmd/guide_lab_protocols.html#pcr-유의-사항",
    "title": "실험실 프로토콜 모음",
    "section": "7.4 PCR 유의 사항",
    "text": "7.4 PCR 유의 사항\n\n여러 component 를 혼합할 때에는 시료간에 오염이 되지 않도록 주의하여야 하며 가능하면 공기를 통한 오염을 방지할 수 있는 tip 을 사용하는 것이 좋습니다. 반응물 혼합 시에는 tube 를 ice 상에 두고서 혼합하여야 상온에서의 잘못 primer annealing 에 의한 extension 을 방지할 수 있습니다. 이론적으로 Taq DNA polymerase 는 최적 온도 이하에서도 반응이 어느 정도 진행됨 으로 상온 등에서 정확하게 annealing 되지 않은 primer 에 의한 임의의 반응이 진행됨으로써 원하는 size 의 product 이외의 non-specific product 가 만들어질 수 있습니다.\nPCR 은 민감도가 뛰어난 실험이기 때문에 아주 적은 양의 DNA 가 오염되더라도 실험에 큰 영향을 미칠 수 있습니다. 그러므로 PCR 을 위한 template 를 준비하는 곳과 PCR 반응을 하는 곳, 그리고 PCR 후 전기영동 및 분석을 하는 곳은 격리시키는 것이 좋으며, DNase 와 RNase free PCR tube 를 사용하는 것이 좋습니다. 모든 시약류는 반드시 autoclave 와 filteration 을 거친 후 사용하여야 합니다.\nPCR cycling 조건은 PCR 의 종류와 주형 DNA, primer 그리고 PCR 기기등에 따라 달라 져야 합니다\ntemplate DNA 의 완전한 denaturation 이 중요한데 94℃∼95℃에서 2∼3 min 정도로 충분하지만 대부분 5 min 정도 초기 변성 시간을 주는 것이 좋습니다. denaturation 이 충분하지 않으면 primer 의 annealing 과 extension 이 방해받아 정확한 반응물이 생기지 않을 수 도 있습니다.\n보통 94℃∼95℃에서 20∼30 sec 정도이지만 PCR 기기와 tube 등에 따라 시간을 늘리기도 합니다. Template 의 GC 함량이 높으면 높은 온도와 긴 시간을 사용하기도 하지만 필요 이상으로 변성 온도가 높거나 길면 Taq DNA polymerase 의 활성 이 감소됩니다.\n대개의 경우 annealing 온도는 primer 의 Tm 값에 따라 결정됩니다. 온도가 너무 높으면 primer 가 annealing 되지 않아 PCR product 가 생기지 않게 되고, 온도가 너무 낮으면 non-specific annealing 이 일어나 정확한 PCR product 가 생기지 않습니다.\nTaq polymerase 의 경우 72℃에서 1 초당 약 60 개의 염기를 중합시키기 때문에 1 kb 까지는 45 sec 정도면 충분합니다. 하지만 대부분의 경우 1kb 당 1 분정도의 시간이 필요합니다.\n대부분의 경우 25∼35 cycles 을 진행하고, Template 분자가 10 개 이하인 경우에는 40 cycles 정도 진행하면 product 을 관찰할 수 있습니다. 그러나 cycle 의 수를 무작 정 늘린다고 해서 product 의양이 급격히 늘지는 않으며 오히려 비특이적 밴드가 늘어날 수 있습니다.\nPCR 기기는 기본적으로 PCR 반응을 구성하는 세 가지 온도를 최소한의 시간에 정확하 고 재현성있게 유지할 수 있어야 합니다. 또한 반응 tube 에 따라 열전도율의 차이가 있기 때문에 가능하면 thin-walled reaction tube 를 사용하는 것이 좋으며 thermal cycler 의 block 에 꼭 맞는 크기를 사용하여야 합니다.\nTemplate 양과 질은 PCR 에 절대적인 영향을 미칩니다. template 가 적을수록 product 의 양 역시 비례적으로 감소하게 되며, RNA 의 오염은 Mg2+ 이온을 잡아먹어 yield 를 낮추게 되고 오염된 template 에는 반응저해제들을 많이 포함 하고 있어 반응의 효율을 떨어뜨립니다.\nPCR 의 많은 요소들 중에서도 primer 의 염기서열과 농도는 전체 반응의 성패에 가장 큰 영향을 미치는 요인 중 하나로 다음과 같은 사항들을 고려하여 설계하는 것이 좋습니다. 길이는 18∼24mer 가 적당하며 두 primer 의 Tm 값의 차이는 5℃ 이내로 하고 가급적 2 차 구조가 형성되지 않도록하며 G+C 값은 40∼60% 로하여 두 primer 의 3′ 사이에 상보결합이 없어야 합니다.\nPCR 반응에 사용하는 Taq DNA polymerase 는 0.5∼2.5U/20∼50ul volume 정도가 적당합니다. 비율적으로 너무 많은 효소가 들어가게 되면 높은 glycerol 농도로 인하여 product 가 끌리는 현상이나 특이성이 떨어져 불균형적인 결과를 초래하게 되며, 너무 적은 양의 효소를 사용하면 생성물의 양이 부족하게 됩니다.\n항상 dNTP 의 4 가지 요소들은 동일 농도로 사용하여야 합니다. dNTP mixture 의 불균 형은 Taq polymerase 의 fidelity 를 감소시켜 error rate 가 증가될 수 있습니다. 또한 dNTP stock 은 thawing/freezing 에 민감하여 3∼5 차례만 반복하여도 활성이 감소하여 올바른 결과를 기대할 수 없습니다. 그러므로 stock 은 사용량에 맞게끔 적절하게 배분해놓는 것이 좋습니다. 만일 dNTP 의 농도를 증가시키려면 반드시 Mg2+ 의 농도 역시 증가시켜 주어야 합니다. 높은 dNTP 농도는 free Mg2+ 을 감소시켜 효소의 반응을 방해하고 primer 의 annealing 을 감소시키게 됩니다. 일반적으로 사용되는 dNTP 의 최종 농도는 각 200∼250uM 입니다.\nMg2+ 은 dNTP 와 복합체를 형성하여 효소의 실질적인 substrate 로 이용됩니다. free Mg2+ 의 농도는 dNTP, free pyrophosphate 그리 고 EDTA 같은 ion 결합 물질의 농도에 영향을 받게 됩니다. 최적의 실험결과를 위해선 적절한 MgCl2 의 농도를 사용하여야 하는데 가장 일반적인 농도는 1.5mM (dNTP 각 200uM 일 때) 입니다. Mg2+ 은 효소 활성에 영향을 미치고 double-strand DNA 의 Tm 값 을 증가시키는 효과가 있습니다. 과다한 Mg2+ 은 primer 의 비 특이적인 결합과 background 를 증가시키게 됩니다.\nPCR 반응을 하는 동안 mixture 가 증발되는 것을 방지하기 위하여 mineral oil 을 넣어주어야 합니다. 하지만 PCR 기기의 두껑에 히터가 달려있다면 mineral oil 을 넣어 줄 필요 없습니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#annealing-온도",
    "href": "posts/qmd/guide_lab_protocols.html#annealing-온도",
    "title": "실험실 프로토콜 모음",
    "section": "7.5 Annealing 온도",
    "text": "7.5 Annealing 온도\nTm 은 DNA 두 가닥이 반쯤 풀어졌을때 또는 두 가닥 ssDNA 가 반쯤 annealing 됬을떄의 온도를 말합니다. ” 반 쯤 ” 이라는 표현은 ” 반쯤 풀어졌을때 ” 와 ” 반쯤 붙었을때 ” 가 같은 의미로 사용됩니다. 긴 template 와 고농도의 짧은 primer 들이 같이 있을때 프라이머가 적당한 온도가 되면 서서히 유사한 서열에 붙기 시작합니다. 하지만 Tm 에서는 반 밖에 붙지 못하므로, 특히 프라이머의 3’ 쪽이 붙지 못한 상태라면 PCR 이 일어나지 않습니다. 그래서 온도를 좀 더 내려서 프라이머가 template 에 더 붙도록 합니다. DNA 의 Tm 값은 다음과 같이 계산할 수 있습니다.\n\\[ Tm = 4*(G+C)+2*(A+T) \\]\nPrimer 를 디자인할때 가능하면 같은 Tm 값의 forward,reverse primer 를 주문하는 하는것이 좋습니다. 그렇지 못한 경우 낮은 Tm 값의 primer 를 기준으로 약 5 도 정도 낮은 온도에서 PCR 을 수행합니다. 만약 원하는 사이즈의 PCR 밴드와 잡밴드가 같이 뜨면 annealing 온도를 2 도씩 올려 가면서 PCR 실행합니다. 만약 실험실에 gradient PCR 기가 있으면 Tm 값에서 위아래 5 도정도로 설정해 한번에 하는 방법도 있습니다. 보통 20~30 mer 사이는 보통 55 도 근처에서 하면 잘 나오는경우가 많습니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#pcr-잘-안되는-경우",
    "href": "posts/qmd/guide_lab_protocols.html#pcr-잘-안되는-경우",
    "title": "실험실 프로토콜 모음",
    "section": "7.6 PCR 잘 안되는 경우",
    "text": "7.6 PCR 잘 안되는 경우\nprimer 의 길이가 50~60mer 를 넘어간다던가 GC 비율이 현저하게 높거나 낮을때에는 annealing temperature 를 찾아야 하는 경우가 많습니다. 그럴때는 바로 gradient PCR 을 최저 온도 (보통 48~50 도) 에서 윗쪽으로 해보는것이 좋습니다. 잡밴드를 감수하고 원하는 밴드를 PCR 하기 위함입니다."
  },
  {
    "objectID": "posts/qmd/guide_lab_protocols.html#footnotes",
    "href": "posts/qmd/guide_lab_protocols.html#footnotes",
    "title": "실험실 프로토콜 모음",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttp://bitesizebio.com/articles/how-to-analyze-dna-sequencing-results-properly/↩︎"
  },
  {
    "objectID": "posts/qmd/learn_mindDebugging.html",
    "href": "posts/qmd/learn_mindDebugging.html",
    "title": "마음챙김과 효율을 위한 생산성 디버깅",
    "section": "",
    "text": "우리 모두 경험하고 있습니다. 일을 하려고 자리에 앉았는데 갑자기 휴대폰이 울리는 거예요. 어느새 고양이 동영상과 나무 위키 문서를 보게 되죠. 그러고 나면 하루가 어떻게 지나갔는지 벌써 저녁입니다. 낯익은 이야기인가요?\n이 거친 세상에서 집중력을 유지하는 것은 마치 미친 고양이를 쫓아다니는 것 같아요. 하지만 걱정하지 마세요! 이 글에서는 그 미친 고양이를 츄르로 유인하는 지혜를 나누려고 합니다."
  },
  {
    "objectID": "posts/qmd/learn_mindDebugging.html#미루기-내일-할-거야-라는-함정",
    "href": "posts/qmd/learn_mindDebugging.html#미루기-내일-할-거야-라는-함정",
    "title": "마음챙김과 효율을 위한 생산성 디버깅",
    "section": "2.1 미루기: “내일 할 거야” 라는 함정",
    "text": "2.1 미루기: “내일 할 거야” 라는 함정\n미루는 것은 단순한 게으름이 아닙니다.(가끔 낮잠을 자는 것은 오히려 좋은 방법이지요). 미루는 것은 오히려 성인이 되었다는 것과 비슷합니다.3\n다음과 같은 경우가 미루기에 속합니다: - 쿠키 통에 손을 넣은 정치인보다 더 많은 핑계를 대는 경우. - 일을 하지 않는 것에 대한 죄책감이 실제로 일하는 것만큼이나 심할때. - 갑자기 책상 정리를 엄청하고 싶을 때. - 가만히 있는 데 마감일이 다가올때.\n왜 우리는 스스로에게 이런 짓을 할까요? 그럴 수도 있습니다:\n\n실수에 대한 두려움 (안녕, 완벽주의자, 나의 오랜 친구)\n소스에서 길을 잃은 느낌 (목표란 도대체 무엇인가요?)\n게으름뱅이를 효율적으로 보이게 하는 시간 관리 기술\n감정?"
  },
  {
    "objectID": "posts/qmd/learn_mindDebugging.html#번아웃-일과-삶의-균형이-깨졌을-때",
    "href": "posts/qmd/learn_mindDebugging.html#번아웃-일과-삶의-균형이-깨졌을-때",
    "title": "마음챙김과 효율을 위한 생산성 디버깅",
    "section": "2.2 번아웃: 일과 삶의 균형이 깨졌을 때",
    "text": "2.2 번아웃: 일과 삶의 균형이 깨졌을 때\n번아웃은 완전히 다른 차원의 문제입니다. 마치 뇌가 파업을 일으켜 어떤 협상도 받아들이지 않는 것과 같습니다. 다음과 같은 경우 번아웃 상태일 수 있습니다:\n\n할 일 목록을 생각만 해도 자고 싶을 때\n재미있는 일조차 집안일처럼 느껴질때 (넷플릭스를 보며 멍하니 벽만 쳐다보는 게 더 낫겠죠?).\n몸이 SOS 신호를 보내는 경우 (불면증 혹은 불안증세)\n\n번아웃의 결과는 아래와 비슷할 겁니다:\n\n끝이 보이지 않는 업무 스트레스\n줄에 매달린 꼭두각시 같은 느낌\n진흙탕같이 불명확한 업무 지시\n일과 삶의 불균형\n\n나의 생산성이 어떤 것에 의해 저하되는 지를 알아야 해결이 가능합니다. 이제 어떻게 극복할 수 있는지 알아보죠."
  },
  {
    "objectID": "posts/qmd/learn_mindDebugging.html#footnotes",
    "href": "posts/qmd/learn_mindDebugging.html#footnotes",
    "title": "마음챙김과 효율을 위한 생산성 디버깅",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://dev.to/benborla/debugging-your-productivity-a-guide-to-mindfulness-and-efficiency-4le1↩︎\nhttps://jamesclear.com/atomic-habits↩︎\nhttps://www.goodreads.com/book/show/6708.The_Power_of_Now↩︎\nhttps://www.amazon.com/Discipline-Equals-Freedom-Field-Manual/dp/1250156947↩︎"
  },
  {
    "objectID": "posts/qmd/guide_Ds_Store.html",
    "href": "posts/qmd/guide_Ds_Store.html",
    "title": ".DS_Store 파일 관리",
    "section": "",
    "text": ".DS_Store 파일은 다른 OS 로 데이터를 공유하는 과정에서 전달되는 경우가 많고 불필요한 정보까지 옮겨 질 수 있습니다. 그래서 아래와 같이 삭제해서 데이터를 옮기거나 자동 생성을 방지하는 작업이 필요합니다.\n.DS_Store(Desktop Services Store) 는 애플에서 정의한 파일 포맷으로, macOS 에서 아래와 같은 역할을 합니다.1"
  },
  {
    "objectID": "posts/qmd/guide_Ds_Store.html#footnotes",
    "href": "posts/qmd/guide_Ds_Store.html#footnotes",
    "title": ".DS_Store 파일 관리",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://chanhhh.tistory.com/209↩︎\nhttps://jonhyuk0922.tistory.com/116↩︎\nhttps://wooono.tistory.com/251↩︎"
  },
  {
    "objectID": "posts/ipynb/da_visualization_calplot.html",
    "href": "posts/ipynb/da_visualization_calplot.html",
    "title": "Calplot: 파이썬으로 만드는 멋진 캘린더 히트맵",
    "section": "",
    "text": "calplot은 파이썬에서 시계열 데이터를 시각적으로 표현할 수 있는 라이브러리입니다. 이 라이브러리를 사용하면 GitHub의 기여도 그래프와 유사한 캘린더 형태의 히트맵을 쉽게 만들 수 있습니다. 이번 포스팅에서는 Meteostat 라이브러리를 사용하여 날씨 데이터를 가져오고 캘린더 형태로 시각화하는 방법을 소개합니다. 라이브러리를 통해 연도별 데이터를 직관적으로 표현합니다. 특히, 평균 기온과 일교차를 시각화하는 과정을 다룹니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_calplot.html#초기-설정-1",
    "href": "posts/ipynb/da_visualization_calplot.html#초기-설정-1",
    "title": "Calplot: 파이썬으로 만드는 멋진 캘린더 히트맵",
    "section": "2.1 초기 설정",
    "text": "2.1 초기 설정\n먼저, 필요한 상수와 한글 폰트를 설정합니다. 서울의 GPS 좌표를 기반으로 데이터를 가져오며, 한글 폰트를 설정해 그래프에서 한글이 깨지지 않도록 합니다.\n\nfrom datetime import datetime\n\nimport calplot\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom meteostat import Daily, Point, Stations\n\n# Constants\nNAME: str = \"서울\"  # 지역 이름\nGPS: tuple[float, float] = (37.5667, 126.9667)  # GPS 좌표\nSTART: datetime = datetime(2020, 1, 1)  # 조회 시작\nEND: datetime = datetime(2024, 12, 31)  # 조회 끝\n\n# 한글 폰트 설정\nplt.rcParams[\"font.family\"] = \"Pretendard Variable\"\nplt.rcParams[\"axes.unicode_minus\"] = False"
  },
  {
    "objectID": "posts/ipynb/da_visualization_calplot.html#평균-기온-캘린더-플롯",
    "href": "posts/ipynb/da_visualization_calplot.html#평균-기온-캘린더-플롯",
    "title": "Calplot: 파이썬으로 만드는 멋진 캘린더 히트맵",
    "section": "4.1 평균 기온 캘린더 플롯",
    "text": "4.1 평균 기온 캘린더 플롯\ncalplot을 사용해 연도별 평균 기온을 캘린더 형태로 시각화합니다. 색상 맵은 coolwarm으로 설정해 표현합니다.\n\n# 데이터 시각화\ncalplot.calplot(\n    weather_data[\"tavg\"],\n    cmap=\"coolwarm\",\n    yearascending=True,\n    yearlabel_kws={\"fontsize\": 16},\n    suptitle=f\"{NAME} 평균 기온\",\n    suptitle_kws={\"fontsize\": 20, \"y\": 1.05},\n)\nplt.show()\n\n\n\n\n\n\n\n\n위 시각화 결과를 보면 2021년 1월달의 평균 기온이 유난히 낮았다는 것과 2024년 12월의 평균기온이 상당히 높다는 것을 알 수 있습니다. 그리고 여름이 계속 더워지고 있다는 추세가 보이는 것 같습니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_calplot.html#일교차-캘린더-플롯",
    "href": "posts/ipynb/da_visualization_calplot.html#일교차-캘린더-플롯",
    "title": "Calplot: 파이썬으로 만드는 멋진 캘린더 히트맵",
    "section": "4.2 일교차 캘린더 플롯",
    "text": "4.2 일교차 캘린더 플롯\n일반적으로 일교차는 봄과 가을이 심하다고 알고있는데 실제로 그런지 확인해보겠습니다. 일교차 데이터를 캘린더 플롯으로 표현하고 색상 맵은 YlGn으로 설정해 녹색 계열로 변화를 나타냅니다.\n\n# 데이터 시각화\ncalplot.calplot(\n    weather_data[\"diurnal_range\"],\n    cmap=\"YlGn\",\n    yearascending=True,\n    yearlabel_kws={\"fontsize\": 16},\n    suptitle=f\"{NAME} 일교차\",\n    suptitle_kws={\"fontsize\": 20, \"y\": 1.05},\n)\nplt.show()\n\n\n\n\n\n\n\n\n일교차는 더운 기간(7-9월) 제외하고는 패턴을 찾기 힘들어 보입니다. 그리고 가을 보다 봄(3-4월)이 확실히 일교차가 심한 것을 알 수 있네요."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html",
    "href": "posts/ipynb/da_scanpy_workshop_06.html",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "",
    "text": "세포 유형의 발달 궤적을 분석하고 시각화하는 것은 생물학 연구에서 매우 중요한 과정입니다. 특히 단일 세포 전사체 분석(single-cell transcriptomics)의 발전으로, 개별 세포의 발달 경로와 상태 변화를 더 정밀하게 추적할 수 있게 되었습니다. 이러한 분석을 위해 다양한 기법들이 사용되는데, 그 중에서도 PAGA(Partition-based Graph Abstraction)는 매우 유용한 도구로 자리 잡고 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#데이터-불러오기",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#데이터-불러오기",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "3.1 데이터 불러오기",
    "text": "3.1 데이터 불러오기\n다운로드한 trajectory_seurat_filtered.h5ad파일을 불러옵니다.\n\nadata = sc.read_h5ad(\"./input/trajectory/trajectory_seurat_filtered.h5ad\")\nadata\n\nAnnData object with n_obs × n_vars = 5828 × 3585\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'batches', 'dataset', 'nCount', 'nUMI', 'pMito', 'pRibo', 'pHb', 'pChY', 'pChX', 'pnonXY', 'pPCG', 'pNCG', 'pMito_UMIs', 'pRibo_UMIs', 'pHb_UMIs', 'pChY_UMIs', 'pChX_UMIs', 'pnonXY_UMIs', 'pPCG_UMIs', 'pNCG_UMIs', 'SEL_nCount', 'SEL_nUMI', 'SEL_pMito', 'SEL_pRibo', 'SEL_pHb', 'SEL_pChY', 'SEL_pChX', 'SEL_pnonXY', 'SEL_pPCG', 'SEL_pNCG', 'SEL_pMito_UMIs', 'SEL_pRibo_UMIs', 'SEL_pHb_UMIs', 'SEL_pChY_UMIs', 'SEL_pChX_UMIs', 'SEL_pnonXY_UMIs', 'SEL_pPCG_UMIs', 'SEL_pNCG_UMIs', 'S.Score', 'G2M.Score', 'Phase', 'metadata_clusters', 'clusters', 'outlier', 'subgroups', 'clusters_use'\n    var: 'features'\n    obsm: 'X_harmony', 'X_harmony_Phase', 'X_pca', 'X_umap', 'X_umap3d'\n    varm: 'PCs'\n\n\n위 출력을 통해 adata파일에 유맵과 클러스터 정보가 들어 있다는 것을 확인 할 수 있습니다. 이 정보를 다시 사용해도 되지만 여기서는 scanpy를 사용해 다시 분석할 예정입니다.\n\n# X 행렬에 로그 정규화된 카운트값이 들어있는지 확인합니다.\nprint(adata.X[:5, :5])\n\n  (0, 4)    0.11622072805743532\n  (2, 1)    0.09413397843954842\n  (3, 1)    0.08438841021254412\n  (3, 4)    0.08438841021254412\n  (4, 1)    0.14198147850903975"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#데이터-탐색하기",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#데이터-탐색하기",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "3.2 데이터 탐색하기",
    "text": "3.2 데이터 탐색하기\nUMAP 플랏을 그려서 간단하게 살펴봅니다.\n데이터 집합을 분석할 때는 무슨 일이 일어나고 있는지, 데이터에서 보이는 클러스터는 무엇이며, 가장 중요한 것은 클러스터가 서로 어떻게 연관되어 있는지 이해하는 것이 중요합니다. 그럼, 데이터를 조금 살펴봅시다. 이 표의 도움을 받아 데이터 집합에서 이러한 핵심 마커를 나타내는 클러스터 번호를 적어 보세요."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#다시-umap-그리기",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#다시-umap-그리기",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "3.3 다시 UMAP 그리기",
    "text": "3.3 다시 UMAP 그리기\nScanpy를 사용해 클러스터링과 유맵을 다시 실행합니다. 데이터에 이미 포함된 차원감소 데이터인 X_harmony_Phase를 시작점으로 UMAP을 새로 그립니다.\n\n# 먼저 기존에 들어있던 umap 정보를 다른 이름으로 저장합니다.\nadata.obsm[\"X_umap_old\"] = adata.obsm[\"X_umap\"]\n\nsc.pp.neighbors(adata, n_pcs=30, n_neighbors=20, use_rep=\"X_harmony_Phase\")\nsc.tl.umap(adata, min_dist=0.4, spread=3)\n# sc.tl.umap(adata, min_dist=0.6, spread=1.5)\n# sc.pl.umap(\n#     adata,\n#     color=[\"clusters\"],\n#     legend_loc=\"on data\",\n#     legend_fontsize=\"small\",\n#     edges=True,\n# )\n\n# 다시 클러스터링 하기\nsc.tl.leiden(adata, key_added=\"leiden_1.0\", resolution=1.0)  # default resolution in 1.0\nsc.tl.leiden(adata, key_added=\"leiden_1.2\", resolution=1.2)  # default resolution in 1.0\nsc.tl.leiden(adata, key_added=\"leiden_1.4\", resolution=1.4)  # default resolution in 1.0\n\nsc.pl.umap(\n    adata,\n    color=[\"leiden_1.0\", \"leiden_1.2\", \"leiden_1.4\", \"clusters\"],\n    legend_loc=\"on data\",\n    legend_fontsize=\"xx-small\",\n    ncols=2,\n)\n\n\n\n\n\n\n\n\n클러스터로 분류는 되어있지만 각각이 어떤 세포 유형인지는 알 수 없는 아래 표의 마커 유전자 정보를 가지고 세포유형을 지정하도록 하겠습니다.\n\n\n\nMarker\nCell Type\n\n\n\n\nCd34\nHSC progenitor\n\n\nMs4a1\nB cell lineage\n\n\nCd3e\nT cell lineage\n\n\nLtf\nGranulocyte lineage\n\n\nCst3\nMonocyte lineage\n\n\nMcpt8\nMast Cell lineage\n\n\nAlas2\nRBC lineage\n\n\nSiglech\nDendritic cell lineage\n\n\nC1qc\nMacrophage cell lineage\n\n\nPf4\nMegakaryocyte cell lineage\n\n\n\n\nmarkers = [\n    \"Cd34\",\n    \"Alas2\",\n    \"Pf4\",\n    \"Mcpt8\",\n    \"Ltf\",\n    \"Cst3\",\n    \"Siglech\",\n    \"C1qc\",\n    \"Ms4a1\",\n    \"Cd3e\",\n]\n\nsc.pl.umap(adata, color=markers, use_raw=False, ncols=3)\n\n\n\n\n\n\n\n\n위 시각화 결과를 참고해 leiden_1.4 클러스터링 결과에 세포 유형을 지정합니다.\n\n# 클러스터 이름 변경을 위한 매핑 딕셔너리\ncluster_mapping = {\n    \"10\": \"10_megakaryo\",  # Pf4\n    \"17\": \"17_macro\",  # C1qc\n    \"11\": \"11_eryth\",  # Alas2\n    \"18\": \"18_dend\",  # Siglech\n    \"13\": \"13_mast\",  # Mcpt8\n    \"0\": \"0_mono\",  # Cts3\n    \"1\": \"1_gran\",  # Ltf\n    \"9\": \"9_gran\",  # (\"1_gran\"과 동일하지만 다른 클러스터)\n    \"14\": \"14_TC\",  # Cd3e\n    \"16\": \"16_BC\",  # Ms4a1\n    \"8\": \"8_progen\",  # Cd34\n    \"4\": \"4_progen\",  # (another progenitor cluster)\n    \"5\": \"5_progen\",  # (another progenitor cluster)\n}\n\n# 일관성을 위해 leiden_1.4 열을 문자열로 변환하는 코드\nannot = pd.DataFrame(adata.obs[\"leiden_1.4\"].astype(\"string\"))\n\n# 매핑을 적용하여 클러스터 이름을 바꾸고 나머지는 변경하지 않습니다.\nannot[\"annot\"] = annot[\"leiden_1.4\"].map(cluster_mapping).fillna(annot[\"leiden_1.4\"])\n\n# 새 주석으로 데이터 객체를 업데이트합니다.\nadata.obs[\"annot\"] = annot[\"annot\"].astype(\"category\")\n\n# 새 주석을 사용해 UMAP 플롯하기\nsc.pl.umap(\n    adata,\n    color=[\"annot\", \"leiden_1.4\"],\n    legend_loc=\"on data\",\n    ncols=2,\n    legend_fontsize=\"xx-small\",\n)\n# 어노테이션의 값 개수를 표시합니다.\n# print(annot[\"annot\"].value_counts())"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#그래프-엣지-필터링",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#그래프-엣지-필터링",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "4.1 그래프 엣지 필터링",
    "text": "4.1 그래프 엣지 필터링\n먼저 엣지와 UMAP을 겹쳐서 좀 더 자세히 살펴봅시다.\n\nwith plt.rc_context({\"figure.figsize\": (6, 6)}):\n    sc.pl.umap(\n        adata,\n        edges=True,\n        color=\"annot\",\n        legend_loc=\"on data\",\n        legend_fontsize=\"xx-small\",\n    )\n\n\n\n\n\n\n\n\n위 그림에서 알 수 있듯이, 관련 없는 클러스터 사이의 엣지가 보입니다. 따라서 더 적은 수의 이웃(n_neighbors=5)로 다시 그려 보겠습니다.\n\nsc.pp.neighbors(adata, n_neighbors=5, use_rep=\"X_harmony_Phase\", n_pcs=30)\n\nwith plt.rc_context({\"figure.figsize\": (6, 6)}):\n    sc.pl.umap(\n        adata,\n        edges=True,\n        color=\"annot\",\n        legend_loc=\"on data\",\n        legend_fontsize=\"xx-small\",\n    )\n\n\n\n\n\n\n\n\n불필요한 그래프 엣지가 훨씬 줄어들었습니다. 이제 다시 PAGA를 실행합니다.\n\nsc.tl.draw_graph(adata, init_pos=\"X_umap\")\n\nwith plt.rc_context({\"figure.figsize\": (6, 6)}):\n    sc.pl.draw_graph(adata, color=\"annot\", legend_loc=\"on data\", legend_fontsize=\"xx-small\")\n\n\n\n\n\n\n\n\n\nsc.tl.paga(adata, groups=\"annot\")\nwith plt.rc_context({\"figure.figsize\": (5, 5)}):\n    sc.pl.paga(adata, color=\"annot\", edge_width_scale=0.3)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#paga-초기화해서-임베딩하기",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#paga-초기화해서-임베딩하기",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "4.2 PAGA 초기화해서 임베딩하기",
    "text": "4.2 PAGA 초기화해서 임베딩하기\nPAGA 레이아웃의 다른 시작 위치를 사용하여 그래프를 다시 그릴 수 있습니다. 다음은 UMAP에서도 가능합니다.\n\nsc.tl.draw_graph(adata, init_pos=\"paga\")\n\nwith plt.rc_context({\"figure.figsize\": (5, 5)}):\n    sc.pl.draw_graph(adata, color=[\"annot\"], legend_loc=\"on data\", legend_fontsize=\"xx-small\")\n\n\n\n\n\n\n\n\n이제 모든 마커 유전자를 의미 있는 레이아웃으로 볼 수 있습니다.\n\nwith plt.rc_context({\"figure.figsize\": (3, 3)}):\n    sc.pl.draw_graph(adata, color=markers, use_raw=False)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_06.html#두-그래프-비교",
    "href": "posts/ipynb/da_scanpy_workshop_06.html#두-그래프-비교",
    "title": "Scanpy로 scRNA-seq 분석 06",
    "section": "4.3 두 그래프 비교",
    "text": "4.3 두 그래프 비교\n\nwith plt.rc_context({\"figure.figsize\": (5, 5)}):\n    sc.pl.paga_compare(\n        adata,\n        threshold=0.03,\n        title=\"\",\n        right_margin=0.2,\n        size=10,\n        edge_width_scale=0.5,\n        legend_fontsize=10,\n        fontsize=10,\n        frameon=False,\n        edges=True,\n    )\n\n# with plt.rc_context({\"figure.figsize\": (5, 5)}):\n#     plt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html",
    "href": "posts/ipynb/ml_causal_inference_rules.html",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "",
    "text": "# /// script\n# requires-python = \"&gt;=3.9\"\n# dependencies = [\n#     \"matplotlib\",\n#     \"numpy\",\n#     \"pandas\",\n#     \"scipy\",\"\"\n# ]\n# ///\n현실 데이터에서 인과 관계를 관찰할 수 있는 연관성 및 상관관계에 대한 기본 규칙에 대해 알아봅니다. 각각의 규칙을 최대한 쉽게 이해할 수 있도록 간단하게 설명한다음 매우 간단한 파이썬 코드를 사용해 어떻게 작동하는지 살펴봅니다.\n먼저 네 가지 기본 인과 관계 구조를 살펴보고 이후에 기본 규칙에 대해서 알아보겠습니다. 실제로 데이터를 분석할때에는 여기서 살펴본 규칙들을 복합적으로 사용해야 합니다. 따라서 인과 관계 추론에 하여 배우려면 Hernán과 Robins의 책 과 HarvardX 의 인과 관계 추론 과정을 배우는 것을 추천드립니다."
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#완전한-독립",
    "href": "posts/ipynb/ml_causal_inference_rules.html#완전한-독립",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "1.1 완전한 독립",
    "text": "1.1 완전한 독립\nA 와 B 사이에는 경로를 추적할 수 없습니다.\n\n\n\n\n\nflowchart LR\n    A~~~B"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#체인-chain",
    "href": "posts/ipynb/ml_causal_inference_rules.html#체인-chain",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "1.2 2. 체인; Chain",
    "text": "1.2 2. 체인; Chain\n인과 관계 사슬에서 모든 화살표가 A 에서 B 를 가리키는 방향 경로를 추적할 수 있습니다. 사슬 경로는 “열린 경로”라고도 하며, 이러한 유형의 그래프는 A 와 B 사이의 상관 관계를 전달합니다 (규칙 2 참조). 체인에 세 개 이상의 변수가 포함된 경우, A 와 B 를 연결하는 변수 M 을 매개변수라고 부르기도 합니다.\n\n\n\n\n\nflowchart LR\n    A--&gt;B"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#포크-fork",
    "href": "posts/ipynb/ml_causal_inference_rules.html#포크-fork",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "1.3 3. 포크; Fork",
    "text": "1.3 3. 포크; Fork\n인과관계 포크에서 방향이 없는 경로 (모든 화살표가 같은 방향으로 달리지 않음) 는 공통의 인과관계 조상인 C 를 통해 A 에서 B 로 추적할 수 있으며, C 를 종종 교란 변수라고 부릅니다. 포크 경로는 “개방형”이며 A 와 B 사이의 상관관계를 전달합니다 (규칙 3 참조).\n\n\n\n\n\nflowchart LR\n    C--&gt;A\n    C--&gt;B\n    A~~~B"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#콜라이더-collider",
    "href": "posts/ipynb/ml_causal_inference_rules.html#콜라이더-collider",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "1.4 4. 콜라이더; Collider",
    "text": "1.4 4. 콜라이더; Collider\n인과관계 콜라이더에서는 방향이 지정되지 않은 경로 (모든 화살표가 같은 방향으로 달리는 것은 아님) 가 인과관계의 하위 항목 D 를 통해 A 에서 B 로 추적될 수 있으며, D 를 흔히 콜라이더 변수라고 부릅니다. 콜라이더 경로는 “닫힌” 경로이며 A 와 B 사이의 상관관계를 전달하지 않습니다 (규칙 1 참조).\n\n\n\n\n\nflowchart LR\n    A~~~B\n    B--&gt;D\n    A--&gt;D"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#중요한-가정",
    "href": "posts/ipynb/ml_causal_inference_rules.html#중요한-가정",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.1 중요한 가정",
    "text": "2.1 중요한 가정\n\n위의 규칙은 몇 가지 중요한 가정이 충족되는 경우에만 적용되며, 아래에 나열하지만 자세히 설명하지는 않겠습니다\n허위 상관관계가 없습니다: 상관관계는 무작위적인 우연에 의해 발생하는 것이 아닙니다. 큰 수의 법칙에 따르면 데이터가 많을수록 이 가정은 더 신뢰할 수 있습니다.\n일관성: 사용자가 보는 A의 값은 A의 실제 값, 즉 비교 대상인 치료의 값이 데이터의 치료 버전과 일치하는 잘 정의된 개입에 해당합니다.\n교환 가능성: 연구자가 결정하지는 않았지만 모든 치료 가치를 받을 수 있는 조건부 확률은 측정된 공변인에 의해서만 달라집니다.\n양성: L에 대한 조건부 치료의 모든 값을 받을 확률은 0보다 큰 양수입니다.\n충실성: 인과 효과는 데이터에서 평균을 0으로 만드는 방식으로 그룹에 따라 달라지지 않습니다. A가 50%는 긍정적인 영향을 미치고 50%는 똑같이 강력한 부정적인 영향을 미치지 않으며, 이 경우 전체 인구에서 평균적으로 0의 영향을 미칩니다.\n\n이러한 가정 중 하나가 충족되지 않으면 이러한 규칙에서 설명하는 인과 효과와 관찰 데이터 간의 관계가 잠재적으로 깨질 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-1-독립-변수는-상관관계가-없음",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-1-독립-변수는-상관관계가-없음",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.2 규칙 1: 독립 변수는 상관관계가 없음",
    "text": "2.2 규칙 1: 독립 변수는 상관관계가 없음\n\n\n\n\n\nflowchart LR\n    A~~~B\n\n\n\n\n\n\nA 와 B 가 인과적으로 독립적이라면 데이터에서 서로 연관되지 않습니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import stats\n\nplt.style.use(\"ggplot\")\n\n# Rule 1\nn = 10000  # Number of data points\na = np.random.normal(0, 1, n)  # A is a random variable\nb = np.random.normal(0, 1, n)  # B is a random variable\n\n# Calculate correlation\ncorrelation = np.corrcoef(a, b)[0, 1]\n\n# Create scatter plot\nplt.figure(figsize=(5, 5))\nplt.scatter(a, b, s=2, alpha=0.5)\n\n# Add title and labels\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\n\n# Add correlation text to the plot\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation: {correlation:.5f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A~~~B\n    B--&gt;D\n    A--&gt;D\n\n\n\n\n\n\nA 와 B 는 인과적 자손 (인과적 충돌자) 을 공유하더라도 인과적으로 독립적이며, D. 공유된 자손의 두 독립적 원인은 서로 상관관계가 없습니다 (규칙 7 은은 제외)."
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-2-인과적-영향은-상관관계를-생성합니다",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-2-인과적-영향은-상관관계를-생성합니다",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.3 규칙 2: 인과적 영향은 상관관계를 생성합니다",
    "text": "2.3 규칙 2: 인과적 영향은 상관관계를 생성합니다\n\n\n\n\n\nflowchart LR\n    A--&gt;B\n\n\n\n\n\n\nA 가 B 의 원인인 경우 또는 B 가 A 의 원인인 경우 데이터에서 A 와 B 는 상관관계가 있습니다.\n\n# Rule 2\n\nn = 10000  # Number of data points\na = np.random.normal(0, 1, n)  # A is a random variable\nb = a + np.random.normal(0, 1, n)  # B is a random variable\n\n# Calculate correlation\ncorrelation = np.corrcoef(a, b)[0, 1]\n\n# Create scatter plot\nplt.figure(figsize=(5, 5))\nplt.scatter(a, b, s=2, alpha=0.5)\n\n# Add title and labels\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\n\n# Add correlation text to the plot\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation: {correlation:.5f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.show()\n\n\n\n\n\n\n\n\n이런 인과관계는 A가 M을 유발하고 M이 다시 B를 유발하는 (중계하는)경우에도 적용됩니다.\n\n\n\n\n\nflowchart LR\n    A--&gt;M\n    M--&gt;B\n\n\n\n\n\n\n\n\n# Rule 2 (mediation)\n\nn = 10000  # Number of data points\na = np.random.normal(0, 1, n)  # A is a random variable\nm = a + np.random.normal(0, 1, n)  # M is a function of A\nb = m + np.random.normal(0, 1, n)  # B is a function of M\n\n# Calculate correlation\ncorrelation = np.corrcoef(a, b)[0, 1]\n\n# Create scatter plot\nplt.figure(figsize=(5, 5))\nplt.scatter(a, b, s=2, alpha=0.5)\n\n# Add title and labels\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\n\n# Add correlation text to the plot\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation: {correlation:.5f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-3-교락은-상관-관계를-만듭니다.",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-3-교락은-상관-관계를-만듭니다.",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.4 규칙 3: 교락은 상관 관계를 만듭니다.",
    "text": "2.4 규칙 3: 교락은 상관 관계를 만듭니다.\nA와 B가 공통 조상 C(인과적 포크)를 공유하는 경우, A와 B는 데이터에서 상관관계가 생깁니다. 이러한 현상을 흔히 교락 또는 ’제3의 변수 문제’라고 합니다.\n\n\n\n\n\nflowchart LR\n    C--&gt;A\n    A~~~B\n    C--&gt;B\n\n\n\n\n\n\n\n\n# Rule 3\nn = 10000  # Number of data points\nc = np.random.normal(0, 1, n)  #  C is a random variable\na = c + np.random.normal(0, 1, n)  # A is a function of C\nb = c + np.random.normal(0, 1, n)  # B is a function of C\n\n# Calculate correlation\ncorrelation = np.corrcoef(a, b)[0, 1]\n\n# Create scatter plot\nplt.figure(figsize=(5, 5))\nplt.scatter(a, b, s=2, alpha=0.5)\n\n# Add title and labels\nplt.xlabel(\"A\")\nplt.ylabel(\"B\")\n\n# Add correlation text to the plot\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation: {correlation:.5f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.show()\n\n\n\n\n\n\n\n\n이 규칙은 C가 A 또는 B에 미치는 영향이 다른 변수를 통해 매개되는 경우에도 적용됩니다.\n\n\n\n\n\nflowchart LR\n    C--&gt;M\n    M--&gt;A\n    A~~~N\n    C--&gt;N\n    N--&gt;B"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-4-무작위-조작은-인과적-영향으로부터-변수를-보호합니다.",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-4-무작위-조작은-인과적-영향으로부터-변수를-보호합니다.",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.5 규칙 4: 무작위 조작은 인과적 영향으로부터 변수를 보호합니다.",
    "text": "2.5 규칙 4: 무작위 조작은 인과적 영향으로부터 변수를 보호합니다.\nA가 조작 변수인 무작위 대조 실험에서처럼 A의 값을 무작위로 할당할 수 있는 경우 다른 변수가 A에 영향을 줄 수 없습니다.\n\n\n\n\n\nflowchart LR\n    C1--xA[\"do(A)\"]\n    C2--xA\n    C3--xA\n\n\n\n\n\n\n\ndo(A) 표기는 A의 값을 무작위화하는 것을 의미합니다. 달리 말하면, 완전한 실험 통제와 무작위화를 통해 어떤 변수도 A의 값에 영향을 미치지 못하도록 하는 것입니다."
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-5-교란-요인에-대한-통제는-해당-교란-요인으로-인해-발생하는-상관관계를-차단합니다.",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-5-교란-요인에-대한-통제는-해당-교란-요인으로-인해-발생하는-상관관계를-차단합니다.",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.6 규칙 5: 교란 요인에 대한 통제는 해당 교란 요인으로 인해 발생하는 상관관계를 차단합니다.",
    "text": "2.6 규칙 5: 교란 요인에 대한 통제는 해당 교란 요인으로 인해 발생하는 상관관계를 차단합니다.\nA와 B가 공통 조상 C(인과적 포크)를 공유하는 경우, C를 제어하면 C에 의해 생성된 A와 B 간의 교란 상관관계(규칙 3)가 제거됩니다.\n\n\n\n\n\nflowchart LR\n    C{\"if(C)\"}--&gt;A\n    A~~~B\n    C--&gt;B\n\n\n\n\n\n\n\n# Rule 5\n\nn = 10000  # Number of data points\nc = np.random.normal(0, 1, n)  # C is a random variable\na = c + np.random.normal(0, 1, n)  # A is a function of C\nb = c + np.random.normal(0, 1, n)  # B is a function of C\n\n# Perform linear regression\nslope_a, intercept_a, _, _, _ = stats.linregress(c, a)\nslope_b, intercept_b, _, _, _ = stats.linregress(c, b)\n\n# Calculate residuals\nresiduals_a = a - (slope_a * c + intercept_a)\nresiduals_b = b - (slope_b * c + intercept_b)\n\n# Create scatter plot of residuals\nplt.figure(figsize=(5, 5))\nplt.scatter(residuals_a, residuals_b, s=2, alpha=0.5)\nplt.title(\"Scatter Plot of Residuals(Rule 5)\")\nplt.xlabel(\"Residuals of A ~ C\")\nplt.ylabel(\"Residuals of B ~ C\")\n\n# Calculate and display correlation of residuals\ncorrelation = np.corrcoef(residuals_a, residuals_b)[0, 1]\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation of Residuals: {correlation:.4f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-6-매개자를-통제하면-매개된-인과-효과로-인해-발생하는-상관관계가-차단됩니다.",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-6-매개자를-통제하면-매개된-인과-효과로-인해-발생하는-상관관계가-차단됩니다.",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.7 규칙 6: 매개자를 통제하면 매개된 인과 효과로 인해 발생하는 상관관계가 차단됩니다.",
    "text": "2.7 규칙 6: 매개자를 통제하면 매개된 인과 효과로 인해 발생하는 상관관계가 차단됩니다.\n\n\n\n\n\nflowchart LR\n    A--&gt;M\n    M--&gt;B \n\n\n\n\n\n\nA가 M의 원인이고 M이 B의 원인인 경우, M을 통제하면 매개 인과 효과(규칙 2)에 의해 생성된 A와 B 간의 상관관계가 제거됩니다.\n\n# Rule 6\n\nn = 10000  # Number of data points\na = np.random.normal(0, 1, n)  # A is a random variable\nm = a + np.random.normal(0, 1, n)  # M is a function of A\nb = m + np.random.normal(0, 1, n)  # B is a function of M\n\n# Perform linear regression\nslope_a, intercept_a, _, _, _ = stats.linregress(m, a)\nslope_b, intercept_b, _, _, _ = stats.linregress(m, b)\n\n# Calculate residuals\nresiduals_a = a - (slope_a * m + intercept_a)\nresiduals_b = b - (slope_b * m + intercept_b)\n\n# Create scatter plot of residuals\nplt.figure(figsize=(5, 5))\nplt.scatter(residuals_a, residuals_b, s=2, alpha=0.5)\nplt.title(\"Scatter Plot of Residuals (Rule 6)\")\nplt.xlabel(\"Residuals of A ~ M\")\nplt.ylabel(\"Residuals of B ~ M\")\n\n# Calculate and display correlation of residuals\ncorrelation = np.corrcoef(residuals_a, residuals_b)[0, 1]\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation of Residuals: {correlation:.4f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-7-콜라이더를-제어하면-상관-관계로-이어짐",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-7-콜라이더를-제어하면-상관-관계로-이어짐",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.8 규칙 7: 콜라이더를 제어하면 상관 관계로 이어짐",
    "text": "2.8 규칙 7: 콜라이더를 제어하면 상관 관계로 이어짐\n\n\n\n\n\nflowchart LR\n    A~~~B\n    B--&gt;D\n    A--&gt;D \n\n\n\n\n\n\nA와 B가 인과 관계의 하위 항목(콜라이더) D를 공유하고 D를 제어하면 데이터에서 A와 B가 상관 관계를 갖게 됩니다. 이를 흔히 “콜라이더에 대한 조건부” 또는 콜라이더 편향이라고 합니다.\n\n# Rule 7\n\nn = 10000  # Number of data points\na = np.random.normal(0, 1, n)  # A is a random variable\nb = np.random.normal(0, 1, n)  # B is a random variable\nd = a + b + np.random.normal(0, 1, n)  # D is a function of A and B\n\n# Perform linear regression\nslope_a, intercept_a, _, _, _ = stats.linregress(d, a)\nslope_b, intercept_b, _, _, _ = stats.linregress(d, b)\n\n# Calculate residuals\nresiduals_a = a - (slope_a * d + intercept_a)\nresiduals_b = b - (slope_b * d + intercept_b)\n\n# Create scatter plot of residuals\nplt.figure(figsize=(5, 5))\nplt.scatter(residuals_a, residuals_b, s=2, alpha=0.5)\nplt.title(\"Scatter Plot of Residuals (Rule 7)\")\nplt.xlabel(\"Residuals of A ~ D\")\nplt.ylabel(\"Residuals of B ~ D\")\n\n# Calculate and display correlation of residuals\ncorrelation = np.corrcoef(residuals_a, residuals_b)[0, 1]\nplt.text(\n    0.05,\n    0.95,\n    f\"Correlation of Residuals: {correlation:.4f}\",\n    transform=plt.gca().transAxes,\n    verticalalignment=\"top\",\n    bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.5},\n)\n\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_causal_inference_rules.html#규칙-8-인과-관계에-있는-자손에-대한-제어는-조상에-대한-부분적-제어입니다.",
    "href": "posts/ipynb/ml_causal_inference_rules.html#규칙-8-인과-관계에-있는-자손에-대한-제어는-조상에-대한-부분적-제어입니다.",
    "title": "인과 관계 추론을 위한 기본 규칙",
    "section": "2.9 규칙 8: 인과 관계에 있는 자손에 대한 제어는 조상에 대한 (부분적) 제어입니다.",
    "text": "2.9 규칙 8: 인과 관계에 있는 자손에 대한 제어는 조상에 대한 (부분적) 제어입니다.\nB가 A의 자손이고 B가 제어되는 경우, A도 (부분적으로) 제어됩니다.\n\n\n\n\n\nflowchart LR\n    A--&gt;B\n\n\n\n\n\n\nB를 통제할 때 A를 통제하는 정도는 일반적으로 A가 B를 얼마나 확실하게 유발하는지에 따라 달라집니다.\n아래 예에서 C는 A와 B의 교란 변수이지만 CM을 통제하면 교란 영향을 부분적으로 차단할 수 있습니다.\n\n\n\n\n\nflowchart LR\n    C--&gt;A\n    A~~~B\n    C--&gt;B\n    C--&gt;D[\"CM\"]\n\n\n\n\n\n\nCM이 C의 약간 신뢰할 수 있는 측정값인 경우 CM을 통제하면 A와 B 간의 상관관계가 일부 제거되지만 C를 통제할 때만큼은 아닙니다:\n\n# Rule 8\n\nn = 10000  # Number of data points\nc = np.random.normal(0, 1, n)  # C is a random variable\na = 2 * c + np.random.normal(0, 1, n)  # A is a function of C\nb = 2 * c + np.random.normal(0, 1, n)  # B is a function of C\ncm = 2 * c + np.random.normal(0, 1, n)  # CM is a function of C\n\n# Perform linear regressions\nslope_ac, intercept_ac, _, _, _ = stats.linregress(c, a)\nslope_bc, intercept_bc, _, _, _ = stats.linregress(c, b)\nslope_acm, intercept_acm, _, _, _ = stats.linregress(cm, a)\nslope_bcm, intercept_bcm, _, _, _ = stats.linregress(cm, b)\n\n# Calculate residuals\nresiduals_ac = a - (slope_ac * c + intercept_ac)\nresiduals_bc = b - (slope_bc * c + intercept_bc)\nresiduals_acm = a - (slope_acm * cm + intercept_acm)\nresiduals_bcm = b - (slope_bcm * cm + intercept_bcm)\n\n# Create subplots\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))\n\n\n# Function to add correlation text to plot\ndef add_correlation_text(ax, x, y):\n    corr = np.corrcoef(x, y)[0, 1]\n    ax.text(\n        0.05,\n        0.95,\n        f\"Correlation: {corr:.4f}\",\n        transform=ax.transAxes,\n        verticalalignment=\"top\",\n        bbox={\"boxstyle\": \"round\", \"facecolor\": \"white\", \"alpha\": 0.7},\n    )\n\n\n# Plot 1: No control\nax1.scatter(a, b, s=2, alpha=0.5)\nax1.set_title(\"No control\")\nax1.set_xlabel(\"A\")\nax1.set_ylabel(\"B\")\nadd_correlation_text(ax1, a, b)\n\n# Plot 2: Controlling for CM\nax2.scatter(residuals_acm, residuals_bcm, s=2, alpha=0.5)\nax2.set_title(\"Controlling for CM\")\nax2.set_xlabel(\"Residuals of A ~ CM\")\nax2.set_ylabel(\"Residuals of B ~ CM\")\nadd_correlation_text(ax2, residuals_acm, residuals_bcm)\n\n# Plot 3: Controlling for C\nax3.scatter(residuals_ac, residuals_bc, s=2, alpha=0.5)\nax3.set_title(\"Controlling for C\")\nax3.set_xlabel(\"Residuals of A ~ C\")\nax3.set_ylabel(\"Residuals of B ~ C\")\nadd_correlation_text(ax3, residuals_ac, residuals_bc)\n\n# Adjust layout and display\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n상관관계가 반드시 선형적 상관관계를 의미하는 것은 아닙니다.\n이 글에서는 “상관관계”라는 용어를 많이 사용합니다. 많은 사람들에게 상관관계라는 용어는 선형적 상관관계와 동의어입니다. 하지만 제가 의미하는 바는 그렇지 않습니다. 여기서 “상관관계”는 단순히 “상호 관계”, “연관성” 또는 “상호 정보”를 의미합니다. A와 B가 상관관계가 있다는 것은 A에 어떤 일이 발생하면 B에도 체계적으로 어떤 일이 발생한다는 의미일 뿐입니다.\n예를 들어, 규칙 2는 A가 B를 유발할 때 A와 B가 선형적으로 상관관계가 있다는 것을 의미하는 것이 아니라, A가 변하면 B가 어떤 식으로든 체계적으로 변한다는 것을 의미합니다.\n간단하게 설명하기 위해 모든 예제 R 코드에서 선형 상관관계를 사용했습니다. 그러나 실제 생활에서 우리가 기대하는 상관 관계/연관 관계/상호 정보의 패턴은 전적으로 관련된 인과 관계의 기능적 형태에 따라 달라집니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html",
    "href": "posts/ipynb/da_scanpy_workshop_04.html",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "",
    "text": "클러스터링으로 scRNA-seq 데이터를 여러 그룹으로 나눈 뒤에는 해당 그룹이 어떤 세포인지 아는 것은 분석 결과를 해석할 때 중요합니다. 세포 유형을 예측하는 방법에는 크게 두 가지 방법이 있습니다. 레퍼런스 scRNA-seq 데이터를 사용해 유사도를 비교하는 방법과 알려진 마커 유전자를 사용해 직접 세포 유형을 지정하는 방법입니다. 레퍼런스 데이터는 이미 세포 유형의 전사체 표현 데이터를 말합니다. 이 데이터를 사용하여 클러스터링된 세포들의 전사체 표현 패턴을 레퍼런스 데이터와 비교하여 가장 유사한 세포 유형을 예측합니다. 여기서는 가장 간단한 ingest 방법을 사용해봅니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#비교-데이터-불러오기",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#비교-데이터-불러오기",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "2.1 비교 데이터 불러오기",
    "text": "2.1 비교 데이터 불러오기\nscanpy.datasets함수를 사용해 레퍼런스로 사용할 pbmc3k데이터를 불러옵니다. 여기서 주의할 점은 레퍼런스 데이터와 실험 데이터는 비슷한 실험 조건을 가져야 한다는 것입니다. 예를 들어, 레퍼런스 데이터가 10X Genomics의 Chromium 플랫폼으로 생성되었다면, 실험 데이터도 동일한 플랫폼으로 생성되어야 합니다. 이는 플랫폼 간의 차이로 인해 발생하는 바이어스를 최소화하기 위함입니다.\n\nadata_ref = sc.datasets.pbmc3k_processed()\nadata_ref.obs[\"sample\"] = \"pbmc3k\"\nadata_ref\n\nAnnData object with n_obs × n_vars = 2638 × 1838\n    obs: 'n_genes', 'percent_mito', 'n_counts', 'louvain', 'sample'\n    var: 'n_cells'\n    uns: 'draw_graph', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'\n    obsm: 'X_pca', 'X_tsne', 'X_umap', 'X_draw_graph_fr'\n    varm: 'PCs'\n    obsp: 'distances', 'connectivities'\n\n\n\nprint(adata_ref.shape)\nadata_ref.obs.head()\n\n(2638, 1838)\n\n\n\n\n\n\n\n\n\nn_genes\npercent_mito\nn_counts\nlouvain\nsample\n\n\nindex\n\n\n\n\n\n\n\n\n\nAAACATACAACCAC-1\n781\n0.030178\n2419.0\nCD4 T cells\npbmc3k\n\n\nAAACATTGAGCTAC-1\n1352\n0.037936\n4903.0\nB cells\npbmc3k\n\n\nAAACATTGATCAGC-1\n1131\n0.008897\n3147.0\nCD4 T cells\npbmc3k\n\n\nAAACCGTGCTTCCG-1\n960\n0.017431\n2639.0\nCD14+ Monocytes\npbmc3k\n\n\nAAACCGTGTATGCG-1\n522\n0.012245\n980.0\nNK cells\npbmc3k\n\n\n\n\n\n\n\n\nsc.pl.umap(adata_ref, color=[\"louvain\"])"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#분석-데이터-불러오기",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#분석-데이터-불러오기",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "2.2 분석 데이터 불러오기",
    "text": "2.2 분석 데이터 불러오기\n클러스터링 단계에서 저장된 코로나19 데이터 개체를 읽어와 보겠습니다.\n\npath_file = \"./output/covid/results/scanpy_covid_qc_dr_sc_cl.h5ad\"\nadata = sc.read_h5ad(path_file)\nadata.obs[\"sample\"] = \"covid\"\nadata\n\nAnnData object with n_obs × n_vars = 7227 × 19094\n    obs: 'type', 'sample', 'batch', 'n_counts', 'leiden_1.0', 'leiden_0.6', 'leiden_0.4', 'leiden_1.4', 'louvain_1.0', 'louvain_0.6', 'louvain_0.4', 'louvain_1.4', 'kmeans5', 'kmeans10', 'kmeans15', 'hclust_5', 'hclust_10', 'hclust_15'\n    var: 'gene_ids', 'feature_types', 'genome', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std', 'highly_variable_nbatches', 'highly_variable_intersection'\n    uns: 'hclust_10_colors', 'hclust_15_colors', 'hclust_5_colors', 'hvg', 'kmeans10_colors', 'kmeans15_colors', 'kmeans5_colors', 'leiden_0.4', 'leiden_0.4_colors', 'leiden_0.6', 'leiden_0.6_colors', 'leiden_1.0', 'leiden_1.0_colors', 'leiden_1.4', 'leiden_1.4_colors', 'log1p', 'louvain_0.4', 'louvain_0.4_colors', 'louvain_0.6', 'louvain_0.6_colors', 'louvain_1.0', 'louvain_1.0_colors', 'louvain_1.4', 'louvain_1.4_colors', 'neighbors', 'pca', 'rank_genes_groups', 'sample_colors', 't-test', 't-test_ov', 'tsne', 'umap', 'wilcoxon'\n    obsm: 'Scanorama', 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts', 'log1p'\n    obsp: 'connectivities', 'distances'\n\n\n\n# adata.uns[\"log1p\"][\"base\"] = None\nprint(adata.shape)\n\n(7227, 19094)\n\n\n\nsc.pl.umap(adata, color=[\"louvain_0.6\"])"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#ingest-사용해-예측하기",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#ingest-사용해-예측하기",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "2.3 Ingest 사용해 예측하기",
    "text": "2.3 Ingest 사용해 예측하기\n세포 유형 예측을 위한 또 다른 방법은 Ingest이며, 자세한 내용은 링크을 참조하세요. 먼저 두 데이터 집합에 동일한 유전자가 있는지 확인합니다.\n\nvar_names = adata_ref.var_names.intersection(adata.var_names)\nprint(f\"타겟 데이터의 유전자 수: {adata.shape[1]}\")\nprint(f\"레퍼런스 데이터의 유전자 수: {adata_ref.shape[1]}\")\nprint(f\"타겟과 레퍼런스 데이터에서 중첩되는 유전자 수: {len(var_names)}\")\n\n타겟 데이터의 유전자 수: 19094\n레퍼런스 데이터의 유전자 수: 1838\n타겟과 레퍼런스 데이터에서 중첩되는 유전자 수: 1674\n\n\n먼저 두 데이터 세트에 대해 동일한 유전자 세트를 사용하여 pca와 umap을 다시 실행해야 합니다. 데이터 세트에 대해 동일한 유전자 세트로 다시 실행해야 합니다.\n\nadata_ref_ = adata_ref[:, var_names]\nadata_target_ = adata[:, var_names]\n\nsc.pp.pca(adata_ref_)\nsc.pp.neighbors(adata_ref_)\nsc.tl.umap(adata_ref_)\nsc.pp.pca(adata_target_)\nsc.pp.neighbors(adata_target_)\nsc.tl.umap(adata_target_)\nsc.tl.ingest(adata_target_, adata_ref_, obs=\"louvain\")\n\n# to fix colors\nadata_target_.uns[\"louvain_colors\"] = adata_ref_.uns[\"louvain_colors\"]\nsc.pl.umap(adata_target_, color=[\"louvain\", \"louvain_0.6\"], wspace=0.5)\n\n\n\n\n\n\n\n\n\nadata_concat = adata_ref_.concatenate(adata_target_, batch_categories=[\"ref\", \"target\"])\nadata_concat.obs.louvain = adata_concat.obs.louvain.astype(\"category\")\n# fix category ordering\nadata_concat.obs.louvain.cat.reorder_categories(\n    adata_ref.obs.louvain.cat.categories,\n)\n# fix category colors\nadata_concat.uns[\"louvain_colors\"] = adata_ref.uns[\"louvain_colors\"]\nsc.pl.umap(adata_concat, color=[\"batch\", \"louvain\"])\n\n\n\n\n\n\n\n\n임베딩에서 그룹의 Density plot 하위 집합을 부분적으로 시각화하기\n\nsc.tl.embedding_density(adata_concat, groupby=\"batch\")\nsc.pl.embedding_density(adata_concat, groupby=\"batch\", ncols=2)\n\n\n\n\n\n\n\n\n각각의 leiden_0.6 클러스터에 어떤 세포 유형들이 들어 있는지 막대 그래프를 그려봅니다.\n\ndef plot_stacked_bar(data, index_col, columns_col, legend_position):\n    tmp = pd.crosstab(data.obs[index_col], data.obs[columns_col], normalize=\"index\")\n    ax = tmp.plot.bar(stacked=True, grid=False, width=0.8)\n    ax.legend(bbox_to_anchor=legend_position, loc=\"upper right\", frameon=False)\n    ax.set_xlabel(index_col)\n    ax.set_ylabel(\"Fraction of cells\")\n    ax.set_title(columns_col)\n    return ax\n\n\nax = plot_stacked_bar(adata_concat, \"louvain_0.6\", \"louvain\", (1.6, 1))\nplt.show()\n\n\n\n\n\n\n\n\n\npred_ingest = adata_concat[adata_concat.obs[\"batch\"] == \"target\"].obs[\"louvain\"]\n# 인덱스에서 '-target' 제거\npred_ingest.index = pred_ingest.index.str.replace(\"-target\", \"\", regex=False)\n\nadata.obs[\"pred_ingest\"] = pred_ingest\n\nsc.pl.umap(adata, color=[\"louvain_0.6\", \"pred_ingest\"], ncols=2)\n\n\n\n\n\n\n\n\n위 시각화 결과를 보면 어떤 클러스터는 명확한 예측 결과를 보여지만 다른 클러스터에서는 여러 세포유형의 섞여있는 것으로 보입니다. 이런 경우에는 해당 클러스터에 속한 세포들이 어떤 유전자를 발현하는지 살펴보고 생물학적 지식을 활용해 결정해야 합니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#마커-유전자를-사용해-예측하기",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#마커-유전자를-사용해-예측하기",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "2.4 마커 유전자를 사용해 예측하기",
    "text": "2.4 마커 유전자를 사용해 예측하기\n세포 유형을 예측하는데 가장 많이 사용되는 방법은 알려진 마커 유전자 목록과 비교해보는 방법입니다. 이 방법을 위해서는 신뢰할 수 있고 분석중인 샘플과 연관된 마커 유전자 목록이 필요합니다. 여기서는 사람 세포의 마커 유전자 목록을 불러와 사용하겠습니다.\n\n# 사람 세포 마커 유전자 목록 불러오기\npath_file = \"./input/human_cell_markers.txt\"\ndf = pd.read_table(path_file)\nprint(df.shape)\n\n(2868, 15)\n\n\n파일에는 2868개의 유전자가 포함되어 있네요. 세포 유형 예측을 위해 약간의 수정을 통해 gene_dict 객체를 만들어 줍니다.\n\n# 세포 유형별 유전자 수에 대한 필터링\ndf[\"nG\"] = df.geneSymbol.str.split(\",\").str.len()\n\ndf = df[df[\"nG\"] &gt; 5]\ndf = df[df[\"nG\"] &lt; 100]\ndf = df[df[\"cancerType\"] == \"Normal\"]\n\ndf.index = df.cellName\ngene_dict = df.geneSymbol.str.split(\",\").to_dict()\n\ndf.head()\n\n\n\n\n\n\n\n\nspeciesType\ntissueType\nUberonOntologyID\ncancerType\ncellType\ncellName\nCellOntologyID\ncellMarker\ngeneSymbol\ngeneID\nproteinName\nproteinID\nmarkerResource\nPMID\nCompany\nnG\n\n\n\n\n13\nHuman\nLiver\nUBERON_0002107\nNormal\nNormal cell\nKupffer cell\nCL_0000091\nCD11b, CD14, CD18, CD32, CD68\nITGAM, CD14, ITGB2, [FCGR2A, FCGR2B, FCGR2C], ...\n3684, 929, 3689, [2212, 2213, 9103], 968\nITAM, CD14, ITB2, [FCG2A, FCG2B, FCG2C], CD68\nP11215, P08571, P05107, [P12318, P31994, P3199...\nExperiment\n17692868\nNaN\n7.0\n\n\n22\nHuman\nPeripheral blood\nUBERON_0005408\nNormal\nNormal cell\nMonocyte\nCL_0000576\nCD11b, CD16, CD19, CD2, CD3, CD56, CD94, NKG2A\nITGAM, [FCGR3A, FCGR3B], CD19, CD2, [CD3D, CD3...\n3684, [2214, 2215], 930, 914, [915, 916, 917],...\nITAM, [FCG3A, FCG3B], CD19, CD2, [CD3D, CD3E, ...\nP11215, [P08637, O75015], P15391, P06729, [P04...\nExperiment\n29610856\nNaN\n11.0\n\n\n23\nHuman\nBlood\nUBERON_0000178\nNormal\nNormal cell\nNatural killer cell\nCL_0000623\nCD11b, CD16, CD19, CD2, CD3, CD56, CD94, NKG2A\nITGAM, [FCGR3A, FCGR3B], CD19, CD2, [CD3D, CD3...\n3684, [2214, 2215], 930, 914, [915, 916, 917],...\nITAM, [FCG3A, FCG3B], CD19, CD2, [CD3D, CD3E, ...\nP11215, [P08637, O75015], P15391, P06729, [P04...\nExperiment\n29610856\nNaN\n11.0\n\n\n25\nHuman\nGingiva\nUBERON_0001828\nNormal\nNormal cell\nMesenchymal stem cell\nCL_0000134\nCD105, CD166, CD29, CD44, CD49e, CD73, CD90\nENG, ALCAM, ITGB1, CD44, ITGA5, NT5E, THY1\n2022, 214, 3688, 960, 3678, 4907, 7070\nEGLN, CD166, ITB1, CD44, ITA5, 5NTD, THY1\nP17813, Q13740, P05556, P16070, P08648, P21589...\nExperiment\n29604386\nNaN\n7.0\n\n\n28\nHuman\nPeripheral blood\nUBERON_0005408\nNormal\nNormal cell\nMonocyte\nCL_0000576\nCD14, CD19, CD20, CD27, CD3, CD38, IgA, IgG\nCD14, CD19, MS4A1, CD27, [CD3D, CD3E, CD3G], C...\n929, 930, 931, 939, [915, 916, 917], 952, 973,...\nCD14, CD19, CD20, CD27, [CD3D, CD3E, CD3G], CD...\nP08571, P15391, P11836, P26842, [P04234, P0776...\nExperiment\n29579044\nNaN\n10.0\n\n\n\n\n\n\n\n이제 gseapy.enrichr 함수를 사용해 위에서 만든 gene_dict과 louvain_0.6의 DEG 목록과 비교해 세포 유형을 예측합니다.\n\n# 클러스터별로 DEG 분석\nsc.tl.rank_genes_groups(adata, \"louvain_0.6\", method=\"wilcoxon\", key_added=\"wilcoxon\")\n\ngsea_res = {}\npred = {}\n\nfor cl in adata.obs[\"louvain_0.6\"].cat.categories.tolist():\n    glist = (\n        sc.get.rank_genes_groups_df(adata, group=cl, key=\"wilcoxon\")[\"names\"]\n        .squeeze()\n        .str.strip()\n        .tolist()\n    )\n    enr_res = gseapy.enrichr(\n        gene_list=glist[:300],\n        organism=\"Human\",\n        gene_sets=gene_dict,\n        background=adata.layers[\"counts\"].shape[1],\n        cutoff=1,\n    )\n    if enr_res.results.shape[0] == 0:\n        pred[cl] = \"Unass\"\n    else:\n        enr_res.results.sort_values(by=\"P-value\", axis=0, ascending=True, inplace=True)\n        gsea_res[cl] = enr_res\n        pred[cl] = enr_res.results[\"Term\"][0]\n\npred\n\n{'0': 'Circulating fetal cell',\n '1': 'CD4+ T cell',\n '2': 'CD4+ T cell',\n '3': 'CD8+ T cell',\n '4': 'CD1C+_A dendritic cell',\n '5': 'B cell',\n '6': 'CD16+ dendritic cell',\n '7': 'B cell',\n '8': 'Circulating fetal cell',\n '9': 'Circulating fetal cell',\n '10': 'Circulating fetal cell',\n '11': 'Circulating fetal cell'}\n\n\n예측된 결과를 시각화로 살펴봅니다.\n\nprediction = [pred[x] for x in adata.obs[\"louvain_0.6\"]]\nadata.obs[\"GS_overlap_pred\"] = prediction\n\nsc.pl.umap(adata, color=\"GS_overlap_pred\")"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#세포유형-지정하기",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#세포유형-지정하기",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "2.5 세포유형 지정하기",
    "text": "2.5 세포유형 지정하기\n위에서 얻은 결과를 통해 세포 유형을 지정하고 시각화 해봅니다.\n\n# 임의로 주석\ncluster_annotations = {\n    \"0\": \"CD14+ Monocyte\",\n    \"1\": \"CD4T cell\",\n    \"2\": \"CD4T cell\",\n    \"3\": \"CD8T cell\",\n    \"4\": \"NK cell\",\n    \"5\": \"B cell\",\n    \"6\": \"CD14+ Monocyte\",\n    \"7\": \"B cell\",\n    \"8\": \"FCGR3A+ Monocyte\",\n    \"9\": \"CD4T cell\",\n    \"10\": \"Circulating fetal cell\",\n    \"11\": \"Circulating fetal cell\",\n}\n\nadata.obs[\"cell_type\"] = adata.obs[\"louvain_0.6\"].map(cluster_annotations)\n\n# 주석 확인\nsc.pl.umap(adata, color=[\"louvain_0.6\", \"cell_type\"])"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#over-representation-analysis-ora",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#over-representation-analysis-ora",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "3.1 Over-representation analysis (ORA)",
    "text": "3.1 Over-representation analysis (ORA)\nORA는 주어진 유전자 목록에서 특정 기능이나 경로에 속하는 유전자들이 과발현 되는지를 평가하는 방법입니다. ORA는 특정 생물학적 기능이나 경로와 관련된 유전자들이 관심 있는 유전자 목록에서 통계적으로 유의미하게 많이 포함되어 있는지 확인합니다. 이를 통해 특정 생물학적 기능이나 경로가 실험 조건에서 중요한 역할을 하는지 파악할 수 있습니다. ORA을 하면 유의미성을 나타내는 p-value와 함께 과도하게 나타나는 유전자 집합 결과를 얻습니다. 다만 유전자 발현 수준이나 경로의 구조를 고려하지 않는다는 한계점이 있습니다.\n이제 예시로 코로나 환자의 DEG를 사용하여 면역 반응, 염증 경로, 바이러스 복제와 관련된 경로들이 유의미하게 변화하는지를 살펴보겠습니다.\n\nsc.tl.rank_genes_groups(adata, \"type\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(\n    adata,\n    n_genes=25,\n    sharey=False,\n    key=\"wilcoxon\",\n    ncols=3,\n)\n\n\n\n\n\n\n\n\n앞서 구한 DEG 목록을 gseapy에 넘겨서 ORA 분석을 진행합니다. 많이 사용되는 몇가지 데이터베이스 목록은 아래와 같습니다.\n\nGO_Biological_Process_2018\nKEGG_2019_Human\nKEGG_2019_Mouse\nWikiPathways_2019_Human\nWikiPathways_2019_Mouse\n\n\n# 가능한 데이터베이스 : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’\ngene_set_names = gseapy.get_library_name(organism=\"Human\")\n\n# ?gseapy.enrichr\nglist = (\n    sc.get.rank_genes_groups_df(\n        adata, group=\"Covid\", key=\"wilcoxon\", log2fc_min=0.25, pval_cutoff=0.05\n    )[\"names\"]\n    .squeeze()\n    .str.strip()\n    .tolist()\n)\n\n간단한 막대그래프를 사용해 결과를 시각화합니다.\n\ndef plot_ora(\n    glist,\n    gene_set=\"GO_Biological_Process_2018\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n):\n    enr_res = gseapy.enrichr(\n        gene_list=glist,\n        organism=\"Human\",\n        gene_sets=gene_set,\n        cutoff=0.5,\n    )\n    if truncate:\n        # True 시 뒤의 코드명 일부 제거.\n        enr_res.res2d[\"Term\"] = enr_res.res2d[\"Term\"].apply(lambda x: \" \".join(x.split(\" \")[:-1]))\n    ax = gseapy.barplot(\n        enr_res.res2d,\n        title=gene_set,\n        figsize=size,\n        color=color,\n    )\n    ax.grid(False)\n    return ax\n\n\nax = plot_ora(\n    glist,\n    gene_set=\"GO_Biological_Process_2018\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n)\nplt.show()\n\n\n\n\n\n\n\n\n\nax = plot_ora(glist, gene_set=\"KEGG_2019_Human\", size=(5, 4), color=\"darkred\", truncate=False)\nplt.show()\n\n\n\n\n\n\n\n\n\nax = plot_ora(\n    glist,\n    gene_set=\"WikiPathways_2019_Human\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_04.html#functional-class-scoring-fcs-분석",
    "href": "posts/ipynb/da_scanpy_workshop_04.html#functional-class-scoring-fcs-분석",
    "title": "Scanpy로 scRNA-seq 분석 04",
    "section": "3.2 Functional Class Scoring (FCS) 분석",
    "text": "3.2 Functional Class Scoring (FCS) 분석\nORA외에도 Functional Class Scoring(FCS) 분석을 진행 할 수 있습니다. FCS는 유전자 집합 내 발현 변화 또한 고려한 방법입니다. FCS 분석 중 유명한 방법이 유전자 세트 강화 분석(GSEA)입니다. GSEA는 각 유전자에 발현 변화(예: 로그 폴드 변화)를 기준으로 점수를 부여하고, 이 점수를 유전자 집합 내에서 합산하거나 평균을 구한 후, 무작위 분포(퍼뮤테이션 기반 또는 파라메트릭)와 비교합니다. 그 결과 (일반적으로 폴드 변화를 기반으로) 순위가 매겨진 유전자 목록을 점수화하고 순열 테스트를 계산하여 특정 유전자 세트가 상향 조절된 유전자에 더 많이 존재하는지, 하향 조절된 유전자에 더 많이 존재하는지, 아니면 차등 조절되지 않는지를 확인할 수 있습니다. 이 방법의 장점은 발현 수준을 고려하기 때문에 미묘한 효과도 포착할 수 있다는 것입니다. 다만 집합내 유전자들이 서로 독립이라는 가정해야 한다는 한계점이 있습니다.\nGSEA를 수행하기 위해서는 모든 차등 발현 유전자(DEG)와 그 로그 폴드 체인지를 포함한 테이블이 필요합니다.\n\n# Available databases : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’\ngene_set_names = gseapy.get_library_name(organism=\"Human\")\n\ngene_rank = sc.get.rank_genes_groups_df(adata, group=\"Covid\", key=\"wilcoxon\")[\n    [\"names\", \"logfoldchanges\"]\n]\ngene_rank.sort_values(by=[\"logfoldchanges\"], inplace=True, ascending=False)\n\n# 계산_qc_metrics는 유전자당 세포 수를 계산합니다.\nsc.pp.calculate_qc_metrics(adata, percent_top=None, log1p=False, inplace=True)\n\n# 최소 30개 이상의 세포에서 발현되는 유전자를 필터링합니다.\ngene_rank = gene_rank[gene_rank[\"names\"].isin(adata.var_names[adata.var.n_cells_by_counts &gt; 30])]\n\ngene_rank\n\n\n\n\n\n\n\n\nnames\nlogfoldchanges\n\n\n\n\n2800\nCCL7\n24.208344\n\n\n2868\nIL1A\n24.117874\n\n\n2360\nCYP19A1\n23.754789\n\n\n2903\nPRTN3\n23.376261\n\n\n1107\nNXF3\n9.236358\n\n\n...\n...\n...\n\n\n16567\nENHO\n-4.197762\n\n\n15497\nLYNX1\n-4.719684\n\n\n15466\nC5orf17\n-5.105195\n\n\n17113\nLYPD2\n-5.713926\n\n\n18516\nAC004556.1\n-26.306053\n\n\n\n\n13553 rows × 2 columns\n\n\n\n다음으로 GSEA를 실행합니다. 그러면 여러 경로에 대한 정보가 포함된 테이블이 생성됩니다. 이 테이블을 p-value 또는 정규화된 강화 점수(NES) 기준으로 정렬하고 필터링하여 상위 경로만 시각화할 수 있습니다. 이 분석은 실험 조건에서 중요한 역할을 하는 주요 경로를 식별하고 분석할 수 있습니다.\n\nres = gseapy.prerank(rnk=gene_rank, gene_sets=\"KEGG_2021_Human\")\n\nterms = res.res2d.Term\nprint(terms[:10])\n\n0                              IL-17 signaling pathway\n1                                 Rheumatoid arthritis\n2    Viral protein interaction with cytokine and cy...\n3               Cytokine-cytokine receptor interaction\n4    AGE-RAGE signaling pathway in diabetic complic...\n5                          Chemokine signaling pathway\n6                                           Amoebiasis\n7               Fluid shear stress and atherosclerosis\n8                           Osteoclast differentiation\n9                                            Pertussis\nName: Term, dtype: object\n\n\n\ngseapy.gseaplot(rank_metric=res.ranking, term=terms[0], **res.results[terms[0]])\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를 보면 KEGG 데이터베이스의 IL-17 signaling pathway 경로가 과발현 되어 있다는 것을 알 수있습니다. IL-17은 염증 반응을 조절하는 중요한 사이토카인입니다. 이 경로의 상향 조절은 강한 염증 반응을 나타내며, 면역계가 병원체와 싸우는 과정에서 중요한 역할을 합니다. 따라서 이런 경로의 상향 조절은 염증, 면역 반응, 감염 및 대사질환과 관련된 중요한 생물학적 변화를 시사합니다.\n마지막으로, 다른 분석을 위해 데이터를 저장해 보겠습니다.\n\nsave_file = \"./output/covid/results/scanpy_covid_annot.h5ad\"\nadata.write_h5ad(save_file, compression=\"gzip\")"
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html",
    "href": "posts/ipynb/tool_jupyter_notebook.html",
    "title": "Jupyter notebook 소개",
    "section": "",
    "text": "Jupyter Notebook은 웹 브라우저를 통해 실행되는 오픈 소스 인터랙티브 컴퓨팅 환경입니다. 코드, 텍스트, 수식, 이미지 등 다양한 형태의 콘텐츠를 하나의 문서에 통합하여 작성, 실행 및 저장할 수 있어 코딩과 문서화를 동시에 할 수 있다는 장점이 있습니다. 그리고 Python뿐 아니라 R, Julia, Scala 등 40개 이상의 프로그래밍 언어를 지원합니다. 작성한 노트북을 동료와 공유하거나 GitHub, Binder, JupyterHub 등의 플랫폼을 통해 배포할 수 있어 데이터 과학, 머신러닝 연구, 교육 및 문서화에 매우 유용합니다."
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#코드-실행-및-문서화",
    "href": "posts/ipynb/tool_jupyter_notebook.html#코드-실행-및-문서화",
    "title": "Jupyter notebook 소개",
    "section": "1.1 코드 실행 및 문서화",
    "text": "1.1 코드 실행 및 문서화\n\n인터랙티브 코드 실행: 셀 단위로 코드를 작성하고 실행하여 그 결과를 즉시 확인할 수 있습니다. 이는 데이터 분석, 시뮬레이션 및 머신러닝 모델 개발 시 신속한 피드백을 가능하게 합니다.\nMarkdown 및 LaTeX 지원: Markdown 셀을 이용해 설명 텍스트, 수식, 표 등을 삽입할 수 있으며 LaTeX 수식은 MathJax를 통해 렌더링됩니다.\n단축키 및 모드: Jupyter Notebook은 셀 선택(커맨드 모드)와 코드 편집(에디트 모드) 등 두 가지 모드를 제공하며 다양한 단축키를 통해 작업 효율을 극대화할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#데이터-시각화-도구-통합",
    "href": "posts/ipynb/tool_jupyter_notebook.html#데이터-시각화-도구-통합",
    "title": "Jupyter notebook 소개",
    "section": "1.2 데이터 시각화 도구 통합",
    "text": "1.2 데이터 시각화 도구 통합\nJupyter Notebook은 Matplotlib, Seaborn, Plotly, Bokeh 등 다양한 시각화 라이브러리와 원활하게 통합됩니다. 또한 코드를 실행하면 결과가 셀 바로 아래에 출력되며, 이를 통해 데이터 분석 및 모델 개발 과정에서 식별된 패턴 및 이상치를 즉시 확인할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#jupyter-notebook-단축키-가이드",
    "href": "posts/ipynb/tool_jupyter_notebook.html#jupyter-notebook-단축키-가이드",
    "title": "Jupyter notebook 소개",
    "section": "3.1 Jupyter Notebook 단축키 가이드",
    "text": "3.1 Jupyter Notebook 단축키 가이드\n자세한 것은 공식 문서를 참고하세요.\n\n3.1.1 1. 셀 선택 모드 (Command Mode)\nesc 또는 ctrl + m를 눌러 셀이 파란색이 된 상태에서 사용\n\n위로 셀 추가: a\n아래로 셀 추가: b\n선택 셀 삭제: d d (d를 두번 누름)\n선택 셀 잘라내기 (삭제로 써도 무방): x\n선택 셀 복사하기: c\n선택 셀 아래에 붙여넣기: v\n선택 셀과 아래 셀과 합치기: shift + m\n실행결과 열기/닫기: o\nMarkdown으로 변경: m\nCode로 변경: y\n파일 저장: ctrl + s 또는 s\n선택 셀의 코드 입력 모드로 돌아가기: enter\n\n\n\n3.1.2 2. 코드 입력 모드 (Edit Mode)\nenter를 눌러 셀이 초록색이 된 상태에서 사용\n\n선택 셀의 코드 전체 선택: ctrl + a\n선택 셀 내 실행 취소: ctrl + z\n선택 셀 내 다시 실행: ctrl + y\n커서 위치 라인 주석처리: ctrl + /\n선택 셀 코드 실행: ctrl + enter\n선택 셀 코드 실행 후 다음 Cell로 이동 (없으면 새로 추가): shift + enter\n커서 위치에서 셀 둘로 나누기: shift + ctrl + -\n파일 저장: ctrl + s\n셀 선택 모드로 돌아가기: esc 또는 ctrl + m"
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#코드셀-실행-예제",
    "href": "posts/ipynb/tool_jupyter_notebook.html#코드셀-실행-예제",
    "title": "Jupyter notebook 소개",
    "section": "4.1 코드셀 실행 예제",
    "text": "4.1 코드셀 실행 예제\n\n4.1.1 Bouncing Ball 시뮬레이션\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n\ndef bouncing_ball(g, h0, v0, cor, t_max, dt):\n    t = np.arange(0, t_max, dt)\n    h = np.zeros_like(t)\n    v = np.zeros_like(t)\n\n    h[0] = h0\n    v[0] = v0\n\n    for i in range(1, len(t)):\n        v[i] = v[i - 1] - g * dt\n        h[i] = h[i - 1] + v[i] * dt\n\n        if h[i] &lt; 0:\n            h[i] = 0\n            v[i] = -cor * v[i - 1]\n\n    return t, h\n\n\n# 시뮬레이션 매개변수\ng = 9.8  # 중력 가속도 (m/s^2)\nh0 = 1.0  # 초기 높이 (m)\nv0 = 0  # 초기 속도 (m/s)\ncor = 0.8  # 반발 계수\nt_max = 3.0  # 시뮬레이션 시간 (s)\ndt = 0.001  # 시간 간격 (s)\n\n# 시뮬레이션 실행\nt, h = bouncing_ball(g, h0, v0, cor, t_max, dt)\n\n# 그래프 그리기\nplt.figure(figsize=(5, 3))\nplt.plot(t, h)\nplt.title(\"Bouncing Ball\")\nplt.xlabel(\"time (ms)\")\nplt.ylabel(\"height\")\nplt.grid(True)\nplt.ylim(0, 1.1)\nplt.show()\n\n# CSV 파일로 저장\ndf = pd.DataFrame({\"time(ms)\": t, \"height\": h})\ndf.head()\n# df.to_csv('bouncing_ball_data.csv', index=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntime(ms)\nheight\n\n\n\n\n0\n0.000\n1.000000\n\n\n1\n0.001\n0.999990\n\n\n2\n0.002\n0.999971\n\n\n3\n0.003\n0.999941\n\n\n4\n0.004\n0.999902\n\n\n\n\n\n\n\n\n\n4.1.2 붓꽃 데이터 시각화\nIris 데이터셋을 분석하며, 기초적인 데이터 시각화 및 탐색에 대한 예제를 제공합니다. 예를 들어, 아래와 같은 코드를 작성하여 Iris 데이터셋의 꽃잎 길이와 너비를 시각화할 수 있습니다:\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\n# 아이리스 데이터셋 로드\niris = load_iris()\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\ndf[\"species\"] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\n# 산점도 그리기\nplt.figure(figsize=(5, 5))\ncolors = {\"setosa\": \"red\", \"versicolor\": \"green\", \"virginica\": \"blue\"}\nfor species, group in df.groupby(\"species\", observed=True):\n    plt.scatter(\n        group[\"sepal length (cm)\"], group[\"sepal width (cm)\"], label=species, color=colors[species]\n    )\n\nplt.title(\"Iris Sepal Length vs Width\")\nplt.xlabel(\"Sepal Length (cm)\")\nplt.ylabel(\"Sepal Width (cm)\")\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#매직-명령어magic-commands",
    "href": "posts/ipynb/tool_jupyter_notebook.html#매직-명령어magic-commands",
    "title": "Jupyter notebook 소개",
    "section": "4.2 매직 명령어(Magic commands)",
    "text": "4.2 매직 명령어(Magic commands)\n주피터 노트북에서 매직 명령어는 코드 실행을 단순화하고 노트북의 기능을 확장하는 데 유용한 특별한 명령어입니다. 매직 명령어는 두 가지 유형으로 나뉩니다:\n\n라인 매직 명령어: ’%’로 시작하며 한 줄에 적용됩니다.\n셀 매직 명령어: ’%%’로 시작하며 전체 셀에 적용됩니다.\n\n\n4.2.1 주요 매직 명령어\n\n4.2.1.1 라인 매직 명령어\n\n%time: 특정 코드의 실행 시간을 측정합니다.\n%timeit: 코드를 여러 번 실행하여 평균 실행 시간을 측정합니다.\n%lsmagic: 사용 가능한 모든 매직 명령어를 나열합니다.\n%matplotlib inline: matplotlib 그래프를 인라인으로 표시합니다.\n%load: 외부 스크립트 파일을 현재 셀에 불러옵니다.\n%pwd: 현재 노트북의 디렉토리 정보를 출력합니다.\n%ls: 현재 디렉토리의 목록을 출력합니다.\n\n\n\n4.2.1.2 셀 매직 명령어\n\n%%time: 셀 전체의 실행 시간을 측정합니다.\n%%timeit: 셀 전체를 여러 번 실행하여 평균 실행 시간을 측정합니다.\n%%writefile: 셀의 내용을 파일로 저장합니다.\n%%capture: 셀의 출력을 캡처하여 변수에 저장합니다.\n%%bash: 셀에서 bash 명령어를 실행합니다.\n%%html: HTML 코드를 실행하고 렌더링합니다.\n%%latex: LaTeX 코드를 실행하고 렌더링합니다.\n\n\n\n\n4.2.2 사용 예시\n\n파일 저장: %%writefile sample.py로 시작하는 셀의 내용을 ‘sample.py’ 파일로 저장할 수 있습니다.\n코드 실행 시간 측정: %time sum(range(1000000))로 특정 연산의 실행 시간을 측정할 수 있습니다.\n외부 파일 로드: %load sample.py로 ‘sample.py’ 파일의 내용을 현재 셀에 불러올 수 있습니다.\n\n매직 명령어의 예시로 현재 디렉토리 위치를 출력해 보겠습니다.\n\n%pwd\n\n'/Users/fkt/Downloads/repo/tomorrow-lab.github.io/posts/ipynb'\n\n\n\n%timeit sum(range(100))\n\n322 ns ± 2.13 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#교육용-템플릿",
    "href": "posts/ipynb/tool_jupyter_notebook.html#교육용-템플릿",
    "title": "Jupyter notebook 소개",
    "section": "5.1 교육용 템플릿:",
    "text": "5.1 교육용 템플릿:\nJupyter Notebook은 Markdown과 코드 셀을 결합하여 학습 자료 및 실습 자료를 제작하기 좋습니다. 코로나19 데이터 분석 예제와 같이 단계별 주석과 설명을 포함한 템플릿을 활용하면 학생들이 실습을 통해 데이터 분석 기법을 배울 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#연구-재현성",
    "href": "posts/ipynb/tool_jupyter_notebook.html#연구-재현성",
    "title": "Jupyter notebook 소개",
    "section": "5.2 연구 재현성:",
    "text": "5.2 연구 재현성:\nBinder, JupyterHub, Docker 컨테이너를 통해 동일한 실행 환경을 재현 가능하게 만들어 연구 결과의 재현성을 높일 수 있습니다. 또한 노트북 파일과 함께 환경 구성 파일을 공유하는 방식이 흔히 사용됩니다."
  },
  {
    "objectID": "posts/ipynb/tool_jupyter_notebook.html#다중-커널-연동",
    "href": "posts/ipynb/tool_jupyter_notebook.html#다중-커널-연동",
    "title": "Jupyter notebook 소개",
    "section": "5.3 다중 커널 연동:",
    "text": "5.3 다중 커널 연동:\nPython과 R 커널을 함께 사용하여 상호 간 데이터를 교환하고 분석할 수 있습니다. 예를 들어 매직 명령어 %R을 사용하여 Python 데이터 프레임을 R로 전달한 다음 R의 통계 함수를 활용하는 방법도 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html",
    "href": "posts/ipynb/da_statistics_basics.html",
    "title": "파이썬 통계분석하기",
    "section": "",
    "text": "통계 계산을 위한 프로그래밍 언어에 R 프로그래밍 언어가 있는데 왜 파이썬을 써야 할까요? R은 문법 자체부터 통계에 특화되어 있고 여러가지 통계분석을 할 수 있습니다. 그럼에도 불구하고 제가 파이썬을 통계분석에 사용하는 이유는 간단합니다. 파이썬은 보다 범용적인 언어이고 라이브러리가 풍부해서 제가 원하는 기능은 거의 이미 다 있기 때문이죠.\n\n\n여기 brain_size 라는 데이터를 살펴 보겠습니다.\n\n# 필요한 라이브러리를 불러옵니다.\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\n\n\nbrain_size 데이터는 Willerman이 1991년에 사람의 뇌 크기와 무게, 그리고 IQ에 대하여 측정한 값입니다. 범주형의 데이터와 수치형 데이터로 구성 되어 있죠.\nPandas의 read_csv 기능을 이용해 데이터프레임을 만들어 보겠습니다.\n\ndf = pd.read_csv(\n    \"http://www.scipy-lectures.org/_downloads/brain_size.csv\",\n    sep=\";\",\n    index_col=0,\n    na_values=\".\",\n)\ndf.head()  # 상단의 5개의 데이터 확인하기\n\n\n\n\n\n\n\n\nGender\nFSIQ\nVIQ\nPIQ\nWeight\nHeight\nMRI_Count\n\n\n\n\n1\nFemale\n133\n132\n124\n118.0\n64.5\n816932\n\n\n2\nMale\n140\n150\n124\nNaN\n72.5\n1001121\n\n\n3\nMale\n139\n123\n150\n143.0\n73.3\n1038437\n\n\n4\nMale\n133\n129\n128\n172.0\n68.8\n965353\n\n\n5\nFemale\n137\n132\n134\n147.0\n65.0\n951545\n\n\n\n\n\n\n\n간단히 살펴보면, 총 40명의 사람들의 성별, IQ, 몸무게, 키 그리고 MRI_count(total pixel Count from the 18 MRI scans) 값이 측정되어 있습니다. IQ의 경우 3종류로 세분화 되어있는데 각각을 알아 보면 아래와 같습니다.\n\nFull Scale Intelligence Quotient (FSIQ) : VIQ와 PIQ의 종합적인 수치입니다\nVerbal IQ (VIQ) : 언어적인 측면을 측정합니다.\nPerformance IQ (PIQ) : 논리, 계산적인 측면을 측정\n\n\n\n\npandas에서는 간단하게 평균값과 표준편차등을 계산해주는 기능이 있습니다.\ndescribe() 함수를 사용하면 모든 열에 대한 설명통계값을 보여줍니다.\n\n# padas 에서 제공하는 설명 통계\ndf.describe()\n\n\n\n\n\n\n\n\nFSIQ\nVIQ\nPIQ\nWeight\nHeight\nMRI_Count\n\n\n\n\ncount\n40.000000\n40.000000\n40.00000\n38.000000\n39.000000\n4.000000e+01\n\n\nmean\n113.450000\n112.350000\n111.02500\n151.052632\n68.525641\n9.087550e+05\n\n\nstd\n24.082071\n23.616107\n22.47105\n23.478509\n3.994649\n7.228205e+04\n\n\nmin\n77.000000\n71.000000\n72.00000\n106.000000\n62.000000\n7.906190e+05\n\n\n25%\n89.750000\n90.000000\n88.25000\n135.250000\n66.000000\n8.559185e+05\n\n\n50%\n116.500000\n113.000000\n115.00000\n146.500000\n68.000000\n9.053990e+05\n\n\n75%\n135.500000\n129.750000\n128.00000\n172.000000\n70.500000\n9.500780e+05\n\n\nmax\n144.000000\n150.000000\n150.00000\n192.000000\n77.000000\n1.079549e+06\n\n\n\n\n\n\n\nIQ의 평균값은 113이군요. 몸무게는 kg으로 변환하면 약 70kg쯤 됩니다.\n\n\n\n전체적인 데이터의 양상을 보기에는 시각화가 중요합니다. 파이썬에서는 간단하게 산포 행렬(sactter matrix)를 그려 볼 수 있습니다.\n먼저 키와 몸무게, MRI_count 간의 상관관계를 보겠습니다.\n\n# Plotting data\nfrom pandas.plotting import scatter_matrix\n\n# 키와 몸무게, MRI_count\nscatter_matrix(df[[\"Weight\", \"Height\", \"MRI_Count\"]])\n\narray([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A1D2B70&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A443668&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A47E588&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A4B9588&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A56D4A8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A56D4E0&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A5DC978&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A614EB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A643B70&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n키와 몸무계는 서로 연관이 있는듯 하고 나머지는 그다지 서로 연관이 없어 보입니다.\n그 다음으로는 여러 IQ 수치간에 상관관계를 알아 보죠.\n\nscatter_matrix(df[[\"PIQ\", \"VIQ\", \"FSIQ\"]])\n\narray([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A9AD6A0&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A9F34A8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AA2E3C8&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AA64358&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AAA0358&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AAA0390&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB01EB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB3DEB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB72EB8&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n당연하지만, FSIQ는 VIQ, PIQ 각각과 연관성이 있어 보입니다. VIQ와 PIQ간에는 애매하게 연관성이 없어 보이네요. FSIQ의 히스토그램에서는 100 - 125 사이에는 데이터가 없는 것을 확인 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#예를-들어봅시다.",
    "href": "posts/ipynb/da_statistics_basics.html#예를-들어봅시다.",
    "title": "파이썬 통계분석하기",
    "section": "",
    "text": "여기 brain_size 라는 데이터를 살펴 보겠습니다.\n\n# 필요한 라이브러리를 불러옵니다.\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd"
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#csv-파일-읽어오기",
    "href": "posts/ipynb/da_statistics_basics.html#csv-파일-읽어오기",
    "title": "파이썬 통계분석하기",
    "section": "",
    "text": "brain_size 데이터는 Willerman이 1991년에 사람의 뇌 크기와 무게, 그리고 IQ에 대하여 측정한 값입니다. 범주형의 데이터와 수치형 데이터로 구성 되어 있죠.\nPandas의 read_csv 기능을 이용해 데이터프레임을 만들어 보겠습니다.\n\ndf = pd.read_csv(\n    \"http://www.scipy-lectures.org/_downloads/brain_size.csv\",\n    sep=\";\",\n    index_col=0,\n    na_values=\".\",\n)\ndf.head()  # 상단의 5개의 데이터 확인하기\n\n\n\n\n\n\n\n\nGender\nFSIQ\nVIQ\nPIQ\nWeight\nHeight\nMRI_Count\n\n\n\n\n1\nFemale\n133\n132\n124\n118.0\n64.5\n816932\n\n\n2\nMale\n140\n150\n124\nNaN\n72.5\n1001121\n\n\n3\nMale\n139\n123\n150\n143.0\n73.3\n1038437\n\n\n4\nMale\n133\n129\n128\n172.0\n68.8\n965353\n\n\n5\nFemale\n137\n132\n134\n147.0\n65.0\n951545\n\n\n\n\n\n\n\n간단히 살펴보면, 총 40명의 사람들의 성별, IQ, 몸무게, 키 그리고 MRI_count(total pixel Count from the 18 MRI scans) 값이 측정되어 있습니다. IQ의 경우 3종류로 세분화 되어있는데 각각을 알아 보면 아래와 같습니다.\n\nFull Scale Intelligence Quotient (FSIQ) : VIQ와 PIQ의 종합적인 수치입니다\nVerbal IQ (VIQ) : 언어적인 측면을 측정합니다.\nPerformance IQ (PIQ) : 논리, 계산적인 측면을 측정"
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#pandas-설명통계",
    "href": "posts/ipynb/da_statistics_basics.html#pandas-설명통계",
    "title": "파이썬 통계분석하기",
    "section": "",
    "text": "pandas에서는 간단하게 평균값과 표준편차등을 계산해주는 기능이 있습니다.\ndescribe() 함수를 사용하면 모든 열에 대한 설명통계값을 보여줍니다.\n\n# padas 에서 제공하는 설명 통계\ndf.describe()\n\n\n\n\n\n\n\n\nFSIQ\nVIQ\nPIQ\nWeight\nHeight\nMRI_Count\n\n\n\n\ncount\n40.000000\n40.000000\n40.00000\n38.000000\n39.000000\n4.000000e+01\n\n\nmean\n113.450000\n112.350000\n111.02500\n151.052632\n68.525641\n9.087550e+05\n\n\nstd\n24.082071\n23.616107\n22.47105\n23.478509\n3.994649\n7.228205e+04\n\n\nmin\n77.000000\n71.000000\n72.00000\n106.000000\n62.000000\n7.906190e+05\n\n\n25%\n89.750000\n90.000000\n88.25000\n135.250000\n66.000000\n8.559185e+05\n\n\n50%\n116.500000\n113.000000\n115.00000\n146.500000\n68.000000\n9.053990e+05\n\n\n75%\n135.500000\n129.750000\n128.00000\n172.000000\n70.500000\n9.500780e+05\n\n\nmax\n144.000000\n150.000000\n150.00000\n192.000000\n77.000000\n1.079549e+06\n\n\n\n\n\n\n\nIQ의 평균값은 113이군요. 몸무게는 kg으로 변환하면 약 70kg쯤 됩니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#산포-행렬을-그려보겠습니다.",
    "href": "posts/ipynb/da_statistics_basics.html#산포-행렬을-그려보겠습니다.",
    "title": "파이썬 통계분석하기",
    "section": "",
    "text": "전체적인 데이터의 양상을 보기에는 시각화가 중요합니다. 파이썬에서는 간단하게 산포 행렬(sactter matrix)를 그려 볼 수 있습니다.\n먼저 키와 몸무게, MRI_count 간의 상관관계를 보겠습니다.\n\n# Plotting data\nfrom pandas.plotting import scatter_matrix\n\n# 키와 몸무게, MRI_count\nscatter_matrix(df[[\"Weight\", \"Height\", \"MRI_Count\"]])\n\narray([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A1D2B70&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A443668&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A47E588&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A4B9588&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A56D4A8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A56D4E0&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A5DC978&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A614EB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A643B70&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n키와 몸무계는 서로 연관이 있는듯 하고 나머지는 그다지 서로 연관이 없어 보입니다.\n그 다음으로는 여러 IQ 수치간에 상관관계를 알아 보죠.\n\nscatter_matrix(df[[\"PIQ\", \"VIQ\", \"FSIQ\"]])\n\narray([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A9AD6A0&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000A9F34A8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AA2E3C8&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AA64358&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AAA0358&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AAA0390&gt;],\n       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB01EB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB3DEB8&gt;,\n        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000AB72EB8&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n당연하지만, FSIQ는 VIQ, PIQ 각각과 연관성이 있어 보입니다. VIQ와 PIQ간에는 애매하게 연관성이 없어 보이네요. FSIQ의 히스토그램에서는 100 - 125 사이에는 데이터가 없는 것을 확인 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#sample-t-test",
    "href": "posts/ipynb/da_statistics_basics.html#sample-t-test",
    "title": "파이썬 통계분석하기",
    "section": "2.1 1-sample T-test",
    "text": "2.1 1-sample T-test\n하나의 집단의 평균이 특정 기준보다 유의미하게 다른지 를 알아보는 분석 방법입니다. Student T-test이라고도 하는 1-sample T-test 를 사용하려면 scipy.stats.ttest_1samp() 함수를 사용하면 됩니다.\n\nfrom scipy import stats\n\n\n## Student’s t-test: the simplest statistical test\nstats.ttest_1samp(df[\"VIQ\"], 0)\n# VIQ의 평균값이 0과 통계적으로 유의미하게 다른지 알아 보겠습니다.\n\nTtest_1sampResult(statistic=30.088099970849328, pvalue=1.3289196468728067e-28)\n\n\n간단하게 결론만 말하자면, p-value가 아주 낮음(10의 -28제곱) 으로 VIQ의 평균은 0이 아니라고 말할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#sample-t-test-1",
    "href": "posts/ipynb/da_statistics_basics.html#sample-t-test-1",
    "title": "파이썬 통계분석하기",
    "section": "2.2 2-sample t-test",
    "text": "2.2 2-sample t-test\n서로 다른 두개의 그룹 간 평균의 차이가 유의미 한지 여부를 판단하기 위해 시행합니다. 2-sample t-test 는 scipy.stats.ttest_ind(): 함수를 사용합니다.\n예를 들어 여자의 VIQ와 남자의 VIQ의 평균은 통계적으로 차이가 있는지 알아 보겠습니다.\n\n# 여자의 VIQ\nfemale_viq = df[df[\"Gender\"] == \"Female\"][\"VIQ\"]\n# 남자의 VIQ\nmale_viq = df[df[\"Gender\"] == \"Male\"][\"VIQ\"]\n# 두개의 리스트를 가지고 t-test실행\nstats.ttest_ind(female_viq, male_viq)\n\nTtest_indResult(statistic=-0.77261617232750113, pvalue=0.44452876778583217)\n\n\np-value가 0.44로 아주 높게 나왔습니다. 따라서 기무가설이었던 남자와 여자의 VIQ 평균에는 차이가 있다. 는 기각되고 차이가 없다 라고 결론을 낼 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#paired-tests",
    "href": "posts/ipynb/da_statistics_basics.html#paired-tests",
    "title": "파이썬 통계분석하기",
    "section": "2.3 Paired tests:",
    "text": "2.3 Paired tests:\nPaired t-test는 동일한 집단에서의 반복적인 측정에 의한 차이를 비교하기 위해 사용됩니다. 예를 들면 커피가 수면시간에 미치는 영향을 보기 위해 커피를 마시지 않고 측정하고 커피를 마시고 측정한 데이터를 수집하여 사용합니다. &gt; 전제조건을 충족하기 위해서는 실험이 길어지는 단점이 있습니다"
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#f-test",
    "href": "posts/ipynb/da_statistics_basics.html#f-test",
    "title": "파이썬 통계분석하기",
    "section": "4.1 F-test",
    "text": "4.1 F-test\nF-test는 두 표본의 분산에 대한 차이가 통계적으로 유의한가를 판별하는 검정기법입니다. 다른 이름으로 var-test로도 불립니다.\n\nfrom statsmodels.formula.api import ols\n\nmodel = ols(\"VIQ ~ Gender + MRI_Count + Height\", df).fit()\nprint(model.summary())\nprint(model.f_test([0, 1, 0, 0]))\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                    VIQ   R-squared:                       0.246\nModel:                            OLS   Adj. R-squared:                  0.181\nMethod:                 Least Squares   F-statistic:                     3.809\nDate:                Thu, 21 Dec 2017   Prob (F-statistic):             0.0184\nTime:                        15:34:54   Log-Likelihood:                -172.34\nNo. Observations:                  39   AIC:                             352.7\nDf Residuals:                      35   BIC:                             359.3\nDf Model:                           3                                         \nCovariance Type:            nonrobust                                         \n==================================================================================\n                     coef    std err          t      P&gt;|t|      [0.025      0.975]\n----------------------------------------------------------------------------------\nIntercept        166.6258     88.824      1.876      0.069     -13.696     346.948\nGender[T.Male]     8.8524     10.710      0.827      0.414     -12.890      30.595\nMRI_Count          0.0002   6.46e-05      2.615      0.013    3.78e-05       0.000\nHeight            -3.0837      1.276     -2.417      0.021      -5.674      -0.494\n==============================================================================\nOmnibus:                        7.373   Durbin-Watson:                   2.109\nProb(Omnibus):                  0.025   Jarque-Bera (JB):                2.252\nSkew:                           0.005   Prob(JB):                        0.324\nKurtosis:                       1.823   Cond. No.                     2.40e+07\n==============================================================================\n\nWarnings:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 2.4e+07. This might indicate that there are\nstrong multicollinearity or other numerical problems.\n&lt;F test: F=array([[ 0.68319608]]), p=0.4140878441244722, df_denom=35, df_num=1&gt;\n\n\nF test 결과, p-value 가 0.41로 아주 높게 나왔습니다. 따라서 기무가설을 기각하지 못합니다. 다시 말해 성별에 의한 VIQ 차이는 없다 라고 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_basics.html#시각화",
    "href": "posts/ipynb/da_statistics_basics.html#시각화",
    "title": "파이썬 통계분석하기",
    "section": "4.2 시각화",
    "text": "4.2 시각화\n시각화를 하면 통계분석에 사용된 변수간의 상관관계를 손쉽게 확인할 수 있습니다. 아래 코드는 scatter_matrix를 그리는 방법입니다.\n\n# This plotting is useful to get an intuitions on the relationships between\n# our different variables\n\n# Fill in the missing values for Height for plotting\ndf[\"Height\"].fillna(method=\"pad\", inplace=True)\n\n# The parameter 'c' is passed to plt.scatter and will control the color\n# The same holds for parameters 'marker', 'alpha' and 'cmap', that\n# control respectively the type of marker used, their transparency and\n# the colormap\nscatter_matrix(\n    df[[\"VIQ\", \"MRI_Count\", \"Height\"]],\n    c=(df[\"Gender\"] == \"Female\"),\n    marker=\"o\",\n    alpha=0.7,\n)\n\nfig = plt.gcf()\nfig.suptitle(\"purple: male, yellow: female\", size=13)\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html",
    "href": "posts/ipynb/ml_deepsp_basics.html",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "",
    "text": "항체의약품을 개발하는 과정은 시간과 비용이 많이 들고 성공 확률 또한 낮습니다. 수많은 후보 항체 중 어떤 것이 임상 개발까지 이어질지 예측하는 것은 마치 ’바늘찾기’와 같습니다.\n이러한 문제를 해결하기 위해 인공지능 기술이 바이오 의약품 개발에 접목되고 있습니다. 특히 딥러닝 기술은 방대한 양의 데이터를 학습하여 항체 후보 물질의 특성을 예측하고, 개발 성공 가능성을 높이는 데 기여하고 있습니다. 오늘은 DeepSP라는 딥러닝 기반 모델을 통해 항체 의약품의 개발 가능성을 예측하는 방법을 알아보고자 합니다. 이 튜토리얼은 여러분이 복잡한 계산이나 전문 지식 없이도 DeepSP 모델을 이해하고 활용할 수 있도록 돕는 것을 목표로 합니다."
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#anarci-실행",
    "href": "posts/ipynb/ml_deepsp_basics.html#anarci-실행",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "2.1 ANARCI 실행",
    "text": "2.1 ANARCI 실행\n아래 명령어를 통해 각 서열에 파일에 대한 서열 정렬과 CDR 영역을 식별할 수 있습니다.\n\n-p 옵션은 CPU 코어 수를 지정합니다. 여기에서는 30개를 사용했습니다.\n주피터 노트북안에서 실행해서 SyntaxWarning이 발생했습니다. 터미널에서 실행할때는 문제가 없을 것입니다.\n\n\n!ANARCI -i ../data/example/seq_H.fasta -o ../data/example/seq_aligned -p 30 -s imgt -r heavy --csv\n!ANARCI -i ../data/example/seq_L.fasta -o ../data/example/seq_aligned -p 30 -s imgt -r light --csv\n\n/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/AbDev/.pixi/envs/default/bin/ANARCI:13: SyntaxWarning: invalid escape sequence '\\ '\n  ANARCI                                                 \\\\\\    //\n/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/AbDev/.pixi/envs/default/bin/ANARCI:13: SyntaxWarning: invalid escape sequence '\\ '\n  ANARCI                                                 \\\\\\    //"
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#서열-데이터-전처리",
    "href": "posts/ipynb/ml_deepsp_basics.html#서열-데이터-전처리",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "3.1 서열 데이터 전처리",
    "text": "3.1 서열 데이터 전처리\n중쇄(heavy chain)와 경쇄(light chain) 서열 데이터를 읽고 단일 텍스트 파일로 만드는 전처리를 진행합니다.\n\nimport pandas as pd\n\n\ndef seq_preprocessing(infile_H_path: str, infile_L_path: str, outfile_path: str) -&gt; None:\n    \"\"\"\n    중쇄와 경쇄 시퀀스 데이터를 CSV 파일에서 읽어 처리하고,\n    결합된 시퀀스를 단일 텍스트 파일로 작성합니다.\n\n    Args:\n        infile_H_path: 중쇄 시퀀스 CSV 파일 경로\n        infile_L_path: 경쇄 시퀀스 CSV 파일 경로\n        outfile_path: 출력 텍스트 파일 경로\n    \"\"\"\n    try:\n        infile_H: pd.DataFrame = pd.read_csv(infile_H_path)\n        infile_L: pd.DataFrame = pd.read_csv(infile_L_path)\n    except FileNotFoundError as e:\n        print(f\"Error: A required file was not found. {e}\")\n        return\n    except pd.errors.EmptyDataError:\n        print(\"Error: One of the input CSV files is empty.\")\n        return\n\n    h_list_base: list[str] = [str(i) for i in range(1, 112)]\n    h_list_suffixes: list[str] = [f\"111{s}\" for s in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"]] + [\n        f\"112{s}\" for s in [\"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"]\n    ]\n    h_list_end: list[str] = [str(i) for i in range(112, 129)]\n    H_inclusion_list: list[str] = h_list_base + h_list_suffixes + h_list_end\n    L_inclusion_list: list[str] = [str(i) for i in range(1, 128)]\n\n    H_columns_to_select: list[str] = [col for col in H_inclusion_list if col in infile_H.columns]\n    L_columns_to_select: list[str] = [col for col in L_inclusion_list if col in infile_L.columns]\n\n    H_seq_data: pd.DataFrame = infile_H.loc[:, H_columns_to_select].fillna(\"-\")\n    L_seq_data: pd.DataFrame = infile_L.loc[:, L_columns_to_select].fillna(\"-\")\n\n    H_seq_series: pd.Series = H_seq_data.apply(lambda row: \"\".join(row.values.astype(str)), axis=1)\n    L_seq_series: pd.Series = L_seq_data.apply(lambda row: \"\".join(row.values.astype(str)), axis=1)\n\n    combined_seq_series: pd.Series = H_seq_series + L_seq_series\n    output_series: pd.Series = infile_H[\"Id\"].astype(str) + \" \" + combined_seq_series.astype(str)\n\n    with open(outfile_path, \"w\") as outfile:\n        outfile.write(\"\\n\".join(output_series))\n\n\nPATH: str = \"../data/example/\"\nseq_preprocessing(\n    PATH + \"seq_aligned_H.csv\", PATH + \"seq_aligned_KL.csv\", PATH + \"seq_aligned_HL.csv\"\n)\n\n전처리가 완료되면 seq_aligned_HL.csv 파일이 생성됩니다. 이 파일은 DeepSP 모델에 입력될 준비가 된 데이터입니다. 이제 이 파일을 사용하여 DeepSP 모델을 실행할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#deepsp-모델-실행",
    "href": "posts/ipynb/ml_deepsp_basics.html#deepsp-모델-실행",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "3.2 DeepSP 모델 실행",
    "text": "3.2 DeepSP 모델 실행\n\nimport numpy as np\nfrom keras.models import model_from_json\nfrom tensorflow.keras.models import Sequential, model_from_json\n\n\ndef load_pred_data(filename: str) -&gt; tuple[list[str], list[str]]:\n    name_list: list[str] = []\n    seq_list: list[str] = []\n    with open(filename) as datafile:\n        for line in datafile:\n            line = line.strip().split()\n            name_list.append(line[0])\n            seq_list.append(line[1])\n    return name_list, seq_list\n\n\ndef one_hot_encoder(s: str) -&gt; np.ndarray:\n    d: dict[str, int] = {\n        \"A\": 0,\n        \"C\": 1,\n        \"D\": 2,\n        \"E\": 3,\n        \"F\": 4,\n        \"G\": 5,\n        \"H\": 6,\n        \"I\": 7,\n        \"K\": 8,\n        \"L\": 9,\n        \"M\": 10,\n        \"N\": 11,\n        \"P\": 12,\n        \"Q\": 13,\n        \"R\": 14,\n        \"S\": 15,\n        \"T\": 16,\n        \"V\": 17,\n        \"W\": 18,\n        \"Y\": 19,\n        \"-\": 20,\n    }\n\n    x: np.ndarray = np.zeros((len(d), len(s)))\n    x[[d[c] for c in s], range(len(s))] = 1\n    return x\n\n\nname_list, seq_list = load_pred_data(PATH + \"seq_aligned_HL.txt\")\n\nfor prop in [\"SAPpos\", \"SCMpos\", \"SCMneg\"]:\n    json_file = open(\"../models/Conv1D_regression\" + prop + \".json\")\n    loaded_model_json = json_file.read()\n    json_file.close()\n\n    loaded_model = model_from_json(loaded_model_json, custom_objects={\"Sequential\": Sequential})\n\n    # load weights into model\n    loaded_model.load_weights(\"../models/Conv1D_regression_\" + prop + \".h5\")\n\n    X = [one_hot_encoder(s=x) for x in seq_list]\n    X = np.transpose(np.asarray(X), (0, 2, 1))\n    X = np.asarray(X)\n\n    loaded_model.compile(optimizer=\"adam\", loss=\"mae\", metrics=[\"mae\"])\n    y_pred = loaded_model.predict(X)\n\n    outfile = open(PATH + \"pnas_deep\" + prop + \".csv\", \"w\")\n\n    for i in range(len(y_pred)):\n        outfile.write(f\"{name_list[i]} {' '.join([f'{num:.2f}' for num in y_pred[i]])}\")\n        outfile.write(\"\\n\")\n\n    outfile.close()\n\ndf_pnas_SAPpos = pd.read_csv(PATH + \"pnas_deepSAPpos.csv\", delimiter=\" \", header=None)\ndf_pnas_SAPpos.columns = [\n    \"Name\",\n    \"SAP_pos_CDRH1\",\n    \"SAP_pos_CDRH2\",\n    \"SAP_pos_CDRH3\",\n    \"SAP_pos_CDRL1\",\n    \"SAP_pos_CDRL2\",\n    \"SAP_pos_CDRL3\",\n    \"SAP_pos_CDR\",\n    \"SAP_pos_Hv\",\n    \"SAP_pos_Lv\",\n    \"SAP_pos_Fv\",\n]\n\ndf_pnas_SCMpos = pd.read_csv(PATH + \"pnas_deepSCMpos.csv\", delimiter=\" \", header=None)\ndf_pnas_SCMpos.columns = [\n    \"Name\",\n    \"SCM_pos_CDRH1\",\n    \"SCM_pos_CDRH2\",\n    \"SCM_pos_CDRH3\",\n    \"SCM_pos_CDRL1\",\n    \"SCM_pos_CDRL2\",\n    \"SCM_pos_CDRL3\",\n    \"SCM_pos_CDR\",\n    \"SCM_pos_Hv\",\n    \"SCM_pos_Lv\",\n    \"SCM_pos_Fv\",\n]\n\ndf_pnas_SCMneg = pd.read_csv(PATH + \"pnas_deepSCMneg.csv\", delimiter=\" \", header=None)\ndf_pnas_SCMneg.columns = [\n    \"Name\",\n    \"SCM_neg_CDRH1\",\n    \"SCM_neg_CDRH2\",\n    \"SCM_neg_CDRH3\",\n    \"SCM_neg_CDRL1\",\n    \"SCM_neg_CDRL2\",\n    \"SCM_neg_CDRL3\",\n    \"SCM_neg_CDR\",\n    \"SCM_neg_Hv\",\n    \"SCM_neg_Lv\",\n    \"SCM_neg_Fv\",\n]\n\nmerged_df = df_pnas_SAPpos.merge(df_pnas_SCMneg, on=\"Name\", how=\"inner\")\ndf_deepsp = merged_df.merge(df_pnas_SCMpos, on=\"Name\", how=\"inner\")\n\ndf_deepsp.to_csv(PATH + \"SAPSCM.csv\", index=False)\n\n2025-08-22 16:52:19.201950: I tensorflow/core/util/port.cc:153] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n2025-08-22 16:52:19.220436: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.\nTo enable the following instructions: SSE3 SSE4.1 SSE4.2 AVX AVX2 AVX_VNNI FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.\n\n\n\n5/5 ━━━━━━━━━━━━━━━━━━━━ 0s 22ms/step\n\n5/5 ━━━━━━━━━━━━━━━━━━━━ 0s 20ms/step\n\nWARNING:tensorflow:5 out of the last 11 calls to &lt;function TensorFlowTrainer.make_predict_function.&lt;locals&gt;.one_step_on_data_distributed at 0x79cf3848f7e0&gt; triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n\n1/5 ━━━━━━━━━━━━━━━━━━━━ 0s 63ms/stepWARNING:tensorflow:5 out of the last 11 calls to &lt;function TensorFlowTrainer.make_predict_function.&lt;locals&gt;.one_step_on_data_distributed at 0x79cf3848f7e0&gt; triggered tf.function retracing. Tracing is expensive and the excessive number of tracings could be due to (1) creating @tf.function repeatedly in a loop, (2) passing tensors with different shapes, (3) passing Python objects instead of tensors. For (1), please define your @tf.function outside of the loop. For (2), @tf.function has reduce_retracing=True option that can avoid unnecessary retracing. For (3), please refer to https://www.tensorflow.org/guide/function#controlling_retracing and https://www.tensorflow.org/api_docs/python/tf/function for  more details.\n\n5/5 ━━━━━━━━━━━━━━━━━━━━ 0s 18ms/step\n\n\n\n\n예측이 완료되면 이제 결과를 확인해봅니다.\n\nprint(df_deepsp.head())\n\n          Name  SAP_pos_CDRH1  SAP_pos_CDRH2  SAP_pos_CDRH3  SAP_pos_CDRL1  \\\n0   abituzumab           3.86           4.35           8.72           2.15   \n1    abrilumab           3.42           1.08           1.83           2.09   \n2   adalimumab           2.13           2.52          14.45           1.90   \n3  alemtuzumab           2.27           3.70           5.04           2.22   \n4   alirocumab           2.34           0.49           5.75           6.34   \n\n   SAP_pos_CDRL2  SAP_pos_CDRL3  SAP_pos_CDR  SAP_pos_Hv  SAP_pos_Lv  ...  \\\n0           4.70           6.79        30.68       45.53       36.43  ...   \n1           2.40           6.01        17.93       43.01       31.23  ...   \n2           3.59           3.17        27.50       58.42       30.52  ...   \n3           2.76           3.33        20.66       52.66       32.29  ...   \n4           2.48           4.47        23.01       52.35       43.46  ...   \n\n   SCM_pos_CDRH1  SCM_pos_CDRH2  SCM_pos_CDRH3  SCM_pos_CDRL1  SCM_pos_CDRL2  \\\n0          33.36          50.21          58.55          37.38          99.53   \n1           3.42          -1.28           7.43          36.73           8.36   \n2           3.18          19.58          29.51         116.77          41.76   \n3          31.13         109.97         113.78          59.37          59.35   \n4          87.39          30.73          22.05         163.36          64.86   \n\n   SCM_pos_CDRL3  SCM_pos_CDR  SCM_pos_Hv  SCM_pos_Lv  SCM_pos_Fv  \n0          19.15       301.27      877.35     1176.29     2044.64  \n1          19.31        67.66      919.62      941.50     1849.14  \n2          55.55       263.84      907.11     1219.44     2109.09  \n3         156.55       539.40     1461.24     1302.77     2748.46  \n4          19.05       393.55     1270.47      966.63     2228.18  \n\n[5 rows x 31 columns]\n\n\n위 결과를 보면 전체적으로 SAP와 SCM의로 구분되어 있는데, SAP는 응집도(Aggregation)와 관련된 특성이고 SCM는 전하(Charge)와 관련된 것입니다. 그리고 전하가 postive인지 negative인지에 따라 구분되고 CDR 영역에 따라 CDR1, CDR2, CDR3, Hv(heavy chain variable region), Lv(light chain variable region)등으로 구분되어 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#abdev에-사용된-지표간의-상관-관계",
    "href": "posts/ipynb/ml_deepsp_basics.html#abdev에-사용된-지표간의-상관-관계",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "6.1 AbDev에 사용된 지표간의 상관 관계",
    "text": "6.1 AbDev에 사용된 지표간의 상관 관계\n12가지 지표들의 상관관계를 시각화해서 어떤 지표들이 서로 연관되어 있는지 확인합니다. 이를 통해 특정 지표가 다른 지표에 영향을 미치는지 파악할 수 있습니다.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\ndf = results_df\n\n# 상관관계 행렬 계산 시 숫자형 데이터만 사용하도록 수정합니다.\ncorr_mat = df.corr(numeric_only=True).stack().reset_index(name=\"correlation\")\n\ng = sns.relplot(\n    data=corr_mat,\n    x=\"level_0\",\n    y=\"level_1\",\n    hue=\"correlation\",\n    size=\"correlation\",\n    palette=\"vlag\",\n    hue_norm=(-1, 1),\n    edgecolor=\".5\",\n    height=4,\n    sizes=(50, 200),\n    size_norm=(-0.2, 0.8),\n)\n\ng.set(xlabel=\"\", ylabel=\"\", aspect=\"equal\")\ng.despine(left=True, bottom=True)\nfor label in g.ax.get_xticklabels():\n    label.set_rotation(90)\n\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를 보면 ACSINS, AS, BVP, CIC, CSI, ELISA, PSR 값은 서로 양의 상관관계를 갖고 있는 것을 알 수 있습니다. 반면 SGAC는 대체로 음의 상관관계를 갖고 있습니다. 이러한 상관관계는 항체의 특정 생물물리학적 특성들이 서로 어떻게 연관되어 있는지를 이해하는 데 도움이 됩니다."
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#abdev-결과-클러스터-맵",
    "href": "posts/ipynb/ml_deepsp_basics.html#abdev-결과-클러스터-맵",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "6.2 AbDev 결과 클러스터 맵",
    "text": "6.2 AbDev 결과 클러스터 맵\n클러스터 맵을 통해 AbDev 결과를 시각화합니다. 이를 통해 각 항체의 생물물리학적 특성들이 어떻게 그룹화되는지 확인할 수 있습니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\ndef create_biophysical_clustermap(df: pd.DataFrame):\n    \"\"\"\n    주어진 DataFrame을 사용하여 클러스터 맵을 생성하고 시각화합니다.\n    'Name' 열을 인덱스로 설정하고, 나머지 수치형 열을 클러스터 맵에 표시합니다.\n    클러스터 맵은 데이터를 계층적으로 클러스터링하여 유사한 데이터 포인트를 그룹화합니다.\n\n    Args:\n        df (pd.DataFrame): 'Name' 및 생물물리학적 특성 예측 결과를 포함하는 DataFrame.\n    \"\"\"\n\n    # 'Name' 열을 인덱스로 설정하여 시각화에 사용합니다.\n    df_clustermap = df.set_index(\"Name\")\n\n    # 'Name'을 제외한 모든 수치형 데이터를 선택합니다.\n    numeric_df = df_clustermap.select_dtypes(include=np.number)\n\n    # Seaborn을 사용하여 클러스터 맵을 그립니다.\n    # 클러스터링을 통해 데이터의 숨겨진 패턴을 발견할 수 있습니다.\n    # standard_scale=1: 데이터를 표준화하여 각 특성의 스케일을 맞춥니다.\n    clustermap = sns.clustermap(\n        numeric_df,\n        cmap=\"viridis\",\n        figsize=(12, 10),\n        annot=False,\n        standard_scale=1,\n        cbar_pos=(0.02, 0.8, 0.05, 0.18),  # 컬러바의 위치와 크기를 조정합니다.\n    )\n\n    # Y축 틱 레이블의 폰트 크기를 줄입니다.\n    # 올바른 축인 ax_heatmap을 사용하여 Y축 틱 레이블의 폰트 크기를 조정합니다.\n    plt.setp(clustermap.ax_heatmap.get_yticklabels(), fontsize=8)\n\n    # 플롯을 화면에 표시합니다.\n    plt.suptitle(\"Biophysical Properties Clustermap\", y=1.02)\n    plt.show()\n\n\n# 함수 호출\ncreate_biophysical_clustermap(df)"
  },
  {
    "objectID": "posts/ipynb/ml_deepsp_basics.html#deepviscosity-결과-시각화",
    "href": "posts/ipynb/ml_deepsp_basics.html#deepviscosity-결과-시각화",
    "title": "항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼",
    "section": "6.3 DeepViscosity 결과 시각화",
    "text": "6.3 DeepViscosity 결과 시각화\nDeepViscosity 모델의 예측 결과를 시각화합니다. 이를 통해 각 항체의 점도 등급이 어떻게 분포되어 있는지 확인할 수 있습니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\ndef create_deepvis_heatmap(df: pd.DataFrame):\n    \"\"\"\n    주어진 DataFrame을 사용하여 3개의 서브플롯으로 구성된 히트맵을 생성하고 시각화합니다.\n    이 함수는 'Name', 'Prob_Mean', 'Prob_Std', 'DeepViscosity_classes'\n    열을 포함하는 데이터프레임을 입력으로 받습니다.\n\n    Args:\n        df (pd.DataFrame): 'Name' 및 수치형 예측 결과를 포함하는 DataFrame.\n                          (예: df_deepvis)\n    \"\"\"\n\n    # 히트맵을 위해 'Name' 열을 인덱스로 설정합니다.\n    df_heatmap = df.set_index(\"Name\")\n\n    # 히트맵에 사용할 수치형 데이터만 선택합니다.\n    numeric_df = df_heatmap[[\"Prob_Mean\", \"Prob_Std\", \"DeepViscosity_classes\"]]\n\n    # 데이터를 3개의 서브플롯으로 분할합니다.\n    chunk_size = len(numeric_df) // 3\n    chunks = [numeric_df.iloc[i * chunk_size : (i + 1) * chunk_size] for i in range(2)]\n    chunks.append(numeric_df.iloc[2 * chunk_size :])\n\n    # 3개의 서브플롯이 있는 figure를 생성합니다.\n    # figsize를 조정하여 전체적인 크기를 보기 좋게 만듭니다.\n    fig, axes = plt.subplots(1, 3, figsize=(10, 12))\n\n    # 각 서브플롯에 히트맵을 그립니다.\n    for i, ax in enumerate(axes):\n        sns.heatmap(\n            chunks[i],\n            ax=ax,\n            annot=True,\n            cmap=\"viridis\",\n            linewidths=0.5,\n            cbar=False,\n            cbar_kws={\"label\": \"Value\"},\n        )\n        ax.set_title(f\"Predictions Heatmap - {i + 1}\")\n        ax.set_xlabel(\"\")\n        ax.set_ylabel(\"\")\n\n    # 전체 레이아웃을 조정합니다.\n    plt.tight_layout()\n\n    # 플롯을 화면에 표시합니다.\n    plt.show()\n\n\ncreate_deepvis_heatmap(df_deepvis)"
  },
  {
    "objectID": "posts/ipynb/bio_epitope_binning.html",
    "href": "posts/ipynb/bio_epitope_binning.html",
    "title": "파이썬으로 Epitope binning 하기",
    "section": "",
    "text": "치료용 단클론 항체(mAbs)는 바이오의약품 시장의 70% 이상을 차지하며 지속적으로 성장하고 있습니다. 항체 개발 초기 단계에서 치료제 및 진단 도구로 사용하기 위해 적절한 특성을 가진 후보를 선별하는 것이 중요합니다. 에피토프 빈닝은 mAbs가 표적 단백질(항원)에 결합하는 특성을 파악하는 방법입니다. 이 과정에서 동일한 표적 단백질에 특이적인 mAbs를 쌍으로 테스트하여 항원의 특정 부위에 대한 결합을 서로 차단하는지 여부를 평가합니다. 같은 에피토프에 대한 결합을 차단하는 mAbs는 함께 “빈”으로 분류됩니다. 같은 빈에 속한 mAbs는 종종 유사한 기능을 하므로 에피토프 빈을 통해 후보 항체의 다양성을 확인 할 수 있습니다. 에피토프 다양성은 지적 재산권 보호를 확대하는 데도 중요합니다. 예를 들면 항체들이 같은 항원에 결합하더라도 작용 메커니즘이 다를 수 있는데 이는 일부 암과 감염성 질환 치료에 중요하기 때문입니다.\nSPR을 이용한 에피토프 빈닝의 주요 장점은 항원과 소량의 정제된 항체만 있으면 테스트할 수 있다는 것입니다. SPR을 통한 에피토프 비닝의 원리를 간략하게 설명하면 다음과 같습니다. 첫번째 항체를 고정시켜 놓고 항원과 두번째 항체를 넣어서 RU값을 측정하는데, 에피토프가 겹치지 않는 경우에 RU 값이 높게 측정됩니다. 즉, 에피토프가 비슷한 경우는 RU 값이 낮게 측정되는 것입니다. 이제 SPR을 통해 얻은 epitope binning 데이터를 파이썬으로 분석해서 어떤 항체 커뮤니티가 있는지 식별해보도록 하겠습니다."
  },
  {
    "objectID": "posts/ipynb/bio_epitope_binning.html#히트맵",
    "href": "posts/ipynb/bio_epitope_binning.html#히트맵",
    "title": "파이썬으로 Epitope binning 하기",
    "section": "2.1 히트맵",
    "text": "2.1 히트맵\n히트맵은 차단, 비차단 및 불확실한 항체 쌍에 대한 빠른 개요를 제공합니다. 이를 통해 히트맵 내 데이터를 간편하게 검사할 수 있으며 다음과 같은 이점을 제공합니다:\n\n직관적 이해: 복잡한 데이터를 색상 코드로 표현하여 한눈에 파악할 수 있습니다.\n패턴 식별: 대량의 데이터에서 패턴이나 트렌드를 쉽게 발견할 수 있습니다.\n유연한 분석: 컷오프 값을 조정함으로써 다양한 조건에서 데이터를 분석할 수 있습니다.\n효율적인 데이터 해석: 많은 양의 정보를 압축된 형태로 표현하여 빠른 의사결정을 돕습니다.\n\n\nimport matplotlib.colors as mcolors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Nord Aurora 색상\n# A3BE8C: Nord8 (녹색)\n# EBCB8B: Nord9 (노란색)\n# BF616A: Nord11 (빨간색)\naurora_colors = [\"#BF616A\", \"#EBCB8B\", \"#A3BE8C\"]\n\n# 사용자 정의 색상 맵 생성\ncmap = sns.color_palette(aurora_colors)\n\n# 마스크 생성: NaN은 True, 나머지는 False\nmask = np.isnan(wide_data)\n\nplt.figure(figsize=(10, 10))\nsns.heatmap(\n    df,\n    cmap=cmap,\n    annot=False,\n    linewidths=0.1,\n    mask=mask,\n    vmin=0,  # 최소값을 0으로 설정\n    vmax=1,  # 최대값을 1로 설정 (필요에 따라 조정)\n    center=0.5,  # 중간값을 0.5로 설정\n    cbar_kws={\"label\": \"Value\"},\n    cbar=False,\n    square=True,\n)\n\nplt.title(\"\")\nplt.xlabel(\"\")\nplt.ylabel(\"\")\nplt.show()\n\n\n\n\n\n\n\n\n위 히트맵 결과를 통해 크게 4개의 클러스터가 존재하고 있다는 것을 쉽게 유추할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/bio_epitope_binning.html#knn-클러스터링-및-네트워크-시각화",
    "href": "posts/ipynb/bio_epitope_binning.html#knn-클러스터링-및-네트워크-시각화",
    "title": "파이썬으로 Epitope binning 하기",
    "section": "2.2 KNN 클러스터링 및 네트워크 시각화",
    "text": "2.2 KNN 클러스터링 및 네트워크 시각화\nK-Nearest Neighbors (KNN) 클러스터링은 에피토프 빈닝 데이터를 분석하고 시각화하는 데 유용한 방법으로 히트맵보다 더 명료한 결과를 보여줍니다.\n\nimport matplotlib.colors as mcolors\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom adjustText import adjust_text\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\n\n# 데이터 로드\ndata = tidy_df.reset_index()\n\n# NaN 값을 포함한 행 제거 및 First_ab와 Second_ab가 동일한 행 제거\ndata_clean = data.dropna().query(\"First_ab != Second_ab\")\n\n# 방향성 그래프 생성\nG = nx.DiGraph()\nfor _, row in data_clean.iterrows():\n    G.add_edge(row[\"First_ab\"], row[\"Second_ab\"], weight=row[\"Binding\"])\n\n# 인접 행렬 생성\nadj_matrix = nx.to_numpy_array(G)\n\n# 특성 스케일링\nscaler = StandardScaler()\nadj_matrix_scaled = scaler.fit_transform(adj_matrix)\n\n# KMeans 클러스터링\nn_clusters = 4  # 클러스터 수 고정\nkmeans = KMeans(n_clusters=n_clusters, random_state=420)\ncluster_labels = kmeans.fit_predict(adj_matrix_scaled)\n\n# 클러스터 정보 저장\npartition = dict(zip(G.nodes(), cluster_labels))\n\n# 클러스터 중심 계산\ncluster_centers = kmeans.cluster_centers_\n\n\n# 노드 위치 조정 함수\ndef adjust_positions(pos, partition, cluster_centers):\n    new_pos = {}\n    for node, position in pos.items():\n        cluster = partition[node]\n        center = cluster_centers[cluster][:2]  # 2D 좌표만 사용\n        # 노드를 클러스터 중심 방향으로 이동\n        new_pos[node] = position * 0.3 + center * 0.7\n    return new_pos\n\n\n# 그래프 시각화\nplt.figure(figsize=(8, 8))  # 그림 크기를 더 크게 조정\npos = nx.spring_layout(G, k=0.5, iterations=50)\npos = adjust_positions(pos, partition, cluster_centers)\n\n# 노드 색상 설정\ncolors = [partition[node] for node in G.nodes()]\n\n# Nord Aurora 색상 정의\naurora_colors = [\"#A3BE8C\", \"#EBCB8B\", \"#D08770\", \"#BF616A\", \"#B48EAD\"]\n\n# Aurora 색상으로 ColorMap 생성\naurora_cmap = mcolors.ListedColormap(aurora_colors)\n\n# 노드 그리기\nnx.draw_networkx_nodes(G, pos, node_color=colors, node_size=100, cmap=aurora_cmap)\n\n# 엣지 그리기 (방향성과 가중치 반영)\nedge_weights = [G[u][v][\"weight\"] for u, v in G.edges()]\nmax_weight = max(edge_weights)\nedge_widths = [1 + 3 * (w / max_weight) for w in edge_weights]\n\nnx.draw_networkx_edges(\n    G,\n    pos,\n    alpha=0.3,\n    edge_color=\"lightgray\",\n    # width=edge_widths,\n    arrows=True,\n    arrowsize=10,\n)\n\n# 라벨 위치 조정을 위한 준비\ntexts = []\nfor node, (x, y) in pos.items():\n    texts.append(plt.text(x, y, node, fontsize=8, ha=\"center\", va=\"center\"))\n\n# 라벨 위치 자동 조정\nadjust_text(texts, arrowprops={\"arrowstyle\": \"-\", \"color\": \"gray\", \"lw\": 0.5})\n\nplt.title(\"Directed Graph with Weighted Edges\")\nplt.axis(\"off\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n위의 결과를 통해 총 4개의 항체의 클러스터를 확인 할 수 있었고 히트맵 결과와 유사함이 확인되었습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_QC.html#배경ambient-rna-제거",
    "href": "posts/ipynb/tool_scanpy_QC.html#배경ambient-rna-제거",
    "title": "scRNA-seq 데이터 QC하기",
    "section": "3.1 배경(Ambient) RNA 제거",
    "text": "3.1 배경(Ambient) RNA 제거\n\n\n\n배경 RNA는 세포의 기본 mRNA와 함께 카운트되어 혼동을 일으킵니다.\n\n\ndroplet 기술을 사용한 scRNA-seq의 경우, 세포가 용해되면서 나온 mRNA가 세포들과 함께 시퀀싱될 수 있습니다. 이런 현상을 배경(Ambient) RNA 오염이라 하며 다운스트림 분석에서 해석을 왜곡할 수 있습니다.\n배경 RNA 오염은 사용한 scRNA-seq 기술과 분석한 세포의 유형에 따라 달라지기 때문에 데이터를 적절하게 보정하는 것이 중요합니다. 현재 알려진 방법으로는 SoupX[Young and Behjati, 2020] 및 DecontX[Yang et al., 2020]와 같은 방법이 있는데 이는 세포 용해액의 구성을 추정해 카운트 행렬의 값을 수정하는 원리입니다.\nSoupX는 R언어로 작성되어 있음으로 아래의 코드와 같이 파이썬의 rpy2 모듈을 사용해야 합니다.\n\n%%R\nlibrary(SoupX)\n\n\n    WARNING: The R package \"reticulate\" only fixed recently\n    an issue that caused a segfault when used with rpy2:\n    https://github.com/rstudio/reticulate/pull/1188\n    Make sure that you use a version of that package that includes\n    the fix.\n    \n\n\nSoupX로 더 나은 결과를 얻기 위해서는 클러스터링 정보가 필요합니다.[Young and Behjati, 2020] 먼저 AnnData 객체의 복사본을 만들어 정규화하고, 클러스터링을 진행 합니다. 클러스터링 정보는 soupx_groups 객체로 저장해 사용합니다.\n\nadata_pp = adata.copy()\nsc.pp.normalize_per_cell(adata_pp)\nsc.pp.log1p(adata_pp)\nsc.pp.pca(adata_pp)\nsc.pp.neighbors(adata_pp)\nsc.tl.leiden(adata_pp, key_added=\"soupx_groups\")\n\n# 클러스터를 .obs에 soupx_groups로 추가하고 벡터로 저장합니다.\nsoupx_groups = adata_pp.obs[\"soupx_groups\"]\n\n# AnnData 객체의 복사본을 삭제해 메모리를 절약합니다.\ndel adata_pp\n\n# 세포, 유전자, 필터링된 카운터 행렬을 저장합니다.\n# SoupX에는 모양 특징 x 바코드 행렬이 필요하므로 transpose해야 합니다.\ncells = adata.obs_names\ngenes = adata.var_names\ndata = adata.X.T\n\ncellranger에서 얻은 raw_feature_bc_matrix.h5를 data_tod 객체로 저장해 SoupX의 인풋으로 사용합니다.\n\nadata_raw = sc.read_10x_h5(\n    filename=data_path + \"raw_feature_bc_matrix.h5\",\n)\nadata_raw.var_names_make_unique()\ndata_tod = adata_raw.X.T\n# 객체를 삭제해 메모리를 절약합니다.\ndel adata_raw\n\n이제 SoupX를 실행하기 위한 모든 준비가 완료되었습니다. SoupChannel 객체를 만들고 메타데이터를 데이터 프레임 형식으로 추가합니다. 그런다음 autoEstCont함수를 사용해 배경 RNA 오염 비율을 계산하고 adjustCounts로 카운트 행렬을 보정합니다.다\n\n%%R -i data -i data_tod -i genes -i cells -i soupx_groups -o out \n\n# specify row and column names of data\nrownames(data) = genes\ncolnames(data) = cells\n# ensure correct sparse format for table of counts and table of droplets\ndata &lt;- as(data, \"sparseMatrix\")\ndata_tod &lt;- as(data_tod, \"sparseMatrix\")\n\n# Generate SoupChannel Object for SoupX \nsc = SoupChannel(data_tod, data, calcSoupProfile = FALSE)\n\n# Add extra meta data to the SoupChannel object\nsoupProf = data.frame(row.names = rownames(data), est = rowSums(data)/sum(data), counts = rowSums(data))\nsc = setSoupProfile(sc, soupProf)\n# Set cluster information in SoupChannel\nsc = setClusters(sc, soupx_groups)\n\n# Estimate contamination fraction\nsc  = autoEstCont(sc, doPlot=TRUE)\n# Infer corrected table of counts and rount to integer\nout = adjustCounts(sc, roundToInt = TRUE)\n\n\n\n\n\n\n\n\n이후의 모든 분석 단계에 보정된 카운트 행렬을 사용하고자 soupX_counts 레이어로 .X을 덮어씌웁니다.\n\nadata.layers[\"counts\"] = adata.X\nadata.layers[\"soupX_counts\"] = out.T\nadata.X = adata.layers[\"soupX_counts\"]\n\n추가로 최소 20개 이상의 세포에서 검출되지 않는 유전자는 필터링합니다.\n\nprint(f\"Total number of genes: {adata.n_vars}\")\n\n# Min 20 cells - filters out 0 count genes\nsc.pp.filter_genes(adata, min_cells=20)\nprint(f\"Number of genes after cell filter: {adata.n_vars}\")\n\nTotal number of genes: 32285\nNumber of genes after cell filter: 14534"
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_QC.html#이중체doublet-검출",
    "href": "posts/ipynb/tool_scanpy_QC.html#이중체doublet-검출",
    "title": "scRNA-seq 데이터 QC하기",
    "section": "3.2 이중체(Doublet) 검출",
    "text": "3.2 이중체(Doublet) 검출\n\n\n\n세포 쌍을 무작위로 샘플링하고 유전자 발현 프로필을 평균화하여 염색체 수를 얻고 PCA 공간에 투영합니다. 그런 다음 kNN으로 Doublet점수를 계산해 검출합니다.\n\n\n이중체는 두 개 이상의 세포가 하나의 droplet에 포함된 것입니다. 이런 기술적인 문제가 있기 때문에 카운터 행렬에서 ‘세포’ 대신 ’바코드’라는 용어를 사용하는 것입니다. 이중체는 동일한 세포 유형(그러나 다른 개체에서 유래한)에 의해 형성된 동형 이중체와 그렇지 않은 이형 이중체가 있습니다. 동형 이중체는 카운트 행렬의 정보로 구별이 어렵고 셀 해싱이나 SNP로만 식별할 수 있기 때문에 여기서 다루는 이중체 검출의 목표가 아닙니다.\n반면에 이형 이중체는 잘못 분류될 가능성이 높고 다운스트림 결과를 왜곡할 수 있음으로 이를 식별하는 것은 중요합니다. 일반적으로 이중체 검출은 전처리 초기 단계에서 진행합니다. 이형 이중체 검출을 위한 여러 소프트웨어 패키지들이 있는데 scDblFinder는 현재 가장 검출 정확도가 높고 우수한 계산 효율성 및 안정성을 가진 도구로 평가됩니다.[Xi and Li, 2021] 따라서 여기에서는 scDblFinder 사용합니다.\n\n%%R\nlibrary(Seurat)\nlibrary(scater)\nlibrary(scDblFinder)\nlibrary(BiocParallel)\n\n\ndata_mat = adata.X.T\n\nscDblFinder는 입력 값으로 SingleCellExperiment객체를 사용하므로 아래 예시 코드와 같이 AnnData객체를 변환해야 합니다. 코드를 실행하면 다음의 열이 결과로 추가됩니다.\n\nscDblFinder.score: Doublet 점수(높을수록 셀이 이중일 가능성이 높음)\nscDblFinder.class: 분류(Doublet 또는 Singlet)\n\n\n%%R -i data_mat -o doublet_score -o doublet_class\n\nset.seed(42)\nsce = scDblFinder(\n    SingleCellExperiment(list(counts=data_mat), )\n)\n\ndoublet_score = sce$scDblFinder.score\ndoublet_class = sce$scDblFinder.class\n\n\n# scDblFinder 결과를 AnnData 객체의 .obs에 추가합니다.\nadata.obs[\"scDblFinder_score\"] = doublet_score\nadata.obs[\"scDblFinder_class\"] = doublet_class\nadata.obs.scDblFinder_class.value_counts()\n\nscDblFinder_class\nsinglet    10125\ndoublet     1701\nName: count, dtype: int64\n\n\nDoublet 점수를 시각화해 scDblFinder_class이 올바른지 확인합니다.\nplt.hist(doublet_score, bins=20)\nplt.title(\"Doublet score\")\nplt.show()\n\n\n\n\n\n\n\n추후에 진행될 다운스트림 분석 과정에서 더 많은 또는 더 적은 셀을 필터링하는 것이 필요할 수 있습니다. 따라서 지금 당장 식별된 이중체를 삭제하는 것은 좋은 생각이 아닙니다. 지금까지 진행한 품질 관리 절차를 통해 얼마나 많은 바코드와 유전자가 필터링 되었는지 확인하고 파일로 저장하겠습니다.\n\n\n바코드 수: 13486 -&gt; 11826(0.9)\n유전자 수: 32285 -&gt; 14534(0.5)"
  },
  {
    "objectID": "posts/ipynb/bio_cellcounting.html",
    "href": "posts/ipynb/bio_cellcounting.html",
    "title": "OpenCV를 사용해 이미지에서 세포 수 측정",
    "section": "",
    "text": "생물학 실험에서 이미지에서 세포 수를 측정 작업은 매우 흔한 일입니다. 일반적으로는 이미지를 촬영하는 장비에 자동으로 세포 수를 측적하는 소프트웨어가 같이 제공되고 있습니다. 그러나 가끔은 수동으로 세포의 수를 측정해야하는 경우가 생기곤 합니다. 그런 작업은 시간과 노력이 많이 들고 결과를 신뢰하기 어렵습니다.\n이런 문제를 해결하기 위해 이번 글에서는 오픈소스 컴퓨터 비전 라이브러리인 OpenCV를 사용해 이미지를 분석하고 세포 수를 자동으로 측정하는 방법을 소개합니다. OpenCV는 강력하고 유연한 이미지 처리 라이브러리이며 세포 수 계수 외에도 다양한 생물학적 이미지 분석에 활용될 수 있습니다.\n\n1 사용된 코드\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef process_image(image_path):\n    # 이미지 읽기 및 전처리\n    original_im = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n\n    # 중간값 필터 적용 (노이즈 제거) 및 배경 추정\n    im = cv2.medianBlur(original_im, ksize=3)\n    bg = cv2.medianBlur(im, ksize=101)\n\n    # 배경 제거 및 신호 정규화\n    signal = cv2.subtract(im, bg)\n    signal = cv2.normalize(signal, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)\n\n    # 가우시안 블러 적용 및 마스크 생성\n    smooth = cv2.GaussianBlur(signal, (0, 0), sigmaX=2)\n    valmask = smooth &gt; 24\n    peakmask = smooth == cv2.dilate(smooth, None, iterations=20)\n\n    # 블롭 처리\n    blobs = (valmask & peakmask).astype(np.uint8) * 255\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (11, 11))\n    blobs = cv2.morphologyEx(blobs, cv2.MORPH_DILATE, kernel)\n\n    # 연결된 컴포넌트 분석\n    nlabels, _, _, centroids = cv2.connectedComponentsWithStats(blobs)\n\n    return original_im, signal, centroids, nlabels - 1\n\n\ndef visualize_results(original, processed, centroids):\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))\n\n    ax1.imshow(original, cmap=\"gray\")\n    ax1.set_title(\"Original Image\")\n    ax1.axis(\"off\")\n\n    ax2.imshow(processed, cmap=\"gray\")\n    ax2.set_title(\"Processed Image\")\n    ax2.axis(\"off\")\n\n    for pt in centroids[1:]:\n        ax2.add_artist(plt.Circle(pt, 20, fill=False, color=\"lime\", linewidth=1))\n\n    plt.tight_layout()\n    plt.show()\n\n\n# 메인 실행 부분\nimage_path = \"../data/input/cell_0.png\"\noriginal, processed, centroids, cell_count = process_image(image_path)\nprint(f\"총 {cell_count}개 세포 확인.\")\nvisualize_results(original, processed, centroids)\n\n총 174개 세포 확인.\n\n\n\n\n\n\n\n\n\n다른 이미지에 위의 코드를 다시 사용해보겠습니다.\n\n# 다른 이미지\nimage_path = \"../data/input/cell_2.png\"\noriginal, processed, centroids, cell_count = process_image(image_path)\nprint(f\"총 {cell_count}개 세포 확인.\")\nvisualize_results(original, processed, centroids)\n\n총 293개 세포 확인.\n\n\n\n\n\n\n\n\n\n이번 글에서는 OpenCV를 사용하여 이미지를 분석하고 세포 수를 측정 하는 방법에 대해 설명했습니다. 다만 위에 제시된 방법은 다양한 종류의 세포 이미지에 적용 가능하지 않습니다. 위의 코드는 특정 세포 이미지에 맞춰 최적화된 결과입니다. 따라서 다른 종류의 세포 이미지나 촬영 조건이 다른 이미지에 동일한 코드를 적용할 경우 코드의 파라미터를 조정하거나 전처리 과정을 필요할 수 있습니다.\n그러니 더 효율적이고 정확한 세포 수 측정을 위해서는 NeurIPS 2022 세포 분할 챌린지 최종 우승 소프트웨어인 celldetection를 사용해보시길 권장합니다.\n\n\n2 Reference\n\n이미지 출처"
  },
  {
    "objectID": "posts/ipynb/bio_GSE_fetch.html",
    "href": "posts/ipynb/bio_GSE_fetch.html",
    "title": "GSE에서 sc-RNAseq 데이터 가져오기",
    "section": "",
    "text": "GSE 데이터베이스는 고처리량 유전자 발현 데이터, 특히 유전자 발현 옴니버스(Gene Expression Omnibus) 데이터의 저장소입니다. 이는 국립생물공학정보센터(NCBI)에서 관리하는 무료 온라인 데이터베이스로, 연구자와 과학자들이 유전자 발현 데이터를 공유하고 접근하는 데 널리 사용됩니다. 이 데이터베이스는 RNA 시퀀싱 실험을 포함한 다양한 출처의 방대한 데이터셋 컬렉션을 포함하고 있고 연구자들이 다운로드하여 추가 분석과 연구 목적으로 활용할 수 있습니다. 이는 생물정보학과 유전체학 연구에 매우 귀중한 자원입니다.\n\n1 예시 데이터\n예시 데이터로 GSE231559를 불러오는 방법을 다뤄 보겠습니다. GSE231559는 2023년 9월 25일에 공개된 데이터셋으로, 대장암(CRC)의 단일 세포 수준에서의 유전자 발현 프로파일을 다루고 있습니다. 이 연구는 MD Anderson 암센터의 CRC Moon Shot 프로젝트의 일환으로 수행되었으며, 단일 세포 RNA 시퀀싱(scRNA-seq) 기술을 사용하여 대장암의 다양성을 분석했습니다. 이 데이터셋은 Oncogenic KRAS drives lipo–fibrogenesis to promote angiogenesis and colon cancer progression 논문에 사용되었습니다.\n\n\n2 원시 데이터 살펴보기\nGSE 데이터베이스에서 파일을 다운로드해서 압축을 풀어보면 GSE231559가 아래와 같이 여러개의 파일로 되어 있다는 것을 확인 할 수 있습니다.\nGSM7290760_SC10_21N_barcodes.tsv.gz  GSM7290773_SC10_5_barcodes.tsv.gz\nGSM7290760_SC10_21N_features.tsv.gz  GSM7290773_SC10_5_features.tsv.gz\nGSM7290760_SC10_21N_matrix.mtx.gz    GSM7290773_SC10_5_matrix.mtx.gz\nGSM7290761_SC10_22T_barcodes.tsv.gz  GSM7290774_SC10_7_barcodes.tsv.gz\nGSM7290761_SC10_22T_features.tsv.gz  GSM7290774_SC10_7_features.tsv.gz\nGSM7290761_SC10_22T_matrix.mtx.gz    GSM7290774_SC10_7_matrix.mtx.gz\nGSM7290762_SC10_23N_barcodes.tsv.gz  GSM7290775_SC10_8_barcodes.tsv.gz\nGSM7290762_SC10_23N_features.tsv.gz  GSM7290775_SC10_8_features.tsv.gz\nGSM7290762_SC10_23N_matrix.mtx.gz    GSM7290775_SC10_8_matrix.mtx.gz\nGSM7290763_SC10_24T_barcodes.tsv.gz  GSM7290776_SC143_17_barcodes.tsv.gz\nGSM7290763_SC10_24T_features.tsv.gz  GSM7290776_SC143_17_features.tsv.gz\nGSM7290763_SC10_24T_matrix.mtx.gz    GSM7290776_SC143_17_matrix.mtx.gz\nGSM7290764_SC10_25N_barcodes.tsv.gz  GSM7290777_SC143_7_barcodes.tsv.gz\nGSM7290764_SC10_25N_features.tsv.gz  GSM7290777_SC143_7_features.tsv.gz\nGSM7290764_SC10_25N_matrix.mtx.gz    GSM7290777_SC143_7_matrix.mtx.gz\nGSM7290765_SC10_26N_barcodes.tsv.gz  GSM7290778_SC173_1_barcodes.tsv.gz\nGSM7290765_SC10_26N_features.tsv.gz  GSM7290778_SC173_1_features.tsv.gz\nGSM7290765_SC10_26N_matrix.mtx.gz    GSM7290778_SC173_1_matrix.mtx.gz\nGSM7290766_SC10_27N_barcodes.tsv.gz  GSM7290779_SC173_2_barcodes.tsv.gz\nGSM7290766_SC10_27N_features.tsv.gz  GSM7290779_SC173_2_features.tsv.gz\nGSM7290766_SC10_27N_matrix.mtx.gz    GSM7290779_SC173_2_matrix.mtx.gz\nGSM7290767_SC10_28T_barcodes.tsv.gz  GSM7290780_SC216_1_barcodes.tsv.gz\nGSM7290767_SC10_28T_features.tsv.gz  GSM7290780_SC216_1_features.tsv.gz\nGSM7290767_SC10_28T_matrix.mtx.gz    GSM7290780_SC216_1_matrix.mtx.gz\nGSM7290768_SC10_29N_barcodes.tsv.gz  GSM7290781_SC216_2_barcodes.tsv.gz\nGSM7290768_SC10_29N_features.tsv.gz  GSM7290781_SC216_2_features.tsv.gz\nGSM7290768_SC10_29N_matrix.mtx.gz    GSM7290781_SC216_2_matrix.mtx.gz\nGSM7290769_SC10_30T_barcodes.tsv.gz  GSM7290782_SC216_3_barcodes.tsv.gz\nGSM7290769_SC10_30T_features.tsv.gz  GSM7290782_SC216_3_features.tsv.gz\nGSM7290769_SC10_30T_matrix.mtx.gz    GSM7290782_SC216_3_matrix.mtx.gz\nGSM7290770_SC10_35N_barcodes.tsv.gz  GSM7290783_SC216_5_barcodes.tsv.gz\nGSM7290770_SC10_35N_features.tsv.gz  GSM7290783_SC216_5_features.tsv.gz\nGSM7290770_SC10_35N_matrix.mtx.gz    GSM7290783_SC216_5_matrix.mtx.gz\nGSM7290771_SC10_37N_barcodes.tsv.gz  GSM7290784_SC216_6_barcodes.tsv.gz\nGSM7290771_SC10_37N_features.tsv.gz  GSM7290784_SC216_6_features.tsv.gz\nGSM7290771_SC10_37N_matrix.mtx.gz    GSM7290784_SC216_6_matrix.mtx.gz\nGSM7290772_SC10_38T_barcodes.tsv.gz  GSM7290785_SC216_7_barcodes.tsv.gz\nGSM7290772_SC10_38T_features.tsv.gz  GSM7290785_SC216_7_features.tsv.gz\nGSM7290772_SC10_38T_matrix.mtx.gz    GSM7290785_SC216_7_matrix.mtx.gz\n골치가 아파지네요. 그래도 파일명에 일정한 패턴이 있기에 아래 파이썬 코드를 사용해 갹갹의 adata 객체를 만들어서 합치면 될 것 같습니다.\n\nimport os\n\nimport anndata as ad\nimport numpy as np\nimport pandas as pd\nfrom scipy.io import mmread\nfrom scipy.sparse import csr_matrix\n\n\ndef load_mtx_file(file_path: str) -&gt; csr_matrix:\n    return mmread(file_path).transpose().tocsr()\n\n\ndef load_tsv_file(\n    file_path: str, header: int | None = None, names: list[str] | None = None\n) -&gt; pd.DataFrame:\n    return pd.read_csv(file_path, sep=\"\\t\", header=header, names=names)\n\n\ndef create_anndata(\n    X: csr_matrix,\n    obs_names: list[str],\n    var_names: np.ndarray,\n    var_gene_ids: np.ndarray,\n    code_name: str,\n) -&gt; ad.AnnData:\n    adata = ad.AnnData(X=X)\n    adata.obs_names = obs_names\n    adata.var_names = var_names\n    adata.var[\"gene_ids\"] = var_gene_ids\n    adata.obs[\"Code_name\"] = code_name\n    return adata\n\n\ndef process_sample(data_dir: str, sample_name: str) -&gt; ad.AnnData | None:\n    matrix_file = os.path.join(data_dir, f\"{sample_name}_matrix.mtx.gz\")\n    features_file = os.path.join(data_dir, f\"{sample_name}_features.tsv.gz\")\n    barcodes_file = os.path.join(data_dir, f\"{sample_name}_barcodes.tsv.gz\")\n    code_name = sample_name.split(\"_\")[0]\n\n    if not all(os.path.exists(f) for f in [matrix_file, features_file, barcodes_file]):\n        print(f\"Missing files for {sample_name}\")\n        return None\n\n    try:\n        X = load_mtx_file(matrix_file)\n        gene_names = load_tsv_file(\n            features_file, names=[\"gene_ids\", \"gene_symbols\", \"Gene_expression\"]\n        )\n        barcodes = load_tsv_file(barcodes_file, names=[\"barcode\"])\n\n        obs_names = [f\"{code_name}_{b}\" for b in barcodes[\"barcode\"]]\n        var_names = gene_names[\"gene_symbols\"].values\n        var_gene_ids = gene_names[\"gene_ids\"].values\n\n        adata = create_anndata(X, obs_names, var_names, var_gene_ids, code_name)\n        print(f\"Successfully read {sample_name}\")\n        return adata\n    except Exception as e:\n        print(f\"Error reading {sample_name}: {str(e)}\")\n        return None\n\n\ndata_dir: str = \"../input/GSE231559\"\nadatas: list[ad.AnnData] = []\n\nfor file in os.listdir(data_dir):\n    if file.endswith(\"_matrix.mtx.gz\"):\n        sample_name: str = file.replace(\"_matrix.mtx.gz\", \"\")\n        adata: ad.AnnData | None = process_sample(data_dir, sample_name)\n        if adata is not None:\n            adatas.append(adata)\n\nprint(f\"Total number of processed samples: {len(adatas)}\")\n\nSuccessfully read GSM7290779_SC173_2\nSuccessfully read GSM7290775_SC10_8\nSuccessfully read GSM7290761_SC10_22T\nSuccessfully read GSM7290770_SC10_35N\nSuccessfully read GSM7290768_SC10_29N\nSuccessfully read GSM7290777_SC143_7\nSuccessfully read GSM7290776_SC143_17\nSuccessfully read GSM7290766_SC10_27N\nSuccessfully read GSM7290774_SC10_7\nSuccessfully read GSM7290763_SC10_24T\nSuccessfully read GSM7290784_SC216_6\nSuccessfully read GSM7290767_SC10_28T\nSuccessfully read GSM7290764_SC10_25N\nSuccessfully read GSM7290782_SC216_3\nSuccessfully read GSM7290780_SC216_1\nSuccessfully read GSM7290783_SC216_5\nSuccessfully read GSM7290769_SC10_30T\nSuccessfully read GSM7290773_SC10_5\nSuccessfully read GSM7290771_SC10_37N\nSuccessfully read GSM7290772_SC10_38T\nSuccessfully read GSM7290765_SC10_26N\nSuccessfully read GSM7290760_SC10_21N\nSuccessfully read GSM7290762_SC10_23N\nSuccessfully read GSM7290781_SC216_2\nSuccessfully read GSM7290785_SC216_7\nSuccessfully read GSM7290778_SC173_1\nTotal number of processed samples: 26\n\n\n성공적으로 데이터를 불어왔는지 확인하기 첫번째 객체의 데이터를 확인해봅니다.\n\nadatas[0].obs.head()\n\n\n\n\n\n\n\n\nCode_name\n\n\n\n\nGSM7290779_AAACCCAAGCTAATCC-1\nGSM7290779\n\n\nGSM7290779_AAACGAAAGTCTAGCT-1\nGSM7290779\n\n\nGSM7290779_AAAGAACAGCTCAGAG-1\nGSM7290779\n\n\nGSM7290779_AAAGAACCATGAATAG-1\nGSM7290779\n\n\nGSM7290779_AAAGGATAGAGGCTGT-1\nGSM7290779\n\n\n\n\n\n\n\n\nadatas[0].var.head()\n\n\n\n\n\n\n\n\ngene_ids\n\n\n\n\nMIR1302-2HG\nENSG00000243485\n\n\nFAM138A\nENSG00000237613\n\n\nOR4F5\nENSG00000186092\n\n\nAL627309.1\nENSG00000238009\n\n\nAL627309.3\nENSG00000239945\n\n\n\n\n\n\n\n문제없이 불러온 것 같습니다.\n\n\n3 여러 데이터를 하나로 합치기\n이제 여러 데이터를 하나의 객체로 합쳐보겠습니다. 추가로 메타 데이터를 찾아서 맵핑을 통해 환자 정보와 질병 정보를 추가합니다.\n\ndef make_var_names_unique(adatas: list[ad.AnnData]) -&gt; list[ad.AnnData]:\n    for adata in adatas:\n        adata.var_names_make_unique()\n    return adatas\n\n\ndef merge_anndata(adatas: list[ad.AnnData]) -&gt; ad.AnnData:\n    adata_merged = ad.concat(adatas, join=\"outer\", axis=0, index_unique=\"-\")\n    all_var = pd.concat([adata.var for adata in adatas], axis=0, join=\"outer\")\n    all_var = all_var.loc[~all_var.index.duplicated(keep=\"first\")]\n    adata_merged.var = all_var.loc[adata_merged.var_names]\n    adata_merged.obs[\"Code_name\"] = np.concatenate(\n        [np.repeat(adata.obs[\"Code_name\"].iloc[0], adata.n_obs) for adata in adatas]\n    )\n    return adata_merged\n\n\ndef create_sample_dict() -&gt; dict[str, str]:\n    return {\n        \"GSM7290760\": \"L1_N\",\n        \"GSM7290761\": \"L1_T\",\n        \"GSM7290762\": \"C1_N\",\n        \"GSM7290763\": \"C1_T\",\n        \"GSM7290764\": \"L2_N\",\n        \"GSM7290765\": \"L3_N\",\n        \"GSM7290766\": \"L4_N\",\n        \"GSM7290767\": \"L4_T\",\n        \"GSM7290768\": \"C2_N\",\n        \"GSM7290769\": \"C2_T\",\n        \"GSM7290770\": \"L5_N\",\n        \"GSM7290771\": \"C3_N\",\n        \"GSM7290772\": \"C3_T\",\n        \"GSM7290773\": \"C4_T\",\n        \"GSM7290774\": \"C5_T\",\n        \"GSM7290775\": \"L6_T\",\n        \"GSM7290776\": \"L7_N\",\n        \"GSM7290777\": \"C6_T\",\n        \"GSM7290778\": \"L8_T\",\n        \"GSM7290779\": \"L8_T\",\n        \"GSM7290780\": \"L9_N\",\n        \"GSM7290781\": \"L9_T\",\n        \"GSM7290782\": \"L10_T\",\n        \"GSM7290783\": \"L11_T\",\n        \"GSM7290784\": \"L11_N\",\n        \"GSM7290785\": \"L12_T\",\n    }\n\n\ndef map_code_to_sample(code: str, sample_dict: dict[str, str]) -&gt; str:\n    return sample_dict.get(code, None)\n\n\ndef create_metadata() -&gt; pd.DataFrame:\n    metadata = {\n        \"Patient\": [\n            \"C1\",\n            \"C2\",\n            \"C3\",\n            \"C4\",\n            \"C5\",\n            \"C6\",\n            \"L1\",\n            \"L4\",\n            \"L6\",\n            \"L8\",\n            \"L9\",\n            \"L11\",\n        ],\n        \"Location\": [\n            \"Colon\",\n            \"Colon\",\n            \"Colon\",\n            \"Colon\",\n            \"Colon\",\n            \"Colon\",\n            \"Liver\",\n            \"Liver\",\n            \"Liver\",\n            \"Liver\",\n            \"Liver\",\n            \"Liver\",\n        ],\n        \"Gender\": [\"M\", \"M\", \"F\", \"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"M\"],\n        \"Current_age\": [47, 39, 65, 85, 72, 62, 64, 70, 68, 54, 56, 60],\n        \"Stage_at_collection\": [\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"II\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n            \"IV\",\n        ],\n        \"MS_status\": [\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSI\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n            \"MSS\",\n        ],\n    }\n    meta_df = pd.DataFrame(metadata)\n    meta_df.set_index(\"Patient\", inplace=True)\n    return meta_df\n\n\ndef extract_patient_id(sample: str) -&gt; str:\n    return sample.split(\"_\")[0]\n\n\ndef determine_tissue(sample: str) -&gt; str:\n    parts = sample.split(\"_\")\n    if parts[-1].endswith(\"T\"):\n        return \"tumor\"\n    elif parts[-1].endswith(\"N\"):\n        return \"normal\"\n    else:\n        return \"unknown\"\n\n\ndef add_metadata_to_anndata(adata: ad.AnnData, meta_df: pd.DataFrame) -&gt; ad.AnnData:\n    adata.obs[\"Patient\"] = adata.obs[\"Sample\"].apply(extract_patient_id)\n    for column in meta_df.columns:\n        adata.obs[column] = adata.obs[\"Patient\"].map(meta_df[column])\n    adata.obs[\"Tissue_type\"] = adata.obs[\"Sample\"].apply(determine_tissue)\n    return adata\n\n\n# Main execution\nadatas = make_var_names_unique(adatas)\nadata_merged = merge_anndata(adatas)\n\nsample_dict = create_sample_dict()\nadata_merged.obs[\"Sample\"] = adata_merged.obs[\"Code_name\"].apply(\n    lambda x: map_code_to_sample(x, sample_dict)\n)\n\nmeta_df = create_metadata()\nadata_merged = add_metadata_to_anndata(adata_merged, meta_df)\n\n# Check the result\nadata_merged.obs.head()\n\n\n\n\n\n\n\n\nCode_name\nSample\nPatient\nLocation\nGender\nCurrent_age\nStage_at_collection\nMS_status\nTissue_type\n\n\n\n\nGSM7290779_AAACCCAAGCTAATCC-1-0\nGSM7290779\nL8_T\nL8\nLiver\nM\n54.0\nIV\nMSS\ntumor\n\n\nGSM7290779_AAACGAAAGTCTAGCT-1-0\nGSM7290779\nL8_T\nL8\nLiver\nM\n54.0\nIV\nMSS\ntumor\n\n\nGSM7290779_AAAGAACAGCTCAGAG-1-0\nGSM7290779\nL8_T\nL8\nLiver\nM\n54.0\nIV\nMSS\ntumor\n\n\nGSM7290779_AAAGAACCATGAATAG-1-0\nGSM7290779\nL8_T\nL8\nLiver\nM\n54.0\nIV\nMSS\ntumor\n\n\nGSM7290779_AAAGGATAGAGGCTGT-1-0\nGSM7290779\nL8_T\nL8\nLiver\nM\n54.0\nIV\nMSS\ntumor\n\n\n\n\n\n\n\n위의 출력을 보니 데이터가 정상적으로 합쳐진 것 같습니다. 데이터의 크기도 확인해보죠.\n\nadata_merged.obs.shape\n\n(39992, 15)\n\n\n\n\n4 데이터 저장하기\n이제 데이터 분석에 사용하기 위해 결과를 h5ad 파일로 저장합니다.\n\n# 결과 저장\nadata_merged.write(\"../output/241015_GSE231559_merged.h5ad\", compression=\"gzip\")\n\n\n\n5 마치며\n이번 글에서 우리는 GSE231559 데이터셋을 불러오고 처리하는 과정을 살펴보았습니다. 이러한 과정은 생물정보학 연구에서 매우 중요한 단계이지만, 몇 가지 도전적인 측면이 있습니다. 특히 수동으로 데이터를 합치는 과정과 메타데이터를 추가하는 부분은 모든 데이터셋마다 통일되지 않아 작업자가 직접 작성해야 한다는 점이 번거로울 수 있습니다. 각 데이터셋의 고유한 특성과 구조로 인해 이 과정을 완전히 자동화하기는 어렵기 때문입니다.\n그럼에도 불구하고, 이러한 과정을 직접 수행해보는 것은 데이터의 구조와 특성을 깊이 이해하는 데 큰 도움이 됩니다. 또한, 이를 통해 데이터 처리 능력을 향상시킬 수 있으며, 향후 유사한 작업을 더 효율적으로 수행할 수 있게 될 것입니다.\n이 글을 통해 독자 여러분이 GSE231559와 같은 데이터셋을 직접 다루어보고, 생물정보학 데이터 처리의 실제적인 측면을 경험해보시기를 바랍니다. 이러한 경험은 여러분의 연구나 프로젝트에 큰 도움이 될 것입니다.\n\n\n6 참고\n\n이 데이터를 포함하고 있는 다른 CRC scRNA-seq 데이터 모음: https://onlinelibrary.wiley.com/doi/10.1002/tox.24157"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html",
    "href": "posts/ipynb/da_scanpy_workshop_07.html",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "",
    "text": "공간 전사체 분석은 종양 연구에서 매우 중요한데 종양 미세환경 내의 세포들(종양 세포, 면역세포, 혈관세포 등)과 그들의 상호작용을 이해하는 데 도움이 되기 때문입니다. 특히 공간에서 일어나는 유전자 발현 패턴이 특정 치료제나 면역 치료에 대한 반응성을 예측할 수 있다고 믿어지기 때문에 더욱 더 중요해지고 있습니다. 이번 글에서는 공간 전사체(이하 Visium)데이터와 scRNA-seq 데이터를 결합하는 방법을 위주로 살펴보겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html#스팟-필터링",
    "href": "posts/ipynb/da_scanpy_workshop_07.html#스팟-필터링",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "3.1 스팟 필터링",
    "text": "3.1 스팟 필터링\n미토콘드리아 판독률이 25% 미만이고 헤모글로빈(hb) 판독률이 20% 미만 그리고 검출된 유전자가 1,000개 이상인 모든 스팟을 선택합니다. 데이터에 적합한 필터링 기준은 사전 지식을 바탕으로 직접 판단해야 합니다.\n\nkeep = (\n    (adata.obs[\"pct_counts_hb\"] &lt; 20)\n    & (adata.obs[\"pct_counts_mt\"] &lt; 25)\n    & (adata.obs[\"n_genes_by_counts\"] &gt; 1000)\n)\nprint(sum(keep))\n\nadata = adata[keep, :]\n\n5749\n\n\n필터링한 결과에 대한 조직 절편을 다시 시각화 합니다.\n\nfor library in library_names:\n    print(library)\n    sc.pl.spatial(\n        adata[adata.obs.library_id == library, :],\n        library_id=library,\n        color=[\"total_counts\", \"n_genes_by_counts\", \"pct_counts_mt\", \"pct_counts_hb\"],\n        ncols=2,\n    )\n\nV1_Mouse_Brain_Sagittal_Anterior\n\n\n\n\n\n\n\n\n\nV1_Mouse_Brain_Sagittal_Posterior"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html#많이-발현되는-유전자-확인",
    "href": "posts/ipynb/da_scanpy_workshop_07.html#많이-발현되는-유전자-확인",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "3.2 많이 발현되는 유전자 확인",
    "text": "3.2 많이 발현되는 유전자 확인\n데이터에서 가장 많이 발현되는 유전자가 무엇인지 살펴보겠습니다.\n\nwith plt.rc_context({\"figure.figsize\": (5, 4)}):\n    sc.pl.highest_expr_genes(adata, n_top=20)\n\n\n\n\n\n\n\n\n위 시각화 결과에서 알 수 있듯이 미토콘드리아 유전자는 가장 많이 발현되는 유전자 중 하나입니다. 또한 lncRNA,Bc1(Brain cytoplasmic RNA1)도 많이 발현됩니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html#유전자-필터링하기",
    "href": "posts/ipynb/da_scanpy_workshop_07.html#유전자-필터링하기",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "3.3 유전자 필터링하기",
    "text": "3.3 유전자 필터링하기\n데이터에서 Bc1 유전자, 헤모글로빈 유전자(혈액 오염), 미토콘드리아 유전자를 제거합니다.\n\nmito_genes = adata.var_names.str.startswith(\"mt-\")\nhb_genes = adata.var_names.str.contains(\"^Hb.*-\")\n\nremove = np.add(mito_genes, hb_genes)\nremove[adata.var_names == \"Bc1\"] = True\nkeep = np.invert(remove)\nprint(f\"제거되는 데이터의 갯수: {sum(remove)}\")\n\nadata = adata[:, keep]\n\n제거되는 데이터의 갯수: 22"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html#visium-데이터셋-하위-집합-만들기",
    "href": "posts/ipynb/da_scanpy_workshop_07.html#visium-데이터셋-하위-집합-만들기",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "8.1 Visium 데이터셋 하위 집합 만들기",
    "text": "8.1 Visium 데이터셋 하위 집합 만들기\n불러온 scRNA-seq 데이터는 마우스 대뇌 피질에 대한 것임으로 전체 Visium 데이터에서 대뇌 피질에 대한 부분만 분리해 사용합니다. 물론 전체 데이터를 사용해서 분석을 수행할 수 있지만 위양성이 발생할 수 있음으로 주의해서 해석해야 합니다.\n디컨볼루션을 위해서는 카운트 데이터가 필요하므로 앞서 생성한 counts_adata 객체에서 하위 집합을 만들 것입니다.\n\nlib_a = \"V1_Mouse_Brain_Sagittal_Anterior\"\n\ncounts_adata.obs[\"clusters\"] = adata.obs.clusters\n\nadata_anterior_subset = counts_adata[\n    (counts_adata.obs.library_id == lib_a) & (counts_adata.obsm[\"spatial\"][:, 1] &lt; 6000),\n    :,\n].copy()\n\n# 대뇌 피질 클러스터 선택\nadata_anterior_subset = adata_anterior_subset[\n    adata_anterior_subset.obs.clusters.isin([\"3\", \"5\", \"6\"]), :\n]\n\n# 올바른 구역만 있는지 확인\nwith plt.rc_context({\"figure.figsize\": (5, 5)}):\n    sc.pl.spatial(\n        adata_anterior_subset,\n        img_key=\"hires\",\n        library_id=lib_a,\n        color=[\"clusters\"],\n        # size=1.5,\n    )"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_07.html#디컨볼루션deconvolution",
    "href": "posts/ipynb/da_scanpy_workshop_07.html#디컨볼루션deconvolution",
    "title": "Scanpy로 scRNA-seq 분석 07",
    "section": "8.2 디컨볼루션(Deconvolution)",
    "text": "8.2 디컨볼루션(Deconvolution)\n디컨볼루션은 scRNA-seq 데이터를 사용해 벌크 RNA-seq 데이터셋에서 세포 유형의 비율를 추정하는 방법입니다. Visium 데이터도 일종의 작은 벌크 RNA-seq 데이터로 판단할 수 있기에 적용 할 수 있습니다. 디컨볼루션을 하는 방법에는 DWLS, cell2location, Tangram, Stereo-Seq, RCTD, SCDC 등이 알려져 있습니다. 여기서는 SCVI-tools 패키지에 구현된 Stereoscope을 사용합니다. 자세한 내용은 깃허브를 참조하세요.\n\n8.2.1 디컨볼루션을 위한 유전자 선택하기\n디컨볼루션 방법을 사용하기 위해서는 사전에 유전자 선택해야 하며 아래와 같은 여러 옵션이 있습니다.\n\nVisium 데이터에 가변 유전자를 사용.\nVisium 데이터와 scRNAseq 데이터 모두에 가변 유전자 사용.\nVisium 데이터의 클러스터 간에 DE 유전자를 사용.\n\n여기서는 scRNAseq 데이터의 클러스터당 상위 DE 유전자를 사용할 것입니다.\n\nsc.tl.rank_genes_groups(adata_cortex, \"subclass\", method=\"t-test\", n_genes=100, use_raw=False)\n\nsc.tl.filter_rank_genes_groups(adata_cortex, min_fold_change=1)\n\ngenes = sc.get.rank_genes_groups_df(adata_cortex, group=None)\n# genes\ndeg = genes.names.unique().tolist()\n# Visium 데이터에도 있는 유전자만 남깁니다.\ndeg = np.intersect1d(deg, adata_anterior_subset.var.index).tolist()\n# print(len(deg))\n\n# dotplot 그리기\nsc.pl.rank_genes_groups_dotplot(adata_cortex, n_genes=2)\n\n\n\n\n\n\n\n\n\n\n8.2.2 모델 훈련\n이제 scRNA-seq 데이터를 사용해 모델을 훈련해보겠습니다. 모든 데이터가 카운트 단위여야 한다는 것에 유의하세요. 또한 anndata 객체에 카운트 데이터가 복사본으로 count 레이어로 저장되어 있어야 합니다.\n\n# 카운트 데이터 복사하기\nsc_adata = adata_cortex.copy()\nsc_adata.X = adata_cortex.raw.X.copy()\n\n# 카운트 레이어 추가\nsc_adata.layers[\"counts\"] = sc_adata.X.copy()\n\n# DEG에 속한 유전자로 하위 집합 만들기\nsc_adata = sc_adata[:, deg].copy()\n\n# stereoscope 만들기\nRNAStereoscope.setup_anndata(sc_adata, layer=\"counts\", labels_key=\"subclass\")\n\n# 모델은 파일에 저장되므로 실행 속도가 느린 경우 train = False를 설정해 로컬에 저장된 모델을 읽습니다.\ntrain = True\nif train:\n    sc_model = RNAStereoscope(sc_adata)\n    sc_model.train(max_epochs=300)\n    sc_model.history[\"elbo_train\"][10:].plot()\n    sc_model.save(\"./data/spatial/visium/scanpy_scmodel\", overwrite=True)\nelse:\n    sc_model = RNAStereoscope.load(\"./data/spatial/visium/scanpy_scmodel\", sc_adata)\n    print(\"Loaded RNA model from file!\")\n\nAn NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\nYou are using a CUDA device ('NVIDIA GeForce RTX 4090') that has Tensor Cores. To properly utilize them, you should set `torch.set_float32_matmul_precision('medium' | 'high')` which will trade-off precision for performance. For more details, read https://pytorch.org/docs/stable/generated/torch.set_float32_matmul_precision.html#torch.set_float32_matmul_precision\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\n\n\nEpoch 300/300: 100%|██████████| 300/300 [00:15&lt;00:00, 19.80it/s, v_num=1, train_loss_step=1.38e+7, train_loss_epoch=1.34e+7]\n\n\n`Trainer.fit` stopped: `max_epochs=300` reached.\n\n\nEpoch 300/300: 100%|██████████| 300/300 [00:15&lt;00:00, 19.86it/s, v_num=1, train_loss_step=1.38e+7, train_loss_epoch=1.34e+7]\n\n\n\n\n\n\n\n\n\n\n\n8.2.3 세포 유형 예측하기\n먼저 새로운 Visium 개체 st_adata를 만들고 카운트 데이터를 레이어로 만듭니다.\n\nst_adata = adata_anterior_subset.copy()\n\nst_adata.layers[\"counts\"] = st_adata.X.copy()\nst_adata = st_adata[:, deg].copy()\n\nSpatialStereoscope.setup_anndata(st_adata, layer=\"counts\")\n\ntrain = True\nif train:\n    spatial_model = SpatialStereoscope.from_rna_model(st_adata, sc_model)\n    spatial_model.train(max_epochs=2000)\n    spatial_model.history[\"elbo_train\"][10:].plot()\n    spatial_model.save(\"./data/spatial/visium/scanpy_stmodel\", overwrite=True)\nelse:\n    spatial_model = SpatialStereoscope.load(\"./data/spatial/visium/scanpy_stmodel\", st_adata)\n    print(\"Loaded Spatial model from file!\")\n\nGPU available: True (cuda), used: True\nTPU available: False, using: 0 TPU cores\nIPU available: False, using: 0 IPUs\nHPU available: False, using: 0 HPUs\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\n\n\nEpoch 2000/2000: 100%|██████████| 2000/2000 [00:19&lt;00:00, 102.09it/s, v_num=1, train_loss_step=1.11e+6, train_loss_epoch=1.1e+6] \n\n\n`Trainer.fit` stopped: `max_epochs=2000` reached.\n\n\nEpoch 2000/2000: 100%|██████████| 2000/2000 [00:19&lt;00:00, 100.99it/s, v_num=1, train_loss_step=1.11e+6, train_loss_epoch=1.1e+6]\n\n\n\n\n\n\n\n\n\n이제 scRNA-seq 데이터에서 가져온 세포 유형이 실제로 어떻게 예측되는지 시각화를 통해 살펴봅니다.\n\n# 모델의 예측 결과를 `.obs` 슬롯에 추가합니다.\nst_adata.obsm[\"deconvolution\"] = spatial_model.get_proportions()\n\n# 또한 .obsm에 데이터프레임 추가합니다.\nfor ct in st_adata.obsm[\"deconvolution\"].columns:\n    st_adata.obs[ct] = st_adata.obsm[\"deconvolution\"][ct]\n\n\nwith plt.rc_context({\"figure.figsize\": (6, 4)}):\n    sc.pl.spatial(\n        st_adata,\n        img_key=\"hires\",\n        color=[\"L2/3 IT\", \"L4\", \"L5 PT\", \"L6 CT\", \"Oligo\", \"Astro\"],\n        library_id=lib_a,\n        size=1.5,\n        ncols=2,\n    )\n\n\n\n\n\n\n\n\n또한 바이올린 플랏으로 클러스터간 예측된 세포 유형에 대해 시각화해봅니다.\n\nwith plt.rc_context({\"figure.figsize\": (5, 5)}):\n    sc.pl.violin(\n        st_adata,\n        [\"L2/3 IT\", \"L6 CT\", \"Oligo\", \"Astro\"],\n        jitter=0.4,\n        groupby=\"clusters\",\n        rotation=90,\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n디컨볼루션 결과는 예측 결과로 매개변수, 유전자 선택 등을 어떻게 조정하는지에 따라 다른 결과가 나올 수 있습니다. 그러니 항상 검증하는 단계가 필요합니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_id2symbol.html#pybiomart",
    "href": "posts/ipynb/tool_scanpy_id2symbol.html#pybiomart",
    "title": "Scanpy로 gene_id를 gene_symbol로 변경하기",
    "section": "1.1 pybiomart?",
    "text": "1.1 pybiomart?\npybiomart의 목적은 파이썬에서 BioMart 데이터베이스를 쉽게 접근할 수 있게 간단한 인터페이스를 제공하는 것으로 R에서 biomaRt와 유사한 기능을 제공하는 것을 목표로 합니다. 다음 콘다 명령어를 통해 설치할 수 있습니다.\nconda install pybiomart"
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_id2symbol.html#anndata-객체에-대하여",
    "href": "posts/ipynb/tool_scanpy_id2symbol.html#anndata-객체에-대하여",
    "title": "Scanpy로 gene_id를 gene_symbol로 변경하기",
    "section": "2.1 AnnData 객체에 대하여",
    "text": "2.1 AnnData 객체에 대하여\nScanpy에서 사용되는 AnnData 객체는 개별 세포/유전자 주석 데이터를 저장하는 데이터 구조입니다.AnnData 객체는 크게 네 가지 주요 구성 요소로 구성됩니다.\n\nadata.X는 세포 x 유전자 레이아웃에서 유전자 발현 카운트 정보를 저장.\nadata.obs는 세포 주석을 가리키며, 세포 유형, 총 카운트, 클러스터 ID 등이 Pandas 데이터프레임 형태로 저장. 일반적으로 색인은 세포 바코드를 사용.\nadata.var는 유전자 주석을 가리키며, 유전자 ID, 유전자 심볼, 해당 유전자가 높은 변동성을 가지고 있는지 여부 등이 데이터프레임으로 저장.\nadata.uns는 세포나 유전자와 직접적으로 연결되지 않은 비구조적인 데이터를 포함. 예를 들면 KNN, PCA값 등이 있음."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_id2symbol.html#세포-주석-살펴보기",
    "href": "posts/ipynb/tool_scanpy_id2symbol.html#세포-주석-살펴보기",
    "title": "Scanpy로 gene_id를 gene_symbol로 변경하기",
    "section": "2.2 세포 주석 살펴보기",
    "text": "2.2 세포 주석 살펴보기\n\nadata.obs.head()\n\n\n\n\n\n\n\n\nSample Characteristic[organism]\nSample Characteristic Ontology Term[organism]\nSample Characteristic[individual]\nSample Characteristic Ontology Term[individual]\nSample Characteristic[ethnic group]\nSample Characteristic Ontology Term[ethnic group]\nSample Characteristic[sex]\nSample Characteristic Ontology Term[sex]\nSample Characteristic[age]\nSample Characteristic Ontology Term[age]\n...\nSample Characteristic[clinical history]\nSample Characteristic Ontology Term[clinical history]\nFactor Value[clinical history]\nFactor Value Ontology Term[clinical history]\nFactor Value[sampling time point]\nFactor Value Ontology Term[sampling time point]\nFactor Value[inferred cell type - ontology labels]\nFactor Value Ontology Term[inferred cell type - ontology labels]\nFactor Value[inferred cell type - authors labels]\nFactor Value Ontology Term[inferred cell type - authors labels]\n\n\n\n\nSAMEA7198212-AAAACCGCACAAGCCC\nHomo sapiens\nhttp://purl.obolibrary.org/obo/NCBITaxon_9606\npatient1\nNaN\nThai\nNaN\nmale\nhttp://purl.obolibrary.org/obo/PATO_0000384\n35 year\nNaN\n...\nsecondary DENV-4 infection\nNaN\nsecondary DENV-4 infection\nNaN\none day before defervescence\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\nSAMEA7198212-AAAACCGTCATTGCGA\nHomo sapiens\nhttp://purl.obolibrary.org/obo/NCBITaxon_9606\npatient1\nNaN\nThai\nNaN\nmale\nhttp://purl.obolibrary.org/obo/PATO_0000384\n35 year\nNaN\n...\nsecondary DENV-4 infection\nNaN\nsecondary DENV-4 infection\nNaN\none day before defervescence\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\nSAMEA7198212-AAAACTCCAAGGTGTG\nHomo sapiens\nhttp://purl.obolibrary.org/obo/NCBITaxon_9606\npatient1\nNaN\nThai\nNaN\nmale\nhttp://purl.obolibrary.org/obo/PATO_0000384\n35 year\nNaN\n...\nsecondary DENV-4 infection\nNaN\nsecondary DENV-4 infection\nNaN\none day before defervescence\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\nSAMEA7198212-AAAACTCCAGCGTCCA\nHomo sapiens\nhttp://purl.obolibrary.org/obo/NCBITaxon_9606\npatient1\nNaN\nThai\nNaN\nmale\nhttp://purl.obolibrary.org/obo/PATO_0000384\n35 year\nNaN\n...\nsecondary DENV-4 infection\nNaN\nsecondary DENV-4 infection\nNaN\none day before defervescence\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\nSAMEA7198212-AAAATGATCCTAGGGC\nHomo sapiens\nhttp://purl.obolibrary.org/obo/NCBITaxon_9606\npatient1\nNaN\nThai\nNaN\nmale\nhttp://purl.obolibrary.org/obo/PATO_0000384\n35 year\nNaN\n...\nsecondary DENV-4 infection\nNaN\nsecondary DENV-4 infection\nNaN\none day before defervescence\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 28 columns"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#scrna-seq과-10xgenomics",
    "href": "posts/ipynb/tool_seurat_tutorials.html#scrna-seq과-10xgenomics",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "1.1 scRNA seq과 10xGenomics",
    "text": "1.1 scRNA seq과 10xGenomics\nscRNA-seq는 single-cell RNA sequencing의 줄임말로, 하나의 세포에서 mRNA를 측정하는 방법입니다. 이 기술은 기존 bulk RNA-seq 방법과는 달리 하나의 세포에서 RNA를 추출하여 분석합니다. 이를 통해, 개별 세포의 유전자 발현 패턴, 전사체 감지, 변형과 발현의 상호작용 등을 이해할 수 있습니다.\n10xGenomics는 scRNA-seq 분석에서 매우 인기있는 플랫폼으로 droplet-based 방법을 사용합니다. droplet-based 방법은 cell barcoding 및 unique molecular identifier(UMI)를 사용하여 RNA-seq 라이브러리를 생성하는 공정으로 사실상 현재 scRNA seq분야에 표준으로 사용됩니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#시퀀싱-데이터-준비",
    "href": "posts/ipynb/tool_seurat_tutorials.html#시퀀싱-데이터-준비",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "2.1 시퀀싱 데이터 준비",
    "text": "2.1 시퀀싱 데이터 준비\n실험을 통해 다음과 같은 fastq 파일을 가지고 있다고 간주합니다. 여기에서는 학습 목적으로 아주 작은 데이터셋으로 진행합니다만 실제 데이터는 훨씬 큽니다.\n.(pbmc_1k_v3_fastqs)\n├── pbmc_1k_v3_S1_L001_I1_001.fastq.gz\n├── pbmc_1k_v3_S1_L001_R1_001.fastq.gz\n├── pbmc_1k_v3_S1_L001_R2_001.fastq.gz\n├── pbmc_1k_v3_S1_L002_I1_001.fastq.gz\n├── pbmc_1k_v3_S1_L002_R1_001.fastq.gz\n└── pbmc_1k_v3_S1_L002_R2_001.fastq.gz"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-설치",
    "href": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-설치",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "2.2 cell ranger 설치",
    "text": "2.2 cell ranger 설치\n여기에서는 설치 방법은 생략하고 공식 홈페이지 링크를 참조하시기 바랍니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-실행",
    "href": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-실행",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "2.3 cell ranger 실행",
    "text": "2.3 cell ranger 실행\ncellranger count --id=run_count_1kpbmcs \\\n   --fastqs=./pbmc_1k_v3_fastqs \\\n   --sample=pbmc_1k_v3 \\\n   --transcriptome=./refdata-gex-GRCh38-2020-A\n   --nosecondary\n위의 명령어를 통해 cell ranger를 실행할 수 있습니다. --id 는 생성되는 결과의 폴더명이며, --fastqs는 fastq 파일이 있는 폴더의 위치, --sample은 metadata에 들어가는 샘플 정보, --transcriptome는 참조 전사체의 위치 입니다.\n저의 경우는 10x Genomics 사이트에서 다음의 명령어로 다운로드 받았습니다. 참고로 참조 전사체는 실험에 사용된 시료에 따라 다르게 사용해야 합니다.\nwget https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2020-A.tar.gz\ntar -zxvf refdata-gex-GRCh38-2020-A.tar.gz"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-결과",
    "href": "posts/ipynb/tool_seurat_tutorials.html#cell-ranger-결과",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "2.4 cell ranger 결과",
    "text": "2.4 cell ranger 결과\ncell ranger가 문제없이 작동했다면 out 폴더에 다음과 같은 파일과 폴더가 생겨납니다.\n.(out)\n├── analysis\n├── cloupe.cloupe\n├── filtered_feature_bc_matrix\n├── filtered_feature_bc_matrix.h5\n├── metrics_summary.csv\n├── molecule_info.h5\n├── possorted_genome_bam.bam\n├── possorted_genome_bam.bam.bai\n├── raw_feature_bc_matrix\n├── raw_feature_bc_matrix.h5\n└── web_summary.html\n이중에 Seurat 패키지가 필요로 하는 것은 filtered_feature_bc_matrix 폴더 입니다. 폴더안에는 다음과 같은 파일이 들어있습니다.\n.(filtered_feature_bc_matrix)\n├── barcodes.tsv.gz\n├── features.tsv.gz\n└── matrix.mtx.gz\n이걸로 모든 사전 준비가 완료되었습니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#사용할-패키기-불러오기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#사용할-패키기-불러오기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "2.5 사용할 패키기 불러오기",
    "text": "2.5 사용할 패키기 불러오기\n\n2.5.1 Seurat\nSeurat은 R 프로그래밍 언어로 작성된 scRNA-seq 데이터 분석을 위한 유명한 패키지 중 하나입니다. Seurat은 높은 차원의 scRNA-seq 데이터에서 유전자 발현 패턴을 탐색하고 이를 이용하여 세포 및 클러스터의 식별과 분석, 특성 제시, 시각화 등 다양한 분석 작업을 수행할 수 있습니다. Seurat은 다양한 데이터 전처리 및 정규화 기능과 함께 차원 축소, 클러스터링, 시각화, 서브셋 생성, 유전자 발현 분석, 세포간 상호작용 분석 등 다양한 분석 도구를 제공합니다. Seurat은 현재까지 업데이트와 기능 추가가 활발하게 이루어지고 있으며, scRNA-seq 분석에 필수적인 유틸리티 패키지 중 하나입니다.\n\n\n2.5.2 scDblFinder\nscDblFinder는 단일 세포 RNA 시퀀싱 데이터에서 더블렛(두 개의 세포가 동시에 캡처되어 하나의 세포로 보이는 것) 현상을 탐지하고 제거하기 위한 R 패키지입니다. 이 패키지는 UMI(Unique Molecular Identifier)를 기반으로하여 두 개 이상의 세포에서 동시에 탐지된 UMIs를 찾아서 더블렛으로 추정하고, 더블렛으로 추정된 셀을 제거합니다. 이를 통해 scRNA-seq 데이터의 정확도와 해석력을 높일 수 있습니다. 또한, scDblFinder는 Seurat 및 SingleCellExperiment 형식의 데이터를 지원하며, 다양한 분석 옵션을 제공하여 사용자가 데이터에 맞게 조정할 수 있습니다.\n\n\n2.5.3 tidyverse\ntidyverse는 데이터 분석에 필요한 필수 R 패키지들의 모음으로 데이터 처리, 시각화, 모델링, 프로그래밍 등의 다양한 작업을 수행하는 데 사용됩니다. 주요 패키지로는 ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats 등이 있습니다.\n\noptions(verbose=FALSE) # Seurat 함수들이 실행될 때 로그 메시지를 표시하지 않습니다.\noptions(tidyverse.quiet=TRUE) # tidyverse 패키지의 로그 메시지가 출력되지 않습니다.\noptions(warn=-1)\noptions(future.rng.onMisuse=\"ignore\")\n\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(scDblFinder)\nlibrary(future) # Enable parallelization\nplan(\"multicore\", workers=30) # cpu core에 맞게 조절합니다.\n# plan()\n\n\n\n2.5.4 패키지 버전 확인\n\n2.5.4.1 사용한 Seurat 패키지의 버전\n\npackageVersion(\"Seurat\")\n\n[1] ‘4.3.0’\n\n\n\n\n2.5.4.2 사용한 scDblFinder 패키지의 버전\n\npackageVersion(\"scDblFinder\")\n\n[1] ‘1.12.0’"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#count-행렬은-어떻게-생겼을까",
    "href": "posts/ipynb/tool_seurat_tutorials.html#count-행렬은-어떻게-생겼을까",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "4.1 count 행렬은 어떻게 생겼을까?",
    "text": "4.1 count 행렬은 어떻게 생겼을까?\n\n# 처음 5개의 세포에 있는 몇 가지 유전자를 확인해봅니다.\nseurat_obj[[\"RNA\"]]@counts[c(\"CD3D\", \"TCL1A\", \"MS4A1\"), 1:3]\n\n3 x 3 sparse Matrix of class \"dgCMatrix\"\n      AAACCCAAGGAGAGTA-1 AAACGCTTCAGCCCAG-1 AAAGAACAGACGACTG-1\nCD3D                   .                  .                  6\nTCL1A                  .                  9                  .\nMS4A1                  .                  5                  ."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#seurat-개체의-메타데이터는-어디에-저장될까",
    "href": "posts/ipynb/tool_seurat_tutorials.html#seurat-개체의-메타데이터는-어디에-저장될까",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "4.2 Seurat 개체의 메타데이터는 어디에 저장될까?",
    "text": "4.2 Seurat 개체의 메타데이터는 어디에 저장될까?\nseurat_obj@meta.data 혹은 seurat_obj[[]]을 통해 메타데이터를 확인할 수 있습니다.\n\nhead(seurat_obj@meta.data, 5)\n\n\nA data.frame: 5 × 3\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\n\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n\n\n\n\nAAACCCAAGGAGAGTA-1\npbmc1k\n12861\n3871\n\n\nAAACGCTTCAGCCCAG-1\npbmc1k\n9432\n3234\n\n\nAAAGAACAGACGACTG-1\npbmc1k\n6520\n2631\n\n\nAAAGAACCAATGGCAG-1\npbmc1k\n4362\n2121\n\n\nAAAGAACGTCTGCAAT-1\npbmc1k\n9905\n3157"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#서열-데이터-품질-관리",
    "href": "posts/ipynb/tool_seurat_tutorials.html#서열-데이터-품질-관리",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "5.1 서열 데이터 품질 관리",
    "text": "5.1 서열 데이터 품질 관리\nscRNA seq 데이터의 분석의 신뢰성을 얻기 위해서 데이터의 품질 관리는 필수이빈다. Seurat을 사용하면 품질관리(QC) 지표를 쉽게 탐색하고 사용자 정의 기준에 따라 세포를 필터링할 수 있습니다. 일반적으로 사용되는 QC 기준은 다음 세가지 입니다.\n\n각 세포에서 검출된 고유 유전자의 수.\n\n품질이 낮은 세포는 종종 유전자가 매우 적습니다.\n이중 또는 다중의 세포가 들어간 droplet에는 비정상적으로 유전자 수가 높습니다.\n\n각 세포에서 검출된 총 서열의 수(고유 유전자의 수와 밀접한 상관관계가 있음)\n미토콘드리아 게놈에 매핑되는 서열의 비율\n\n품질이 낮거나 죽어가는 세포에는 미토콘드리아 유전자가 많이 발견됩니다.\n\n\n\n5.1.1 QC 지표 시각화하기\n\n5.1.1.1 바이올린 플랏\n\nseurat_obj[[\"percent.mt\"]] &lt;- PercentageFeatureSet(seurat_obj, pattern=\"^MT-\") \n# mouse 시료의 경우 pattern을 \"^mt-\"로 변경해야 합니다.\n\nplot &lt;- VlnPlot(seurat_obj, features=c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol=3)\n\noptions(repr.plot.width=6, repr.plot.height=6)\nplot\n\n\n\n\n\n\n\n\n\n\n5.1.1.2 Scatter 플랏\n\nplot1 &lt;- FeatureScatter(seurat_obj, feature1=\"nCount_RNA\", feature2=\"percent.mt\")\nplot2 &lt;- FeatureScatter(seurat_obj, feature1=\"nCount_RNA\", feature2=\"nFeature_RNA\")\n\noptions(repr.plot.width=12, repr.plot.height=6)\nplot1 + plot2\n\n\n\n\n\n\n\n\n\n\n\n5.1.2 QC 및 추가 분석을 위한 세포 선택하기\n위의 결과를 토대로 nFeature_RNA가 200개에서 6000개 사이이고 percent.mt가 20 이하인 세포들만 선택합니다.\n\nseurat_obj &lt;- subset(seurat_obj, subset=nFeature_RNA &gt; 200 & nFeature_RNA &lt; 6000 & percent.mt &lt; 20)\n\n아직 모든 QC 과정이 끝난 것은 아닙니다. PCA를 진행하고나서 scDblFinder 패키지를 사용해 추가적인 더블렛 데이터를 제거하겠습니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#데이터-정규화하기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#데이터-정규화하기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "5.2 데이터 정규화하기",
    "text": "5.2 데이터 정규화하기\nQC를 통해 일부 데이터를 제거한 다음 단계는 데이터를 정규화하는 것입니다. 여기서는 각 세포의 발현 값을 전체 발현으로 나누고 스케일 계수(기본적으로 10,000)를 곱한 다음 로그 변환하는 LogNormalize방법을 사용합니다. 이렇게 정규화된 값은 seurat_obj[[\"RNA\"]]@data에 저장됩니다.\n\nseurat_obj &lt;- NormalizeData(seurat_obj, verbose=FALSE)\nseurat_obj &lt;- FindVariableFeatures(seurat_obj, verbose=FALSE)\nseurat_obj &lt;- ScaleData(seurat_obj, verbose=FALSE)\nseurat_obj &lt;- RunPCA(seurat_obj, verbose=FALSE)\n\n\n5.2.1 Elbow 플랏 그리기\nSeurat에서 clustering을 수행하기 전에는 몇 개의 차원(dimension)을 사용할지 결정해야 합니다. 차원의 수는 PCA와 같은 차원 축소 기법을 사용하여 줄여진 차원의 수를 의미합니다. 그리고 이 차원의 수는 클러스터링 알고리즘에 사용됩니다.\n그러나 차원의 수가 너무 적거나 많으면 적절한 클러스터링이 어려울 수 있습니다. 차원이 적을 경우 정보 손실이 크게 발생하고, 차원이 많을 경우에는 불필요한 차원의 포함으로 인해 과적합(overfitting)이 발생할 가능성이 있습니다.\n따라서 적절한 차원의 수를 선택하기 위해 elbow plot을 사용합니다. elbow plot은 차원의 수를 x축으로, 해당 차원의 데이터를 잘 설명하는 정도(예: variance)를 y축으로 나타냅니다. 이 때, 차원의 수를 늘리면 y축 값은 점점 증가하게 됩니다. 그러나 어느 지점 이후로는 y값이 더 이상 크게 증가하지 않고 평평해지는 지점이 나타나는데, 이 지점이 elbow point입니다. 이 지점 이후로는 차원을 늘려도 데이터를 잘 설명하지 못하므로, elbow point를 기준으로 적절한 차원의 수를 선택합니다. 이를 통해 데이터의 차원을 축소할 때, 적절한 차원의 수를 선택하여 과적합을 방지하고 필요한 정보만을 추출할 수 있습니다.\n\nplot &lt;- ElbowPlot(seurat_obj)\n\noptions(repr.plot.width = 6, repr.plot.height = 6)\nplot"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#umap-그리기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#umap-그리기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "6.1 UMAP 그리기",
    "text": "6.1 UMAP 그리기\nUMAP은 Uniform Manifold Approximation and Projection의 약자로, scRNA-seq 데이터를 시각화하기 위한 비선형 차원 축소 방법 중 하나입니다. t-SNE와 유사한 기능을 가지고 있지만, 대규모 데이터셋에서 더욱 빠르고 정확한 임베딩을 제공합니다.\nUMAP은 데이터의 국부적인 구조를 보존하는데 초점을 둡니다. 즉, 비슷한 특성을 가진 데이터들이 서로 가깝게 묶이고, 서로 다른 특성을 가진 데이터들은 더 멀리 배치되도록 임베딩을 생성합니다. 이를 통해, scRNA-seq 데이터의 복잡한 구조를 파악하고 시각화할 수 있습니다.\n\nseurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:10, verbose = FALSE)\nseurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.5, verbose = FALSE)\n# 일반적으로 resolution 값은 0.1 ~ 1.0 사이의 값을 많이 사용합니다. \n# 값이 작을수록 세분화된 군집을 얻을 수 있기 때문에\n# 세포의 종류나 상태 등을 더 세부적으로 파악하고자 할 때는 작은 값이 유용합니다. \n# 반면 큰 값은 대부분의 데이터를 하나의 군집으로 묶어줌으로써 전체적인 데이터 구조를 파악하는 데에 유용할 수 있습니다.\nseurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:10, verbose = FALSE)\n\nplot &lt;- DimPlot(seurat_obj, reduction = \"umap\", label=TRUE)\n\noptions(repr.plot.width = 6, repr.plot.height = 6)\nplot\n\n\n\n\n\n\n\n\n위의 UMAP 플랏을 통해 총 10개의 cluster로 나누어 졌음을 알 수 있습니다. 이제 추가적인 QC를 진행해보겠습니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#scdblfinder를-사용해-doublet-제거-하기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#scdblfinder를-사용해-doublet-제거-하기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "6.2 scDblFinder를 사용해 doublet 제거 하기",
    "text": "6.2 scDblFinder를 사용해 doublet 제거 하기\nscDblFinder는 클러스터 정보를 기반으로 인공적으로 생성된 더블렛을 찾아냅니다. 아래 코드를 통해 더블렛을 찾고 UMAP 플랏에 표시해보겠습니다.\n\nsce &lt;- scDblFinder(GetAssayData(seurat_obj, slot = \"counts\"), clusters = Idents(seurat_obj))\n# scDblFinder 결과 점수를 다시 Seurat 객체로 옮깁니다.\nseurat_obj$scDblFinder.score &lt;- sce$scDblFinder.score\n\np &lt;- FeaturePlot(seurat_obj, \"scDblFinder.score\", pt.size = 0.1) \noptions(repr.plot.width = 6, repr.plot.height = 6)\np\n\nAssuming the input to be a matrix of counts or expected counts.\n\n11 clusters\n\nCreating ~5000 artificial doublets...\n\nas(&lt;dgeMatrix&gt;, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead\n\nDimensional reduction\n\nEvaluating kNN...\n\nTraining model...\n\niter=0, 32 cells excluded from training.\n\niter=1, 29 cells excluded from training.\n\niter=2, 30 cells excluded from training.\n\nThreshold found:0.519\n\n30 (2.6%) doublets called\n\n\n\n\n\n\n\n\n\n\nscDblFinder 결과에서 Threshold 값이 0.519 라는 것과 총 30(2.6%)개의 더블렛이 계산되었습니다. 다시 subset()함수를 사용해 scDblFinder 값이 0.519 이하인 세포만 고르는 QC 과정을 진행하겠습니다.\n\n6.2.1 더블렛 제거하기\n\n# 개체 메타 데이터의 값에 대한 하위 집합만들기\nseurat_obj &lt;- subset(x = seurat_obj, subset = scDblFinder.score &lt; 0.519 )\n\nDefaultAssay(seurat_obj) &lt;- \"RNA\"  # default assay is RNA\nseurat_obj &lt;- NormalizeData(seurat_obj, verbose = FALSE)\nseurat_obj &lt;- FindVariableFeatures(seurat_obj, verbose = FALSE)\nseurat_obj &lt;- ScaleData(seurat_obj, verbose = FALSE)\nseurat_obj &lt;- RunPCA(seurat_obj, verbose = FALSE)\nseurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:10, verbose = FALSE)\nseurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.5, verbose = FALSE)\nseurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:10, verbose = FALSE)\n\np &lt;- DimPlot(seurat_obj, label = TRUE)\n\noptions(repr.plot.width = 7, repr.plot.height = 7)\np"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#marker-gene-찾기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#marker-gene-찾기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "7.1 Marker gene 찾기",
    "text": "7.1 Marker gene 찾기\n\nmarkers &lt;- FindAllMarkers(seurat_obj, only.pos = TRUE, verbose = FALSE)\nwrite_csv(markers, \"../output/pbmc1k_marker.csv\") # 결과를 csv 파일로 저장\nmarkers %&gt;% head()\n\n\nA data.frame: 6 × 7\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\ncluster\ngene\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;fct&gt;\n&lt;chr&gt;\n\n\n\n\nS100A12\n4.929494e-211\n3.984628\n0.979\n0.047\n9.960536e-207\n0\nS100A12\n\n\nVCAN\n3.023544e-202\n4.236786\n1.000\n0.086\n6.109374e-198\n0\nVCAN\n\n\nCD14\n3.015410e-195\n2.387003\n0.954\n0.058\n6.092936e-191\n0\nCD14\n\n\nCSF3R\n2.588854e-192\n2.561836\n0.979\n0.080\n5.231038e-188\n0\nCSF3R\n\n\nMNDA\n1.513641e-189\n3.044325\n0.993\n0.104\n3.058462e-185\n0\nMNDA\n\n\nS100A8\n1.971209e-188\n5.905527\n0.996\n0.142\n3.983026e-184\n0\nS100A8\n\n\n\n\n\nFindAllMarkers() 결과는 데이터프레임입니다. avg_log2FC는 다른 클러스터와 비교해 발현량이 얼마나 차이나는지를 의미합니다. 해당 열을 가지고 각 클러스터당 상위 5개의 유전자 마커를 추려서 heatmap 을 그려봅니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#marker-gene-heatmap",
    "href": "posts/ipynb/tool_seurat_tutorials.html#marker-gene-heatmap",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "7.2 Marker gene heatmap",
    "text": "7.2 Marker gene heatmap\n\ntop5 &lt;- markers %&gt;% group_by(cluster) %&gt;% top_n(n = 5, wt = avg_log2FC)\np &lt;- DoHeatmap(seurat_obj, features = top5$gene) + NoLegend()\n\noptions(repr.plot.width = 7, repr.plot.height = 7)\np\n\n\n\n\n\n\n\n\n위의 heatmap은 멋져보이기는 하지만 그렇게 큰 정보를 제공해주지는 않습니다. 일반적으로 클러스터가 어떤 세포인지 알아내는 작업이 scRNA seq 분석방법에서 가장 중요한 부분이며 여러가지 접근법이 있지만 가장 덜 자동화된 부분이기도 합니다.\n가장 일반적인 방법은 FindAllMarkers() 함수를 이용해 얻은 각 클러스터의 유전자 마커와 참조 데이터 세트를 비교 하는 것입니다. 참조 데이터 세트란, 이미 잘 정의된 세포 유형들의 scRNA-seq 데이터로 현재 분석 중인 데이터의 클러스터들을 참조 데이터 세트와 비교하여 유사한 패턴을 가진 세포 유형을 찾아내는 것입니다. 이 작업은 시간이 아주 많이 필요하며 작업자에 따라 다른 결과가 나옵니다. 그래서 이번에는 ChatGPT를 사용하는 방법으로 해보겠습니다."
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#chatgpt-사용하기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#chatgpt-사용하기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "7.3 ChatGPT 사용하기",
    "text": "7.3 ChatGPT 사용하기\n\nChatGPT에 대한 자세한 설명은 생략합니다.\n\n프롬프터에 클러스터의 유전자 마커를 쉽게 입력하기 위해 다음의 코드를 사용합니다.\n\n# 빈 리스트 생성\nmarker_list &lt;- list()\ngene_number &lt;- 10 # 10개의 유전자만 찾아낼때\n\n# for loop으로 리스트에 값 추가\nfor (i in unique(Idents(seurat_obj))) {\n  marker_list[[paste0(\"cluster\",i)]] &lt;- markers %&gt;% group_by(cluster) %&gt;% top_n(gene_number, avg_log2FC) %&gt;%\n      ungroup() %&gt;% arrange(cluster, desc(avg_log2FC)) %&gt;% filter(cluster == i) %&gt;% .$gene\n}\n\n# 결과 출력\nmarker_list\n\n\n    $cluster0\n        \n'S100A8''S100A9''LYZ''VCAN''S100A12''FCN1''MNDA''CTSS''NAMPT''PLXDC2'\n\n    $cluster3\n        \n'IGHM''AFF3''IGHD''IGLC2''FCRL1''BANK1''TCL1A''BACH2''CD79A''LINC00926'\n\n    $cluster7\n        \n'GZMH''NKG7''CCL5''SGCD''SAMD3''CST7''GZMK''TOX''GZMA''KLRG1'\n\n    $cluster1\n        \n'INPP4B''IL7R''ANK3''CDC14A''SERINC5''BCL11B''IL32''RORA''CAMK4''TTC39C'\n\n    $cluster6\n        \n'IGKC''IGHA1''JCHAIN''IGHG3''IGHGP''IGHG1''IGHG2''BANK1''OSBPL10''MS4A1'\n\n    $cluster2\n        \n'LEF1''NELL2''TSHZ2''FHIT''CAMK4''PRKCA''BCL11B''PDE3B''TXK''TRABD2A'\n\n    $cluster5\n        \n'KLRB1''SLC4A10''IL4I1''GZMK''COLQ''ZBTB16''ADAM12''IL32''AL136456.1''AGAP1'\n\n    $cluster4\n        \n'TCF7L2''CST3''HLA-DPA1''FCGR3A''LST1''HLA-DPB1''AIF1''HLA-DRB1''HLA-DRA''IFI30'\n\n    $cluster8\n        \n'GNLY''NKG7''PRF1''KLRD1''GZMA''KLRF1''SPON2''FGFBP2''CST7''GZMB'\n\n    $cluster9\n        \n'PPBP''GP1BB''NRGN''PF4''CAVIN2''TUBB1''CLU''GNG11''RGS18''HIST1H2AC'\n\n\n\n\n위 코드의 출력을 가지고 ChatGPT에 입력했더니 다음과 같이 말했습니다.\n주어진 유전자 목록만으로는 각각의 클러스터의 정확한 세포 유형을 알 수 없습니다. 유전자는 여러 종류의 세포에서 발현될 수 있기 때문입니다. 유전자의 발현 패턴을 분석하거나 추가적인 실험 결과와 함께 고려해야만 각 클러스터의 세포 유형을 추론할 수 있습니다.\n\n그러나 일반적으로 각 클러스터에 대한 예상 세포 유형은 다음과 같습니다:\n\n$cluster0: 이 클러스터는 PBMC에서 neutrophils을 나타내는 것으로 추정됩니다.\n$cluster1: 이 클러스터는 PBMC에서 CD4 T cells을 나타내는 것으로 추정됩니다.\n$cluster2: 이 클러스터는 PBMC에서 B cells을 나타내는 것으로 추정됩니다.\n$cluster3: 이 클러스터는 PBMC에서 B cells을 나타내는 것으로 추정됩니다.\n$cluster4: 이 클러스터는 PBMC에서 monocytes을 나타내는 것으로 추정됩니다.\n$cluster5: 이 클러스터는 PBMC에서 NK cells을 나타내는 것으로 추정됩니다.\n$cluster6: 이 클러스터는 PBMC에서 B cells을 나타내는 것으로 추정됩니다.\n$cluster7: 이 클러스터는 PBMC에서 CD8 T cells을 나타내는 것으로 추정됩니다.\n$cluster8: 이 클러스터는 PBMC에서 NK cells을 나타내는 것으로 추정됩니다.\n$cluster9: 이 클러스터는 PBMC에서 platelets을 나타내는 것으로 추정됩니다.\n위의 결과를 통해 대부분의 클러스터 타입을 알 수 있지만, B cell이 3개 NK cell이 2개로 중복됩니다. 좀 더 세분화하기 위해 B cell의 유전자 마커를 물어봅니다.\nB cell은 다양한 sub type으로 분류될 수 있습니다. 일부 sub type들과 그에 따른 대표 마커들은 다음과 같습니다.\n\n- Naive B cell\n    CD19, CD20, CD27-, IgD+, IgM+\n- Memory B cell\n    CD19, CD20, CD27+, IgD-, IgM+/-\n- Plasma cell\n    CD19, CD20-, CD38++, CD138+, MUM1+, IRF4+, XBP1+\n- Germinal center B cell\n    CD19, CD20, CD77+, CD10+, BCL6+, AID+\n- Regulatory B cell (Breg)\n    CD19, CD20, CD24++, CD38++, CD25+, IL-10+\n- B1 B cell\n    CD19, CD20, CD27+, IgM+, CD43+\n- Marginal zone B cell\n    CD19, CD20, CD27-, CD43-, IgM+, IgD+, CD23-, CD21+\n\n각 sub type마다 대표적인 마커들이 있지만, 이것들만으로 모든 sub type을 완벽하게 분류하는 것은 어렵습니다. 따라서, sub type 분류는 보통 여러 마커를 조합하여 결정됩니다.\n이번에는 NK cell 세분화를 위한 유전자 마커를 물어봅니다.\nNK 세포는 크게 두 가지 subset으로 나눌 수 있습니다: CD56bright NK 세포와 CD56dim NK 세포입니다. CD56bright NK 세포는 주로 면역 조절에 관여하며, cytokine을 분비하는 역할을 합니다. 반면 CD56dim NK 세포는 주로 세포 독성에 관여하며, 인체 내에서 암세포와 바이러스에 대한 첫 번째 방어선 역할을 합니다.\n\nCD56bright NK 세포를 구별하는 유전자 마커로는 CD56(bright) (NCAM1)과 CD16 (FCGR3A)이 있습니다. 반면 CD56dim NK 세포를 구별하는 유전자 마커로는 CD56(dim) (NCAM1)과 KIR (Killer-cell immunoglobulin-like receptors)가 있습니다. KIR은 NK 세포의 분화 상태, 활성 상태, 대상 세포와의 상호 작용 등을 조절합니다.\n위의 결과와 pbmc1k_marker.csv 파일을 비교하면서 다음과 같이 클러스터의 이름을 지정합니다.\n\nChatGPT를 사용한 방법은 정확하지 않고 힌트정도만 알 수 있습니다. 실제 실험결과라면 SingleR 패키지 혹은 문헌 검색을 통해 직접 찾아보시기 바랍니다.\n\n그리고 UMAP 플랏을 그려서 결과를 확인합니다.\n\n# 참조를 위해 이전 ID 클래스(클러스터 레이블)를 저장합니다.\nseurat_obj[[\"old.ident\"]] &lt;- Idents(object = seurat_obj)\n\n# 레이블 변경하기\nseurat_obj &lt;- RenameIdents(\n    object = seurat_obj,\n    `0` = \"neutrophils\",\n    `1` = \"CD4+ T cells\",\n    `2` = \"naive B cells\",\n    `3` = \"Plasma cells\",\n    `4` = \"monocytes\",\n    `5` = \"CD56bright NK cells\",\n    `6` = \"memory  B cells\",\n    `7` = \"CD8 T cells\",\n    `8` = \"CD56dim NK cells\",\n    `9` = \"platelet\"\n    )\n\n\np &lt;- DimPlot(seurat_obj, reduction = \"umap\", label = TRUE, pt.size = 0.5) + NoLegend()\n\noptions(repr.plot.width = 7, repr.plot.height = 7)\np"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#클러스터당-세포-수-확인",
    "href": "posts/ipynb/tool_seurat_tutorials.html#클러스터당-세포-수-확인",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "8.1 클러스터당 세포 수 확인",
    "text": "8.1 클러스터당 세포 수 확인\n\ntable(Idents(seurat_obj))\n\n\n        neutrophils        CD4+ T cells       naive B cells        Plasma cells \n                284                 204                 169                 130 \n          monocytes CD56bright NK cells     memory  B cells         CD8 T cells \n                 87                  74                  60                  54 \n   CD56dim NK cells            platelet \n                 53                  15"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#클러스터당-세포-비율-확인",
    "href": "posts/ipynb/tool_seurat_tutorials.html#클러스터당-세포-비율-확인",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "8.2 클러스터당 세포 비율 확인",
    "text": "8.2 클러스터당 세포 비율 확인\n\nprop.table(table(Idents(seurat_obj)))\n\n\n        neutrophils        CD4+ T cells       naive B cells        Plasma cells \n         0.25132743          0.18053097          0.14955752          0.11504425 \n          monocytes CD56bright NK cells     memory  B cells         CD8 T cells \n         0.07699115          0.06548673          0.05309735          0.04778761 \n   CD56dim NK cells            platelet \n         0.04690265          0.01327434"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_tutorials.html#rds-파일로-저장하기",
    "href": "posts/ipynb/tool_seurat_tutorials.html#rds-파일로-저장하기",
    "title": "Seurat으로 scRNA seq데이터 분석하기",
    "section": "8.3 RDS 파일로 저장하기",
    "text": "8.3 RDS 파일로 저장하기\nRDS 파일을 저장해두면 추후 분석에 위의 과정을 반복할 필요가 없습니다.\n\nsaveRDS(seurat_obj, file = \"../output/pbmc1k_final.rds\")\n\n지금 까지 살펴본 내용을 요약해보면 다음과 같습니다.\n\nPre-processing: 데이터 전처리를 통해 불필요한 변수 제거, 정규화 등을 수행합니다.\nDimensionality reduction: 차원 축소 기법을 사용해 데이터의 주요 구조를 파악합니다.\nClustering: 유사한 특성을 가진 데이터들을 그룹화합니다.\nCell type identification: 각 클러스터에 대해 유전자 발현 패턴 등을 비교하여 cell type을 추론합니다.\n\n이후 진행되는 scRNA-seq Downstream analysis는 여기서 얻은 결과를 기반으로 합니다. 따라서 여기서의 결과가 부정확하거나 신뢰성이 떨어지면 추가 분석에서 얻은 결과 또한 의미가 없습니다. 그러므로 분석에서 사용된 데이터의 품질, 분석 방법의 적절성, 도구의 성능 등을 철저히 검토하고 확실한 기준에 따라 분석을 수행하세요. 또한, 추후에 데이터나 분석 방법이 변경되는 경우 이전의 결과와의 비교를 통해 신뢰성을 유지할 수 있도록 관리하는 것도 잊지 말아야 합니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html",
    "href": "posts/ipynb/ml_LLM_handson.html",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "",
    "text": "최근 출간된 책 Hands-On Large Language Models (Jay Alammar, Maarten Grootendorst 저, 2024)을 읽고 그 내용을 정리해보려고 합니다. 이 책은 급속도로 발전하고 있는 대규모 언어 모델(Large Language Models, LLMs)의 이론을 쉽게 풀어내며 동시에 실습을 통해 독자들이 직접 경험할 수 있도록 구성했습니다. LLM의 전반적인 내용을 다루고 있어 AI와 자연어 처리에 관심 있는 분들에게 훌륭한 가이드가 될 것 같습니다. 이번 포스팅에서는 이 책의 내용 중 쓸만한 코드와 짧은 설명을 공유하려고 합니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#tokens-and-embedding",
    "href": "posts/ipynb/ml_LLM_handson.html#tokens-and-embedding",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "1.1 Tokens and Embedding",
    "text": "1.1 Tokens and Embedding\n토크나이저는 어떻게 텍스트를 자르는가? 3가지 중요 팩터: 1. 어휘 크기 (Vocabulary size) 2. 미등록 단어 (Out-of-vocabulary words) 처리 3. 언어의 특성 (Language characteristics)\n토크나이저 분류\n\nWord token: 공백이나 구두점을 기준으로 단어 단위로 분리\nSubword token: 자주 사용되는 단어는 그대로 두고, 드문 단어는 더 작은 단위로 분리 (예: WordPiece, BPE)\nCharacter token: 개별 문자 단위로 분리\nByte token: 바이트 단위로 분리, 모든 언어와 특수 문자 처리 가능"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#inside-of-llm",
    "href": "posts/ipynb/ml_LLM_handson.html#inside-of-llm",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "1.2 Inside of LLM",
    "text": "1.2 Inside of LLM\nLLM은 3개의 컴포넌트로 구성:\n\nTokenizer: 입력 텍스트를 토큰으로 변환\nTransformer: 토큰을 처리하고 문맥을 이해하는 핵심 아키텍처\nLM head: Transformer의 출력을 받아 다음 토큰을 예측하는 층\n\n\n1.2.1 최근 트랜스포머 블록의 발전\n\n1.2.1.1 RoPE\nRoPE는 다음과 같은 특징을 가집니다:\n\n상대적 위치 정보 인코딩: RoPE는 토큰 간의 상대적 위치 관계를 직접적으로 모델링합니다.\n회전 행렬 사용: 위치 정보를 회전 행렬을 통해 인코딩하여 효율적으로 처리합니다.\n길이 외삽(extrapolation) 능력: 학습 시 사용된 시퀀스 길이보다 긴 시퀀스에 대해서도 잘 작동합니다.\n계산 효율성: 기존 위치 임베딩 방식에 비해 계산 효율성이 높습니다.\n성능 향상: 특히 장문 텍스트 처리에서 성능 향상을 보입니다.\n\nRoPE는 GPT-3, PaLM, LLaMA 등 최신 대규모 언어 모델에서 널리 사용되고 있으며, 특히 긴 문맥을 다루는 데 효과적입니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#텍스트-분류",
    "href": "posts/ipynb/ml_LLM_handson.html#텍스트-분류",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "2.1 텍스트 분류",
    "text": "2.1 텍스트 분류\n자연어 처리에서 흔히 수행되는 작업 중 하나가 분류입니다. 이 작업의 목표는 입력된 텍스트에 레이블이나 클래스를 할당하도록 모델을 훈련시키는 것입니다. 텍스트 분류는 전 세계적으로 다양한 용도로 활용되고 있습니다. 감성 분석, 의도 파악, 개체 추출, 언어 감지 등이 그 예입니다.\n대표적 언어 모델과 생성형 언어 모델이 분류 작업에 미치는 영향은 실로 막대합니다. 이러한 모델들은 텍스트 분류의 정확도와 효율성을 크게 향상시켰으며 더 복잡하고 미묘한 분류 작업을 가능하게 만들었습니다. 특히 사전 학습된 대규모 언어 모델(LLM)의 등장으로 텍스트 분류 작업의 성능이 비약적으로 발전했습니다.\n\n2.1.1 텍스트 감정 분석 with Representation model\n텍스트 데이터를 가져와 텍스트의 감정 분석을 “cardiffnlp/twitter-roberta-base-sentiment-latest” 모델을 사용해 진행합니다. 이 모델은 RoBERTa 아키텍처를 기반으로 하며, 특히 트위터 데이터로 미세 조정되어 소셜 미디어 텍스트의 감정 분석에 최적화되어 있습니다.\n\nimport numpy as np\nfrom datasets import load_dataset\nfrom sklearn.metrics import classification_report\nfrom tqdm import tqdm\nfrom transformers import pipeline\nfrom transformers.pipelines.pt_utils import KeyDataset\n\n# 데이터셋 불러오기\ndata = load_dataset(\"rotten_tomatoes\")\n\n# Hugging Face 모델\nmodel_name: str = \"cardiffnlp/twitter-roberta-base-sentiment-latest\"\n\n# 모델을 파이프라인에 로드\npipe = pipeline(model=model_name, tokenizer=model_name, top_k=None, device=\"cuda:0\")\n\n# 추론 실행\ny_pred: list[int] = []\nfor output in tqdm(pipe(KeyDataset(data[\"test\"], \"text\")), total=len(data[\"test\"])):\n    negative_score = output[0][\"score\"]\n    positive_score = output[2][\"score\"]\n    assignment = np.argmax([negative_score, positive_score])\n    y_pred.append(assignment)\n\n\ndef evaluate_performance(y_true: list[int], y_pred: list[int]) -&gt; None:\n    \"\"\"분류 보고서 생성 및 출력\"\"\"\n    performance: str = classification_report(y_true, y_pred, target_names=[\"부정적\", \"긍정적\"])\n    print(performance)\n\n\n# 성능 평가 실행\nevaluate_performance(data[\"test\"][\"label\"], y_pred)\n\n100%|█████████████████████████| 1066/1066 [00:02&lt;00:00, 459.29it/s]\n\n\n              precision    recall  f1-score   support\n\n         부정적       0.50      1.00      0.67       533\n         긍정적       0.00      0.00      0.00       533\n\n    accuracy                           0.50      1066\n   macro avg       0.25      0.50      0.33      1066\nweighted avg       0.25      0.50      0.33      1066\n\n\n\n\n\n\n\n\n2.1.2 텍스트 감정 분석 with Generative model\n생성형 모델을 사용한 텍스트 감정 분석은 기존의 분류 기반 접근 방식과는 다른 새로운 패러다임을 제시합니다. 이 방식은 기존 방법보다 더 정확하고 세밀한 결과를 제공할 수 있지만, 모델의 훈련과 계산 비용이 높다는 단점도 있습니다.\n\nimport numpy as np\nfrom datasets import load_dataset\nfrom tqdm import tqdm\nfrom transformers import pipeline\nfrom transformers.pipelines.pt_utils import KeyDataset\n\n# 영화 리뷰 데이터셋 로드\ndata = load_dataset(\"rotten_tomatoes\")\n\n# Hugging Face 모델\nmodel_name: str = \"google/flan-t5-small\"\n\n# 모델을 파이프라인에 로드\npipe = pipeline(\"text2text-generation\", model=model_name, device=\"cuda:0\")\n\n# 데이터 준비\nprompt = \"Is the following sentence positive or negative? \"\ndata = data.map(lambda example: {\"t5\": prompt + example[\"text\"]})\n\n# 추론 실행\ny_pred = []\nfor output in tqdm(pipe(KeyDataset(data[\"test\"], \"t5\")), total=len(data[\"test\"])):\n    text = output[0][\"generated_text\"]\n    y_pred.append(0 if text == \"negative\" else 1)\n\n\ndef evaluate_performance(y_true: list[int], y_pred: list[int]) -&gt; None:\n    \"\"\"분류 보고서 생성 및 출력\"\"\"\n    performance: str = classification_report(y_true, y_pred, target_names=[\"부정적\", \"긍정적\"])\n    print(performance)\n\n\n# 성능 평가 실행\nevaluate_performance(data[\"test\"][\"label\"], y_pred)\n\n100%|█████████████████████████| 1066/1066 [00:08&lt;00:00, 121.39it/s]\n\n\n              precision    recall  f1-score   support\n\n         부정적       0.83      0.85      0.84       533\n         긍정적       0.85      0.83      0.84       533\n\n    accuracy                           0.84      1066\n   macro avg       0.84      0.84      0.84      1066\nweighted avg       0.84      0.84      0.84      1066"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#텍스트-클러스터링과-토픽-클러스터링",
    "href": "posts/ipynb/ml_LLM_handson.html#텍스트-클러스터링과-토픽-클러스터링",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "2.2 텍스트 클러스터링과 토픽 클러스터링",
    "text": "2.2 텍스트 클러스터링과 토픽 클러스터링\n텍스트 클러스터링과 토픽 모델링은 문서 컬렉션을 분석하는 두 가지 주요 접근 방식입니다. 텍스트 클러스터링은 유사한 문서들을 그룹화하여 컬렉션을 여러 클러스터로 나누는 것을 목표로 합니다. 일반적으로 각 문서는 하나의 클러스터에만 속하게 됩니다. 반면 토픽 모델링은 문서 컬렉션에 내재된 추상적인 ’토픽’들을 발견하는 것을 목표로 합니다.\n\n2.2.1 BERTopic: 모듈식 토픽 모델링 프레임워크\nBERTopic은 최신 자연어 처리 기술을 활용한 강력한 토픽 모델링 프레임워크입니다. BERTopic은 전통적인 토픽 모델링 기법인 LDA에 비해 더 정교한 결과를 제공할 수 있으며, 특히 짧은 텍스트나 특정 도메인의 텍스트에 대해 우수한 성능을 보입니다. 학술 연구, 소셜 미디어 분석, 고객 피드백 분석 등 다양한 분야에서 활용될 수 있으며, 대규모 문서 컬렉션에서 의미 있는 인사이트를 추출하는 데 유용합니다.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport umap\nfrom datasets import load_dataset\nfrom hdbscan import HDBSCAN\nfrom sentence_transformers import SentenceTransformer\n\n# huggingface에서 데이터 로드\ndataset = load_dataset(\"effectiveML/ArXiv-10\")[\"train\"]\n\n# 메타데이터 추출\nabstracts = dataset[\"abstract\"]\ntitles = dataset[\"title\"]\n\n# 1단계\n# 각 초록에 대한 임베딩 생성\nembedding_model = SentenceTransformer(\"thenlper/gte-small\")\nembeddings = embedding_model.encode(abstracts, show_progress_bar=True)\n\n# 2단계\n# 384차원의 입력 임베딩을 50차원으로 축소\numap_model = umap.UMAP(n_components=50, min_dist=0.0, metric=\"cosine\", random_state=42)\nreduced_embeddings = umap_model.fit_transform(embeddings)\n\n# 3단계\n# 모델을 학습하고 클러스터 추출\nhdbscan_model = HDBSCAN(\n    min_cluster_size=50, metric=\"euclidean\", cluster_selection_method=\"eom\"\n).fit(reduced_embeddings)\nclusters = hdbscan_model.labels_\n\n# 시각화를 위한 준비: 384차원 임베딩을 2차원으로 축소\nreduced_embeddings = umap.UMAP(\n    n_components=2, min_dist=0.0, metric=\"cosine\", random_state=42\n).fit_transform(embeddings)\n\n# 데이터프레임 생성\ndf = pd.DataFrame(reduced_embeddings, columns=[\"x\", \"y\"])\ndf[\"title\"] = titles\ndf[\"cluster\"] = [str(c) for c in clusters]\n\n# 이상치와 비이상치(클러스터) 선택\nclusters_df = df.loc[df.cluster != \"-1\", :]\noutliers_df = df.loc[df.cluster == \"-1\", :]\n\n\n# 플랏 크기 지정\nplt.figure(figsize=(6, 6))\nplt.scatter(\n    outliers_df.x,\n    outliers_df.y,\n    alpha=0.1,\n    s=0.1,\n    c=\"grey\",\n)\nplt.scatter(\n    clusters_df.x,\n    clusters_df.y,\n    c=clusters_df.cluster.astype(int),\n    alpha=0.15,\n    s=0.1,\n    cmap=\"viridis_r\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nfrom copy import deepcopy\n\nimport pandas as pd\nfrom bertopic import BERTopic\nfrom bertopic.representation import TextGeneration\nfrom transformers import pipeline\n\n# BERTopic 모델 훈련\ntopic_model = BERTopic(\n    embedding_model=embedding_model,\n    umap_model=umap_model,\n    hdbscan_model=hdbscan_model,\n    verbose=True,\n).fit(abstracts, embeddings)\n\n# 원본 표현 저장\noriginal_topics = deepcopy(topic_model.topic_representations_)\n\n# Flan-T5를 사용한 토픽 표현 업데이트\ngenerator = pipeline(\"text2text-generation\", model=\"google/flan-t5-small\")\n\n# 프롬프트 정의\nprompt = \"\"\"I have a topic that contains the following documents:\n[DOCUMENTS]\nThe topic is described by the following keywords: '[KEYWORDS]'.\nBased on the documents and keywords, what is this topic about?\"\"\"\n\nrepresentation_model = TextGeneration(\n    generator, prompt=prompt, doc_length=50, tokenizer=\"whitespace\"\n)\ntopic_model.update_topics(abstracts, representation_model=representation_model)\n\n\n# 토픽 차이 표시 함수\ndef topic_differences(model, original_topics, nr_topics=5):\n    \"\"\"두 모델 간의 토픽 표현 차이를 보여줍니다\"\"\"\n    df = pd.DataFrame(columns=[\"Topic\", \"Original\", \"Updated\"])\n    for topic in range(nr_topics):\n        # 모델별로 토픽당 상위 5개 단어 추출\n        og_words = \" | \".join(list(zip(*original_topics[topic]))[0][:5])\n        new_words = \" \".join(list(zip(*model.get_topic(topic)))[0][:5])\n        df.loc[len(df)] = [topic, og_words, new_words]\n    return df\n\n\n# 토픽 차이 출력\nprint(topic_differences(topic_model, original_topics))\n\n2025-01-21 12:04:12,339 - BERTopic - Dimensionality - Fitting the dimensionality reduction algorithm\n2025-01-21 12:05:33,792 - BERTopic - Dimensionality - Completed ✓\n2025-01-21 12:05:33,799 - BERTopic - Cluster - Start clustering the reduced embeddings\n2025-01-21 12:05:37,721 - BERTopic - Cluster - Completed ✓\n2025-01-21 12:05:37,728 - BERTopic - Representation - Extracting topics from clusters using representation models.\n2025-01-21 12:05:41,069 - BERTopic - Representation - Completed ✓\n100%|████████████████████████████| 205/205 [00:03&lt;00:00, 54.17it/s]\n\n\n   Topic                                           Original  \\\n0      0                 mathbb | prove | mathcal | we | if   \n1      1                      flow | fluid | the | of | and   \n2      2  channel | wireless | communication | mimo | pr...   \n3      3  quantum | entanglement | states | bell | measu...   \n4      4  solar | plasma | magnetic | coronal | reconnec...   \n\n                    Updated  \n0                 Maths      \n1              dynamics      \n2            Networking      \n3  Quantum entanglement      \n4          Solar-energy      \n\n\n\nfig = topic_model.visualize_document_datamap(\n    titles,\n    title=\"\",\n    topics=list(range(20)),\n    reduced_embeddings=reduced_embeddings,\n    width=600,  # 7인치에 해당하는 픽셀 수 (100 픽셀/인치 기준)\n    height=600,  # 7인치에 해당하는 픽셀 수\n    label_font_size=11,  # 텍스트 크기 축소\n    label_wrap_width=15,  # 레이블 줄바꿈 너비 축소\n    use_medoids=True,\n)"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#프롬프트-엔지니어링",
    "href": "posts/ipynb/ml_LLM_handson.html#프롬프트-엔지니어링",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "2.3 프롬프트 엔지니어링",
    "text": "2.3 프롬프트 엔지니어링\n생성형 사전 학습 트랜스포머(GPT) 모델은 사용자가 제시한 프롬프트에 대응하여 텍스트를 생성하는 놀라운 능력을 갖추고 있습니다. 프롬프트 엔지니어링을 통해 이러한 프롬프트를 효과적으로 설계함으로써 생성되는 텍스트의 품질을 크게 향상시킬 수 있습니다.\n이번에는 이러한 생성형 모델에 대해 더 자세히 살펴보고, 프롬프트 엔지니어링의 세계로 깊이 들어가 보겠습니다. 또한 생성형 모델을 이용한 추론, 검증, 그리고 모델 출력의 평가 방법까지 다루어 볼 것입니다.\n프롬프트 엔지니어링은 단순히 질문을 던지는 것을 넘어서, 모델이 원하는 방식으로 응답하도록 유도하는 기술입니다. 이는 모델의 성능을 최적화하고, 특정 작업에 맞춤화된 결과를 얻는 데 핵심적인 역할을 합니다.\n\nimport torch\nfrom transformers import (\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    logging,\n    pipeline,\n)\n\n# 사용할 모델 이름 지정\nmodel_name = \"microsoft/Phi-3.5-mini-instruct\"\n\n# 모델 로드 및 설정\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    device_map=\"cuda\",  # GPU 사용\n    torch_dtype=torch.float16,  # 16비트 부동소수점 사용\n    trust_remote_code=True,\n)\n# 토크나이저 로드\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\n# 텍스트 생성 파이프라인 설정\npipe = pipeline(\n    \"text-generation\",\n    model=model,  # 모델 지정\n    tokenizer=tokenizer,  # 토크나이저 지정\n    return_full_text=False,  # 전체 텍스트 반환 안 함\n    max_new_tokens=500,  # 최대 새 토큰 수\n    do_sample=False,  # 샘플링 사용 안 함\n)\n\n# 프롬프트 설정\nmessages = [\n    {\n        \"role\": \"user\",\n        \"content\": \"직장동료에게 보내는 이메일의 짧은 인사말 3개만 적어줘.\",\n    }\n]\n\n# 출력 생성\noutput = pipe(messages)\n# 생성된 텍스트 출력\nprint(output[0][\"generated_text\"])\n\n`flash-attention` package not found, consider installing for better performance: No module named 'flash_attn'.\nCurrent `flash-attention` does not support `window_size`. Either upgrade or use `attn_implementation='eager'`.\n\n\n\n\n\nYou are not running the flash-attention implementation, expect numerical differences.\n\n\n 제목: 환영 인사드리기\n\n안녕 친구,\n\n안녕하세요! 이 이메일을 보내드리고 직장에 합류하게 되어 기쁩니다. 팀에서 함께 일하고 함께 성장하기를 기대합니다. 행운을 빌어요!\n\n감사합니다,\n[당신의 이름]\n\n\n\n2.3.1 모델 출력 제어\n모델 매개변수를 조정하여 원하는 종류의 출력을 제어할 수 있습니다. temperature와 top_p 매개변수는 출력의 무작위성을 제어합니다.\n\n2.3.1.1 Temperature(온도)\nTemperature는 생성된 텍스트의 무작위성 또는 창의성을 제어합니다. 이는 확률이 낮은 토큰을 선택할 가능성을 정의합니다. 기본 아이디어는 temperature가 0이면 항상 가장 가능성이 높은 단어를 선택하기 때문에 매번 동일한 응답을 생성한다는 것입니다.\n\n\n2.3.1.2 top_p\ntop_p(핵 샘플링이라고도 함)는 LLM이 고려할 수 있는 토큰의 부분집합(핵)을 제어하는 샘플링 기법입니다. 누적 확률에 도달할 때까지 토큰을 고려합니다. top_p를 0.1로 설정하면 해당 값에 도달할 때까지 토큰을 고려합니다.\n\n# Using a high temperature\noutput = pipe(messages, do_sample=True, temperature=1)\nprint(output[0][\"generated_text\"])\n\n 제목: 안녕하세요, [동료 이름]\n\n안녕하세요! 저를 잘 기억해주시고, 전문적인 지원과 협력을 이어오시길 바랍니다.\n\n감사드립니다!\n\n[당신의 이름]\n\n\n\n# Using a high top_p\noutput = pipe(messages, do_sample=True, top_p=1)\nprint(output[0][\"generated_text\"])\n\n 제목: 인사 릴렉센\n\n---\n\n1. 빠른 칭호와 행운을 바쳐:\n   안녕하세요 [동료 이름],\n\n   이 메시지를 전해드리며, 우리를 부러워하게 만드는 발신인 이 글을 통해 전하고자 합니다. 이 역할에서 네가 저녁부터 아침까지 우수하게 일하고 있다는 증거로 자리매김하는 것을 자랑스럽게 여깁니다.\n\n2. 긍정적인 기여에 감사:\n   네가 간략한 지원도 및 공유된 실력에 영향을 미친 프로젝트와 빈틈없는 팀플 작물에 큰 마스터피스를 제공해주셨습니다. 이 회사를 하나의 개인으로부터 더 강력하고 협력적인 집단으로 시간이 지나면서 지속적인 성장을 목격하고 있습니다.\n\n3. 앞으로의 연결:\n   이 인사의 마당에 더 나\n\n\n\n\n\n2.3.2 고급 프롬프트 엔지니어링\n좋은 프롬프트를 만드는 것은 간단해 보일 수 있습니다. 구체적인 질문을 하고, 정확하게 표현하며, 몇 가지 예시를 추가하면 끝난 것 같죠! 하지만 프롬프트 작성은 매우 빠르게 복잡해질 수 있으며, 그 결과 대규모 언어 모델(LLM)을 활용하는 데 있어 종종 과소평가되는 요소입니다. 여기서는 프롬프트를 구축하기 위한 여러 가지 고급 기법을 살펴보겠습니다.\n\n\n2.3.3 복잡한 프롬프트\n이 복잡한 프롬프트는 프롬프트 작성의 모듈식 특성을 보여줍니다. 우리는 자유롭게 구성 요소를 추가하거나 제거할 수 있고 출력에 미치는 영향을 판단할 수 있습니다.\n\n# 프롬프트 구성 요소\npersona = \"당신은 인공지능과 기계학습 분야의 전문가입니다. 복잡한 기술 문서를 쉽게 이해할 수 있는 요약으로 만드는 데 탁월합니다.\\n\"\ninstruction = \"제공된 기술 문서의 핵심 내용을 요약해주세요.\\n\"\ncontext = \"요약은 개발자들이 문서의 가장 중요한 정보를 빠르게 파악할 수 있도록 핵심 포인트를 추출해야 합니다.\\n\"\ndata_format = \"주요 개념과 기술을 설명하는 글머리 기호 요약을 만드세요. 그 다음 주요 내용을 간결하게 요약하는 단락을 작성하세요.\\n\"\naudience = \"이 요약은 최신 AI 개발 동향을 빠르게 파악해야 하는 바쁜 개발자들을 위한 것입니다.\\n\"\ntone = \"전문적이고 명확한 톤을 사용해야 합니다.\\n\"\n\n# 아래 내용을 원하는 문장으로 변경했습니다.\ntext = \"\"\"\n머신러닝 모델의 성능을 향상시키는 방법 중 하나는 앙상블 학습입니다. 앙상블 학습은 여러 개의 모델을 조합하여 더 나은 예측 결과를 얻는 방법입니다.\n주요 앙상블 기법으로는 배깅(Bagging), 부스팅(Boosting), 스태킹(Stacking)이 있습니다.\n배깅은 동일한 알고리즘을 사용하지만 서로 다른 학습 데이터 부분집합으로 여러 모델을 학습시키는 방법입니다.\n부스팅은 이전 모델의 오류를 보완하는 방향으로 순차적으로 모델을 학습시키는 방법입니다.\n스태킹은 여러 모델의 예측 결과를 새로운 모델의 입력으로 사용하여 최종 예측을 수행하는 방법입니다.\n이러한 앙상블 기법들은 단일 모델보다 일반적으로 더 높은 성능과 안정성을 제공합니다.\n\"\"\"\n\ndata = f\"요약할 텍스트: {text}\"\n\n# 전체 프롬프트 - 생성된 출력에 미치는 영향을 보기 위해 부분을 제거하거나 추가할 수 있습니다\nquery = persona + instruction + context + data_format + audience + tone + data\n\nmessages = [{\"role\": \"user\", \"content\": query}]\nprint(tokenizer.apply_chat_template(messages, tokenize=False))\n\n# 출력 생성\noutputs = pipe(messages)\nprint(outputs[0][\"generated_text\"])\n\n&lt;|user|&gt;\n당신은 인공지능과 기계학습 분야의 전문가입니다. 복잡한 기술 문서를 쉽게 이해할 수 있는 요약으로 만드는 데 탁월합니다.\n제공된 기술 문서의 핵심 내용을 요약해주세요.\n요약은 개발자들이 문서의 가장 중요한 정보를 빠르게 파악할 수 있도록 핵심 포인트를 추출해야 합니다.\n주요 개념과 기술을 설명하는 글머리 기호 요약을 만드세요. 그 다음 주요 내용을 간결하게 요약하는 단락을 작성하세요.\n이 요약은 최신 AI 개발 동향을 빠르게 파악해야 하는 바쁜 개발자들을 위한 것입니다.\n전문적이고 명확한 톤을 사용해야 합니다.\n요약할 텍스트: \n머신러닝 모델의 성능을 향상시키는 방법 중 하나는 앙상블 학습입니다. 앙상블 학습은 여러 개의 모델을 조합하여 더 나은 예측 결과를 얻는 방법입니다.\n주요 앙상블 기법으로는 배깅(Bagging), 부스팅(Boosting), 스태킹(Stacking)이 있습니다.\n배깅은 동일한 알고리즘을 사용하지만 서로 다른 학습 데이터 부분집합으로 여러 모델을 학습시키는 방법입니다.\n부스팅은 이전 모델의 오류를 보완하는 방향으로 순차적으로 모델을 학습시키는 방법입니다.\n스태킹은 여러 모델의 예측 결과를 새로운 모델의 입력으로 사용하여 최종 예측을 수행하는 방법입니다.\n이러한 앙상블 기법들은 단일 모델보다 일반적으로 더 높은 성능과 안정성을 제공합니다.\n&lt;|end|&gt;\n&lt;|endoftext|&gt;\n **요약: 앙상블 학습을 통한 머신러닝 성능 향상**\n\n*글머리기호 요약:*\n- 앙상블 학습: 여러 모델의 조합\n- 주요 기법: 배깅, 부스팅, 스태킹\n- 성능 향상: 일반적으로 더 높고 안정적\n\n*요약 단락:*\n앙상블 학습은 머신러닝 모델의 성능을 향상시키기 위해 여러 개의 모델을 조합하는 기술입니다. 주요 앙상블 기법에는 배깅, 부스팅, 스태킹이 포함됩니다.\n\n배깅은 동일한 알고리즘을 사용하면서 서로 다른 학습 데이터 부분집합으로 여러 모델을 학습시키는 방법입니다. 이 방법은 모델의 불필요한 동질성을 줄이고 오류를 완화하여 더 안정적인 예측을 제공합니다.\n\n부스팅은 이전 모\n\n\n\n\n2.3.4 문맥 내 학습: 예시 제공\n우리는 LLM(대규모 언어 모델)에 우리가 정확히 달성하고자 하는 것의 예시를 제공할 수 있습니다. 이는 종종 문맥 내 학습이라고 불리며, 모델에 정확한 예시를 제공하는 방식입니다.\n\n# 만들어낸 단어를 문장에서 사용하는 단일 예시 활용\none_shot_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": \"'퀴블녹스'는 자유자재로 크기를 바꿀 수 있는 마법 생물입니다. '퀴블녹스'라는 단어를 사용한 문장의 예시는 다음과 같습니다:\",\n    },\n    {\n        \"role\": \"assistant\",\n        \"content\": \"여행을 갈 때 내 애완 퀴블녹스는 쥐만큼 작아져서 주머니에 쉽게 넣고 다닐 수 있어요.\",\n    },\n    {\n        \"role\": \"user\",\n        \"content\": \"'실드치다'는 어처구니 없는 상황이나 인물의 입장을 방어하는 것을 의미합니다. '실드치다'라는 단어를 사용한 문장의 예시는 다음과 같습니다:\",\n    },\n]\nprint(tokenizer.apply_chat_template(one_shot_prompt, tokenize=False))\n\n# 출력 생성\noutputs = pipe(one_shot_prompt)\nprint(outputs[0][\"generated_text\"])\n\n&lt;|user|&gt;\n'퀴블녹스'는 자유자재로 크기를 바꿀 수 있는 마법 생물입니다. '퀴블녹스'라는 단어를 사용한 문장의 예시는 다음과 같습니다:&lt;|end|&gt;\n&lt;|assistant|&gt;\n여행을 갈 때 내 애완 퀴블녹스는 쥐만큼 작아져서 주머니에 쉽게 넣고 다닐 수 있어요.&lt;|end|&gt;\n&lt;|user|&gt;\n'줌블하다'는 비정통적이지만 효과적인 방식으로 문제를 해결하는 것을 의미합니다. '줌블하다'라는 단어를 사용한 문장의 예시는 다음과 같습니다:&lt;|end|&gt;\n&lt;|endoftext|&gt;\n 올해의 과제를 처리하는 데 어려움을 겪으며, 우리는 줌블하게 새로운 프로세스를 도입하여 효율성을 높이고 성공적으로 마무리했습니다.\n\n\n\n\n2.3.5 Chain Prompting: 문제를 나누어 해결하기\n문제를 하나의 프롬프트 내에서 해결하는 대신, 여러 프롬프트 사이에서 나누어 해결할 수 있습니다. 본질적으로 이 방법은 한 프롬프트의 출력을 다음 프롬프트의 입력으로 사용하여 문제를 해결하는 연속적인 상호작용 체인을 만드는 것입니다. Chain Prompting은 특히 다단계 추론, 복잡한 분석, 또는 여러 도메인의 지식을 결합해야 하는 작업에서 효과적입니다.\n\n# 스마트홈 기기의 이름과 슬로건 생성\nproduct_prompt = [{\"role\": \"user\", \"content\": \"스마트홈 기기의 이름과 슬로건을 만들어주세요.\"}]\noutputs = pipe(product_prompt)\nproduct_description = outputs[0][\"generated_text\"]\nprint(product_description)\n\n# 생성된 제품 이름과 슬로건을 바탕으로 짧은 판매 문구 생성\nsales_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": f\"다음 제품에 대한 매우 짧은 판매 문구를 생성해주세요: '{product_description}'\",\n    }\n]\noutputs = pipe(sales_prompt)\nsales_pitch = outputs[0][\"generated_text\"]\nprint(sales_pitch)\n\n 이름: \"SmartHaven\"\n\n슬로건: \"SmartHaven - 디지털 편안함, 현실 속 편안한 집.\"\n\nSmartHaven는 스마트홈 기기의 편안함과 효율성을 실현하는 최첨단 기기로, 집의 모든 영역에서 디지털 혁신을 제공합니다. 이 기기는 생활의 질을 향상시키고, 집의 안전성을 강화하며, 사용자의 생활을 효율적이고 편안하게 만듭니다. SmartHaven의 디지털 편안함과 현실 속 편안한 집을 상징하는 슬로건은 이러한 기능을 강조하고, 소비자들이 스마트홈의 풍부한 가치를 느낄 수 있도록 합니다.\n \"SmartHaven: 현실 속 편안한 집, 디지털 편안함을 누릴 순간.\"\n\n\n\n\n2.3.6 생성형 모델을 이용한 추론\n추론은 인간 지능의 핵심 요소이며 종종 추론과 유사해 보이는 LLM의 창발적 행동과 비교됩니다. 우리가 “유사해 보이는”이라고 강조하는 이유는 이 글을 쓰는 시점에서 이러한 모델들은 일반적으로 학습 데이터의 암기와 패턴 매칭을 통해 이러한 행동을 보여주는 것으로 여겨지기 때문입니다.\n\n\n2.3.7 Chain-of-Thought: 답변 전에 생각하기\nChain-of-Thought(사고 연쇄)는 생성형 모델이 질문에 직접 답변하지 않고 먼저 “생각”하도록 하는 것을 목표로 합니다.Chain-of-Thought 방식은 특히 수학 문제 풀이, 논리 퍼즐, 복잡한 의사 결정 과정 등에서 효과적으로 사용될 수 있으며, 모델의 추론 능력을 향상시키는 데 도움이 됩니다.\n\n# 명시적인 추론 없이 답변하기\nstandard_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": \"민수는 색연필 12자루를 가지고 있었습니다. 새 색연필 세트를 받았는데, 그 세트에는 8자루가 들어있었습니다. 그런데 3자루를 동생에게 주었습니다. 민수는 지금 몇 자루의 색연필을 가지고 있나요?\",\n    },\n    {\"role\": \"assistant\", \"content\": \"17\"},\n    {\n        \"role\": \"user\",\n        \"content\": \"학교 도서관에 책이 300권 있었습니다. 새로운 책 50권을 구입했고, 학생들이 25권을 빌려갔습니다. 지금 도서관에 있는 책은 몇 권인가요?\",\n    },\n]\n\n# 생성 모델 실행\noutputs = pipe(standard_prompt)\nprint(outputs[0][\"generated_text\"])\n\n 325권\n\n이 문제를 해결하기 위해서는 다음 단계를 따릅니다:\n\n1. 도서관에는 초기에 300권의 책이 있었습니다.\n2. 새로운 책 50권을 도서관에 추가했습니다. 이를 기존의 총 권수에 더합니다: 300 + 50 = 350권.\n3. 그런 다음, 학생들이 25권을 빌려갔습니다. 이를 현재의 총 권수에서 빼야 합니다: 350 - 25 = 325권.\n\n따라서, 도서관에는 현재 325권의 책이 남아 있습니다.\n\n\n\n# 사고 과정을 포함한 답변\ncot_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": \"민수는 색연필 12자루를 가지고 있었습니다. 새 색연필 세트를 2개 받았는데, 각 세트에는 5자루가 들어있었습니다. 민수는 지금 몇 자루의 색연필을 가지고 있나요?\",\n    },\n    {\n        \"role\": \"assistant\",\n        \"content\": \"민수는 처음에 12자루의 색연필을 가지고 있었습니다. 2개의 새 세트에 각각 5자루씩 들어있으므로 10자루를 추가로 받았습니다. 12 + 10 = 22. 따라서 답은 22자루입니다.\",\n    },\n    {\n        \"role\": \"user\",\n        \"content\": \"학교 도서관에 책이 45권 있었습니다. 15권을 학생들에게 대출해주고 새로운 책 20권을 구입했습니다. 지금 도서관에 있는 책은 몇 권인가요?\",\n    },\n]\n\n# 출력 생성\noutputs = pipe(cot_prompt)\nprint(outputs[0][\"generated_text\"])\n\n 도서관에서는 처음에 45권의 책이 있었습니다. 15권을 학생들에게 대출했으므로 45 - 15 = 30권이 남았습니다. 그런 다음 20권의 새로운 책을 구입했으므로 30 + 20 = 50권의 책이 지금 도서관에 있습니다. 따라서 답은 50권입니다.\n\n\n\n\n2.3.8 제로샷 Chain-of-Thought\n모델에게 예시를 제공하는 대신에 우리는 단순히 생성형 모델에게 추론 과정을 제공하도록 요청할 수 있습니다(제로샷 chain-of-thought). 이를 위해 효과적인 다양한 형태가 있지만 흔하고 효과적인 방법 중 하나는 “단계별로 생각해 봅시다”라는 문구를 사용하는 것입니다. 이 방법은 특히 다양한 유형의 문제에 대해 빠르게 추론 과정을 얻고자 할 때 유용하며, 모델의 일반화된 추론 능력을 테스트하는 데에도 효과적입니다.\n\n# Zero-shot Chain-of-Thought\nzeroshot_cot_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": \"도서관에 책이 50권 있었습니다. 15권을 대출해주고 새로 20권을 구입했습니다. 지금 도서관에 있는 책은 몇 권인가요? 단계별로 생각해봅시다.\",\n    }\n]\n\n# 출력 생성\noutputs = pipe(zeroshot_cot_prompt)\nprint(outputs[0][\"generated_text\"])\n\n 이 문제를 해결하기 위해 다음 단계를 따르겠습니다:\n\n1. 도서관에서 시작하는 초기 책 수: 50권\n2. 대출된 책 수: 15권\n3. 구입한 새로운 책 수: 20권\n\n이제 이 값을 사용하여 현재 도서관에 있는 책 수를 계산해봅시다:\n\n1. 시작하는 초기 책 수에서 대출된 책 수를 빼줍니다: 50 - 15 = 35권\n2. 이 결과에 구입한 새로운 책 수를 더합니다: 35 + 20 = 55권\n\n따라서, 현재 도서관에는 55권의 책이 있습니다.\n\n\n\n\n2.3.9 Tree-of-Thought: 중간 단계 탐색하기\nChain-of-Thought와 자기 일관성(self-consistency)의 개념은 더 복잡한 추론을 가능하게 하기 위한 것입니다. 여러 “생각”들을 샘플링하고 이를 더 신중하게 만듦으로써 생성형 모델의 출력을 개선합니다.\n\n# Zero-shot Tree-of-Thought\nzeroshot_tot_prompt = [\n    {\n        \"role\": \"user\",\n        \"content\": \"세 명의 다른 전문가들이 이 질문에 답하고 있다고 상상해보세요. 모든 전문가는 자신의 생각의 1단계를 적은 다음 그룹과 공유합니다. 그런 다음 모든 전문가는 다음 단계로 넘어갑니다. 만약 어느 전문가라도 자신이 틀렸다는 것을 깨닫게 되면 그 즉시 토론에서 빠집니다. 질문은 '학교 도서관에 책이 80권 있었습니다. 30권을 학생들에게 대출해주고 새로운 책 25권을 구입했습니다. 지금 도서관에 있는 책은 몇 권인가요?' 입니다. 결과에 대해 반드시 토론해주세요.\",\n    }\n]\n\n# 출력 생성\noutputs = pipe(zeroshot_tot_prompt)\nprint(outputs[0][\"generated_text\"])\n\n 1단계: 초기 책 수를 기억하기\n80권의 책이 도서관에서 시작합니다.\n\n2단계: 학생들에게 대출된 책 수를 계산하기\n30권의 책이 학생들에게 대출됩니다.\n\n3단계: 구입한 새로운 책 수를 계산하기\n25권의 새로운 책이 도서관에 추가됩니다.\n\n4단계: 현재 책 수를 계산하기\n1단계에서 시작한 80권에서 2단계의 30권을 빼고, 그리고 3단계의 25권을 더합니다.\n\n80 - 30 = 50\n50 + 25 = 75\n\n토론:\n도서관에는 80권의 책이 시작되었습니다. 그 다음, 30권의 책이 학생들에게 대출되었습니다. 이로 인해 도서관에는 50권의 책이 남았습니다. 그 다음, 25권의 새로운 책이 도서관에 추가되었습니다. 따"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#의미론적-검색-및-검색-증강-생성",
    "href": "posts/ipynb/ml_LLM_handson.html#의미론적-검색-및-검색-증강-생성",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "2.4 의미론적 검색 및 검색 증강 생성",
    "text": "2.4 의미론적 검색 및 검색 증강 생성\n\n2.4.1 밀집 검색 (Dense Retrieval)\n밀집 검색은 검색 쿼리가 관련 결과와 가까울 것이라는 특성에 의존합니다.\n\n2.4.1.1 밀집 검색 주의사항\n\n거짓 양성: 의미적으로 유사하지만 실제로 관련이 없는 결과를 반환할 수 있습니다.\n답변 부재: 코퍼스에 답변이 없는 경우에도 가장 가까운 결과를 반환합니다.\n컨텍스트 손실: 단어의 정확한 일치보다는 의미적 유사성에 중점을 두기 때문에 특정 키워드나 구문을 놓칠 수 있습니다.\n계산 비용: 대규모 데이터셋에서는 계산 비용이 높을 수 있습니다.\n도메인 특화의 어려움: 특정 도메인의 전문 용어나 개념을 정확히 포착하기 어려울 수 있습니다.\n\n\nimport torch\nfrom transformers import (\n    DPRContextEncoder,\n    DPRContextEncoderTokenizer,\n    DPRQuestionEncoder,\n    DPRQuestionEncoderTokenizer,\n)\n\nquestion_model = \"facebook/dpr-question_encoder-single-nq-base\"\ncontext_model = \"facebook/dpr-ctx_encoder-single-nq-base\"\n\n# 인코더와 토크나이저 초기화\nquestion_encoder = DPRQuestionEncoder.from_pretrained(question_model)\nquestion_tokenizer = DPRQuestionEncoderTokenizer.from_pretrained(question_model)\ncontext_encoder = DPRContextEncoder.from_pretrained(context_model)\ncontext_tokenizer = DPRContextEncoderTokenizer.from_pretrained(context_model)\n\n# 질문 인코딩\nquestion = \"듄의 작가는 누구인가요?\"\nquestion_input = question_tokenizer(question, return_tensors=\"pt\")\nquestion_embedding = question_encoder(**question_input).pooler_output\n\n# 컨텍스트 인코딩\ncontext = \"듄은 1965년에 미국 작가 프랭크 허버트가 쓴 공상과학 소설입니다.\"\ncontext_input = context_tokenizer(context, return_tensors=\"pt\")\ncontext_embedding = context_encoder(**context_input).pooler_output\n\n# 유사도 계산\nsimilarity = torch.matmul(question_embedding, context_embedding.transpose(0, 1))\nprint(f\"유사도 점수: {similarity.item():.4f}\")\n\n유사도 점수: 75.5189\n\n\n\n\n\n2.4.2 재순위화 예시\n재순위화 시스템(예: monoBERT)은 사용자의 검색어와 후보 결과들을 분석하여 각 문서가 해당 검색어와 얼마나 관련이 있는지 점수를 매깁니다. 이렇게 산출된 관련성 점수를 바탕으로 사전에 선별된 결과들의 순서를 재배열합니다. 이 과정을 통해 검색어에 대한 결과의 순위가 개선되어 더욱 정확하고 관련성 높은 정보를 상위에 표시할 수 있게 됩니다.\n재순위화 시스템의 주요 특징은 다음과 같습니다:\n\n정교한 관련성 평가: 단순한 키워드 매칭을 넘어 문맥과 의미를 고려한 심층적인 관련성 평가를 수행합니다.\n맞춤형 순위 조정: 사용자의 검색 의도를 더 정확히 반영하여 결과의 순위를 조정합니다.\n검색 품질 향상: 사용자에게 더 관련성 높고 유용한 정보를 우선적으로 제공함으로써 전반적인 검색 경험을 개선합니다.\n다양한 요소 고려: 문서의 내용, 구조, 메타데이터 등 다양한 요소를 종합적으로 분석하여 순위를 결정합니다.\n\n\nimport torch\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer\n\nmodel_name = \"cross-encoder/ms-marco-MiniLM-L-6-v2\"\n# 재순위화 모델 로드\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForSequenceClassification.from_pretrained(model_name)\n\n# 예시 쿼리와 검색된 문단들\nquery = \"프랑스의 수도는 어디인가요?\"\npassages = [\n    \"파리는 프랑스의 수도이자 가장 인구가 많은 도시입니다.\",\n    \"런던은 영국과 잉글랜드의 수도입니다.\",\n    \"프랑스는 서유럽에 위치한 국가입니다.\",\n]\n\n# 문단 재순위화\npairs = [[query, passage] for passage in passages]\ninputs = tokenizer(pairs, padding=True, truncation=True, return_tensors=\"pt\")\nwith torch.no_grad():\n    scores = model(**inputs).logits.squeeze(-1)\n\n# 점수에 따라 문단 정렬\nreranked_passages = [p for _, p in sorted(zip(scores, passages), reverse=True)]\n\nprint(\"재순위화된 문단:\")\nfor i, passage in enumerate(reranked_passages, 1):\n    print(f\"{i}. {passage}\")\n\n재순위화된 문단:\n1. 파리는 프랑스의 수도이자 가장 인구가 많은 도시입니다.\n2. 런던은 영국과 잉글랜드의 수도입니다.\n3. 프랑스는 서유럽에 위치한 국가입니다.\n\n\n\n\n2.4.3 RAG(검색 증강 생성)\nRAG는 검색 시스템의 파이프라인 끝단에 생성형 대규모 언어 모델(LLM)을 배치하는 혁신적인 접근 방식입니다. 이 방법을 통해 시스템은 검색된 문서를 바탕으로 답변을 생성하면서 동시에 출처를 인용할 수 있습니다. RAG의 주요 특징과 장점은 다음과 같습니다:\n\n정보의 정확성과 최신성: 실시간으로 검색된 최신 정보를 바탕으로 답변을 생성하므로, 항상 최신의 정확한 정보를 제공할 수 있습니다.\n근거 기반 응답: 생성된 답변의 각 부분에 대해 출처를 제시함으로써, 사용자는 정보의 신뢰성을 직접 확인할 수 있습니다.\n유연한 지식 확장: 모델의 재학습 없이도 새로운 정보를 즉시 활용할 수 있어, 지식 기반을 지속적으로 확장할 수 있습니다.\n맥락 이해 능력 향상: 검색된 문서들의 맥락을 종합적으로 이해하여 더 깊이 있고 관련성 높은 답변을 생성합니다.\n투명성 제고: 정보의 출처를 명확히 제시함으로써 AI 시스템의 의사결정 과정을 더 투명하게 만듭니다.\n\n\nimport torch\nfrom transformers import (\n    AutoModel,\n    AutoTokenizer,\n    RagRetriever,\n    RagSequenceForGeneration,\n)\n\n# 사전 훈련된 모델 로드\nquestion_encoder = AutoModel.from_pretrained(\"facebook/dpr-question_encoder-single-nq-base\")\nquestion_tokenizer = AutoTokenizer.from_pretrained(\"facebook/dpr-question_encoder-single-nq-base\")\ngenerator_tokenizer = AutoTokenizer.from_pretrained(\"facebook/bart-large\")\n\n# RAG 컴포넌트 초기화\nretriever = RagRetriever.from_pretrained(\n    \"facebook/rag-sequence-nq\", index_name=\"exact\", use_dummy_dataset=True\n)\nmodel = RagSequenceForGeneration.from_pretrained(\"facebook/rag-sequence-nq\", retriever=retriever)\n\n\ndef generate_answer(query):\n    # 쿼리 인코딩\n    input_ids = question_tokenizer(query, return_tensors=\"pt\")[\"input_ids\"]\n    question_hidden_states = question_encoder(input_ids)[0]\n\n    # 관련 문서 검색\n    retriever_output = retriever(input_ids, question_hidden_states, return_tensors=\"pt\")\n\n    # 답변 생성\n    input_ids = retriever_output[\"input_ids\"]\n    attention_mask = retriever_output[\"attention_mask\"]\n    output = model.generate(input_ids=input_ids, attention_mask=attention_mask)\n\n    # 생성된 답변 디코딩 및 반환\n    return generator_tokenizer.decode(output[0], skip_special_tokens=True)\n\n\n# 사용 예시\nquery = \"프랑스의 수도는 어디인가요?\"\nanswer = generate_answer(query)\nprint(f\"질문: {query}\")\nprint(f\"답변: {answer}\")"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#멀티모달-llm",
    "href": "posts/ipynb/ml_LLM_handson.html#멀티모달-llm",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "2.5 멀티모달 LLM",
    "text": "2.5 멀티모달 LLM\n대규모 언어 모델(LLM)에서는 멀티모달 입력을 받아들이고 이를 바탕으로 추론하는 능력은 이전에는 접근하기 어려웠던 새로운 가능성을 열어줄 수 있습니다. 여기에서는 멀티모달 기능을 갖춘 여러 LLM을 살펴보고 실제 사용 사례로 어떤 의미를 갖는지 알아볼 것입니다.\n\n2.5.1 CLIP(텍스트와 이미지 연결)\nCLIP은 이미지와 텍스트 모두의 임베딩을 계산할 수 있는 임베딩 모델입니다. CLIP은 컴퓨터 비전과 자연어 처리의 경계를 허물고 두 영역을 통합하는 강력한 도구로 자리잡고 있습니다. 이를 통해 AI 시스템은 인간의 의사소통 방식에 더 가까워지고 더욱 자연스럽고 직관적인 상호작용이 가능해집니다. CLIP의 주요 특징은 다음과 같습니다:\n\n통합된 표현 공간: 이미지와 텍스트를 동일한 벡터 공간에 표현하여 직접적인 비교가 가능합니다.\n크로스모달 학습: 이미지와 텍스트 사이의 관계를 학습하여 더 풍부한 이해를 가능하게 합니다.\n유연한 응용: 이미지 검색, 이미지 캡셔닝, 시각적 질의응답 등 다양한 작업에 활용될 수 있습니다.\n제로샷 학습 능력: 특정 작업에 대한 추가 학습 없이도 새로운 개념을 인식할 수 있습니다.\n\n\nfrom urllib.request import urlopen\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom transformers import CLIPModel, CLIPProcessor, CLIPTokenizerFast\n\n# 이미지 불러오기\nimage_url = \"https://raw.githubusercontent.com/HandsOnLLM/Hands-On-Large-Language-Models/main/chapter09/images/puppy.png\"\nimage = Image.open(urlopen(image_url)).convert(\"RGB\")\ncaption = \"A ppuppy playing in the snow\"\nmodel_id = \"openai/clip-vit-base-patch32\"\n\n# 텍스트 전처리를 위한 토크나이저 로드\nclip_tokenizer = CLIPTokenizerFast.from_pretrained(model_id)\n\n# 이미지 전처리를 위한 프로세서 로드\nclip_processor = CLIPProcessor.from_pretrained(model_id)\n\n# 텍스트 및 이미지 임베딩 생성을 위한 주 모델\nmodel = CLIPModel.from_pretrained(model_id)\n\n# 입력 토큰화\ninputs = clip_tokenizer(caption, return_tensors=\"pt\")\n\n# 텍스트 임베딩 생성\ntext_embedding = model.get_text_features(**inputs)\n\n# 이미지 전처리\nprocessed_image = clip_processor(text=None, images=image, return_tensors=\"pt\")[\"pixel_values\"]\n\n# 이미지 임베딩 생성\nimage_embedding = model.get_image_features(processed_image)\n\n# 시각화를 위한 이미지 준비\nprocessed_img = processed_image.squeeze(0)\nprocessed_img = processed_img.permute(*torch.arange(processed_img.ndim - 1, -1, -1))\nprocessed_img = np.einsum(\"ijk-&gt;jik\", processed_img.numpy())\n\n# 원본 이미지와 처리된 이미지 시각화\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\nax1.imshow(image)\nax1.set_title(\"Original Image\")\nax1.axis(\"off\")\nax2.imshow(processed_img)\nax2.set_title(\"Processed Image\")\nax2.axis(\"off\")\nplt.show()\n\n# 임베딩 정규화\ntext_embedding /= text_embedding.norm(dim=-1, keepdim=True)\nimage_embedding /= image_embedding.norm(dim=-1, keepdim=True)\n\n# 유사도 계산\ntext_embedding = text_embedding.detach().cpu().numpy()\nimage_embedding = image_embedding.detach().cpu().numpy()\nscore = text_embedding @ image_embedding.T\nprint(f\"유사도 점수: {score.item():.4f}\")\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Got range [-1.7922626..2.145897].\n\n\n\n\n\n\n\n\n\n유사도 점수: 0.3006\n\n\n\n\n2.5.2 BLIP-2(양식 간 격차 해소)\n처음부터 멀티모달 언어 모델을 만드는 것은 엄청난 컴퓨팅 파워와 데이터를 필요로 합니다. 이러한 모델을 만들려면 수십억 개의 이미지, 텍스트, 그리고 이미지-텍스트 쌍을 사용해야 합니다. 이는 쉽게 실현 가능한 일이 아닙니다. BLIP-2는 이러한 어려움을 해결하기 위해 새로운 접근 방식을 취합니다. 처음부터 아키텍처를 구축하는 대신, 사전 학습된 이미지 인코더와 사전 학습된 LLM을 연결하는 ’쿼리 트랜스포머(Q-Former)’라는 다리를 구축하여 시각-언어 간의 격차를 해소합니다. 이 방식의 주요 장점은 다음과 같습니다:\n\n효율적인 학습: BLIP-2는 이미지 인코더와 LLM을 처음부터 학습할 필요 없이 연결 다리만 학습하면 됩니다.\n기존 기술 활용: 이미 존재하는 기술과 모델을 최대한 활용하여 효율성을 높입니다.\n유연성: 다양한 사전 학습 모델을 조합하여 사용할 수 있어, 특정 작업에 최적화된 구성을 만들 수 있습니다.\n성능 향상: 각 분야에서 최고의 성능을 보이는 모델들을 결합함으로써 전반적인 성능을 크게 향상시킬 수 있습니다.\n자원 절약: 거대한 데이터셋과 컴퓨팅 자원이 필요한 전체 모델 학습을 피할 수 있어 시간과 비용을 절약합니다.\n\n\nfrom urllib.request import urlopen\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom sklearn.preprocessing import MinMaxScaler\nfrom transformers import AutoModelForVisualQuestionAnswering, AutoProcessor\n\n# 프로세서와 주 모델 로드\nblip_processor = AutoProcessor.from_pretrained(\n    \"Salesforce/blip2-opt-2.7b\",\n)\nmodel = AutoModelForVisualQuestionAnswering.from_pretrained(\n    \"Salesforce/blip2-opt-2.7b\", torch_dtype=torch.float16\n)\n\n# 추론 속도 향상을 위해 모델을 GPU로 이동\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nmodel.to(device)\n\n# 슈퍼카 이미지 로드\ncar_path = \"https://raw.githubusercontent.com/HandsOnLLM/Hands-On-Large-Language-Models/main/chapter09/images/car.png\"\nimage = Image.open(urlopen(car_path)).convert(\"RGB\")\n\n# 이미지 전처리\ninputs = blip_processor(image, return_tensors=\"pt\").to(device, torch.float16)\ninputs[\"pixel_values\"].shape\n\n# numpy로 변환하고 (1, 3, 224, 224)에서 (224, 224, 3) 형태로 변경\nimage_inputs = inputs[\"pixel_values\"][0].detach().cpu().numpy()\nimage_inputs = np.einsum(\"ijk-&gt;kji\", image_inputs)\nimage_inputs = np.einsum(\"ijk-&gt;jik\", image_inputs)\n\n# RGB 값을 나타내기 위해 이미지 입력을 0-255로 스케일링\nscaler = MinMaxScaler(feature_range=(0, 255))\nimage_inputs = scaler.fit_transform(image_inputs.reshape(-1, image_inputs.shape[-1])).reshape(\n    image_inputs.shape\n)\nimage_inputs = np.array(image_inputs, dtype=np.uint8)\n\n# numpy 배열을 Image로 변환\nImage.fromarray(image_inputs)\n\n# 텍스트 전처리\ntext = \"Her vocalization was remarkably melodic\"\ntoken_ids = blip_processor(image, text=text, return_tensors=\"pt\")\ntoken_ids = token_ids.to(device, torch.float16)[\"input_ids\"][0]\n\n# 입력 ID를 다시 토큰으로 변환\ntokens = blip_processor.tokenizer.convert_ids_to_tokens(token_ids)\n\n# 공백 토큰을 밑줄로 대체\ntokens = [token.replace(\"Ġ\", \"_\") for token in tokens]\n\n# 시각화\nplt.figure(figsize=(5, 5))\n\n# 이미지 표시\nplt.subplot(2, 1, 1)\nplt.imshow(Image.fromarray(image_inputs))\nplt.title(\"Processed Image\")\nplt.axis(\"off\")\n\n# 텍스트와 토큰 표시\nplt.subplot(2, 1, 2)\nplt.text(\n    0.5,\n    0.9,\n    f\"Original Text: {text}\",\n    horizontalalignment=\"center\",\n    fontsize=12,\n    wrap=True,\n)\nplt.text(0.5, 0.65, \"Tokens:\", horizontalalignment=\"center\", fontsize=12)\nplt.text(0.5, 0.2, \" \".join(tokens), horizontalalignment=\"center\", fontsize=10, wrap=True)\nplt.axis(\"off\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n2.5.2.1 사용 사례 1: 이미지 캡셔닝\n이미지 캡셔닝은 주어진 이미지의 내용을 설명하는 텍스트를 자동으로 생성하는 작업입니다.\n\n# 이미지 로드\nurl = \"https://upload.wikimedia.org/wikipedia/commons/7/70/Rorschach_blot_01.jpg\"\nimage = Image.open(urlopen(url)).convert(\"RGB\")\n\n# 캡션 생성\ninputs = blip_processor(image, return_tensors=\"pt\").to(device, torch.float16)\ngenerated_ids = model.generate(**inputs, max_new_tokens=20)\ngenerated_text = blip_processor.batch_decode(generated_ids, skip_special_tokens=True)\ngenerated_text = generated_text[0].strip()\n\n# 이미지와 생성된 텍스트 시각화\nplt.figure(figsize=(5, 5))\nplt.imshow(image)\nplt.axis(\"off\")\nplt.title(f\"Generated text: {generated_text}\", fontsize=12)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2.5.2.2 사용 사례 2: 시각적 질의응답\n시각적 질의응답은 이미지와 관련된 질문에 대해 AI가 답변을 제공하는 기술입니다.\n\n# 이미지 로드\nurl = \"https://upload.wikimedia.org/wikipedia/commons/7/70/Rorschach_blot_01.jpg\"\nimage = Image.open(urlopen(url)).convert(\"RGB\")\n\n# 시각적 질문 답변\nprompt = \"Question: Write down what you see in this picture. Answer:\"\n\n# 이미지와 프롬프트 처리\ninputs = blip_processor(image, text=prompt, return_tensors=\"pt\").to(device, torch.float16)\n\n# 텍스트 생성\ngenerated_ids = model.generate(**inputs, max_new_tokens=30)\ngenerated_text = blip_processor.batch_decode(generated_ids, skip_special_tokens=True)\ngenerated_text = generated_text[0].strip()\n\n# 이미지와 생성된 텍스트 시각화\nplt.figure(figsize=(5, 5))\nplt.imshow(image)\nplt.axis(\"off\")\nplt.title(f\"{generated_text}\", fontsize=12, wrap=True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n이러한 다중 모달 텍스트 생성 모델의 핵심 아이디어는 입력 이미지의 시각적 특징을 LLM이 사용할 수 있는 텍스트 임베딩으로 투영하는 것입니다. 이 모델을 이미지 캡셔닝과 다중 모달 채팅 기반 프롬프팅에 사용하는 방법을 보았는데, 여기서는 두 가지 양식을 결합하여 응답을 생성합니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#텍스트-임베딩-모델-생성",
    "href": "posts/ipynb/ml_LLM_handson.html#텍스트-임베딩-모델-생성",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "3.1 텍스트 임베딩 모델 생성",
    "text": "3.1 텍스트 임베딩 모델 생성\n텍스트 임베딩 모델은 많은 강력한 자연어 처리 애플리케이션의 기초를 이룹니다. 이들은 텍스트 생성 모델과 같은 이미 인상적인 기술들을 더욱 강화하는 기반을 마련합니다. 임베딩 모델을 생성하는 방법은 여러 가지가 있지만, 일반적으로 우리는 대조 학습을 주목합니다. 이는 많은 임베딩 모델의 중요한 측면인데, 이 과정을 통해 모델이 의미론적 표현을 효율적으로 학습할 수 있기 때문입니다.\n\n3.1.1 대조 생성(Generating Contrastive) 예제\n\nimport random\n\nfrom datasets import Dataset, load_dataset\nfrom sentence_transformers import SentenceTransformer, losses\nfrom sentence_transformers.evaluation import EmbeddingSimilarityEvaluator\nfrom sentence_transformers.trainer import SentenceTransformerTrainer\nfrom sentence_transformers.training_args import SentenceTransformerTrainingArguments\nfrom tqdm import tqdm\n\n# GLUE에서 MNLI 데이터셋 로드\nmnli = load_dataset(\"glue\", \"mnli\", split=\"train\").select(range(50_000))\nmnli = mnli.remove_columns(\"idx\")\nmnli = mnli.filter(lambda x: True if x[\"label\"] == 0 else False)\n\n# 데이터 전처리\ntrain_dataset = {\"anchor\": [], \"positive\": [], \"negative\": []}\nsoft_negatives = mnli[\"hypothesis\"]\nrandom.shuffle(soft_negatives)\nfor row, soft_negative in tqdm(zip(mnli, soft_negatives)):\n    train_dataset[\"anchor\"].append(row[\"premise\"])\n    train_dataset[\"positive\"].append(row[\"hypothesis\"])\n    train_dataset[\"negative\"].append(soft_negative)\ntrain_dataset = Dataset.from_dict(train_dataset)\n\n# 모델\nembedding_model = SentenceTransformer(\"bert-base-uncased\")\n\n# 손실 함수 정의. 소프트맥스 손실에서는 레이블 수를 명시적으로 설정해야 함.\ntrain_loss = losses.MultipleNegativesRankingLoss(model=embedding_model)\n\n# 평가 함수 및 stsb를 위한 임베딩 유사도 평가기 생성\nval_sts = load_dataset(\"glue\", \"stsb\", split=\"validation\")\nevaluator = EmbeddingSimilarityEvaluator(\n    sentences1=val_sts[\"sentence1\"],\n    sentences2=val_sts[\"sentence2\"],\n    scores=[score / 5 for score in val_sts[\"label\"]],\n    main_similarity=\"cosine\",\n)\n\n# 훈련 인자 정의\nargs = SentenceTransformerTrainingArguments(\n    output_dir=\"mnrloss_embedding_model\",\n    num_train_epochs=1,\n    per_device_train_batch_size=32,\n    per_device_eval_batch_size=32,\n    warmup_steps=100,\n    fp16=True,\n    eval_steps=100,\n    logging_steps=100,\n)\n\n# 임베딩 모델 훈련\ntrainer = SentenceTransformerTrainer(\n    model=embedding_model,\n    args=args,\n    train_dataset=train_dataset,\n    loss=train_loss,\n    evaluator=evaluator,\n)\ntrainer.train()\n\n# 훈련된 모델 평가\nevaluator(embedding_model)\n\n16875it [00:00, 42644.51it/s]\nNo sentence-transformers model found with name bert-base-uncased. Creating a new one with mean pooling.\n\n\n\n      \n      \n      [528/528 00:32, Epoch 1/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n100\n0.346900\n\n\n200\n0.107100\n\n\n300\n0.083700\n\n\n400\n0.068100\n\n\n500\n0.072500\n\n\n\n\n\n\n\n\n\n{'pearson_cosine': np.float64(0.8058287434682441),\n 'spearman_cosine': np.float64(0.8093139517546301)}\n\n\n\n\n3.1.2 임베딩 모델의 미세 조정\n\n3.1.2.1 지도 학습 기반 미세 조정 (Supervised Fine-Tuning, SFT)\n지도 학습 기반 미세 조정(SFT)은 사전 훈련된 임베딩 모델을 특정 작업이나 도메인에 맞게 조정하는 프로세스입니다. 이 방법은 레이블이 지정된 데이터셋을 사용하여 모델의 성능을 향상시키고 특정 용도에 더 적합하게 만듭니다.\n\nfrom datasets import load_dataset\nfrom sentence_transformers import SentenceTransformer, losses\nfrom sentence_transformers.evaluation import EmbeddingSimilarityEvaluator\nfrom sentence_transformers.trainer import SentenceTransformerTrainer\nfrom sentence_transformers.training_args import SentenceTransformerTrainingArguments\n\n# GLUE에서 MNLI 데이터셋 로드\n# 0 = 함의, 1 = 중립, 2 = 모순\ntrain_dataset = load_dataset(\"glue\", \"mnli\", split=\"train\").select(range(25_000))\ntrain_dataset = train_dataset.remove_columns(\"idx\")\n\n# stsb를 위한 임베딩 유사도 평가기 생성\nval_sts = load_dataset(\"glue\", \"stsb\", split=\"validation\")\nevaluator = EmbeddingSimilarityEvaluator(\n    sentences1=val_sts[\"sentence1\"],\n    sentences2=val_sts[\"sentence2\"],\n    scores=[score / 5 for score in val_sts[\"label\"]],\n    main_similarity=\"cosine\",\n)\n\n# 모델 정의\nembedding_model = SentenceTransformer(\"sentence-transformers/all-MiniLM-L6-v2\")\n\n# 손실 함수\ntrain_loss = losses.MultipleNegativesRankingLoss(model=embedding_model)\n\n# 훈련 인자 정의\nargs = SentenceTransformerTrainingArguments(\n    output_dir=\"finetuned_embedding_model\",\n    num_train_epochs=1,\n    per_device_train_batch_size=32,\n    per_device_eval_batch_size=32,\n    warmup_steps=100,\n    fp16=True,\n    eval_steps=100,\n    logging_steps=100,\n)\n\n# 모델 훈련\ntrainer = SentenceTransformerTrainer(\n    model=embedding_model,\n    args=args,\n    train_dataset=train_dataset,\n    loss=train_loss,\n    evaluator=evaluator,\n)\ntrainer.train()\n\n# 훈련된 모델 평가\nevaluator(embedding_model)\n\nColumn 'hypothesis' is at index 1, whereas a column with this name is usually expected at index 0. Note that the column order can be important for some losses, e.g. MultipleNegativesRankingLoss will always consider the first column as the anchor and the second as the positive, regardless of the dataset column names. Consider renaming the columns to match the expected order, e.g.:\ndataset = dataset.select_columns(['hypothesis', 'entailment', 'contradiction'])\n\n\n\n      \n      \n      [782/782 00:20, Epoch 1/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n100\n0.127500\n\n\n200\n0.126100\n\n\n300\n0.108700\n\n\n400\n0.117500\n\n\n500\n0.115400\n\n\n600\n0.105800\n\n\n700\n0.106100\n\n\n\n\n\n\n\n\n\n{'pearson_cosine': np.float64(0.850360102427649),\n 'spearman_cosine': np.float64(0.8505789375274108)}\n\n\n\n\n\n3.1.3 비지도 학습\n현실 세계의 데이터셋에는 우리가 사용할 수 있는 좋은 레이블 세트가 함께 제공되지 않습니다. 대신 미리 정해진 레이블 없이 모델을 훈련시키는 기법을 찾아야 합니다. 이것을 비지도 학습이라 부릅니다. 여기에는 여러 가지 방식이 존재합니다.\n\n3.1.3.1 트랜스포머 기반 순차적 디노이징 오토인코더\nTSDAE는 비지도 학습으로 임베딩 모델을 만드는 매우 우아한 접근 방식입니다. 이 방법은 우리가 전혀 레이블이 지정된 데이터를 가지고 있지 않다고 가정하며, 인위적으로 레이블을 만들 필요가 없습니다.\n\nimport nltk\nfrom datasets import Dataset, load_dataset\nfrom sentence_transformers import SentenceTransformer, losses, models\nfrom sentence_transformers.datasets import DenoisingAutoEncoderDataset\nfrom sentence_transformers.evaluation import EmbeddingSimilarityEvaluator\nfrom sentence_transformers.trainer import SentenceTransformerTrainer\nfrom sentence_transformers.training_args import SentenceTransformerTrainingArguments\nfrom tqdm import tqdm\n\n# 추가 토크나이저 다운로드\nnltk.download(\"punkt\")\nnltk.download(\"punkt_tab\")\n\n# 문장의 평면 리스트 생성\nmnli = load_dataset(\"glue\", \"mnli\", split=\"train\").select(range(25_000))\nflat_sentences = mnli[\"premise\"] + mnli[\"hypothesis\"]\n\n# 입력 데이터에 노이즈 추가\ndamaged_data = DenoisingAutoEncoderDataset(list(set(flat_sentences)))\n\n# 데이터셋 생성\ntrain_dataset = {\"damaged_sentence\": [], \"original_sentence\": []}\nfor data in tqdm(damaged_data):\n    train_dataset[\"damaged_sentence\"].append(data.texts[0])\n    train_dataset[\"original_sentence\"].append(data.texts[1])\ntrain_dataset = Dataset.from_dict(train_dataset)\n\n# stsb를 위한 임베딩 유사도 평가기 생성\nval_sts = load_dataset(\"glue\", \"stsb\", split=\"validation\")\nevaluator = EmbeddingSimilarityEvaluator(\n    sentences1=val_sts[\"sentence1\"],\n    sentences2=val_sts[\"sentence2\"],\n    scores=[score / 5 for score in val_sts[\"label\"]],\n    main_similarity=\"cosine\",\n)\n\n# 임베딩 모델 생성\nword_embedding_model = models.Transformer(\"bert-base-uncased\")\npooling_model = models.Pooling(word_embedding_model.get_word_embedding_dimension(), \"cls\")\nembedding_model = SentenceTransformer(modules=[word_embedding_model, pooling_model])\n\n# 디노이징 오토인코더 손실 사용\ntrain_loss = losses.DenoisingAutoEncoderLoss(embedding_model, tie_encoder_decoder=True)\ntrain_loss.decoder = train_loss.decoder.to(\"cuda\")\n\n# 훈련 인자 정의\nargs = SentenceTransformerTrainingArguments(\n    output_dir=\"tsdae_embedding_model\",\n    num_train_epochs=1,\n    per_device_train_batch_size=16,\n    per_device_eval_batch_size=16,\n    warmup_steps=100,\n    fp16=True,\n    eval_steps=100,\n    logging_steps=1000,\n    disable_tqdm=False,\n)\n\n# 모델 훈련\ntrainer = SentenceTransformerTrainer(\n    model=embedding_model,\n    args=args,\n    train_dataset=train_dataset,\n    loss=train_loss,\n    evaluator=evaluator,\n)\n\ntrainer.train()\n\n# 훈련된 모델 평가\nevaluator(embedding_model)\n\n[nltk_data] Downloading package punkt to /home/fkt/nltk_data...\n[nltk_data]   Package punkt is already up-to-date!\n[nltk_data] Downloading package punkt_tab to /home/fkt/nltk_data...\n[nltk_data]   Package punkt_tab is already up-to-date!\n100%|█████████████████████| 48353/48353 [00:03&lt;00:00, 15391.05it/s]\n\n\n\n      \n      \n      [3023/3023 02:42, Epoch 1/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n1000\n4.637300\n\n\n2000\n3.883400\n\n\n3000\n3.647900\n\n\n\n\n\n\n\n\n\n{'pearson_cosine': np.float64(0.7401165281596465),\n 'spearman_cosine': np.float64(0.7469963144425136)}\n\n\n\n# VRAM clean up\nimport gc\n\nimport torch\n\ngc.collect()\ntorch.cuda.empty_cache()"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#분류를-위한-표현-모델-미세-조정",
    "href": "posts/ipynb/ml_LLM_handson.html#분류를-위한-표현-모델-미세-조정",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "3.2 분류를 위한 표현 모델 미세 조정",
    "text": "3.2 분류를 위한 표현 모델 미세 조정\nBERT 모델을 미세 조정하는 여러 방법과 응용 사례를 살펴보겠습니다.\n\n3.2.1 지도 학습 분류\n사전 학습된 BERT 모델 미세 조정하기위해 앞서 사용했던 것과 동일한 Rotten Tomatoes 데이터셋을 활용하겠습니다. 영어 위키피디아와 미출판 도서들로 구성된 대규모 데이터셋으로 사전 학습된 “bert-base-cased” 모델을 사용할 것입니다.\n\nimport warnings\n\nimport evaluate\nimport numpy as np\nfrom datasets import load_dataset\nfrom transformers import (\n    AutoModelForSequenceClassification,\n    AutoTokenizer,\n    DataCollatorWithPadding,\n    Trainer,\n    TrainingArguments,\n    logging,\n)\n\nlogging.set_verbosity_error()  # 경고 메시지가 표시되지 않고 오류 메시지만 표시\nwarnings.filterwarnings(\"ignore\")  # 경고 메시지 끄기\n\n# 데이터 준비 및 분할\ntomatoes = load_dataset(\"rotten_tomatoes\")\ntrain_data, test_data = tomatoes[\"train\"], tomatoes[\"test\"]\n\n# 모델 및 토크나이저 로드\nmodel_id = \"bert-base-cased\"\nmodel = AutoModelForSequenceClassification.from_pretrained(model_id, num_labels=2)\ntokenizer = AutoTokenizer.from_pretrained(model_id)\n\n# 배치 내 가장 긴 시퀀스에 맞춰 패딩\ndata_collator = DataCollatorWithPadding(tokenizer=tokenizer)\n\n\ndef preprocess_function(examples):\n    \"\"\"입력 데이터 토큰화\"\"\"\n    return tokenizer(examples[\"text\"], truncation=True)\n\n\n# 학습/테스트 데이터 토큰화\ntokenized_train = train_data.map(preprocess_function, batched=True)\ntokenized_test = test_data.map(preprocess_function, batched=True)\n\n\ndef compute_metrics(eval_pred):\n    \"\"\"Calculate F1 score\"\"\"\n    logits, labels = eval_pred\n    predictions = np.argmax(logits, axis=-1)\n    load_f1 = evaluate.load(\"f1\")\n    f1 = load_f1.compute(predictions=predictions, references=labels)[\"f1\"]\n    return {\"f1\": f1}\n\n\n# 매개변수 튜닝을 위한 학습 인자\ntraining_args = TrainingArguments(\n    \"model\",\n    learning_rate=2e-5,\n    per_device_train_batch_size=16,\n    per_device_eval_batch_size=16,\n    num_train_epochs=10,\n    weight_decay=0.01,\n    save_strategy=\"epoch\",\n    report_to=\"none\",\n    disable_tqdm=False,\n)\n\n# 학습 과정을 실행하는 Trainer\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=tokenized_train,\n    eval_dataset=tokenized_test,\n    processing_class=tokenizer,\n    data_collator=data_collator,\n    compute_metrics=compute_metrics,\n)\n\n# 모델 학습\ntrainer.train()\n\n# 결과 평가\ntrainer.evaluate()\n\n\n      \n      \n      [5340/5340 02:46, Epoch 10/10]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n500\n0.418000\n\n\n1000\n0.234400\n\n\n1500\n0.137900\n\n\n2000\n0.072600\n\n\n2500\n0.038000\n\n\n3000\n0.032400\n\n\n3500\n0.023500\n\n\n4000\n0.007000\n\n\n4500\n0.010100\n\n\n5000\n0.004100\n\n\n\n\n\n\n\n    \n      \n      \n      [67/67 00:00]\n    \n    \n\n\n{'eval_loss': 1.279144048690796,\n 'eval_f1': 0.8457899716177862,\n 'eval_runtime': 1.4511,\n 'eval_samples_per_second': 734.612,\n 'eval_steps_per_second': 46.172,\n 'epoch': 10.0}\n\n\n\n\n3.2.2 적은 샷(Few shot) 분류\n적은 샷 분류는 지도 학습 분류의 한 기법으로, 소수의 레이블된 예시만을 바탕으로 분류기가 목표 레이블을 학습하는 방법입니다. 이 기법은 분류 작업이 필요하지만 충분한 레이블된 데이터를 즉시 사용할 수 없을 때 유용합니다. 다시 말해, 이 방법을 통해 각 클래스당 소수의 고품질 데이터 포인트만 레이블링하여 모델을 훈련시킬 수 있습니다.\n\n3.2.2.1 SetFit: 적은 훈련 예시로 효율적인 미세 조정\n적은 샷 텍스트 분류를 수행하기 위해 SetFit이라는 효율적인 프레임워크를 사용합니다. 이는 문장 트랜스포머의 구조를 기반으로 하여 훈련 중 업데이트되는 고품질 텍스트 표현을 생성합니다. SetFit은 다음 세 단계로 구성됩니다: 1. 훈련 데이터 샘플링: 클래스 내부와 외부 선택을 기반으로 긍정적(유사한) 및 부정적(다른) 문장 쌍을 생성합니다. 2. 임베딩 미세 조정: 이전에 생성된 훈련 데이터를 바탕으로 사전 학습된 임베딩 모델을 미세 조정합니다. 3. 분류기 훈련: 임베딩 모델 위에 분류 헤드를 만들고 이전에 생성된 훈련 데이터를 사용하여 훈련시킵니다.\n\n\n3.2.2.2 적은 샷 분류를 위한 미세 조정\n이전에는 약 8,500개의 영화 리뷰를 포함한 데이터셋으로 훈련했습니다. 하지만 이번에는 적은 샷 설정이므로 각 클래스당 16개의 예시만 샘플링할 것입니다. 두 개의 클래스가 있으므로 이전에 사용했던 8,500개의 영화 리뷰와 비교해 단 32개의 문서로만 훈련하게 됩니다.\n\nfrom setfit import SetFitModel, sample_dataset\nfrom setfit import Trainer as SetFitTrainer\nfrom setfit import TrainingArguments as SetFitTrainingArguments\n\n# 클래스당 16개의 예시를 샘플링하여 few-shot 설정을 시뮬레이션합니다\nsampled_train_data = sample_dataset(tomatoes[\"train\"], num_samples=16)\n\n# 사전 훈련된 SentenceTransformer 모델을 로드합니다\nmodel = SetFitModel.from_pretrained(\"sentence-transformers/all-mpnet-base-v2\")\n\n# 훈련 인자를 정의합니다\nargs = SetFitTrainingArguments(\n    num_epochs=3,  # 대조 학습에 사용할 에폭 수\n    num_iterations=20,  # 생성할 텍스트 쌍의 수\n)\nargs.eval_strategy = args.evaluation_strategy\n\n# 트레이너를 생성합니다\ntrainer = SetFitTrainer(\n    model=model,\n    args=args,\n    train_dataset=sampled_train_data,\n    eval_dataset=test_data,\n    metric=\"f1\",\n)\n\n# 훈련 루프\ntrainer.train()\n\n# 테스트 데이터로 모델을 평가합니다\ntrainer.evaluate()\n\nmodel_head.pkl not found on HuggingFace Hub, initialising classification head with random weights. You should TRAIN this model on a downstream task to use it for predictions and inference.\n\n\n\n\n\n***** Running training *****\n  Num unique pairs = 1280\n  Batch size = 16\n  Num epochs = 3\n\n\n{'embedding_loss': 0.3226, 'grad_norm': 1.9545438289642334, 'learning_rate': 8.333333333333333e-07, 'epoch': 0.0125}\n{'embedding_loss': 0.1147, 'grad_norm': 0.20879538357257843, 'learning_rate': 1.7592592592592595e-05, 'epoch': 0.625}\n{'embedding_loss': 0.0009, 'grad_norm': 0.026085715740919113, 'learning_rate': 1.2962962962962964e-05, 'epoch': 1.25}\n{'embedding_loss': 0.0004, 'grad_norm': 0.016781330108642578, 'learning_rate': 8.333333333333334e-06, 'epoch': 1.875}\n{'embedding_loss': 0.0003, 'grad_norm': 0.011119991540908813, 'learning_rate': 3.7037037037037037e-06, 'epoch': 2.5}\n\n\n\n\n\n***** Running evaluation *****\n\n\n{'train_runtime': 13.0872, 'train_samples_per_second': 293.417, 'train_steps_per_second': 18.339, 'train_loss': 0.025163489832387618, 'epoch': 3.0}\n\n\n{'f1': 0.8462273161413563}\n\n\n32개의 레이블된 문서만으로 약 0.85의 F1 점수를 얻었습니다. 원본 데이터의 아주 작은 부분집합으로만 모델을 훈련시켰다는 점을 고려하면 이는 매우 인상적인 결과입니다! SetFit은 적은 샷 분류 작업을 수행할 수 있을 뿐만 아니라 레이블이 전혀 없는 경우인 제로샷 분류에도 대응할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_handson.html#생성-모델-미세-조정",
    "href": "posts/ipynb/ml_LLM_handson.html#생성-모델-미세-조정",
    "title": "실습으로 배우는 대규모 언어 모델",
    "section": "3.3 생성 모델 미세 조정",
    "text": "3.3 생성 모델 미세 조정\n\n3.3.1 지도 학습 미세 조정 (SFT)\n\n3.3.1.1 전체 미세 조정\n가장 일반적인 미세 조정 과정은 전체 미세 조정입니다. LLM을 사전 학습하는 것과 마찬가지로, 이 과정은 목표로 하는 지도 학습 미세 조정(SFT) 작업에 맞춰 모델의 모든 매개변수를 업데이트하는 것을 포함합니다.\n\n\n3.3.1.2 매개변수 효율적 미세 조정 (PEFT)\n모델의 모든 매개변수를 업데이트하는 것은 성능을 크게 향상시킬 수 있는 잠재력이 있지만 몇 가지 단점이 있습니다. 훈련 비용이 많이 들고, 훈련 시간이 길며, 상당한 저장 공간이 필요합니다. 이러한 문제를 해결하기 위해, 더 높은 계산 효율성으로 사전 학습된 모델을 미세 조정하는 데 중점을 둔 매개변수 효율적 미세 조정(PEFT) 대안에 관심이 모아지고 있습니다.\n\n3.3.1.2.1 어댑터\n어댑터는 많은 PEFT 기반 기술의 핵심 구성 요소입니다. 이 방법은 트랜스포머 내부에 추가적인 모듈식 구성 요소를 제안하며, 이를 미세 조정하여 모델의 모든 가중치를 미세 조정할 필요 없이 특정 작업에 대한 모델의 성능을 향상시킬 수 있습니다. 이는 많은 시간과 계산 자원을 절약합니다.\n\n\n3.3.1.2.2 저순위 적응 (LoRA)\n어댑터의 대안으로, 저순위 적응(LoRA)이 소개되었으며 현재 PEFT를 위한 널리 사용되고 효과적인 기술입니다. LoRA는 (어댑터와 마찬가지로) 작은 수의 매개변수만 업데이트하면 되는 기술입니다.\n\n더 효율적인 훈련을 위한 모델 압축: LoRA를 더욱 효율적으로 만들기 위해 원래 가중치를 더 작은 행렬로 투영하기 전에 모델의 원래 가중치의 메모리 요구 사항을 줄일 수 있습니다. LLM의 가중치는 float64나 float32와 같은 비트 수로 표현될 수 있는 주어진 정밀도를 가진 숫자 값입니다.\n\n\nimport torch\nfrom datasets import load_dataset\nfrom peft import LoraConfig, get_peft_model, prepare_model_for_kbit_training\nfrom transformers import (\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    BitsAndBytesConfig,\n    TrainingArguments,\n)\nfrom trl import SFTTrainer\n\noutput_dir = \"./model\"\n\n# TinyLlama의 채팅 템플릿을 사용하기 위해 토크나이저 로드\ntemplate_tokenizer = AutoTokenizer.from_pretrained(\"TinyLlama/TinyLlama-1.1B-Chat-v1.0\")\n\n\ndef format_prompt(example):\n    \"\"\"TinyLLama가 사용하는 &lt;|user|&gt; 템플릿을 사용하여 프롬프트 포맷\"\"\"\n\n    # 답변 포맷\n    chat = example[\"messages\"]\n    prompt = template_tokenizer.apply_chat_template(chat, tokenize=False)\n\n    return {\"text\": prompt}\n\n\n# TinyLLama가 사용하는 템플릿을 사용하여 데이터 로드 및 포맷\ndataset = (\n    load_dataset(\"HuggingFaceH4/ultrachat_200k\", split=\"test_sft\")\n    .shuffle(seed=42)\n    .select(range(3_000))\n)\ndataset = dataset.map(format_prompt)\n\nmodel_name = \"TinyLlama/TinyLlama-1.1B-intermediate-step-1431k-3T\"\n\n# 4비트 양자화 설정 - QLoRA의 Q\nbnb_config = BitsAndBytesConfig(\n    load_in_4bit=True,  # 4비트 정밀도 모델 로딩 사용\n    bnb_4bit_quant_type=\"nf4\",  # 양자화 유형\n    bnb_4bit_compute_dtype=\"float16\",  # 계산 데이터 타입\n    bnb_4bit_use_double_quant=True,  # 중첩 양자화 적용\n)\n\n# GPU에서 훈련할 모델 로드\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    device_map=\"auto\",\n    # 일반 SFT의 경우 이 부분 제외\n    quantization_config=bnb_config,\n)\nmodel.config.use_cache = False\nmodel.config.pretraining_tp = 1\n\n# LLaMA 토크나이저 로드\ntokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code=True)\ntokenizer.pad_token = \"&lt;PAD&gt;\"\ntokenizer.padding_side = \"left\"\ntokenizer.chat_template = template_tokenizer.chat_template\n\n# LoRA 설정 준비\npeft_config = LoraConfig(\n    lora_alpha=32,  # LoRA 스케일링\n    lora_dropout=0.1,  # LoRA 레이어의 드롭아웃\n    r=64,  # 랭크\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n    target_modules=[  # 대상 레이어\n        \"k_proj\",\n        \"gate_proj\",\n        \"v_proj\",\n        \"up_proj\",\n        \"q_proj\",\n        \"o_proj\",\n        \"down_proj\",\n    ],\n)\n\n# 훈련을 위한 모델 준비\nmodel = prepare_model_for_kbit_training(model)\nmodel = get_peft_model(model, peft_config)\n\n# 훈련 인자\ntraining_arguments = TrainingArguments(\n    output_dir=output_dir,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=4,\n    optim=\"paged_adamw_32bit\",\n    learning_rate=2e-4,\n    lr_scheduler_type=\"cosine\",\n    num_train_epochs=1,\n    logging_steps=100,\n    fp16=True,\n    gradient_checkpointing=True,\n    disable_tqdm=False,\n)\n\n# 지도 미세조정 매개변수 설정\ntrainer = SFTTrainer(\n    model=model,\n    train_dataset=dataset,\n    # dataset_text_field=\"text\",\n    tokenizer=tokenizer,\n    args=training_arguments,\n    # max_seq_length=512,\n    # 일반 SFT의 경우 이 부분 제외\n    peft_config=peft_config,\n)\n\n# 모델 훈련\ntrainer.train()\n\n# QLoRA 가중치 저장\ntrainer.model.save_pretrained(\"./model/TinyLlama-1.1B-qlora\")\n\n\n      \n      \n      [375/375 06:35, Epoch 1/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n100\n5.425600\n\n\n200\n5.160700\n\n\n300\n5.117600\n\n\n\n\n\n\n\nfrom peft import AutoPeftModelForCausalLM\nfrom transformers import pipeline\n\nmodel = AutoPeftModelForCausalLM.from_pretrained(\n    \"./model/TinyLlama-1.1B-qlora\",\n    low_cpu_mem_usage=True,\n    device_map=\"auto\",\n)\n\n# LoRA와 기본 모델 병합\nmerged_model = model.merge_and_unload()\n\n# 미리 정의된 프롬프트 템플릿 사용\nprompt = \"\"\"&lt;|user|&gt;\n독감 예방 접종이 필요한 이유에 대해 간단히 설명해줘.&lt;/s&gt;\n&lt;|assistant|&gt;\n\"\"\"\n# 튜닝된 모델 실행\npipe = pipeline(task=\"text-generation\", model=merged_model, tokenizer=tokenizer)\npipe(prompt)[0][\"generated_text\"]\n\n'&lt;|user|&gt;\\n독감 예방 접종이 필요한 이유에 대해 간단히 설명해줘.&lt;/s&gt;\\n&lt;|assistant|&gt;\\nThe reason for preventive treatment is to prevent the spread of the disease and to reduce the risk of complications. This is especially important for people with underlying health conditions, such as diabetes or high blood pressure, who are at higher risk of developing complications.'\n\n\n\n\n\n\n3.3.2 생성 모델 평가\n생성 모델을 평가하는 것은 상당한 도전 과제입니다.\n\n3.3.2.1 단어 수준 지표\n생성 모델을 비교하는 데 흔히 사용되는 지표 범주 중 하나는 단어 수준 평가입니다. 이러한 전통적인 기법들은 참조 데이터셋과 생성된 토큰을 토큰(집합) 수준에서 비교합니다. 일반적인 단어 수준 지표로는 혼란도(perplexity), ROUGE, BLEU, BERTScore 등이 있습니다.\n\n\n3.3.2.2 벤치마크\n언어 생성 및 이해 작업에 대한 생성 모델을 평가하는 일반적인 방법은 MMLU, GLUE, TruthfulQA, GSM8k, HellaSwag와 같은 잘 알려진 공개 벤치마크를 사용하는 것입니다.\n\n\n3.3.2.3 리더보드\n다양한 벤치마크가 존재하기 때문에 어떤 벤치마크가 자신의 모델에 가장 적합한지 선택하기 어려울 수 있습니다. 모델이 공개될 때마다 여러 벤치마크에서 평가되어 전반적인 성능을 보여주는 경우가 많습니다.\n이에 따라 여러 벤치마크를 포함하는 리더보드가 개발되었습니다. 일반적인 리더보드로는 Open LLM Leaderboard가 있으며, 현재 HellaSwag, MMLU, TruthfulQA, GSM8k 등 6개의 벤치마크를 포함하고 있습니다.\n\n\n\n3.3.3 선호도 튜닝 (PPO/DPO)\n모델이 지시를 따를 수 있게 되었더라도, 다양한 상황에서 우리가 기대하는 대로 행동하도록 최종 훈련 단계를 통해 더욱 개선할 수 있습니다. 예를 들어, “LLM이란 무엇인가요?”라는 질문에 대해 “대규모 언어 모델입니다”라는 간단한 답변보다는 LLM의 내부 구조를 자세히 설명하는 답변을 선호할 수 있습니다. 그렇다면 어떻게 하나의 답변을 다른 답변보다 선호하는 우리의 (인간의) 선호도를 LLM의 출력과 일치시킬 수 있을까요?\n\nfrom datasets import load_dataset\nfrom peft import (\n    AutoPeftModelForCausalLM,\n    LoraConfig,\n    get_peft_model,\n    prepare_model_for_kbit_training,\n)\nfrom transformers import AutoTokenizer, BitsAndBytesConfig, logging\nfrom trl import DPOConfig, DPOTrainer\n\n\n# 데이터 전처리\ndef format_prompt(example):\n    \"\"\"TinyLLama가 사용하는 &lt;|user|&gt; 템플릿을 사용하여 프롬프트 포맷\"\"\"\n    system = \"&lt;|system|&gt;\\n\" + example[\"system\"] + \"&lt;/s&gt;\\n\"\n    prompt = \"&lt;|user|&gt;\\n\" + example[\"input\"] + \"&lt;/s&gt;\\n&lt;|assistant|&gt;\\n\"\n    chosen = example[\"chosen\"] + \"&lt;/s&gt;\\n\"\n    rejected = example[\"rejected\"] + \"&lt;/s&gt;\\n\"\n    return {\n        \"prompt\": system + prompt,\n        \"chosen\": chosen,\n        \"rejected\": rejected,\n    }\n\n\n# 데이터셋에 포맷 적용 및 비교적 짧은 답변 선택\ndpo_dataset = load_dataset(\"argilla/distilabel-intel-orca-dpo-pairs\", split=\"train\")\ndpo_dataset = dpo_dataset.filter(\n    lambda r: r[\"status\"] != \"tie\" and r[\"chosen_score\"] &gt;= 8 and not r[\"in_gsm8k_train\"]\n)\ndpo_dataset = dpo_dataset.map(format_prompt, remove_columns=dpo_dataset.column_names)\n\n# 모델 양자화\n# 4비트 양자화 설정 - QLoRA의 Q\nbnb_config = BitsAndBytesConfig(\n    load_in_4bit=True,  # 4비트 정밀도 모델 로딩 사용\n    bnb_4bit_quant_type=\"nf4\",  # 양자화 타입\n    bnb_4bit_compute_dtype=\"float16\",  # 계산 데이터 타입\n    bnb_4bit_use_double_quant=True,  # 중첩 양자화 적용\n)\n\n# LoRA와 기본 모델 병합\nmodel = AutoPeftModelForCausalLM.from_pretrained(\n    \"./model/TinyLlama-1.1B-qlora\",\n    low_cpu_mem_usage=True,\n    device_map=\"auto\",\n    quantization_config=bnb_config,\n)\nmerged_model = model.merge_and_unload()\n\n# LLaMA 토크나이저 로드\nmodel_name = \"TinyLlama/TinyLlama-1.1B-intermediate-step-1431k-3T\"\ntokenizer = AutoTokenizer.from_pretrained(model_name, trust_remote_code=True)\ntokenizer.pad_token = \"&lt;PAD&gt;\"\ntokenizer.padding_side = \"left\"\n\n# LoRA 설정 준비\npeft_config = LoraConfig(\n    lora_alpha=32,  # LoRA 스케일링\n    lora_dropout=0.1,  # LoRA 레이어의 드롭아웃\n    r=64,  # 랭크\n    bias=\"none\",\n    task_type=\"CAUSAL_LM\",\n    target_modules=[\n        # 대상 레이어\n        \"k_proj\",\n        \"gate_proj\",\n        \"v_proj\",\n        \"up_proj\",\n        \"q_proj\",\n        \"o_proj\",\n        \"down_proj\",\n    ],\n)\n\n# 훈련을 위한 모델 준비\nmodel = prepare_model_for_kbit_training(model)\nmodel = get_peft_model(model, peft_config)\n\noutput_dir = \"./model\"\n\n# 훈련 인자\ntraining_arguments = DPOConfig(\n    output_dir=output_dir,\n    per_device_train_batch_size=2,\n    gradient_accumulation_steps=4,\n    optim=\"paged_adamw_32bit\",\n    learning_rate=1e-5,\n    lr_scheduler_type=\"cosine\",\n    max_steps=500,\n    logging_steps=100,\n    fp16=True,\n    gradient_checkpointing=True,\n    warmup_ratio=0.1,\n    beta=0.1,  # beta 값을 여기에 추가\n    max_prompt_length=512,\n    max_length=512,\n    disable_tqdm=False,\n)\n\n# DPO 트레이너 생성\ndpo_trainer = DPOTrainer(\n    model,\n    args=training_arguments,\n    train_dataset=dpo_dataset,\n    processing_class=tokenizer,  # tokenizer 대신 processing_class 사용\n    peft_config=peft_config,\n)\n\n# DPO로 모델 미세조정\ndpo_trainer.train()\n\n# 어댑터 저장\ndpo_trainer.model.save_pretrained(\"./model/TinyLlama-1.1B-dpo-qlora\")\n\n\n      \n      \n      [500/500 10:36, Epoch 0/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n100\n0.593300\n\n\n200\n0.485700\n\n\n300\n0.520400\n\n\n400\n0.476500\n\n\n500\n0.489200\n\n\n\n\n\n\n\nfrom peft import PeftModel\nfrom transformers import pipeline\n\n# LoRA와 기본 모델 병합\nmodel = AutoPeftModelForCausalLM.from_pretrained(\n    \"./model/TinyLlama-1.1B-qlora\",\n    low_cpu_mem_usage=True,\n    device_map=\"auto\",\n)\nsft_model = model.merge_and_unload()\n\n# DPO LoRA와 SFT 모델 병합\ndpo_model = PeftModel.from_pretrained(\n    sft_model,\n    \"./model/TinyLlama-1.1B-dpo-qlora\",\n    device_map=\"auto\",\n)\ndpo_model = dpo_model.merge_and_unload()\n\n# 정의된 프롬프트 템플릿 사용\nprompt = \"\"\"&lt;|user|&gt;\n독감 예방 접종의 중요성에 대해 설명해.&lt;/s&gt;\n&lt;|assistant|&gt;\n\"\"\"\n\n# 튜닝된 모델 실행\npipe = pipeline(task=\"text-generation\", model=dpo_model, tokenizer=tokenizer)\npipe(prompt)[0][\"generated_text\"]\n\n'&lt;|user|&gt;\\n독감 예방 접종의 중요성에 대해 설명해.&lt;/s&gt;\\n&lt;|assistant|&gt;\\nThe importance of preventive treatment in the prevention of chronic diseases has been recognized for centuries. Chronic diseases such as heart disease, stroke, diabetes, and cancer are the leading causes of death worldwide. Preventive treatment is essential to reduce the risk of developing these diseases and improve the quality of life for patients.\\n\\nPreventive treatment involves a combination of lifestyle changes, medications, and medical interventions. These interventions aim to reduce the risk of developing chronic diseases by modifying the lifestyle of the patient, such as smoking cessation, physical activity, and dietary modification.\\n\\nPreventive treatment is often recommended for patients with high risk of developing chronic diseases, such as those with a family history of heart disease, diabetes, or cancer. Patients with these risk factors should be screened regularly for early detection of the disease and receive preventive treatment as soon as possible.\\n\\nIn addition to preventive treatment, patients with chronic diseases should be monitored regularly to detect any changes in their condition and to ensure that they receive the appropriate treatment. This monitoring can help to identify early signs of disease progression and to prevent complications.\\n\\nIn conclusion, preventive treatment is essential to reduce the risk of developing chronic diseases and improve the quality of life for patients. By following a healthy lifestyle, making lifestyle changes, and receiving preventive treatment, patients can reduce their risk of developing chronic diseases and improve their overall health.'\n\n\n우리가 살펴본 미세 조정 과정은 두 단계로 이루어집니다. 첫 번째 단계에서는 사전 학습된 LLM에 지시 데이터를 사용하여 지도 학습 미세 조정을 수행했으며, 이를 흔히 지시 튜닝이라고 합니다. 이 결과로 채팅과 유사한 행동을 하고 지시를 정확히 따를 수 있는 모델이 만들어졌습니다.\n두 번째 단계에서는 정렬 데이터, 즉 어떤 유형의 답변이 다른 답변보다 선호되는지를 나타내는 데이터로 모델을 더욱 개선했습니다. 선호도 튜닝이라고 불리는 이 과정은 이전에 지시 튜닝된 모델에 인간의 선호도를 주입합니다.\nSFT+DPO의 조합을 통한 미세 조절은 훌륭한 방법이지만 두 번의 훈련 루프를 수행하고 두 과정에서 매개변수를 조정해야기 때문에 많은 계산 비용이 발생합니다. 이런 점을 극복하기 위해 새로운 방법들이 나오고 있는데 그 중에 주목할 만한 것은 Odds Ratio Preference Optimization(ORPO)으로 SFT와 DPO를 단일 훈련 과정으로 결합한 것입니다. 이 방법은 두 개의 별도 훈련 루프를 제거해 훈련 과정을 단순화하면서도 QLoRA의 사용을 가능하게 합니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html",
    "href": "posts/ipynb/da_statistics_pingouin.html",
    "title": "파이썬으로 통계 분석하기",
    "section": "",
    "text": "Pingouin은 간단하지만 완전한 통계 기능를 위해 설계되었습니다. 예를 들어 기존의 SciPy 패키지의 ttest_ind 함수는 T-value과 p-value만 알려주지만 Pingouin의 ttest 함수는 T-value, p-value뿐만 아니라 자유도, 효과 크기(Cohen ’s d), 95% 신뢰 구간, 통계적 검정력등을 동시에 출력합니다. 아래의 목록은 할 수 있는 대표적인 분석입니다.\n더 자세한 것은 공식 홈페이지를 참고하세요."
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#one-sample-t-test",
    "href": "posts/ipynb/da_statistics_pingouin.html#one-sample-t-test",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.1 One-sample T-test",
    "text": "2.1 One-sample T-test\n\n모집단의 평균은 4로 가정\n\n\nmu = 4\nx = [5.5, 2.4, 6.8, 9.6, 4.2]\npg.ttest(x, mu)\n\n\n\n\n\n\n\n\nT\ndof\ntail\np-val\nCI95%\ncohen-d\nBF10\npower\n\n\n\n\nT-test\n1.397391\n4\ntwo-sided\n0.234824\n[-1.68, 5.08]\n0.624932\n0.766\n0.191796\n\n\n\n\n\n\n\n자유도(dof)는 4, T-value(T)는 1.3973 이며 p-Value가 일반적인 기준(0.05) 이상이기 때문에 표본 x의 평균은 모집단의 평균과 차이가 없다(귀무가설)고 볼 수 있다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#paired-t-test",
    "href": "posts/ipynb/da_statistics_pingouin.html#paired-t-test",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.2 Paired T-test",
    "text": "2.2 Paired T-test\n꼬리를 one-sided로 설정하면 pingouin이 알아서 꼬리의 방향을 알려줍니다. 아래 코드의 경우 T-value가 음수이기 때문에 꼬리의 방향이 less로 표현됩니다.\n\npre = [5.5, 2.4, 6.8, 9.6, 4.2]\npost = [6.4, 3.4, 6.4, 11.0, 4.8]\npg.ttest(pre, post, paired=True, tail=\"one-sided\")\n\n\n\n\n\n\n\n\nT\ndof\ntail\np-val\nCI95%\ncohen-d\nBF10\npower\n\n\n\n\nT-test\n-2.307832\n4\nless\n0.041114\n[-inf, -0.05]\n0.250801\n3.122\n0.12048\n\n\n\n\n\n\n\n꼬리의 방향이 less라는 것은 표본 x의 평균이 표본 y의 평균보다 작다는 것을 뜻합니다.\n일부러 꼬리의 방향을 반대(greater)로 한 대립 가설을 확인해 봅니다.\n\npg.ttest(pre, post, paired=True, tail=\"greater\")\n\n\n\n\n\n\n\n\nT\ndof\ntail\np-val\nCI95%\ncohen-d\nBF10\npower\n\n\n\n\nT-test\n-2.307832\n4\ngreater\n0.958886\n[-1.35, inf]\n0.250801\n0.32\n0.016865\n\n\n\n\n\n\n\np-value가 엉망인것을 알 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#two-sample-t-test",
    "href": "posts/ipynb/da_statistics_pingouin.html#two-sample-t-test",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.3 Two-sample T-test",
    "text": "2.3 Two-sample T-test\n\n2.3.1 표본 크기가 같은 경우\n\nx = np.random.normal(loc=7, size=20)\ny = np.random.normal(loc=4, size=20)\npg.ttest(x, y, correction=\"auto\")\n\n\n\n\n\n\n\n\nT\ndof\ntail\np-val\nCI95%\ncohen-d\nBF10\npower\n\n\n\n\nT-test\n10.151246\n38\ntwo-sided\n2.245760e-12\n[2.48, 3.71]\n3.210106\n2.223e+09\n1.0\n\n\n\n\n\n\n\n\n\n2.3.2 표본 크기가 다른경우\n\nx = np.random.normal(loc=7, size=20)\ny = np.random.normal(loc=4, size=15)\npg.ttest(x, y, correction=\"auto\")\n\n\n\n\n\n\n\n\nT\ndof\ntail\np-val\nCI95%\ncohen-d\nBF10\npower\n\n\n\n\nT-test\n8.352442\n24.033207\ntwo-sided\n1.443438e-08\n[2.21, 3.65]\n2.995554\n5.808e+06\n1.0"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#pearsons-correlation",
    "href": "posts/ipynb/da_statistics_pingouin.html#pearsons-correlation",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.4 Pearson’s correlation",
    "text": "2.4 Pearson’s correlation\n\nmean, cov, n = [4, 5], [(1, 0.6), (0.6, 1)], 30\nx, y = np.random.multivariate_normal(mean, cov, n).T\npg.corr(x, y)\n\n\n\n\n\n\n\n\nn\nr\nCI95%\nr2\nadj_r2\np-val\nBF10\npower\n\n\n\n\npearson\n30\n0.63893\n[0.36, 0.81]\n0.408231\n0.364397\n0.000145\n220.85\n0.978466"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#robust-correlation",
    "href": "posts/ipynb/da_statistics_pingouin.html#robust-correlation",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.5 Robust correlation",
    "text": "2.5 Robust correlation\n\n# 표본 x에 아웃라이어 추가\nx[5] = 18\n# Use the robust Shepherd's pi correlation\npg.corr(x, y, method=\"shepherd\")\n\n\n\n\n\n\n\n\nn\noutliers\nr\nCI95%\nr2\nadj_r2\np-val\npower\n\n\n\n\nshepherd\n30\n3\n0.391331\n[0.04, 0.66]\n0.15314\n0.090409\n0.043538\n0.586546"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#데이터의-정규성-테스트",
    "href": "posts/ipynb/da_statistics_pingouin.html#데이터의-정규성-테스트",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.6 데이터의 정규성 테스트",
    "text": "2.6 데이터의 정규성 테스트\npingouin.normality()함수를 pandas의 데이터 프레임형식에 사용할 수 있습니다.\n\n# 일변량 정규성(Univariate normality)\npg.normality(x)\n\n\n\n\n\n\n\n\nW\npval\nnormal\n\n\n\n\n0\n0.485009\n3.733778e-09\nFalse\n\n\n\n\n\n\n\n\n# 다변량 정규성(Multivariate normality)\npg.multivariate_normality(np.column_stack((x, y)))\n\n(False, 6.620602006901788e-07)"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#q-q-plot-시각화",
    "href": "posts/ipynb/da_statistics_pingouin.html#q-q-plot-시각화",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.7 Q-Q plot 시각화",
    "text": "2.7 Q-Q plot 시각화\n\nx = np.random.normal(size=50)\nax = pg.qqplot(x, dist=\"norm\")"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#one-way-anova",
    "href": "posts/ipynb/da_statistics_pingouin.html#one-way-anova",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.8 One-way ANOVA",
    "text": "2.8 One-way ANOVA\n기본 내장되어 있는 데이터프레임(mixed_anova)을 사용합니다.\n\n# Read an example dataset\ndf = pg.read_dataset(\"mixed_anova\")\ndf.tail()\n\n\n\n\n\n\n\n\nScores\nTime\nGroup\nSubject\n\n\n\n\n175\n6.176981\nJune\nMeditation\n55\n\n\n176\n8.523692\nJune\nMeditation\n56\n\n\n177\n6.522273\nJune\nMeditation\n57\n\n\n178\n4.990568\nJune\nMeditation\n58\n\n\n179\n7.822986\nJune\nMeditation\n59\n\n\n\n\n\n\n\n\n# Run the ANOVA\naov = pg.anova(data=df, dv=\"Scores\", between=\"Group\", detailed=True)\naov\n\n\n\n\n\n\n\n\nSource\nSS\nDF\nMS\nF\np-unc\nnp2\n\n\n\n\n0\nGroup\n5.459963\n1\n5.459963\n5.243656\n0.0232\n0.028616\n\n\n1\nWithin\n185.342729\n178\n1.041251\nNaN\nNaN\nNaN"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#repeated-measures-anova",
    "href": "posts/ipynb/da_statistics_pingouin.html#repeated-measures-anova",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.9 Repeated measures ANOVA",
    "text": "2.9 Repeated measures ANOVA\n\npg.rm_anova(data=df, dv=\"Scores\", within=\"Time\", subject=\"Subject\", detailed=True)\n\n\n\n\n\n\n\n\nSource\nSS\nDF\nMS\nF\np-unc\nnp2\neps\n\n\n\n\n0\nTime\n7.628428\n2\n3.814214\n3.912796\n0.022629\n0.062194\n0.998751\n\n\n1\nError\n115.027023\n118\n0.974805\nNaN\nNaN\nNaN\nNaN"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#post-hoc-tests-corrected-for-multiple-comparisons",
    "href": "posts/ipynb/da_statistics_pingouin.html#post-hoc-tests-corrected-for-multiple-comparisons",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.10 Post-hoc tests corrected for multiple-comparisons",
    "text": "2.10 Post-hoc tests corrected for multiple-comparisons\n\n# FDR-corrected post hocs with Hedges'g effect size\nposthoc = pg.pairwise_ttests(\n    data=df,\n    dv=\"Scores\",\n    within=\"Time\",\n    subject=\"Subject\",\n    parametric=True,\n    padjust=\"fdr_bh\",\n    effsize=\"hedges\",\n)\n\nposthoc\n\n\n\n\n\n\n\n\nContrast\nA\nB\nPaired\nParametric\nT\ndof\nTail\np-unc\np-corr\np-adjust\nBF10\nhedges\n\n\n\n\n0\nTime\nAugust\nJanuary\nTrue\nTrue\n-1.740370\n59.0\ntwo-sided\n0.087008\n0.130512\nfdr_bh\n0.582\n-0.327583\n\n\n1\nTime\nAugust\nJune\nTrue\nTrue\n-2.743238\n59.0\ntwo-sided\n0.008045\n0.024134\nfdr_bh\n4.232\n-0.482547\n\n\n2\nTime\nJanuary\nJune\nTrue\nTrue\n-1.023620\n59.0\ntwo-sided\n0.310194\n0.310194\nfdr_bh\n0.232\n-0.169520"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#two-way-mixed-anova",
    "href": "posts/ipynb/da_statistics_pingouin.html#two-way-mixed-anova",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.11 Two-way mixed ANOVA",
    "text": "2.11 Two-way mixed ANOVA\n\n# Compute the two-way mixed ANOVA and export to a .csv file\naov = pg.mixed_anova(\n    data=df,\n    dv=\"Scores\",\n    between=\"Group\",\n    within=\"Time\",\n    subject=\"Subject\",\n    correction=False,\n    effsize=\"np2\",\n)\naov\n\n\n\n\n\n\n\n\nSource\nSS\nDF1\nDF2\nMS\nF\np-unc\nnp2\neps\n\n\n\n\n0\nGroup\n5.459963\n1\n58\n5.459963\n5.051709\n0.028420\n0.080120\nNaN\n\n\n1\nTime\n7.628428\n2\n116\n3.814214\n4.027394\n0.020369\n0.064929\n0.998751\n\n\n2\nInteraction\n5.167192\n2\n116\n2.583596\n2.727996\n0.069545\n0.044922\nNaN"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#bland-altman-plot",
    "href": "posts/ipynb/da_statistics_pingouin.html#bland-altman-plot",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.12 Bland-Altman plot",
    "text": "2.12 Bland-Altman plot\n\nmean, cov = [10, 11], [[1, 0.8], [0.8, 1]]\nx, y = np.random.multivariate_normal(mean, cov, 30).T\nax = pg.plot_blandaltman(x, y)"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#paired-t-test-검정력-시각화",
    "href": "posts/ipynb/da_statistics_pingouin.html#paired-t-test-검정력-시각화",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.13 paired T-test 검정력 시각화",
    "text": "2.13 paired T-test 검정력 시각화\nT-검정의 표본 크기와 효과 크기(Cohen’d)에 따른 검정력 곡선을 시각화합니다.\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set(style=\"ticks\", context=\"notebook\", font_scale=1.2)\nd = 0.5  # Fixed effect size\nn = np.arange(5, 80, 5)  # Incrementing sample size\n# Compute the achieved power\npwr = pg.power_ttest(d=d, n=n, contrast=\"paired\", tail=\"two-sided\")\nplt.plot(n, pwr, \"ko-.\")\nplt.axhline(0.8, color=\"r\", ls=\":\")\nplt.xlabel(\"Sample size\")\nplt.ylabel(\"Power (1 - type II error)\")\nplt.title(\"Achieved power of a paired T-test\")\nsns.despine()"
  },
  {
    "objectID": "posts/ipynb/da_statistics_pingouin.html#paired-plot",
    "href": "posts/ipynb/da_statistics_pingouin.html#paired-plot",
    "title": "파이썬으로 통계 분석하기",
    "section": "2.14 Paired plot",
    "text": "2.14 Paired plot\nmixed_anova데이터셋을 가지고 명상이 학교 성적에 미치는 영향에 대한 시각화를 해본다.\n\ndf = pg.read_dataset(\"mixed_anova\").query(\"Group == 'Meditation' and Time != 'January'\")\n\npg.plot_paired(data=df, dv=\"Scores\", within=\"Time\", subject=\"Subject\")"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_02.html",
    "href": "posts/ipynb/da_scanpy_workshop_02.html",
    "title": "Scanpy로 scRNA-seq 분석 02",
    "section": "",
    "text": "이번 실습에서는 데이터의 시각화를 위한 차원축소 방법인 PCA, tSNE, UMAP등에 대해 배우고 배치 효과를 제거해서 여러 데이터셋을 통합하는 방법에 대해 살펴봅니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_02.html#bbknn",
    "href": "posts/ipynb/da_scanpy_workshop_02.html#bbknn",
    "title": "Scanpy로 scRNA-seq 분석 02",
    "section": "7.1 BBKNN",
    "text": "7.1 BBKNN\n먼저 BBKNN(Batch Balanced KNN)을 실행해 보겠습니다. BBKNN은 빠르고 직관적인 배치 효과 제거 도구로 scanpy 워크플로우에서 바로 사용할 수 있습니다. 또한 scanpy.pp.neighbors() 함수 대신에 사용할 수 있습니다. 더 자세한 내용은 BBKNN 문서를 참조하세요.\n\nadata_bbknn = adata.copy()\nneighbors_within_batch = 25 if adata.n_obs &gt; 100000 else 3\n\nbbknn.bbknn(adata_bbknn, batch_key=\"sample\", neighbors_within_batch=neighbors_within_batch)\n\nsc.tl.umap(adata_bbknn)\nsc.tl.tsne(adata_bbknn)\n\n이제 통합되지 않은 공간과 통합된 공간의 축소된 치수를 그릴 수 있습니다.\n\nfig, axs = plt.subplots(2, 2, figsize=(10, 8), constrained_layout=True)\nsc.pl.tsne(adata_bbknn, color=\"sample\", title=\"BBKNN Corrected tsne\", ax=axs[0, 1], show=False)\nsc.pl.tsne(adata, color=\"sample\", title=\"Uncorrected tsne\", ax=axs[0, 0], show=False)\nsc.pl.umap(adata_bbknn, color=\"sample\", title=\"BBKNN Corrected umap\", ax=axs[1, 1], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected umap\", ax=axs[1, 0], show=False)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_02.html#scanorama",
    "href": "posts/ipynb/da_scanpy_workshop_02.html#scanorama",
    "title": "Scanpy로 scRNA-seq 분석 02",
    "section": "7.2 Scanorama",
    "text": "7.2 Scanorama\nScanorama는 scRNA-seq 데이터 세트의 일괄 보정 및 통합을 사용할 수 있도록 설계되었습니다. Scanorama를 통한 보정의 결과는 다른 도구의 입력으로 사용하여 scRNA-seq 클러스터링, 시각화 및 분석에 사용할 수 있습니다. 이제 Scanorama도 사용해 보겠습니다. 먼저, 각 데이터 세트에서 개별 AnnData 객체를 만들어야 합니다.\n\n# 배치별로 개체를 분할합니다.\nbatches = adata.obs[\"sample\"].cat.categories.tolist()\nalldata = {}\nfor batch in batches:\n    alldata[batch] = adata[adata.obs[\"sample\"] == batch,]\n\n# 개별 데이터 집합을 처음에 정의한 가변 유전자로 하위 집합합니다.\nalldata2 = {}\nfor ds in alldata.keys():\n    print(ds)\n    alldata2[ds] = alldata[ds][:, var_genes]\n\n# AnnData 객체 목록으로 변환\nadatas = list(alldata2.values())\n\n# scanorama.integrate 실행\nscanorama.integrate_scanpy(adatas, dimred=50, verbose=False)\n\n# scanorama는 adatas의 각 데이터 집합에서 수정된 행렬을 adata.obsm에 추가합니다.\nadatas[0].obsm[\"X_scanorama\"].shape\n\ncovid_1\ncovid_15\ncovid_16\ncovid_17\nctrl_5\nctrl_13\nctrl_14\nctrl_19\nFound 4268 genes among all datasets\n\n\n(874, 50)\n\n\n\n# 모든 통합 행렬을 가져옵니다.\nscanorama_int = [ad.obsm[\"X_scanorama\"] for ad in adatas]\n\n# 하나의 행렬로 만듭니다.\nall_s = np.concatenate(scanorama_int)\nprint(all_s.shape)\n\n# AnnData 객체에 추가하려면 먼저 새 객체를 만듭니다.\nadata_sc = adata.copy()\nadata_sc.obsm[\"Scanorama\"] = all_s\n\n(7227, 50)\n\n\n\n# tsne 과 umap을 그립니다.\nsc.pp.neighbors(adata_sc, n_pcs=30, use_rep=\"Scanorama\")\nsc.tl.umap(adata_sc)\nsc.tl.tsne(adata_sc, n_pcs=30, use_rep=\"Scanorama\")\n\n이제 통합되지 않은 공간과 통합된 공간을 축소한 차원을 그릴 수 있습니다.\n\nfig, axs = plt.subplots(2, 2, figsize=(10, 8), constrained_layout=True)\nsc.pl.tsne(adata, color=\"sample\", title=\"Uncorrected tsne\", ax=axs[0, 0], show=False)\nsc.pl.tsne(adata_sc, color=\"sample\", title=\"Scanorama tsne\", ax=axs[0, 1], show=False)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected umap\", ax=axs[1, 0], show=False)\nsc.pl.umap(adata_sc, color=\"sample\", title=\"Scanorama umap\", ax=axs[1, 1], show=False)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_02.html#결과-살펴보기",
    "href": "posts/ipynb/da_scanpy_workshop_02.html#결과-살펴보기",
    "title": "Scanpy로 scRNA-seq 분석 02",
    "section": "7.3 결과 살펴보기",
    "text": "7.3 결과 살펴보기\n이제 세 가지 통합 방법을 나란히 사용하여 UMAP을 그려보겠습니다.\n\nfig, axs = plt.subplots(2, 2, figsize=(10, 8), constrained_layout=True)\nsc.pl.umap(adata, color=\"sample\", title=\"Uncorrected\", ax=axs[0, 0], show=False)\nsc.pl.umap(adata_bbknn, color=\"sample\", title=\"BBKNN\", ax=axs[0, 1], show=False)\nsc.pl.umap(adata_sc, color=\"sample\", title=\"Scanorama\", ax=axs[1, 0], show=False)\naxs[-1, -1].axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n배치 효과 제거를 위해 사용할 수 있는 다양한 방법이 있으며, 각 방법에는 장단점이 있습니다. 가장 적합한 방법을 선택하는 데에는 데이터의 특성과 분석 목표에 따라 달라질 수 있습니다. 그러니 다양한 방법을 시도하여 데이터 특성에 가장 잘 맞는 방법을 찾는 것이 중요합니다.\n\n\n\n\n\n\nNote\n\n\n\n배치 효과가 잘 제거되었는지 어떻게 평가할 수 있을까요? 크게 두가지 방법이 있습니다.\n\n시각적 평가: UMAP 플롯을 통해 배치가 잘 섞여 있는지 시각적으로 확인합니다. 배치 간의 구분이 사라지면 배치 효과가 잘 제거된 것입니다.\n실루엣 스코어: 높은 실루엣 스코어는 잘 클러스터링된 데이터를 의미합니다. 배치 효과 제거 전후의 실루엣 스코어를 비교하여 배치 효과 제거의 효과를 평가합니다.\n\n\n\n시각적 평가를 통해 어떤 도구가 배치 효과 보정을 잘 했는지 살펴보면, 아무래도 Scanorma로 한 것이 좋아보입니다. 이후의 분석은 adata_sc 객체를 가지고 진행하겠습니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "tomorrow-lab",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n\n\n\n\n\n\n\n\n\n\nMatplotlib 고급 시각화\n\n\n\nPython\n\nVisualization\n\nMatplotlib\n\n\n\n\n\n\n\n\n\n2025-11-01\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nPDB 데이터베이스에 숨겨진 5가지 진실\n\n\n\nBioinformatics\n\nPDB\n\nProtein databank\n\nTip\n\n\n\n\n\n\n\n\n\n2025-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nFlox 시작하기\n\n\n\nPython\n\nTip\n\nProductivity\n\nProgramming\n\nCheatsheet\n\n\n\n\n\n\n\n\n\n2025-09-06\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n항체 의약품 개발 가능성 예측을 위한 DeepSP 튜토리얼\n\n\n\nPython\n\nDeepSP\n\nBioinformatics\n\nDeepViscosity\n\nAbDev\n\nAntibody\n\nAntibody Drug Development\n\n\n\n\n\n\n\n\n\n2025-08-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nAutoGluon을 사용한 AutoML\n\n\n\nPython\n\nAWS\n\nAutoGluon\n\nMachineLearning\n\nAutoML\n\n\n\n\n\n\n\n\n\n2025-07-20\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nNature Methods 데이터 시각화 컬럼 모음\n\n\n\nTip\n\nProductivity\n\nVisualization\n\n\n\n\n\n\n\n\n\n2025-06-15\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n프로그래밍을 위한 고정폭 폰트\n\n\n\nProductivity\n\nTip\n\nFont\n\n\n\n\n\n\n\n\n\n2025-05-31\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n일상에 필요한 통계학 개념\n\n\n\nStatistic\n\nTip\n\nProductivity\n\n\n\n\n\n\n\n\n\n2025-05-17\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n미루기를 멈추기 위한 간단한 방법들\n\n\n\nProcrastination\n\nProductivity\n\nTip\n\n\n\n\n\n\n\n\n\n2025-05-02\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬을 사용한 각종 Bioinformatic 시각화 스니펫\n\n\n\nBiology\n\nBioinformatics\n\nBiopython\n\nBiotite\n\nPython\n\nVisualization\n\n\n\n\n\n\n\n\n\n2025-04-12\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRFantibody로 de novo antibody discovery\n\n\n\nPython\n\nRFantibody\n\nAntibody\n\nDe novo design\n\n\n\n\n\n\n\n\n\n2025-03-31\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n데이터 기반 의사 결정을 위한 시각화\n\n\n\nData science\n\nPython\n\n\n\n\n\n\n\n\n\n2025-03-29\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nOpenCV를 사용해 이미지에서 세포 수 측정\n\n\n\nPython\n\nOpenCV\n\n\n\n\n\n\n\n\n\n2025-03-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nLLM 사전 학습에 대한 이해\n\n\n\nLLM\n\nMachine Learning\n\nPython\n\n\n\n\n\n\n\n\n\n2025-03-13\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nLLM을 사용한 스팸 메시지 분류\n\n\n\nPython\n\nLLM\n\nHuggingface\n\n\n\n\n\n\n\n\n\n2025-03-01\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬으로 Epitope binning 하기\n\n\n\nPython\n\nVisualization\n\nEpitope binning\n\n\n\n\n\n\n\n\n\n2025-02-23\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nAKTA 크로마토그램(chromatogram) 시각화\n\n\n\nPython\n\nVisualization\n\n\n\n\n\n\n\n\n\n2025-02-14\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n실습으로 배우는 대규모 언어 모델\n\n\n\nLLM\n\nMachine Learning\n\nPython\n\n\n\n\n\n\n\n\n\n2025-01-26\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n타이핑으로 소비되는 칼로리\n\n\n\nPython\n\nVisualization\n\nHealth\n\nFitness\n\nProductivity\n\n\n\n\n\n\n\n\n\n2025-01-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nCalplot: 파이썬으로 만드는 멋진 캘린더 히트맵\n\n\n\nPython\n\nVisualization\n\nCalplot\n\n\n\n\n\n\n\n\n\n2025-01-18\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n코딩테스트 기초\n\n\n\nCoding test\n\nPython\n\nRust\n\nProgramming\n\n\n\n\n\n\n\n\n\n2025-01-11\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n코딩테스트 입문\n\n\n\nCoding test\n\nPython\n\nRust\n\nProgramming\n\n\n\n\n\n\n\n\n\n2025-01-11\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n쿼토로 시작하는 블로그\n\n\n\nQuarto blog\n\nBlog\n\n\n\n\n\n\n\n\n\n2025-01-10\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nMojo 프로그래밍 언어\n\n\n\nCoding\n\nProgramming\n\nMojo lang\n\n\n\n\n\n\n\n\n\n2025-01-08\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬 코딩 팁\n\n\n\nPython\n\nTip\n\nProductivity\n\nProgramming\n\nCheatsheet\n\n\n\n\n\n\n\n\n\n2024-12-21\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n학술 논문을 효율적으로 읽는 법\n\n\n\nData science\n\nTip\n\nProductivity\n\n\n\n\n\n\n\n\n\n2024-11-30\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬으로 Sankey diagram그리기\n\n\n\nPython\n\nVisualization\n\nBioinformatics\n\n\n\n\n\n\n\n\n\n2024-11-29\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nSeurat 라이브러리 치트시트(Cheatsheet)\n\n\n\nR\n\nTip\n\nscRNA-seq\n\nBioinformatics\n\nSeurat\n\nCheatsheet\n\n\n\n\n\n\n\n\n\n2024-11-12\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nGSE에서 sc-RNAseq 데이터 가져오기\n\n\n\nPython\n\nGene Expression Omnibus\n\nscRNA-seq\n\nBioinformatics\n\n\n\n\n\n\n\n\n\n2024-11-09\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n임상 통계학\n\n\n\nClinical trial\n\nStatistics\n\n\n\n\n\n\n\n\n\n2024-10-25\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n인과 관계 추론을 위한 기본 규칙\n\n\n\nPython\n\nCausal inference\n\n\n\n\n\n\n\n\n\n2024-10-19\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nscRNA-seq 소개\n\n\n\nscRNA-seq\n\nBioinformatics\n\nTip\n\n\n\n\n\n\n\n\n\n2024-10-16\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n.DS_Store 파일 관리\n\n\n\nProductivity\n\nTip\n\nMacOS\n\nGit\n\n\n\n\n\n\n\n\n\n2024-10-07\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n사보타지 매뉴얼\n\n\n\nProductivity\n\nTip\n\n\n\n\n\n\n\n\n\n2024-10-07\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRosalind Armory 문제풀이\n\n\n\nPython\n\nRosalind\n\nBioinformatics\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n실험실 프로토콜 모음\n\n\n\nWet lab\n\nTip\n\nProtocols\n\n\n\n\n\n\n\n\n\n2024-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRosalind Stronghold 문제풀이\n\n\n\nPython\n\nRosalind\n\nBioinformatics\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRosalind Algorithmic Heights 문제풀이\n\n\n\nPython\n\nRosalind\n\nBioinformatics\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRosalind Textbook track 문제풀이\n\n\n\nPython\n\nRosalind\n\nBioinformatics\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n문자열 인코딩 문제\n\n\n\nPython\n\nR\n\nCharacter encoding\n\nText encoding\n\nData science\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-21\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n머신러닝을 위한 수학\n\n\n\nMachine Learning\n\nMathmatics\n\nData science\n\n\n\n\n\n\n\n\n\n2024-09-10\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nDockQ로 도킹 모델 품질 측정하기\n\n\n\nBioinformatics\n\nTip\n\nDocking\n\n\n\n\n\n\n\n\n\n2024-09-09\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n마음챙김과 효율을 위한 생산성 디버깅\n\n\n\nProductivity\n\nTip\n\nMindfullness\n\n\n\n\n\n\n\n\n\n2024-09-08\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n오픈 소스 PyMOL 설치하기\n\n\n\nPython\n\nProtein engineering\n\nVisualization\n\nTip\n\n\n\n\n\n\n\n\n\n2024-09-01\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\npip 대신에 uv 사용하기\n\n\n\nPython\n\nPackage manager\n\nVirtual environment\n\nData science\n\nTip\n\n\n\n\n\n\n\n\n\n2024-08-24\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 07\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-08-15\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 06\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-08-11\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 05\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-08-10\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 04\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-07-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 03\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-06-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 02\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-06-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 scRNA-seq 분석 01\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\nWorkshop\n\n\n\n\n\n\n\n\n\n2024-06-17\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n어떻게 데이터 과학은 작동하는가?\n\n\n\nData science\n\nTip\n\n\n\n\n\n\n\n\n\n2024-05-30\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nMarsilea로 복잡한 시각화 처리하기\n\n\n\nPython\n\nData science\n\nBioinformatics\n\nVisualization\n\n\n\n\n\n\n\n\n\n2024-04-20\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nScanpy로 gene_id를 gene_symbol로 변경하기\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\n\n\n\n\n\n\n\n\n2024-04-12\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n미니멀한 폴더 정리: PARA method\n\n\n\nProductivity\n\nTip\n\n\n\n\n\n\n\n\n\n2024-04-04\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nRDS 객체를 10X MEX 형식으로 저장하기\n\n\n\nR\n\nscRNA-seq\n\nBioinformatics\n\nSeurat\n\n\n\n\n\n\n\n\n\n2024-03-26\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nAnnData 객체를 10X MEX 형식으로 저장하기\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\n\n\n\n\n\n\n\n\n2024-03-21\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n의존성 지옥에 빠진 당신을 구하러 온 Pixi\n\n\n\nPython\n\nPackage manager\n\nVirtual environment\n\nR\n\nTip\n\n\n\n\n\n\n\n\n\n2024-02-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nscRNA-seq 데이터 QC하기\n\n\n\nPython\n\nscRNA-seq\n\nBioinformatics\n\nScanpy\n\n\n\n\n\n\n\n\n\n2024-02-22\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n10X genomics scRNA-seq alignment\n\n\n\nPython\n\nBioinformatics\n\nscRNA-seq\n\nCellranger\n\n\n\n\n\n\n\n\n\n2024-02-21\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nminiforge: 파이썬과 R의 패키지 및 개발 환경 관리 도구\n\n\n\nPython\n\nPackage manager\n\nVirtual environment\n\nTip\n\nR\n\n\n\n\n\n\n\n\n\n2024-01-28\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬 statsmodels로 통계분석\n\n\n\nPython\n\nStatistics\n\nT-test\n\nA/B-test\n\nANOVA\n\n\n\n\n\n\n\n\n\n2023-10-07\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬 통계분석하기\n\n\n\nPython\n\nT-test\n\nF-test\n\nStatistics\n\n\n\n\n\n\n\n\n\n2023-09-17\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nSeurat으로 scRNA seq데이터 분석하기\n\n\n\nR\n\nData science\n\nBioinformatics\n\nSeurat\n\n\n\n\n\n\n\n\n\n2023-04-01\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nggpubr로 논문에 사용할 플랏그리기\n\n\n\nR\n\nData science\n\nBioinformatics\n\nVisualization\n\n\n\n\n\n\n\n\n\n2023-03-01\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n파이썬으로 통계 분석하기\n\n\n\nPython\n\nData science\n\nStatistics\n\nT-test\n\nANOVA\n\n\n\n\n\n\n\n\n\n2023-01-23\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\nJupyter notebook 소개\n\n\n\nJupyterlab\n\nJupyter\n\nPython\n\nData science\n\n\n\n\n\n\n\n\n\n2023-01-10\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n데이터사이언스를 위한 파이썬과 R 개발 환경\n\n\n\nR\n\nPackage manager\n\nVirtual environment\n\nBioconductor\n\nPython\n\nTip\n\nData science\n\n\n\n\n\n\n\n\n\n2023-01-04\n\n\nTaeyoon Kim\n\n\n\n\n\n\n\n\n\n\n\n\n깔끔하게 데이터 정리하기\n\n\n\nNews\n\nPython\n\nData science\n\nTidy data\n\n\n\n\n\n\n\n\n\n2023-01-03\n\n\nTaeyoon Kim\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#더-알아-보기",
    "href": "posts/ipynb/da_processing_tidy.html#더-알아-보기",
    "title": "깔끔하게 데이터 정리하기",
    "section": "1.1 더 알아 보기",
    "text": "1.1 더 알아 보기\n\n2014년도에 출판된 논문 입니다.\n데이터의 출처는 이곳 입니다."
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#깔끔한-데이터tidy-data의-특징",
    "href": "posts/ipynb/da_processing_tidy.html#깔끔한-데이터tidy-data의-특징",
    "title": "깔끔하게 데이터 정리하기",
    "section": "1.2 깔끔한 데이터(Tidy data)의 특징",
    "text": "1.2 깔끔한 데이터(Tidy data)의 특징\nJeff Leek가 쓴 책 The Elements of Data Analytic Style에서 정의한 깔끔한 데이터는 아래와 같은 특징을 가집니다.\n\n각 변수는 개별의 열(column)으로 존재한다.\n각 관측치는 행(row)를 구성한다.\n각 표는 단 하나의 관측기준에 의해서 조직된 데이터를 저장한다.\n만약 여러개의 표가 존재한다면, 적어도 하나이상의 열(column)이 공유되어야 한다.\n\n\n변수(Variable): 예를 들면 키, 몸무게, 성별\n값(Value): 예를 들자면 152 cm, 80 kg, 여성\n관측치(Observation): 값을 측정한 단위, 여기서는 각각의 사람\n\n너무 복잡하다고 생각되신다면 아래 예시를 확인하세요.\n\n1.2.1 지저분한 데이터의 예:\n\n\n\n\n\n\n\nTreatment A\n\n\nTreatment B\n\n\n\n\n\n\nJohn Smith\n\n\n-\n\n\n2\n\n\n\n\nJane Doe\n\n\n16\n\n\n11\n\n\n\n\nMary Johnson\n\n\n3\n\n\n1\n\n\n\n\n\n\n\n1.2.2 깔끔한 데이터(Tidy data)의 예:\n\n\n\n\n\nName\n\n\nTreatment\n\n\nResult\n\n\n\n\n\n\nJohn Smith\n\n\na\n\n\n-\n\n\n\n\nJane Doe\n\n\na\n\n\n16\n\n\n\n\nMary Johnson\n\n\na\n\n\n3\n\n\n\n\nJohn Smith\n\n\nb\n\n\n2\n\n\n\n\nJane Doe\n\n\nb\n\n\n11\n\n\n\n\nMary Johnson\n\n\nb\n\n\n1"
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#열-이름column-header이-변수-이름이-아니고-값인-경우",
    "href": "posts/ipynb/da_processing_tidy.html#열-이름column-header이-변수-이름이-아니고-값인-경우",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.1 1. 열 이름(Column header)이 변수 이름이 아니고 값인 경우",
    "text": "2.1 1. 열 이름(Column header)이 변수 이름이 아니고 값인 경우\n\n2.1.1 Pew Research Center Dataset\n종교에 따른 개인의 수입의 관한 데이터입니다. 먼저 pandas의 read_csv기능을 사용해 파일을 읽어옵니다.\n\ndf = pd.read_csv(\"./data/pew-raw.csv\")\ndf\n\n\n\n\n\n\n\nreligion\n&lt;$10k\n$10-20k\n$20-30k\n$30-40k\n$40-50k\n$50-75k\n\n\n\n\n0\nAgnostic\n27\n34\n60\n81\n76\n137\n\n\n1\nAtheist\n12\n27\n37\n52\n35\n70\n\n\n2\nBuddhist\n27\n21\n30\n34\n33\n58\n\n\n3\nCatholic\n418\n617\n732\n670\n638\n1116\n\n\n4\nDont know/refused\n15\n14\n15\n11\n10\n35\n\n\n5\nEvangelical Prot\n575\n869\n1064\n982\n881\n1486\n\n\n6\nHindu\n1\n9\n7\n9\n11\n34\n\n\n7\nHistorically Black Prot\n228\n244\n236\n238\n197\n223\n\n\n8\nJehovahs Witness\n20\n27\n24\n24\n21\n30\n\n\n9\nJewish\n19\n19\n25\n25\n30\n95\n\n\n\n\n\n\n\n\nEvangelical Prot는 기독교 종파중에 하나로 ’개신교’입니다.\n\n문제점: 이 데이터들의 문제는 열 이름(columns headers)이 개인소득의 범위로 되어 있다는 것이죠.\n\n다시 말해서 보기에는 좋아보일지는 몰라도 분석하기에는 어려운 형식입니다.\n\n이러한 데이터를 Tidy data 형태로 변환하기 위해서 pandas라이브러리에서는 아주 쉬운 기능을 제공해 줍니다. 바로 melt라는 기능이지요. pivot table의 반대되는 개념으로 행이 많은 데이터를 열이 많은 데이터로 바꿔줍니다. melt는 아주 유용하기 때문에 앞으로도 자주 언급 됩니다.\n\nformatted_df = pd.melt(df, [\"religion\"], var_name=\"income\", value_name=\"freq\")\nformatted_df = formatted_df.sort_values(by=[\"religion\"])  # 종교 이름순으로 정렬\nformatted_df.head(10)  # 너무 길기 때문에 윗쪽 10개만 보겠습니다.\n\n\n\n\n\n\n\nreligion\nincome\nfreq\n\n\n\n\n0\nAgnostic\n&lt;$10k\n27\n\n\n30\nAgnostic\n$30-40k\n81\n\n\n40\nAgnostic\n$40-50k\n76\n\n\n50\nAgnostic\n$50-75k\n137\n\n\n10\nAgnostic\n$10-20k\n34\n\n\n20\nAgnostic\n$20-30k\n60\n\n\n41\nAtheist\n$40-50k\n35\n\n\n21\nAtheist\n$20-30k\n37\n\n\n11\nAtheist\n$10-20k\n27\n\n\n31\nAtheist\n$30-40k\n52\n\n\n\n\n\n\n\n이것이 Pew Research Center Dataset 의 Tidy data 형태 입니다.\n\n\n2.1.2 Billboard Top 100 Dataset\n이 데이터는 아주 오래전 같은 1999년부터 2000년까지의 빌보드차트 주간 순위 변동을 포함하고 있는 데이터 입니다.\n\ndf = pd.read_csv(\"./data/billboard.csv\", encoding=\"mac_latin2\")\ndf.head(10)\n\n\n\n\n\n\n\nyear\nartist.inverted\ntrack\ntime\ngenre\ndate.entered\ndate.peaked\nx1st.week\nx2nd.week\nx3rd.week\n...\nx67th.week\nx68th.week\nx69th.week\nx70th.week\nx71st.week\nx72nd.week\nx73rd.week\nx74th.week\nx75th.week\nx76th.week\n\n\n\n\n0\n2000\nDestiny's Child\nIndependent Women Part I\n3:38\nRock\n2000-09-23\n2000-11-18\n78\n63.0\n49.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n2000\nSantana\nMaria, Maria\n4:18\nRock\n2000-02-12\n2000-04-08\n15\n8.0\n6.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n2000\nSavage Garden\nI Knew I Loved You\n4:07\nRock\n1999-10-23\n2000-01-29\n71\n48.0\n43.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n2000\nMadonna\nMusic\n3:45\nRock\n2000-08-12\n2000-09-16\n41\n23.0\n18.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\n2000\nAguilera, Christina\nCome On Over Baby (All I Want Is You)\n3:38\nRock\n2000-08-05\n2000-10-14\n57\n47.0\n45.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n5\n2000\nJanet\nDoesn't Really Matter\n4:17\nRock\n2000-06-17\n2000-08-26\n59\n52.0\n43.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n6\n2000\nDestiny's Child\nSay My Name\n4:31\nRock\n1999-12-25\n2000-03-18\n83\n83.0\n44.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n7\n2000\nIglesias, Enrique\nBe With You\n3:36\nLatin\n2000-04-01\n2000-06-24\n63\n45.0\n34.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n8\n2000\nSisqo\nIncomplete\n3:52\nRock\n2000-06-24\n2000-08-12\n77\n66.0\n61.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n9\n2000\nLonestar\nAmazed\n4:25\nCountry\n1999-06-05\n2000-03-04\n81\n54.0\n44.0\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n10 rows × 83 columns\n\n\n\n문제점:\n\n열 이름(columns headers)이 값으로 구성되어 있다: x1st.week, x2st.week 등등\n순위가 100위권 밖으로 밀려나게 되면 Nan 값을 가지고, 따라서 필요없는 부수적인 값이 많아진다.\n\n위 데이터의 깔끔한 데이터를 만들기 위해서는 다시 melt 기능을 사용하겠습니다. 각각의 열이 행이 되도록 하고, 순위가 100위 밖으로 밀려난 경우(Nan값을 갖는경우)에는 행을 삭제할게요.\n\n# Melting\nid_vars = [\n    \"year\",\n    \"artist.inverted\",\n    \"track\",\n    \"time\",\n    \"genre\",\n    \"date.entered\",\n    \"date.peaked\",\n]\ndf = pd.melt(frame=df, id_vars=id_vars, var_name=\"week\", value_name=\"rank\")\n\n# Formatting\ndf[\"week\"] = (\n    df[\"week\"].str.extract(\"(\\d+)\", expand=False).astype(int)\n)  # 정규식으로 x1st.week 에서 숫자 1만 추출\ndf[\"rank\"] = df[\"rank\"].astype(int)\n\n# 필요없는 행을 삭제합니다.\ndf = df.dropna()\n\n# Create \"date\" columns\ndf[\"date\"] = (\n    pd.to_datetime(df[\"date.entered\"])\n    + pd.to_timedelta(df[\"week\"], unit=\"w\")\n    - pd.DateOffset(weeks=1)\n)\n\ndf = df[[\"year\", \"artist.inverted\", \"track\", \"time\", \"genre\", \"week\", \"rank\", \"date\"]]\ndf = df.sort_values(ascending=True, by=[\"year\", \"artist.inverted\", \"track\", \"week\", \"rank\"])\n\n# Assigning the tidy dataset to a variable for future usage\nbillboard = df\n\ndf.head(10)\n\n\n\n\n\n\n\nyear\nartist.inverted\ntrack\ntime\ngenre\nweek\nrank\ndate\n\n\n\n\n246\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n1\n87\n2000-02-26\n\n\n563\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n2\n82\n2000-03-04\n\n\n880\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n3\n72\n2000-03-11\n\n\n1197\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n4\n77\n2000-03-18\n\n\n1514\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n5\n87\n2000-03-25\n\n\n1831\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n6\n94\n2000-04-01\n\n\n2148\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n7\n99\n2000-04-08\n\n\n287\n2000\n2Ge+her\nThe Hardest Part Of Breaking Up (Is Getting Ba...\n3:15\nR&B\n1\n91\n2000-09-02\n\n\n604\n2000\n2Ge+her\nThe Hardest Part Of Breaking Up (Is Getting Ba...\n3:15\nR&B\n2\n87\n2000-09-09\n\n\n921\n2000\n2Ge+her\nThe Hardest Part Of Breaking Up (Is Getting Ba...\n3:15\nR&B\n3\n92\n2000-09-16\n\n\n\n\n\n\n\n위와 같이 데이터를 깔끔하게 만들었습니다. 하지만 track, time, genre 열을 보시면 아주 많은 중복이 있는 것을 알 수 있습니다. 이러한 점을 해결 하는 방법은 다음 예제에서 다루어 보겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#하나의-표에-여러가지-타입",
    "href": "posts/ipynb/da_processing_tidy.html#하나의-표에-여러가지-타입",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.2 2. 하나의 표에 여러가지 타입",
    "text": "2.2 2. 하나의 표에 여러가지 타입\n위에서 다루었던 빌보드차트 데이터를 가지고 데이터가 반복되는 문제를 해결해 보겠습니다.\n문제점:\n\n다양한 관측 단위(observational units), 여기서는 song 과 rank가 하나의 표에 들어 있습니다. 이를 위해서는 표를 나눌 필요가 있습니다.\n\n먼저, 각각의 노래의 자세한 내용을 담고 있는 표를 만들어 보겠습니다. 그런다음 각각의 song_id를 부여합니다. 그런다음 순위 값을 가지고 있는 표를 song_id로 정리합니다.\n\nsongs_cols = [\"year\", \"artist.inverted\", \"track\", \"time\", \"genre\"]\nsongs = billboard[songs_cols].drop_duplicates()\nsongs = songs.reset_index(drop=True)\nsongs[\"song_id\"] = songs.index\nsongs.head(10)\n\n\n\n\n\n\n\nyear\nartist.inverted\ntrack\ntime\ngenre\nsong_id\n\n\n\n\n0\n2000\n2 Pac\nBaby Don't Cry (Keep Ya Head Up II)\n4:22\nRap\n0\n\n\n1\n2000\n2Ge+her\nThe Hardest Part Of Breaking Up (Is Getting Ba...\n3:15\nR&B\n1\n\n\n2\n2000\n3 Doors Down\nKryptonite\n3:53\nRock\n2\n\n\n3\n2000\n3 Doors Down\nLoser\n4:24\nRock\n3\n\n\n4\n2000\n504 Boyz\nWobble Wobble\n3:35\nRap\n4\n\n\n5\n2000\n98°\nGive Me Just One Night (Una Noche)\n3:24\nRock\n5\n\n\n6\n2000\nA*Teens\nDancing Queen\n3:44\nPop\n6\n\n\n7\n2000\nAaliyah\nI Don't Wanna\n4:15\nRock\n7\n\n\n8\n2000\nAaliyah\nTry Again\n4:03\nRock\n8\n\n\n9\n2000\nAdams, Yolanda\nOpen My Heart\n5:30\nGospel\n9\n\n\n\n\n\n\n\n위 와같은 새로운 표를 분리하고, 아래와 같이 순위를 포함하고 있는 표를 새로 만들어줍니다. &gt; 두개의 표를 연결하기 위해 song_id열을 만드는 것을 주의하세요\n\nranks = pd.merge(billboard, songs, on=[\"year\", \"artist.inverted\", \"track\", \"time\", \"genre\"])\nranks = ranks[[\"song_id\", \"date\", \"rank\"]]\nranks.head(10)\n\n\n\n\n\n\n\nsong_id\ndate\nrank\n\n\n\n\n0\n0\n2000-02-26\n87\n\n\n1\n0\n2000-03-04\n82\n\n\n2\n0\n2000-03-11\n72\n\n\n3\n0\n2000-03-18\n77\n\n\n4\n0\n2000-03-25\n87\n\n\n5\n0\n2000-04-01\n94\n\n\n6\n0\n2000-04-08\n99\n\n\n7\n1\n2000-09-02\n91\n\n\n8\n1\n2000-09-09\n87\n\n\n9\n1\n2000-09-16\n92"
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#다양한-변수가-하나의-열에-있는-경우-multiple-variables-stored-in-one-column",
    "href": "posts/ipynb/da_processing_tidy.html#다양한-변수가-하나의-열에-있는-경우-multiple-variables-stored-in-one-column",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.3 3. 다양한 변수가 하나의 열에 있는 경우 Multiple variables stored in one column",
    "text": "2.3 3. 다양한 변수가 하나의 열에 있는 경우 Multiple variables stored in one column\n\n2.3.1 Tubercolosis Example\nWHO(World Health Organization)에서 수집한 결핵환자의 기록입니다. 이 데이터에는 확인된 결핵환자의 국가, 연도, 나이, 성별이 포함되어 있습니다.\n문제점:\n\n몇개의 열(columns)에 다양한 변수가 포함되어 있습니다.(성별과 나이)\n값이 존재하지 않는 곳에 NaN과 0 이 혼재되어 있습니다.\n\n미리 알아둘 점:\n\n열의 이름에 적혀있는 “m”이나 “f”는 성별을 뜻합니다.\n열의 이름에 적혀있는 숫자는 나이대(“0-14”,“15-24”, “25-34”, “45-54”, “55-64”, “65”, “unknown”)를 나타냅니다.\n\n\ndf = pd.read_csv(\"./data/tb-raw.csv\")\ndf\n\n\n\n\n\n\n\ncountry\nyear\nm014\nm1524\nm2534\nm3544\nm4554\nm5564\nm65\nmu\nf014\n\n\n\n\n0\nAD\n2000\n0.0\n0.0\n1.0\n0.0\n0\n0\n0.0\nNaN\nNaN\n\n\n1\nAE\n2000\n2.0\n4.0\n4.0\n6.0\n5\n12\n10.0\nNaN\n3.0\n\n\n2\nAF\n2000\n52.0\n228.0\n183.0\n149.0\n129\n94\n80.0\nNaN\n93.0\n\n\n3\nAG\n2000\n0.0\n0.0\n0.0\n0.0\n0\n0\n1.0\nNaN\n1.0\n\n\n4\nAL\n2000\n2.0\n19.0\n21.0\n14.0\n24\n19\n16.0\nNaN\n3.0\n\n\n5\nAM\n2000\n2.0\n152.0\n130.0\n131.0\n63\n26\n21.0\nNaN\n1.0\n\n\n6\nAN\n2000\n0.0\n0.0\n1.0\n2.0\n0\n0\n0.0\nNaN\n0.0\n\n\n7\nAO\n2000\n186.0\n999.0\n1003.0\n912.0\n482\n312\n194.0\nNaN\n247.0\n\n\n8\nAR\n2000\n97.0\n278.0\n594.0\n402.0\n419\n368\n330.0\nNaN\n121.0\n\n\n9\nAS\n2000\nNaN\nNaN\nNaN\nNaN\n1\n1\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n이 데이터를 정리하기 위해서는 먼저 melt를 이용해 sex + age group 를 합쳐서 하나의 행으로 만들겠습니다. 그런 다음에 다시 행을 sex, age로 구분해서 정리하도록 하죠.\n\ndf = pd.melt(df, id_vars=[\"country\", \"year\"], value_name=\"cases\", var_name=\"sex_and_age\")\n\n# Extract Sex, Age lower bound and Age upper bound group\ntmp_df = df[\"sex_and_age\"].str.extract(\"(\\D)(\\d+)(\\d{2})\", expand=False)\n\n# Name columns\ntmp_df.columns = [\"sex\", \"age_lower\", \"age_upper\"]\n\n# Create `age`column based on `age_lower` and `age_upper`\ntmp_df[\"age\"] = tmp_df[\"age_lower\"] + \"-\" + tmp_df[\"age_upper\"]\n\n# Merge\ndf = pd.concat([df, tmp_df], axis=1)\n\n# Drop unnecessary columns and rows\ndf = df.drop([\"sex_and_age\", \"age_lower\", \"age_upper\"], axis=1)\ndf = df.dropna()\ndf = df.sort_values(ascending=True, by=[\"country\", \"year\", \"sex\", \"age\"])\ndf.head(10)\n\n\n\n\n\n\n\ncountry\nyear\ncases\nsex\nage\n\n\n\n\n0\nAD\n2000\n0.0\nm\n0-14\n\n\n10\nAD\n2000\n0.0\nm\n15-24\n\n\n20\nAD\n2000\n1.0\nm\n25-34\n\n\n30\nAD\n2000\n0.0\nm\n35-44\n\n\n40\nAD\n2000\n0.0\nm\n45-54\n\n\n50\nAD\n2000\n0.0\nm\n55-64\n\n\n81\nAE\n2000\n3.0\nf\n0-14\n\n\n1\nAE\n2000\n2.0\nm\n0-14\n\n\n11\nAE\n2000\n4.0\nm\n15-24\n\n\n21\nAE\n2000\n4.0\nm\n25-34\n\n\n\n\n\n\n\n이것이 정리된 결과 입니다."
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#변수가-행과-열에rows-and-columns-모두-포함되어-있는-경우",
    "href": "posts/ipynb/da_processing_tidy.html#변수가-행과-열에rows-and-columns-모두-포함되어-있는-경우",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.4 4. 변수가 행과 열에(rows and columns) 모두 포함되어 있는 경우",
    "text": "2.4 4. 변수가 행과 열에(rows and columns) 모두 포함되어 있는 경우\n\n2.4.1 Global Historical Climatology Network Dataset\n이것은 2010년도 멕시코 기상청(MX17004)에서 5개월 동안 측정한 기상 데이터입니다.\n\ndf = pd.read_csv(\"./data/weather-raw.csv\")\n\n문제점:\n\n변수들이 행(tmin, tmax) 과 열(days)에 존재합니다.\n\n깔끔한 데이터를 만들기 위해 melt기능을 사용해 day_raw를 각각의 열로 만들겠습니다.\n\ndf = pd.melt(df, id_vars=[\"id\", \"year\", \"month\", \"element\"], var_name=\"day_raw\")\ndf.head(10)\n\n\n\n\n\n\n\nid\nyear\nmonth\nelement\nday_raw\nvalue\n\n\n\n\n0\nMX17004\n2010\n1\ntmax\nd1\nNaN\n\n\n1\nMX17004\n2010\n1\ntmin\nd1\nNaN\n\n\n2\nMX17004\n2010\n2\ntmax\nd1\nNaN\n\n\n3\nMX17004\n2010\n2\ntmin\nd1\nNaN\n\n\n4\nMX17004\n2010\n3\ntmax\nd1\nNaN\n\n\n5\nMX17004\n2010\n3\ntmin\nd1\nNaN\n\n\n6\nMX17004\n2010\n4\ntmax\nd1\nNaN\n\n\n7\nMX17004\n2010\n4\ntmin\nd1\nNaN\n\n\n8\nMX17004\n2010\n5\ntmax\nd1\nNaN\n\n\n9\nMX17004\n2010\n5\ntmin\nd1\nNaN\n\n\n\n\n\n\n\n그럼에도 아직 불필요한 것들이 보이는 군요. 좀 더 깔끔한 데이터를 만들기 위해 tmin, tmax를 각각의 열로 만들겠습니다. 그리고 날짜 정보들을 합쳐서 date로 통합하겠습니다.\n\n# Extracting day\ndf[\"day\"] = df[\"day_raw\"].str.extract(\"d(\\d+)\", expand=False)\ndf[\"id\"] = \"MX17004\"\n\n# To numeric values\ndf[[\"year\", \"month\", \"day\"]] = df[[\"year\", \"month\", \"day\"]].apply(\n    lambda x: pd.to_numeric(x, errors=\"ignore\")\n)\n\n\n# Creating a date from the different columns\ndef create_date_from_year_month_day(row):\n    return datetime.datetime(year=row[\"year\"], month=int(row[\"month\"]), day=row[\"day\"])\n\n\ndf[\"date\"] = df.apply(lambda row: create_date_from_year_month_day(row), axis=1)\ndf = df.drop([\"year\", \"month\", \"day\", \"day_raw\"], axis=1)\ndf = df.dropna()\n\n# Unmelting column \"element\"\ndf = df.pivot_table(index=[\"id\", \"date\"], columns=\"element\", values=\"value\")\ndf.reset_index(drop=False, inplace=True)\ndf\n\n\n\n\n\n\nelement\nid\ndate\ntmax\ntmin\n\n\n\n\n0\nMX17004\n2010-02-02\n27.3\n14.4\n\n\n1\nMX17004\n2010-02-03\n24.1\n14.4\n\n\n2\nMX17004\n2010-03-05\n32.1\n14.2\n\n\n\n\n\n\n\n충분히 깔끔한 모양새가 되었습니다."
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#하나의-관측-단위observational-units가-여러-파일로-나누어져-있는-경우",
    "href": "posts/ipynb/da_processing_tidy.html#하나의-관측-단위observational-units가-여러-파일로-나누어져-있는-경우",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.5 5. 하나의 관측 단위(observational units)가 여러 파일로 나누어져 있는 경우",
    "text": "2.5 5. 하나의 관측 단위(observational units)가 여러 파일로 나누어져 있는 경우\n\n2.5.1 Baby Names in Illinois\n2014, 2015년도 미국 일리노이 주(Illinois)의 신생아의 (남자)이름을 수집한 데이터 입니다.\n문제점:\n\n여러 표와 파일에 데이터가 흩어져 있다.\n연도(Year)”가 파일 이름에 적혀져 있다.\n\n서로 다른 파일에 데이터가 흩어져 있어 조금 복잡한 과정이 필요합니다. 먼저 아래의 코드로 파일 리스트를 만들고 거기에서 연도 값을 뽑아냅니다. 그런 다음 각각의 파일에서 표를 만들어내고 마지막으로 concat기능으로 사용해 하나의 표로 합치겠습니다.\n\ndef extract_year(string):\n    match = re.match(\".+(\\d{4})\", string)\n    if match is not None:\n        return match.group(1)\n\n\npath = \"./data\"\nallFiles = glob.glob(path + \"/201*-baby-names-illinois.csv\")\nframe = pd.DataFrame()\ndf_list = []\nfor file_ in allFiles:\n    df = pd.read_csv(file_, index_col=None, header=0)\n    df.columns = map(str.lower, df.columns)\n    df[\"year\"] = extract_year(file_)\n    df_list.append(df)\n\ndf = pd.concat(df_list)\ndf.head(5)\n\n\n\n\n\n\n\nrank\nname\nfrequency\nsex\nyear\n\n\n\n\n0\n1\nNoah\n837\nMale\n2014\n\n\n1\n2\nAlexander\n747\nMale\n2014\n\n\n2\n3\nWilliam\n687\nMale\n2014\n\n\n3\n4\nMichael\n680\nMale\n2014\n\n\n4\n5\nLiam\n670\nMale\n2014"
  },
  {
    "objectID": "posts/ipynb/da_processing_tidy.html#마치며",
    "href": "posts/ipynb/da_processing_tidy.html#마치며",
    "title": "깔끔하게 데이터 정리하기",
    "section": "2.6 마치며",
    "text": "2.6 마치며\n이 글에서 가장 중점으로 둔것은 파이썬으로 지저분한 데이터를 깔끔하게 만드는 것이 었습니다. 그걸을 위해 Wickham의 논문에서 사용된 데이터를 살펴 보았죠. 깔끔한 데이터(Tidy data)의 최고의 장점은 시각화(Visualization)이 쉽다는 것에 있습니다. 그것은 다음에 다루어 보도록 하겠습니다.\n앞으로는 Tidy data를 고려해서 데이터를 수집하도록 하세요. 모두의 시간은 소중하니까요."
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html",
    "href": "posts/ipynb/bio_biotite.html",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "",
    "text": "생명과학 연구는 방대한 데이터 분석과 복잡한 계산을 요구합니다. 특히 유전체, 단백질체, 전사체 데이터 등 생물학적 데이터의 폭발적인 증가로 인해, 프로그래밍을 활용한 효율적인 데이터 처리 및 분석은 필수적인 역량이 되었습니다. 이러한 어려움을 극복하고 연구 효율성을 높이기 위해 파이썬 기반의 강력한 생물정보학 라이브러리인 Biotite와 Biopython을 활용하는 것은 매우 효과적인 방법입니다. 이 두 라이브러리의 주요 기능과 함께 실제 연구에 유용한 코드 스니펫을 알아보겠습니다."
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#biopython",
    "href": "posts/ipynb/bio_biotite.html#biopython",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "1.1 Biopython",
    "text": "1.1 Biopython\nBiopython은 생물학적 서열을 다루고 분석하는 데 특화된 파이썬 라이브러리입니다. FASTA, GenBank, PDB 등 다양한 생물학적 데이터 포맷을 파싱하고, 서열 정렬, 계통 발생 분석, 단백질 구조 분석 등 광범위한 기능을 제공합니다. Biopython은 오랜 역사를 가지고 있으며, 방대한 사용자 커뮤니티와 잘 정리된 문서 덕분에 초보자부터 전문가까지 쉽게 접근할 수 있다는 장점이 있습니다."
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#biotite",
    "href": "posts/ipynb/bio_biotite.html#biotite",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "1.2 Biotite",
    "text": "1.2 Biotite\nBiotite는 생물정보학 분야에서 자주 사용되는 다양한 도구와 기능을 제공하는 포괄적인 파이썬 패키지입니다. 주요 특징은 다음과 같습니다.\n\n다양한 서열 데이터 분석: DNA, RNA, 단백질 서열을 읽고 쓰고 조작하는 것은 물론, 서열 정렬, 모티프 검색, 계통 발생 분석 등 고급 분석 기능까지 제공합니다.\n분자 3D 구조 탐색 및 시각화: 단백질, 핵산 등의 분자 구조 데이터를 로드하고 분석하며, 시각화 도구와의 연동을 통해 3차원 구조를 효과적으로 탐색할 수 있도록 지원합니다.\n주요 생물학 데이터베이스 접근: NCBI Entrez, UniProt 등 주요 생물학 데이터베이스에 프로그래밍 방식으로 접근하여 필요한 정보를 손쉽게 다운로드하고 활용할 수 있습니다.\n외부 생물정보학 소프트웨어 통합: Autodock, BLAST, Clustal Omega와 같은 널리 사용되는 생물정보학 소프트웨어를 Biotite 환경 내에서 직접 실행하고 결과를 분석할 수 있도록 통합 기능을 제공하여 워크플로우를 간소화합니다."
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#pixi-패키지-관리자로-설치하기",
    "href": "posts/ipynb/bio_biotite.html#pixi-패키지-관리자로-설치하기",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "1.3 pixi 패키지 관리자로 설치하기",
    "text": "1.3 pixi 패키지 관리자로 설치하기\nBiotite와 Biopython은 pip를 통해서도 설치할 수 있지만, pixi는 좀 더 편리한 의존성 관리 기능을 제공합니다. pixi 패키지 관리자를 통해 매우 간단하게 처리할 수 있습니다.\npixi add biopython\npixi add biotite\n\n1.3.1 추가로 필요한 도구 설치하기\nBiotite, Biopython과 함께 사용하면 연구 효율성을 더욱 높일 수 있는 유용한 외부 도구들을 설치합니다.\n\n1.3.1.1 Clustal-Omega: 다중 서열 정렬 도구\nClustal-Omega는 다중 서열 정렬을 수행하는 강력한 명령줄 프로그램입니다. 운영체제별 설치 방법이 다르지만, pixi를 사용하면 다음과 같이 간단하게 설치할 수 있습니다.\npixi project channel add bioconda # 바이오콘다 채널이 필요\npixi add clustalo\n\n\n1.3.1.2 AbNumber: 항체 서열 분석 라이브러리\nAbNumber는 항체 서열 분석을 위한 파이썬 라이브러리로, 넘버링, 가변 영역 식별 등 다양한 기능을 제공합니다. pixi로 간편하게 설치할 수 있습니다.\npixi add abnumber\n\n\n\n1.3.2 흔히 발생하는 오류와 해결 방법\nBiotite를 처음 사용하거나 환경을 업데이트하는 과정에서 다음과 같은 ValueError가 발생할 수 있습니다.\nValueError: numpy.ufunc size changed, may indicate binary incompatibility.\nValueError: numpy.ndarray size changed, may indicate binary incompatibility.\n이 오류는 Biotite가 현재 시스템에 설치된 NumPy 버전과 호환되지 않게 빌드되었을 가능성이 높다는 것을 의미합니다. 일반적으로 Biotite가 이미 설치된 상태에서 NumPy를 업데이트했을 때 발생합니다.\n이 문제를 해결하는 가장 효과적인 방법은 NumPy와 Biotite를 모두 최신 버전으로 업데이트하는 것입니다. pixi를 사용하는 경우 다음 명령어를 실행하여 업데이트를 시도해 보세요.\npixi update numpy biotite\n이제 실제 코드 예시를 살펴보겠습니다. 다음 섹션에서는 Biopython과 Biotite를 활용하여 생물학적 데이터를 다루는 간단하면서도 유용한 코드 스니펫을 제공할 예정입니다.\n\n# 사용한 biotite 버전 확인\n\nimport Bio\nimport biotite\n\nprint(f\"Biotite 버전: {biotite.__version__}\")\nprint(f\"Biopython 버전: {Bio.__version__}\")\n\nBiotite 버전: 1.1.0\nBiopython 버전: 1.85"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#플라스미드-맵-그리기",
    "href": "posts/ipynb/bio_biotite.html#플라스미드-맵-그리기",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "2.1 플라스미드 맵 그리기",
    "text": "2.1 플라스미드 맵 그리기\n아래 코드는 AddGene에서 pET15 플라스미드의 GenBank 파일을 다운로드해서 플라스미드 맵을 그리는 방법입니다.\n\nimport biotite\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.genbank as gb\nimport matplotlib.pyplot as plt\n\n\ndef read_genbank_file(file_path):\n    \"\"\"GenBank 파일을 읽고 주석 정보를 추출합니다.\"\"\"\n    gb_file = gb.GenBankFile.read(file_path)\n    annotation = gb.get_annotation(\n        gb_file,\n        include_only=[\n            \"promoter\",\n            \"terminator\",\n            \"protein_bind\",\n            \"RBS\",\n            \"CDS\",\n            \"rep_origin\",\n            \"primer_bind\",\n        ],\n    )\n    _, seq_length, _, _, _, _ = gb.get_locus(gb_file)\n    return annotation, seq_length\n\n\ndef custom_feature_formatter(feature):\n    \"\"\"각 유전자 요소의 시각화 스타일을 Nord 테마의 Aurora 색상으로 정의합니다.\"\"\"\n    label = feature.qual.get(\"label\")\n    # Nord Aurora 색상 정의\n    nord_aurora = {\n        \"nord11\": \"#BF616A\",  # 빨간색\n        \"nord12\": \"#D08770\",  # 주황색\n        \"nord13\": \"#EBCB8B\",  # 노란색\n        \"nord14\": \"#A3BE8C\",  # 초록색\n        \"nord15\": \"#B48EAD\",  # 보라색\n    }\n    style_map = {\n        \"promoter\": (True, nord_aurora[\"nord14\"], \"black\", label),\n        \"terminator\": (True, nord_aurora[\"nord11\"], \"black\", label),\n        \"protein_bind\": (False, nord_aurora[\"nord15\"], \"black\", label),\n        \"RBS\": (False, nord_aurora[\"nord13\"], \"black\", label),\n        \"CDS\": (True, nord_aurora[\"nord12\"], \"black\", label),\n        \"rep_origin\": (True, nord_aurora[\"nord15\"], \"black\", label),\n        \"primer_bind\": (True, nord_aurora[\"nord14\"], \"black\", label),\n    }\n    return style_map.get(feature.key, (False, \"gray\", \"black\", label))\n\n\ndef plot_plasmid_map(annotation, seq_length, file_name, figsize):\n    \"\"\"플라스미드 맵을 그립니다.\"\"\"\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111, projection=\"polar\")\n    graphics.plot_plasmid_map(\n        ax,\n        annotation,\n        plasmid_size=seq_length,\n        label=file_name,\n        feature_formatter=custom_feature_formatter,\n        tick_step=500,\n    )\n    fig.tight_layout()\n    plt.show()\n\n\n# 메인 실행 부분\nfile_path = \"../data/input/pET15-MHL.gbk\"\nfile_name = \"pET15-MHL\"\n\n# GenBank 파일 읽기 및 주석 추출\nannotation, seq_length = read_genbank_file(file_path)\n\n# 플라스미드 맵 그리기\nplot_plasmid_map(annotation, seq_length, file_name, (5, 5))"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#abi-트레이스-시각화",
    "href": "posts/ipynb/bio_biotite.html#abi-트레이스-시각화",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "2.2 ABI 트레이스 시각화",
    "text": "2.2 ABI 트레이스 시각화\n아래 코드는 Sanger법을 통한 DNA sequencing 결과 중 ABI 트레이스 파일을 검사하기 위해 작성되었습니다. 이미 다른 소프트웨어들이 있지만 사용하기 어려운 경우 Biopython을 사용해 아래와 같이 간단하게 작업할 수 있습니다.\n\nfrom collections import defaultdict\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom Bio import SeqIO\n\n\ndef plot_abi_trace_subplots(\n    file_path,\n    channels=None,\n    start=None,\n    end=None,\n    points_per_subplot=1000,\n    figsize=(14, 10),\n    legend_labels=None,\n):\n    \"\"\"\n    ABI 파일의 trace 데이터를 읽어 subplot을 사용하여 여러 행으로 나누어 시각화하고,\n    하나의 범례를 상단 오른쪽에 표시합니다. 각 subplot의 x축 레이블은 제거되고,\n    제목은 왼쪽으로 정렬됩니다.\n\n    Args:\n        file_path (str): ABI 파일 경로.\n        channels (list, optional): 플롯할 채널 목록. None이면 모든 채널을 플롯합니다.\n        start (int, optional): 플롯할 데이터의 시작 인덱스.\n        end (int, optional): 플롯할 데이터의 끝 인덱스.\n        points_per_subplot (int, optional): 각 subplot에 표시할 데이터 포인트 수. 기본값은 1000입니다.\n        figsize (tuple, optional): 전체 플롯 크기 (가로, 세로). 기본값은 (14, 10)입니다.\n        legend_labels (list, optional): 범례에 표시할 레이블 목록. None이면 채널 이름을 사용합니다.\n    \"\"\"\n    record = SeqIO.read(file_path, \"abi\")\n\n    if channels is None:\n        channels = [\"DATA9\", \"DATA10\", \"DATA11\", \"DATA12\"]\n\n    trace = defaultdict(list)\n    for c in channels:\n        data = record.annotations[\"abif_raw\"][c]\n        if start is not None and end is not None:\n            data = data[start:end]\n        trace[c] = data\n\n    num_points = len(trace[channels[0]]) if trace and trace[channels[0]] else 0\n    num_subplots = int(np.ceil(num_points / points_per_subplot))\n\n    fig, axes = plt.subplots(\n        num_subplots, 1, figsize=figsize, sharex=False\n    )  # sharex를 False로 유지\n    if num_subplots == 1:\n        axes = [axes]  # axes가 하나의 subplot인 경우 리스트로 감싸줍니다.\n\n    pastel_colors = [\"#a8ddb5\", \"#fec44f\", \"#80b1d3\", \"#e78ac3\"]  # 파스텔 톤 색상\n    lines = []\n    labels = legend_labels if legend_labels else channels\n\n    for i, c in enumerate(channels):\n        color = pastel_colors[i % len(pastel_colors)]\n        (line,) = axes[0].plot([], [], color=color, label=labels[i])\n        lines.append(line)\n\n    for i, ax in enumerate(axes):\n        start_index = i * points_per_subplot\n        end_index = min((i + 1) * points_per_subplot, num_points)\n        x = np.arange(start_index, end_index)\n\n        for j, c in enumerate(channels):\n            data_segment = trace[c][start_index:end_index]\n            ax.plot(x, data_segment, color=pastel_colors[j % len(pastel_colors)])\n\n        ax.set_ylabel(\"Intensity\", fontsize=8)\n        ax.tick_params(axis=\"both\", which=\"major\", labelsize=6)\n        ax.tick_params(axis=\"both\", which=\"minor\", labelsize=4)\n        ax.set_xlabel(\"\")\n\n    fig.suptitle(f\"ABI Trace: {file_path}\", fontsize=10, x=0.28)  # 제목 왼쪽 정렬\n    fig.legend(\n        handles=lines,\n        labels=labels,\n        loc=\"upper right\",\n        bbox_to_anchor=(1.0, 1.0),\n        ncol=len(channels),\n    )\n    fig.tight_layout(rect=[0, 0.02, 1, 0.95])  # 제목과 범례 공간 확보 및 조정\n    plt.subplots_adjust(top=0.95)  # 제목 위치 추가 조정\n    plt.show()\n\n\n# 예시 사용:\nfile_path = \"../../input/250407_L234AL235A_R.ab1\"\n\n# 전체 데이터 플롯을 1000 포인트씩 끊어서 여러 subplot으로 표시하고, 하나의 범례를 상단 오른쪽에 배치\nplot_abi_trace_subplots(\n    file_path,\n    points_per_subplot=1000,\n    figsize=(7, 10),\n    legend_labels=[\"A\", \"C\", \"G\", \"T\"],\n)"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#코돈-사용-빈도를-통한-코돈-최적화",
    "href": "posts/ipynb/bio_biotite.html#코돈-사용-빈도를-통한-코돈-최적화",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "2.3 코돈 사용 빈도를 통한 코돈 최적화",
    "text": "2.3 코돈 사용 빈도를 통한 코돈 최적화\n아래 코드는 대장균 K-12 균주의 코돈 사용 빈도 표를 생성합니다. 코돈 사용 빈도는 아미노산을 코딩하는 코돈들의 빈도를 나타냅니다. 이 빈도는 해당 생물체 내 tRNA의 양을 반영할 것으로 예상됩니다. 코돈 사용 빈도는 종마다 다릅니다. 따라서 코돈 최적화 등의 응용에서는 관심 있는 생물체의 코돈 사용 빈도를 살펴보는 것이 중요합니다.\n코돈 사용 빈도 계산을 위해 주석이 달린 대장균 K-12 게놈을 살펴보겠습니다. 이 스크립트는 게놈에서 모든 코딩 서열(CDS)을 추출하고 이 서열들에서 각 코돈의 총 개수를 세어 냅니다. 그런 다음 각 코돈의 총 출현 횟수를 해당 아미노산의 총 출현 횟수로 나누어 상대 빈도를 계산합니다. 성능 향상을 위해 이 스크립트는 주로 기호 자체 대신 기호 코드를 사용합니다.\n먼저 NCBI Entrez 데이터베이스에서 게놈(Accession: U00096)을 GenBank 파일로 가져와 AnnotatedSequence로 파싱합니다. 그런 다음 나중에 총 코돈 빈도를 저장할 딕셔너리를 만듭니다. 앞서 언급했듯이, 이 스크립트는 기호 코드로 작동합니다. 따라서 딕셔너리의 각 코돈은 3개의 문자 대신 3개의 정수로 표현됩니다.\n코돈 사용 빈도 표는 목표 단백질의 DNA 서열을 코돈 사용 빈도에 맞춰 설계함으로써 재조합 단백질 발현을 최적화하는 데 사용될 수 있습니다. 이를 코돈 최적화라고 합니다. 하지만 코돈 최적화를 위한 다양한 알고리즘이 존재합니다. 간단히 하기 위해 이 예제에서는 각 아미노산에 대해 항상 가장 빈번하게 나타나는 코돈을 사용하는 방식을 채택합니다. 그런 다음 대장균 K-12에서의 발현을 위해 코돈 최적화된 DNA 서열을 출력해 보겠습니다.\n\nimport itertools\nimport tempfile\n\nimport biotite.database.entrez as entrez\nimport biotite.sequence as seq\nimport biotite.sequence.io.fasta as fasta\nimport biotite.sequence.io.genbank as gb\nimport numpy as np\n\n\ndef fetch_genome_data(genome_id):\n    \"\"\"NCBI에서 게놈 데이터를 가져옵니다.\"\"\"\n    try:\n        gb_file = gb.GenBankFile.read(\n            entrez.fetch(genome_id, tempfile.gettempdir(), \"gb\", \"nuccore\", \"gb\")\n        )\n        return gb.get_annotated_sequence(gb_file, include_only=[\"CDS\"])\n    except Exception as e:\n        raise RuntimeError(f\"게놈 데이터를 가져오는 중 오류 발생: {e}\")\n\n\ndef initialize_codon_counter(genome):\n    \"\"\"코돈 카운터를 초기화합니다.\"\"\"\n    return dict.fromkeys(itertools.product(*([range(len(genome.sequence.alphabet))] * 3)), 0)\n\n\ndef count_codons(genome, codon_counter):\n    \"\"\"CDS 영역에서 코돈을 카운트합니다.\"\"\"\n    for cds in genome.annotation:\n        cds_seq = genome[cds]\n        if len(cds_seq) % 3 != 0:\n            continue\n        for i in range(0, len(cds_seq), 3):\n            codon_code = tuple(cds_seq.code[i : i + 3])\n            codon_counter[codon_code] += 1\n    return codon_counter\n\n\ndef calculate_relative_frequencies(codon_counter, codon_table):\n    \"\"\"코돈의 상대 빈도를 계산합니다.\"\"\"\n    for amino_acid_code in range(20):\n        codon_codes_for_aa = codon_table[amino_acid_code]\n        total = sum(codon_counter[codon_code] for codon_code in codon_codes_for_aa)\n        if total == 0:\n            continue\n        for codon_code in codon_codes_for_aa:\n            codon_counter[codon_code] /= total\n    return codon_counter\n\n\ndef calculate_codon_usage(genome_id, codon_table_id):\n    \"\"\"주어진 게놈에 대한 코돈 사용을 계산합니다.\"\"\"\n    genome = fetch_genome_data(genome_id)\n    codon_counter = initialize_codon_counter(genome)\n    codon_counter = count_codons(genome, codon_counter)\n    codon_table = seq.CodonTable.load(codon_table_id)\n    return calculate_relative_frequencies(codon_counter, codon_table)\n\n\ndef find_optimal_codons(codon_counter, codon_table):\n    \"\"\"각 아미노산에 대한 최적의 코돈을 찾습니다.\"\"\"\n    optimal_codons = {}\n    for amino_acid_code in range(20):\n        codon_codes_for_aa = codon_table[amino_acid_code]\n        optimal_codons[amino_acid_code] = max(\n            codon_codes_for_aa, key=lambda c: codon_counter.get(c, 0)\n        )\n    return optimal_codons\n\n\ndef optimize_codon_for_protein_string(\n    codon_counter, codon_table_id, protein_name, protein_sequence_str\n):\n    \"\"\"주어진 단백질 서열에 대해 코돈 사용을 최적화합니다.\"\"\"\n    codon_table = seq.CodonTable.load(codon_table_id)\n    optimal_codons = find_optimal_codons(codon_counter, codon_table)\n\n    protein_sequence = seq.ProteinSequence(protein_sequence_str)\n    dna_sequence = seq.NucleotideSequence()\n    dna_sequence.code = np.concatenate(\n        [optimal_codons[amino_acid_code] for amino_acid_code in protein_sequence.code]\n    )\n    dna_sequence += seq.NucleotideSequence(\"TAA\")\n\n    fasta_output = fasta.FastaFile()\n    fasta_name = f\"Codon_optimized_{protein_name}\"\n    fasta_output[fasta_name] = str(dna_sequence)\n    return fasta_output\n\n\ndef parse_fasta(fasta_string):\n    \"\"\"FASTA 문자열을 파싱합니다.\"\"\"\n    return [\n        (entry.split(\"\\n\")[0].strip(), \"\".join(entry.split(\"\\n\")[1:]).strip())\n        for entry in fasta_string.strip().split(\"&gt;\")[1:]\n    ]\n\n\ngenome_id = \"U00096\"\ncodon_table_id = 11\ncodon_counter = calculate_codon_usage(genome_id, codon_table_id)\n\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n\"\"\"\n\nfasta_entries = parse_fasta(fasta_string)\n\nfor protein_name, protein_sequence in fasta_entries:\n    optimized_sequence = optimize_codon_for_protein_string(\n        codon_counter, codon_table_id, protein_name, protein_sequence\n    )\n    print(optimized_sequence)\n\n&gt;Codon_optimized_CBK51939\nGATATTCAGATGACCCAGAGCCCGAGCAGCCTGAGCGCGAGCGTGGGCGATCGCGTGACCATTACCTGCCGCGCGAGCCA\nGGGCATTAGCAGCTGGCTGGCGTGGTATCAGCAGAAACCGGAAAAAGCGCCGAAAAGCCTGATTTATGCGGCGAGCAGCC\nTGCAGAGCGGCGTGCCGAGCCGCTTTAGCGGCAGCGGCAGCGGCACCGATTTTACCCTGACCATTAGCAGCCTGCAGCCG\nGAAGATTTTGCGACCTATTATTGCCAGCAGTATTATAGCTATCCGCGCACCTTTGGCCAGGGCACCAAAGTGGAAATTAA\nATAA\n&gt;Codon_optimized_7WSL_L\nGATATTCAGCTGACCCAGAGCCCGAGCTTTCTGAGCGCGTATGTGGGCGATCGCGTGACCATTACCTGCAAAGCGAGCCA\nGGATGTGGGCACCGCGGTGGCGTGGTATCAGCAGAAACCGGGCAAAGCGCCGAAACTGCTGATTTATTGGGCGAGCACCC\nTGCATACCGGCGTGCCGAGCCGCTTTAGCGGCAGCGGCAGCGGCACCGAATTTACCCTGACCATTAGCAGCCTGCAGCCG\nGAAGATTTTGCGACCTATTATTGCCAGCATTATAGCAGCTATCCGTGGACCTTTGGCCAGGGCACCAAACTGGAAATTAA\nATAA"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#왓슨-크릭-염기쌍-시각화",
    "href": "posts/ipynb/bio_biotite.html#왓슨-크릭-염기쌍-시각화",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "2.4 왓슨-크릭 염기쌍 시각화",
    "text": "2.4 왓슨-크릭 염기쌍 시각화\n제임스 왓슨과 프랜시스 크릭은 DNA 구조를 밝히는 과정에서 DNA 내의 염기들이 무작위로 쌍을 이루는 것이 아니라, 특정한 규칙에 따라 쌍을 이룬다는 것을 발견했습니다. 이 규칙을 왓슨-크릭 염기쌍 규칙이라고 하며, 다음과 같습니다.\n\n아데닌(Adenine, A)은 항상 티민(Thymine, T)과 두 개의 수소 결합을 통해 쌍을 이룹니다.\n구아닌(Guanine, G)은 항상 사이토신(Cytosine, C)과 세 개의 수소 결합을 통해 쌍을 이룹니다.\n\n아래 코드는 실제 DNA 3차 구조에서 가져온 아데닌-티민 염기쌍과 구아닌-사이토신 염기쌍을 시각적으로 보여줍니다. 이를 통해 우리는 다음과 같은 점들을 더 명확하게 이해할 수 있습니다.\n\n염기들의 공간적인 배열: 각 염기가 이중 나선 내에서 어떤 방향으로 놓여 있는지, 서로 어떻게 마주보고 있는지 등을 확인할 수 있습니다.\n수소 결합의 위치와 개수: 아데닌과 티민 사이의 두 개, 구아닌과 사이토신 사이의 세 개 수소 결합의 정확한 위치와 방향을 시각적으로 파악할 수 있습니다. 이 수소 결합들이 염기쌍을 안정화시키는 중요한 역할을 한다는 것을 직접적으로 이해할 수 있습니다.\n\n\nimport biotite.database.rcsb as rcsb\nimport biotite.structure as struc\nimport biotite.structure.graphics as graphics\nimport biotite.structure.io.pdbx as pdbx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# DNA 이중 나선 구조 데이터 가져오기\npdbx_file = pdbx.BinaryCIFFile.read(rcsb.fetch(\"1qxb\", \"bcif\"))\nstructure = pdbx.get_structure(pdbx_file, model=1, include_bonds=True)\nnucleotides = structure[struc.filter_nucleotides(structure)]\n\n# 아데닌-티민과 구아닌-시토신 염기쌍 선택\nbase_pairs = struc.base_pairs(nucleotides)\n\n# 구아닌-시토신 염기쌍 찾기\nfor i, j in base_pairs:\n    if (nucleotides.res_name[i], nucleotides.res_name[j]) == (\"DG\", \"DC\"):\n        guanine, cytosine = [\n            nucleotides[mask] for mask in struc.get_residue_masks(nucleotides, [i, j])\n        ]\n        break\n\n# 아데닌-티민 염기쌍 찾기\nfor i, j in base_pairs:\n    if (nucleotides.res_name[i], nucleotides.res_name[j]) == (\"DA\", \"DT\"):\n        adenine, thymine = [\n            nucleotides[mask] for mask in struc.get_residue_masks(nucleotides, [i, j])\n        ]\n        break\n\npairs = [(guanine, cytosine), (adenine, thymine)]\n\n# 그래프 설정\nfig = plt.figure(figsize=(5.0, 5.0))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# 염기 배열\nfor i, (purine, pyrimidine) in enumerate(pairs):\n    # 피리미딘 염기의 주요 원자 좌표 추출\n    n1, n3, c5, c6 = [\n        pyrimidine[pyrimidine.atom_name == name][0] for name in (\"N1\", \"N3\", \"C5\", \"C6\")\n    ]\n    # 피리미딘 N3-C6 축을 x축에 정렬\n    purine, pyrimidine = [\n        struc.align_vectors(base, n3.coord - c6.coord, np.array([1, 0, 0]))\n        for base in (purine, pyrimidine)\n    ]\n    # 좌표 업데이트\n    n1, n3, c4, c5 = [\n        pyrimidine[pyrimidine.atom_name == name][0] for name in (\"N1\", \"N3\", \"C4\", \"C5\")\n    ]\n    # 피리미딘 염기 평면 법선 벡터를 z축에 정렬하고 염기 간 거리 설정\n    purine, pyrimidine = [\n        struc.align_vectors(\n            base,\n            np.cross(n3.coord - n1.coord, c5.coord - n1.coord),\n            np.array([0, 0, 1]),\n            origin_position=struc.centroid(purine + pyrimidine),\n            target_position=np.array([0, 10 * i, 0]),  # 10 Å 간격으로 염기쌍 분리\n        )\n        for base in (purine, pyrimidine)\n    ]\n    pairs[i] = (purine, pyrimidine)\n\n# 염기쌍 그리기\natoms = pairs[0][0] + pairs[0][1] + pairs[1][0] + pairs[1][1]\n# 원소별 색상 지정\ncolors = np.zeros((atoms.array_length(), 3))\ncolors[atoms.element == \"H\"] = (0.9, 0.9, 0.9)  # 밝은 회색 (파스텔 톤)\ncolors[atoms.element == \"C\"] = (0.7, 0.7, 0.7)  # 연한 회색 (파스텔 톤)\ncolors[atoms.element == \"N\"] = (0.6, 0.6, 1.0)  # 연한 파란색 (파스텔 톤)\ncolors[atoms.element == \"O\"] = (1.0, 0.6, 0.6)  # 연한 빨간색 (파스텔 톤)\ncolors[atoms.element == \"P\"] = (0.6, 1.0, 0.6)  # 연한 초록색 (파스텔 톤)\ngraphics.plot_atoms(ax, atoms, colors, line_width=3, background_color=\"white\", zoom=1.5)\n\n# 수소 결합 그리기\nfor purine, pyrimidine in pairs:\n    pair = purine + pyrimidine\n    bonds = struc.hbond(pair)\n    for donor, hydrogen, acceptor in bonds:\n        hydrogen_coord = pair.coord[hydrogen]\n        acceptor_coord = pair.coord[acceptor]\n        x, y, z = zip(hydrogen_coord, acceptor_coord)\n        ax.plot(x, y, z, linestyle=\":\", color=\"gold\", linewidth=2)\n\n# 무거운 원자 라벨링\nheavy_atoms = atoms[atoms.element != \"H\"]\nfor name, coord in zip(heavy_atoms.atom_name, heavy_atoms.coord):\n    coord = coord + [0.3, 0.15, 0]\n    ax.text(*coord, name, fontsize=\"6\")\n\n# 염기 라벨링\nfor pair in pairs:\n    for base in pair:\n        label = base.res_name[0][1]\n        ring_center = struc.centroid(\n            base[np.isin(base.atom_name, [\"N1\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\"])]\n        )\n        x, y, z = ring_center\n        ax.text(x, y, z, label, fontsize=20, fontweight=\"bold\", va=\"center\", ha=\"center\")\n\n# 그래프 표시\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#protpram-분석-결과",
    "href": "posts/ipynb/bio_biotite.html#protpram-분석-결과",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "3.1 Protpram 분석 결과",
    "text": "3.1 Protpram 분석 결과\nProtParam은 Expasy Proteomics Server에서 개발된 생물정보학 도구로 단백질의 아래와 같이 다양한 물리적 및 화학적 특성을 계산합니다.\n\n분자량\n\n이론적 등전점(pI)\n\n아미노산 조성\n\n소광 계수(Extinction coefficient)\n\n불안정성 지수(Instability index): 단백질 안정성을 예측하며, 값이 40 미만일 경우 안정적임을 나타냅니다.\n\n지방족 지수(Aliphatic index): 지방족 아미노산을 기반으로 열 안정성을 반영합니다.\n\n평균 소수성 지수(GRAVY): 소수성(양수 값) 또는 친수성(음수 값)을 측정합니다.\n\nBiopython을 사용해 protpram분석을 하고 데이터 프레임으로 만들어보겠습니다.\n\nfrom io import StringIO\n\nimport pandas as pd\nfrom Bio import SeqIO\nfrom Bio.SeqUtils.ProtParam import ProteinAnalysis\n\n\ndef calculate_molecular_formula(sequence):\n    \"\"\"주어진 서열의 분자식을 계산합니다.\"\"\"\n    amino_acid_atoms = {\n        \"A\": {\"C\": 3, \"H\": 7, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"R\": {\"C\": 6, \"H\": 14, \"N\": 4, \"O\": 2, \"S\": 0},\n        \"N\": {\"C\": 4, \"H\": 8, \"N\": 2, \"O\": 3, \"S\": 0},\n        \"D\": {\"C\": 4, \"H\": 7, \"N\": 1, \"O\": 4, \"S\": 0},\n        \"C\": {\"C\": 3, \"H\": 7, \"N\": 1, \"O\": 2, \"S\": 1},\n        \"Q\": {\"C\": 5, \"H\": 10, \"N\": 2, \"O\": 3, \"S\": 0},\n        \"E\": {\"C\": 5, \"H\": 9, \"N\": 1, \"O\": 4, \"S\": 0},\n        \"G\": {\"C\": 2, \"H\": 5, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"H\": {\"C\": 6, \"H\": 9, \"N\": 3, \"O\": 2, \"S\": 0},\n        \"I\": {\"C\": 6, \"H\": 13, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"L\": {\"C\": 6, \"H\": 13, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"K\": {\"C\": 6, \"H\": 14, \"N\": 2, \"O\": 2, \"S\": 0},\n        \"M\": {\"C\": 5, \"H\": 11, \"N\": 1, \"O\": 2, \"S\": 1},\n        \"F\": {\"C\": 9, \"H\": 11, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"P\": {\"C\": 5, \"H\": 9, \"N\": 1, \"O\": 2, \"S\": 0},\n        \"S\": {\"C\": 3, \"H\": 7, \"N\": 1, \"O\": 3, \"S\": 0},\n        \"T\": {\"C\": 4, \"H\": 9, \"N\": 1, \"O\": 3, \"S\": 0},\n        \"W\": {\"C\": 11, \"H\": 12, \"N\": 2, \"O\": 2, \"S\": 0},\n        \"Y\": {\"C\": 9, \"H\": 11, \"N\": 1, \"O\": 3, \"S\": 0},\n        \"V\": {\"C\": 5, \"H\": 11, \"N\": 1, \"O\": 2, \"S\": 0},\n    }\n\n    protein_analysis = ProteinAnalysis(sequence)\n    amino_acid_counts = protein_analysis.count_amino_acids()\n\n    carbon_total = 0\n    hydrogen_total = 0\n    oxygen_total = 0\n    nitrogen_total = 0\n    sulfur_total = 0\n    peptide_bonds = 0\n\n    for amino_acid, count in amino_acid_counts.items():\n        if amino_acid in amino_acid_atoms:\n            atoms = amino_acid_atoms[amino_acid]\n            peptide_bonds += count\n            carbon_total += count * atoms[\"C\"]\n            hydrogen_total += count * atoms[\"H\"]\n            oxygen_total += count * atoms[\"O\"]\n            nitrogen_total += count * atoms[\"N\"]\n            sulfur_total += count * atoms[\"S\"]\n\n    peptide_bonds -= 1\n    hydrogen_total -= peptide_bonds * 2\n    oxygen_total -= peptide_bonds\n\n    molecular_formula = (\n        f\"C{carbon_total}H{hydrogen_total}N{nitrogen_total}O{oxygen_total}S{sulfur_total}\"\n    )\n    total_atoms = carbon_total + hydrogen_total + nitrogen_total + oxygen_total + sulfur_total\n    return molecular_formula, total_atoms\n\n\ndef analyze_protein_sequence(fasta_string):\n    \"\"\"FASTA 형식의 단백질 서열 문자열을 분석하고 pandas DataFrame으로 반환합니다.\"\"\"\n\n    fasta_records = SeqIO.parse(StringIO(fasta_string.strip()), \"fasta\")\n    results = []\n\n    for record in fasta_records:\n        protein_sequence = str(record.seq)\n        protein_analysis = ProteinAnalysis(protein_sequence)\n        molecular_weight = protein_analysis.molecular_weight()\n        protein_id = record.id\n        total_amino_acids = len(protein_sequence)\n\n        molecular_formula, total_atoms = calculate_molecular_formula(protein_sequence)\n        extinction_coefficients = protein_analysis.molar_extinction_coefficient()\n\n        results.append(\n            {\n                \"Name\": protein_id,\n                \"Molecular Weight (Dalton)\": molecular_weight,\n                \"Total Amino Acids\": total_amino_acids,\n                \"Chemical Formula\": molecular_formula,\n                \"Total Atoms\": total_atoms,\n                \"Extinction Coefficient (Reduced)\": extinction_coefficients[0],\n                \"Extinction Coefficient (Non-Reduced)\": extinction_coefficients[1],\n                \"Reduced Abs 0.1% (g/L)\": extinction_coefficients[0] / molecular_weight,\n                \"Non-Reduced Abs 0.1% (g/L)\": extinction_coefficients[1] / molecular_weight,\n                \"Theoretical pI\": protein_analysis.isoelectric_point(),\n                \"Aromaticity (%)\": protein_analysis.aromaticity() * 100,\n                \"GRAVY\": protein_analysis.gravy(),\n                \"Instability Index\": protein_analysis.instability_index(),\n            }\n        )\n\n    return pd.DataFrame(results)\n\n\n# Example Usage\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\ndf = analyze_protein_sequence(fasta_string)\ndf\n\n\n\n\n\n\n\n\nName\nMolecular Weight (Dalton)\nTotal Amino Acids\nChemical Formula\nTotal Atoms\nExtinction Coefficient (Reduced)\nExtinction Coefficient (Non-Reduced)\nReduced Abs 0.1% (g/L)\nNon-Reduced Abs 0.1% (g/L)\nTheoretical pI\nAromaticity (%)\nGRAVY\nInstability Index\n\n\n\n\n0\nCBK51939\n11708.8783\n107\nC519H796N136O167S3\n1621\n21430\n21555\n1.830235\n1.840911\n8.620213\n12.149533\n-0.419626\n55.086916\n\n\n1\n7WSL_L\n11795.0749\n107\nC537H806N134O162S2\n1641\n26930\n27055\n2.283156\n2.293754\n7.955350\n14.018692\n-0.276636\n38.553271\n\n\n2\n8AS0_C\n11575.7706\n107\nC513H793N133O166S3\n1608\n14440\n14565\n1.247433\n1.258232\n7.952062\n11.214953\n-0.305607\n58.362617\n\n\n3\n7CGW_B\n11778.9694\n107\nC526H798N136O166S3\n1629\n15930\n16055\n1.352410\n1.363022\n5.517384\n12.149533\n-0.338318\n40.328972\n\n\n4\n5JXE_C\n11997.3292\n111\nC538H832N140O167S2\n1679\n15930\n16055\n1.327796\n1.338215\n6.997187\n10.810811\n-0.189189\n42.244144\n\n\n5\n5B8C_A\n11997.3292\n111\nC538H832N140O167S2\n1679\n15930\n16055\n1.327796\n1.338215\n6.997187\n10.810811\n-0.189189\n42.244144\n\n\n\n\n\n\n\n\nfrom io import StringIO\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom Bio import SeqIO\nfrom Bio.SeqUtils.ProtParam import ProteinAnalysis\n\n\ndef plot_protein_charge_vs_ph(fasta_string, figsize=(3, 3)):\n    \"\"\"FASTA 형식의 단백질 서열 문자열에서 각 단백질의 pH에 따른 전하 변화를 그래프로 표시합니다.\n    netcharge가 0이 되는 x축 값을 annotation으로 추가합니다.\n    \"\"\"\n\n    fasta_records = SeqIO.parse(StringIO(fasta_string.strip()), \"fasta\")\n\n    for record in fasta_records:\n        protein_id = record.id\n        protein_sequence = str(record.seq)\n        protein_analysis = ProteinAnalysis(protein_sequence)\n        isoelectric_point = protein_analysis.isoelectric_point()\n\n        x = np.linspace(3, 11, 1000)\n        y = protein_analysis.charge_at_pH(x)\n\n        fig, ax = plt.subplots(figsize=figsize)  # 그래프 크기 조정\n\n        ax.plot(x, y)\n        ax.axhline(y=0, color=\"k\", linestyle=\"--\", linewidth=1)\n        ax.axvline(isoelectric_point, color=\"k\", linestyle=\"--\", linewidth=1)\n\n        ax.set_xlabel(\"Buffer pH\", size=10)\n        ax.set_ylabel(\"Net charge\", size=10)\n        ax.set_title(f\"Net charge prediction of {protein_id}\", size=12)\n\n        # netcharge가 0이 되는 x축 값 (등전점)에 대한 annotation 추가\n        ax.annotate(\n            f\"pI: {isoelectric_point:.2f}\",\n            xy=(isoelectric_point, 0),\n            xytext=(isoelectric_point + 0.5, 0.6),  # 텍스트 위치 조정\n            fontsize=10,\n        )\n\n        plt.tight_layout()  # 그래프 요소들이 겹치지 않게 자동 조정\n        plt.show()\n\n\n# Example Usage\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n\"\"\"\n\nplot_protein_charge_vs_ph(fasta_string, figsize=(3, 3))"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#화학적-변형-가능-위치potential-sites-of-chemical-modification-예측",
    "href": "posts/ipynb/bio_biotite.html#화학적-변형-가능-위치potential-sites-of-chemical-modification-예측",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "3.2 화학적 변형 가능 위치(Potential sites of chemical modification) 예측",
    "text": "3.2 화학적 변형 가능 위치(Potential sites of chemical modification) 예측\n이 섹션에서는 순수 서열 분석을 기반으로 단백질에 일어나는 화학적 변형 위치를 예측해보겠습니다. 대부분의 단백질은 합성 과정에서 당화(glycosylation)라는 과정을 거칩니다. 단백질 당화 패턴은 약물의 반감기, 안정성, 안전성, 그리고 약효에 큰 영향을 미치는 것으로 알려져 있습니다.\n\n단백질의 당화는 크게 O-결합 및 N-결합 글라이칸의 두 가지가 있으며 O-결합 당화는 산소 원자를 매개로 올리고당이 세린 또는 트레오닌 아미노산 잔기에 결합하는 과정이며, N-결합 당화는 질소 원자를 매개로 올리고당이 아스파라긴 아미노산 잔기에 결합하는 과정입니다.\n\n\n3.2.1 탈아미드화(deamidation) 가능 위치\n아스파라긴(N) 및 글루타민(Q) 잔기는 서열 내에서 작은 측쇄를 가진 아미노산이 뒤따라 중간 펩타이드 그룹이 더 노출될 때 특히 탈아미드화되기 쉽습니다. 민감한 아미노산 뒤에 펩타이드 그룹이 공격받기 쉽도록 글리신과 같은 작고 유연한 잔기가 오는 경우 탈아미드화가 훨씬 빠르게 진행됩니다.\n검색 패턴: ASN/GLN-ALA/GLY/SER/THR\n\n\n3.2.2 O-결합 글리코실화 가능 위치\n세린 및 트레오닌 잔기의 O-연결 글리코실화는 서열 내에서 특히 2-1 및 +3 위치에 하나 이상의 프롤린 잔기가 근처에 존재하는 것에 민감한 것으로 알려져 있습니다.\n검색 패턴: PRO-SER/THR 검색 패턴: SER/THR-X-X-PRO\n\n\n3.2.3 N-결합 글리코실화 가능 위치\n기본적인 N-글리코실화 부위를 찾는 패턴은 다음과 같습니다.\n검색 패턴: ASN-X-SER/THR (X에서 프롤린 제외)\n\n주의 사항: PTM은 서열 외에도 단백질의 3차원 구조 주변 환경 등 다양한 요인의 영향을 받습니다. 따라서, 정규 표현식만으로는 가능성을 100% 정확하게 예측할 수 없습니다. 따라서 추가적인 실험적 검증을 통해 예측 결과를 확인하는 것이 좋습니다.\n\n\nimport re\nfrom io import StringIO\n\nimport pandas as pd\nfrom Bio import SeqIO\n\n\ndef find_modification_sites(fasta_string):\n    \"\"\"FASTA 형식의 단백질 서열 문자열에서 변형 부위를 찾아 DataFrame으로 반환합니다.\"\"\"\n\n    fasta_records = SeqIO.parse(StringIO(fasta_string.strip()), \"fasta\")\n    results = []\n\n    for record in fasta_records:\n        protein_id = record.id\n        protein_sequence = str(record.seq)\n\n        # 탈아미드화 가능 위치 찾기\n        deamidation_pattern = \"(N|Q)(A|G|S|T)\"\n        deamidation_matches = list(re.finditer(deamidation_pattern, protein_sequence))\n        deamidation_sites = [f\"{i.start() + 1}-{i.group()}-{i.end()}\" for i in deamidation_matches]\n\n        # O-연결 글리코실화 가능 위치 (PRO-SER/THR) 찾기\n        o_glycosylation_pattern1 = \"P(S|T)\"\n        o_glycosylation_matches1 = list(re.finditer(o_glycosylation_pattern1, protein_sequence))\n        o_glycosylation_sites1 = [\n            f\"{i.start() + 1}-{i.group()}-{i.end()}\" for i in o_glycosylation_matches1\n        ]\n\n        # O-연결 글리코실화 가능 위치 (SER/THR-X-X-PRO) 찾기\n        o_glycosylation_pattern2 = \"(S|T)[A-Z]{2}P\"\n        o_glycosylation_matches2 = list(re.finditer(o_glycosylation_pattern2, protein_sequence))\n        o_glycosylation_sites2 = [\n            f\"{i.start() + 1}-{i.group()}-{i.end()}\" for i in o_glycosylation_matches2\n        ]\n\n        # N-연결 글리코실화 가능 위치 찾기\n        N_glycosylation_pattern = \"N[^P][ST]\"\n        N_glycosylation_matches = list(re.finditer(N_glycosylation_pattern, protein_sequence))\n        N_glycosylation_sites = [\n            f\"{i.start() + 1}-{i.group()}-{i.end()}\" for i in N_glycosylation_matches\n        ]\n\n        results.append(\n            {\n                \"Protein ID\": protein_id,\n                \"Deamidation Sites\": \", \".join(deamidation_sites) if deamidation_sites else \"None\",\n                \"O-Glycosylation Sites (PRO-SER/THR)\": \", \".join(o_glycosylation_sites1)\n                if o_glycosylation_sites1\n                else \"None\",\n                \"O-Glycosylation Sites (SER/THR-X-X-PRO)\": \", \".join(o_glycosylation_sites2)\n                if o_glycosylation_sites2\n                else \"None\",\n                \"N-Glycosylation Sites (ASN-X-SER/THR)\": \", \".join(N_glycosylation_sites)\n                if N_glycosylation_sites\n                else \"None\",\n            }\n        )\n\n    return pd.DataFrame(results)\n\n\n# Example Usage\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQNSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\ndf = find_modification_sites(fasta_string)\ndf\n\n\n\n\n\n\n\n\nProtein ID\nDeamidation Sites\nO-Glycosylation Sites (PRO-SER/THR)\nO-Glycosylation Sites (SER/THR-X-X-PRO)\nN-Glycosylation Sites (ASN-X-SER/THR)\n\n\n\n\n0\nCBK51939\n7-NS-8, 28-QG-29, 56-QS-57, 101-QG-102\n9-PS-10, 60-PS-61\n57-SGVP-60, 78-SLQP-81\nNone\n\n\n1\n7WSL_L\n6-QS-7, 100-QG-101\n8-PS-9, 59-PS-60\n5-TQSP-8, 56-TGVP-59, 77-SLQP-80, 92-SSYP-95\nNone\n\n\n2\n8AS0_C\n6-QS-7, 27-QS-28, 55-QS-56, 100-QG-101\n8-PS-9, 59-PS-60\n5-TQSP-8, 56-SGVP-59, 77-SLQP-80\nNone\n\n\n3\n7CGW_B\n6-QS-7, 79-QA-80, 90-QA-91, 100-QG-101\nNone\n5-TQSP-8, 56-TGVP-59\nNone\n\n\n4\n5JXE_C\n6-QS-7, 46-QA-47\nNone\n5-TQSP-8, 12-SLSP-15, 60-SGVP-63, 81-SLEP-84\nNone\n\n\n5\n5B8C_A\n6-QS-7, 46-QA-47\nNone\n5-TQSP-8, 12-SLSP-15, 60-SGVP-63, 81-SLEP-84\nNone"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#계통수-관련",
    "href": "posts/ipynb/bio_biotite.html#계통수-관련",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "3.3 계통수 관련",
    "text": "3.3 계통수 관련\n\n3.3.1 아미노산 유사도에 대한 계통수 그리기\n이 예제에서는 아미노산 유성을 나타내는 BLOSUM62 행렬의 정보를 통해 계통수를 시각화 합니다.\n\nimport biotite.sequence as seq\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.phylo as phylo\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef visualize_amino_acid_distances(substitution_matrix=None):\n    \"\"\"\n    아미노산 간의 거리를 계산하고 덴드로그램으로 시각화합니다.\n\n    Args:\n        substitution_matrix (align.SubstitutionMatrix, optional): 사용할 치환 행렬.\n            기본값은 BLOSUM62입니다.\n    \"\"\"\n\n    # 1. 치환 행렬 준비 (BLOSUM62 또는 사용자 지정)\n    if substitution_matrix is None:\n        matrix = align.SubstitutionMatrix.std_protein_matrix()\n        # 불명확한 기호나 정지 신호 제거\n        matrix = align.SubstitutionMatrix(\n            seq.Alphabet(matrix.get_alphabet1().get_symbols()[:-4]),\n            seq.Alphabet(matrix.get_alphabet2().get_symbols()[:-4]),\n            matrix.score_matrix()[:-4, :-4],\n        )\n    else:\n        matrix = substitution_matrix\n\n    similarities = matrix.score_matrix()  # 유사도 행렬\n\n    # 2. 거리 계산 함수 정의\n    def calculate_distance(similarity_matrix, i, j):\n        \"\"\"두 아미노산 간의 거리를 계산합니다.\"\"\"\n        max_similarity = (similarity_matrix[i, i] + similarity_matrix[j, j]) / 2\n        return max_similarity - similarity_matrix[i, j]\n\n    # 3. 거리 행렬 생성\n    num_amino_acids = similarities.shape[0]\n    distances = np.zeros((num_amino_acids, num_amino_acids))\n    for i in range(num_amino_acids):\n        for j in range(num_amino_acids):\n            distances[i, j] = calculate_distance(similarities, i, j)\n\n    # 4. UPGMA 알고리즘으로 계통수 생성\n    tree = phylo.upgma(distances)\n\n    # 5. 덴드로그램 시각화\n    fig, ax = plt.subplots(figsize=(7, 4))\n    amino_acid_labels = [\n        seq.ProteinSequence.convert_letter_1to3(letter).capitalize()\n        for letter in matrix.get_alphabet1()\n    ]\n    graphics.plot_dendrogram(ax, tree, orientation=\"top\", labels=amino_acid_labels)\n    ax.set_ylabel(\"Distance\")\n    ax.yaxis.grid(color=\"lightgray\")  # 그리드 추가\n    plt.show()\n\n\n# 아미노산 거리 시각화 (기본 BLOSUM62 사용)\nvisualize_amino_acid_distances()\n\n\n\n\n\n\n\n\n\n\n3.3.2 단백질간 계통수(Dendrogram) 그리기\n이 예제는 서로 다른 단백질들 서열로 간단한 계통수를 그립니다. 계통수를 그리는 알고리즘으로는 UPGMA을 사용합니다.\n\nimport io\n\nimport biotite.application.clustalo as clustalo\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport biotite.sequence.phylo as phylo\nimport matplotlib.pyplot as plt\n\n\ndef build_and_plot_phylogenetic_tree(fasta_string, title=\"Sequence deviation\", figsize=(5, 5)):\n    \"\"\"\n    주어진 FASTA 문자열로부터 계통수를 생성하고 시각화합니다.\n\n    Args:\n        fasta_string (str): FASTA 형식의 서열 문자열.\n        title (str, optional): 플롯 제목. 기본값은 \"Sequence deviation\".\n    \"\"\"\n\n    # FASTA 문자열을 시퀀스 딕셔너리로 변환\n    fasta_file = io.StringIO(fasta_string)\n    fasta_sequences = fasta.FastaFile.read(fasta_file)\n    sequences_dict = fasta.get_sequences(fasta_sequences)\n\n    # 다중 서열 정렬 (MSA) 생성\n    alignment = clustalo.ClustalOmegaApp.align(list(sequences_dict.values()))\n\n    # 서열 동일성 기반의 거리 행렬 생성\n    distances = 1 - align.get_pairwise_sequence_identity(alignment, mode=\"shortest\")\n\n    # UPGMA 알고리즘을 사용하여 계통수 생성\n    tree = phylo.upgma(distances)\n\n    # 계통수 플롯\n    fig, ax = plt.subplots(1, 1, figsize=figsize)\n    graphics.plot_dendrogram(\n        ax,\n        tree,\n        orientation=\"left\",\n        labels=list(sequences_dict.keys()),\n        show_distance=False,\n        linewidth=2,\n    )\n\n    ax.grid(False)\n    ax.set_xticks([])\n    ax.set_title(title)\n    plt.show()\n\n\n# FASTA 문자열\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\n# 함수 호출\nbuild_and_plot_phylogenetic_tree(fasta_string, title=\"Sequence deviation of LC\", figsize=(2, 4))\n\n\n\n\n\n\n\n\n\n\n3.3.3 단백질 패밀리간의 계통수\n이 예제에서는 다양한 G-단백질 연결 수용체(GPCR)의 진화를 나타내는 비뿌리 계통수를 그립니다. GPCR의 UniProt ID와 유전자 이름은 해당 키워드를 통해 얻고 관련된 서열을 다운로드해 정렬합니다. 다중 서열 정렬에서 쌍별 서열 유사성을 기반으로 이웃-결합(neighbor-joining) 방법을 사용하여 계통수를 생성합니다. 마지막으로 NetworkX 패키지의 그래프 기능을 활용해 시각화합니다.\n\nimport re\n\nimport biotite.application.clustalo as clustalo\nimport biotite.database.uniprot as uniprot\nimport biotite.sequence as seq\nimport biotite.sequence.align as align\nimport biotite.sequence.io.fasta as fasta\nimport biotite.sequence.phylo as phylo\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n# 인간 GPCR을 연구합니다\nSPECIES = \"Human\"\n\n# UniProt 데이터베이스에서 인간 GPCR 단백질 검색\nquery = (\n    uniprot.SimpleQuery(\"reviewed\", \"true\")\n    & uniprot.SimpleQuery(\"organism_name\", \"Homo sapiens\")\n    & uniprot.SimpleQuery(\"keyword\", \"KW-0491\")  # MHC II 키워드 ID\n    # uniprot.SimpleQuery(\"protein_name\", \"prion proteins\")\n)\nids = uniprot.search(query)\n\n# 시퀀스 파일 다운로드 및 시퀀스 읽기\ngenes = []\nsequences = []\ngene_name_pattern = (\n    \"(?&lt;=GN=)[0-9A-Za-z]+\"  # FASTA 헤더에서 유전자 이름을 추출하기 위한 정규표현식 패턴\n)\nfor file in uniprot.fetch(ids, \"fasta\"):\n    fasta_file = fasta.FastaFile.read(file)\n    for header, seq_str in fasta_file.items():\n        genes.append(re.search(gene_name_pattern, header).group(0))\n        sequences.append(seq.ProteinSequence(seq_str))\n\n# Clustal Omega를 사용하여 다중 서열 정렬 생성\nalignment = clustalo.ClustalOmegaApp.align(sequences)\n\n# 트리 계산에 필요한 거리 측정: 두 시퀀스에서 동일하지 않은 아미노산의 비율\ndistances = 1 - align.get_pairwise_sequence_identity(alignment, mode=\"shortest\")\n# 이웃 결합 방법을 통해 트리 생성\ntree = phylo.neighbor_joining(distances)\n# NetworkX 그래프로 변환 (그래프 시각화를 위해 간선 방향은 불필요)\ngraph = tree.as_graph().to_undirected()\n\n# 그래프 시각화\nfig = plt.figure(figsize=(4, 4))\nax = fig.gca()\nax.axis(\"off\")\npos = nx.kamada_kawai_layout(graph)  # 그래프에서 노드 위치 계산\nnode_labels = dict(enumerate(ids))  # 노드에 ID를 이름으로 할당\nnx.draw_networkx_edges(graph, pos, ax=ax)\nnx.draw_networkx_labels(\n    graph,\n    pos,\n    ax=ax,\n    labels=node_labels,\n    font_size=8,\n    bbox={\"pad\": 0, \"color\": \"white\"},  # 가독성을 위해 라벨 뒤에 흰색 배경 추가\n)\nfig.tight_layout()\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#단백질-서열-정렬",
    "href": "posts/ipynb/bio_biotite.html#단백질-서열-정렬",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "3.4 단백질 서열 정렬",
    "text": "3.4 단백질 서열 정렬\nClustal Omega를 사용하여 서열 정렬을 수행하고 시각화합니다.\n\nimport io\n\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport matplotlib.pyplot as plt\nfrom biotite.application.clustalo import ClustalOmegaApp\n\n\ndef align_and_visualize_sequences(fasta_string, figsize=(8, 4)):\n    \"\"\"\n    주어진 FASTA 형식의 문자열로부터 서열을 정렬하고 시각화합니다.\n\n    Args:\n        fasta_string (str): FASTA 형식의 서열 문자열.\n    \"\"\"\n    # 문자열을 파일 객체로 변환\n    fasta_file = io.StringIO(fasta_string)\n\n    # FastaFile 객체 생성\n    fasta_sequences = fasta.FastaFile.read(fasta_file)\n\n    # 시퀀스 가져오기\n    sequences_dict = fasta.get_sequences(fasta_sequences)\n\n    # 딕셔너리 값들의 리스트로 변환\n    sequences_list = list(sequences_dict.values())\n\n    # 서열 개수에 따라 정렬 방법 선택\n    if len(sequences_list) &lt; 3:\n        # pairwise alignment\n        alignment = align.align_global_gaps(sequences_list[0], sequences_list[1])\n        alignments = align.Alignment(sequences_list, alignment.trace)\n        order = [0, 1]\n\n    else:\n        # ClustalOmega 실행\n        app = ClustalOmegaApp(sequences_list)\n        app.start()\n        app.join()\n        alignments = app.get_alignment()\n        order = app.get_alignment_order()\n\n    # 시각화\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111)\n\n    # 시퀀스 이름 리스트 생성\n    sequence_names = list(sequences_dict.keys())\n    # 정렬 순서에 맞게 시퀀스 이름 재정렬\n    ordered_names = [sequence_names[i] for i in order]\n\n    graphics.plot_alignment_type_based(\n        ax,\n        alignments[:, order.tolist()],\n        labels=ordered_names,  # 시퀀스 이름을 레이블로 사용\n        show_numbers=True,\n        color_scheme=\"flower\",\n    )\n    fig.tight_layout()\n    plt.show()\n\n\n# 예시 FASTA 문자열\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\n# 함수 호출\nalign_and_visualize_sequences(fasta_string, figsize=(8, 4))\n\n\n\n\n\n\n\n\n\n3.4.1 서열이 다른 부분만 강조하기\n\nimport io\n\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport matplotlib.pyplot as plt\nfrom biotite.application.clustalo import ClustalOmegaApp\nfrom matplotlib.colors import LinearSegmentedColormap\n\n\ndef visualize_sequence_alignment(fasta_string, annotations=None, figsize=(8, 4)):\n    \"\"\"\n    주어진 FASTA 형식의 문자열로부터 서열을 정렬하고 시각화합니다.\n    서열이 2개인 경우와 3개 이상인 경우를 모두 처리합니다.\n\n    Args:\n        fasta_string (str): FASTA 형식의 서열 문자열.\n        annotations (list, optional): 시각화에 추가할 주석 목록.\n            각 주석은 (x_position, y_position, symbol, color) 튜플로 표현됩니다.\n    \"\"\"\n\n    # FASTA 문자열을 파일 객체로 변환하고 시퀀스 가져오기\n    fasta_file = io.StringIO(fasta_string)\n    fasta_sequences = fasta.FastaFile.read(fasta_file)\n    sequences_dict = fasta.get_sequences(fasta_sequences)\n    sequences_list = list(sequences_dict.values())\n    sequence_names = list(sequences_dict.keys())\n\n    # 서열 개수에 따라 정렬 방법 선택\n    if len(sequences_list) == 2:\n        # 두 개의 서열인 경우 ungapped alignment\n        matrix = align.SubstitutionMatrix.std_protein_matrix()\n        alignment = align.align_ungapped(sequences_list[0], sequences_list[1], matrix=matrix)\n        alignments = align.Alignment(sequences_list[:2], alignment.trace)\n        order = [0, 1]\n    else:\n        # 세 개 이상의 서열인 경우 ClustalOmega 사용\n        app = ClustalOmegaApp(sequences_list)\n        app.start()\n        app.join()\n        alignments = app.get_alignment()\n        order = app.get_alignment_order()\n\n    # 유사도 기반의 색상 맵 생성 (낮은 유사도는 빨간색, 높은 유사도는 흰색)\n    cmap = LinearSegmentedColormap.from_list(\"custom\", [(1.0, 0.3, 0.3), (1.0, 1.0, 1.0)])\n\n    # 주석 추가 함수\n    def add_annotation(ax, position, sequence_index, symbol=\"*\", color=\"grey\"):\n        y_pos = 1 - (sequence_index * 0.2)  # 수직 위치 조절\n        ax.text(\n            position,\n            y_pos,\n            symbol,\n            color=color,\n            ha=\"center\",\n            va=\"center\",\n            fontweight=\"bold\",\n        )\n\n    # 시각화\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111)\n\n    graphics.plot_alignment_similarity_based(\n        ax,\n        alignments,\n        matrix=align.SubstitutionMatrix.std_protein_matrix(),\n        symbols_per_line=50,\n        labels=[sequence_names[i] for i in order],  # 정렬 순서에 맞게 레이블 설정\n        show_numbers=True,\n        cmap=cmap,\n        symbol_size=8,\n        show_line_position=True,\n    )\n\n    # 주석 추가\n    if annotations:\n        for pos, seq_idx, sym, col in annotations:\n            add_annotation(ax, pos, seq_idx, sym, col)\n\n    fig.tight_layout()\n    plt.show()\n\n\n# FASTA 문자열\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\n# 함수 호출\nvisualize_sequence_alignment(fasta_string, figsize=(8, 4))\n\n\n\n\n\n\n\n\n\n\n3.4.2 돌연변이 서열만 표시하기\n\nfrom io import StringIO\n\nimport matplotlib.pyplot as plt\nfrom biotite.sequence import GeneralSequence\nfrom biotite.sequence.align import Alignment\nfrom biotite.sequence.alphabet import LetterAlphabet\nfrom biotite.sequence.graphics import plot_alignment_similarity_based\nfrom biotite.sequence.io.fasta import FastaFile\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\n\n# 사용자 정의 알파벳 생성 (기본 알파벳 + '.') - 전역 또는 함수 내에서 정의\nCUSTOM_ALPHABET: LetterAlphabet = LetterAlphabet(\"ACDEFGHIKLMNPQRSTVWY.\")\n\n\ndef parse_fasta(\n    fasta_string: str, custom_alphabet: LetterAlphabet\n) -&gt; tuple[list[GeneralSequence], list[str]]:\n    \"\"\"\n    FASTA 문자열을 파싱하여 GeneralSequence 객체 리스트와 헤더 리스트를 반환합니다.\n\n    Args:\n        fasta_string: FASTA 형식의 문자열.\n        custom_alphabet: 시퀀스에 사용할 LetterAlphabet 객체.\n\n    Returns:\n        GeneralSequence 객체의 리스트와 헤더 문자열의 리스트를 담은 튜플.\n    \"\"\"\n    fasta_io = StringIO(fasta_string)\n    fasta_file = FastaFile.read(fasta_io)\n    # fasta_file.values()는 시퀀스 문자열(str)을 반환\n    sequences: list[GeneralSequence] = [\n        GeneralSequence(custom_alphabet, seq) for seq in fasta_file.values()\n    ]\n    # fasta_file.keys()는 헤더 문자열(str)을 반환\n    labels: list[str] = list(fasta_file.keys())\n    return sequences, labels\n\n\ndef create_alignment(sequences: list[GeneralSequence]) -&gt; Alignment:\n    \"\"\"\n    GeneralSequence 객체 리스트를 기반으로 Alignment 객체를 생성합니다.\n\n    Args:\n        sequences: GeneralSequence 객체의 리스트.\n\n    Returns:\n        생성된 Alignment 객체.\n    \"\"\"\n    # seq.symbols는 시퀀스의 심볼 표현(보통 문자열과 유사)을 반환\n    trace = Alignment.trace_from_strings(\n        [str(seq) for seq in sequences]\n    )  # .symbols 대신 str() 사용 권장\n    return Alignment(sequences, trace)\n\n\ndef replace_matches_with_dot(\n    alignment: Alignment, custom_alphabet: LetterAlphabet, wt_index: int = 0\n) -&gt; list[GeneralSequence]:\n    \"\"\"\n    WT 서열과 동일한 위치의 문자를 '.'으로 변경한 새로운 GeneralSequence 리스트를 반환합니다.\n\n    Args:\n        alignment: 원본 Alignment 객체.\n        custom_alphabet: 변환된 시퀀스에 사용할 LetterAlphabet 객체.\n        wt_index: WT 서열의 인덱스 (기본값: 0).\n\n    Returns:\n        변환된 GeneralSequence 객체의 리스트.\n    \"\"\"\n    if not alignment.sequences:\n        return []  # 빈 얼라인먼트 처리\n\n    # alignment.sequences[wt_index]는 GeneralSequence 객체\n    # str()을 사용하여 문자열 표현 얻기\n    wt_sequence_str: str = str(alignment.sequences[wt_index])\n    modified_sequence_strs: list[str] = [wt_sequence_str]  # WT 서열은 변경 없이 문자열로 추가\n\n    # alignment.sequences[1:] 또한 GeneralSequence 객체 리스트\n    for current_seq in alignment.sequences[1:]:  # F402 오류 방지\n        modified_seq_chars: list[str] = []\n        # str() 안의 변수 이름도 'current_seq'로 변경\n        seq_str: str = str(current_seq)\n        for wt_char, mut_char in zip(wt_sequence_str, seq_str):\n            modified_seq_chars.append(\".\" if wt_char == mut_char else mut_char)\n        modified_sequence_strs.append(\"\".join(modified_seq_chars))\n\n    # 변환된 문자열 리스트로부터 GeneralSequence 객체 리스트 생성\n    modified_sequences: list[GeneralSequence] = [\n        GeneralSequence(custom_alphabet, seq_str) for seq_str in modified_sequence_strs\n    ]\n    return modified_sequences\n\n\ndef plot_alignment(\n    modified_alignment: Alignment,\n    labels: list[str],\n    figsize: tuple[float, float] = (8.0, 3.0),\n) -&gt; None:\n    \"\"\"\n    Alignment 객체를 기반으로 시각화를 수행합니다.\n\n    Args:\n        modified_alignment: 시각화할 Alignment 객체.\n        labels: 각 시퀀스의 라벨 리스트.\n        figsize: 그래프의 크기 (너비, 높이) 튜플 (기본값: (8.0, 3.0)).\n    \"\"\"\n    # plt.subplots()는 Figure와 Axes(또는 Axes 배열) 객체를 반환\n    fig: Figure\n    ax: Axes\n    fig, ax = plt.subplots(figsize=figsize)\n    fig.patch.set_facecolor(\"white\")  # Figure 배경색 설정\n    ax.patch.set_facecolor(\"white\")  # Axes 배경색 설정\n\n    plot_alignment_similarity_based(\n        axes=ax,  # Axes 객체 전달\n        alignment=modified_alignment,  # Alignment 객체 전달\n        symbols_per_line=50,\n        show_numbers=True,\n        labels=labels,  # 문자열 리스트 전달\n        label_size=10,\n        color_symbols=True,\n        color=\"black\",  # 색상 이름(str) 전달\n    )\n\n    plt.tight_layout()\n    plt.show()\n\n\ndef run_alignment_pipeline(fasta_string: str, figsize: tuple[float, float] = (8.0, 3.0)) -&gt; None:\n    \"\"\"\n    전체 정렬 및 시각화 파이프라인을 실행합니다.\n\n    Args:\n        fasta_string: FASTA 형식의 문자열.\n        figsize: 플롯의 크기 (너비, 높이) 튜플 (기본값: (8.0, 3.0)).\n    \"\"\"\n    # FASTA 파싱 및 Alignment 생성\n    sequences: list[GeneralSequence]\n    labels: list[str]\n    sequences, labels = parse_fasta(fasta_string, CUSTOM_ALPHABET)\n\n    if not sequences:\n        print(\"Error: No sequences found in the FASTA string.\")\n        return  # 시퀀스가 없으면 종료\n\n    original_alignment: Alignment = create_alignment(sequences)\n\n    # 서열 변환 실행 (첫 번째 서열이 WT)\n    modified_sequences: list[GeneralSequence] = replace_matches_with_dot(\n        original_alignment, custom_alphabet=CUSTOM_ALPHABET, wt_index=0\n    )\n\n    if not modified_sequences:\n        print(\"Error: Could not modify sequences.\")\n        return  # 변환 실패 시 종료\n\n    # 변환된 서열로 Alignment 재생성\n    # create_alignment 함수는 GeneralSequence 리스트를 받으므로 그대로 사용 가능\n    modified_alignment: Alignment = create_alignment(modified_sequences)\n\n    # 플롯 생성\n    plot_alignment(modified_alignment, labels, figsize)\n\n\n# FASTA 문자열 정의 (첫 번째 서열이 WT)\nfasta_string: str = \"\"\"\n&gt;WT\nEVQLLESGGGLVQPGGSLRLSCAASGFTFRSFGMSWVRQAPGKGPEWVSSISGSGSDTLYADSVKGRFTISRDNSKNTLYLQMNSLRPEDTAVYYCTIGGSLSRSSQGTLVTVSS\n&gt;F27K\nEVQLLESGGGLVQPGGSLRLSCAASGKTFRSFGMSWVRQAPGKGPEWVSSISGSGSDTLYADSVKGRFTISRDNSKNTLYLQMNSLRPEDTAVYYCTIGGSLSRSSQGTLVTVSS\n&gt;L59S\nEVQLLESGGGLVQPGGSLRLSCAASGFTFRSFGMSWVRQAPGKGPEWVSSISGSGSDTSYADSVKGRFTISRDNSKNTLYLQMNSLRPEDTAVYYCTIGGSLSRSSQGTLVTVSS\n&gt;I98A\nEVQLLESGGGLVQPGGSLRLSCAASGFTFRSFGMSWVRQAPGKGPEWVSSISGSGSDTLYADSVKGRFTISRDNSKNTLYLQMNSLRPEDTAVYYCTAGGSLSRSSQGTLVTVSS\n\"\"\"\n\nrun_alignment_pipeline(fasta_string, figsize=(7, 3))\n\n\n\n\n\n\n\n\n\n\n3.4.3 항체 CDR 영역 시각화\nAbNumber는 ANARCI(항원 수용체 번호 매기기 및 수용체 분류)를 사용하여 항체 번호 매기기와 정렬을 단순화하는 Python API입니다. 이는 번호 매기기, 정렬 및 인간화를 위한 도구를 제공함으로써 항체 연구 및 개발을 간소화합니다.\n\nimport pandas as pd\nfrom abnumber import Chain\n\n\ndef parse_fasta(fasta_string):\n    \"\"\"FASTA 문자열 파싱.\"\"\"\n    return [\n        (entry.split(\"\\n\")[0].strip(), \"\".join(entry.split(\"\\n\")[1:]).strip())\n        for entry in fasta_string.strip().split(\"&gt;\")[1:]\n    ]\n\n\ndef extract_cdr_data(chain_seq):\n    \"\"\"주어진 시퀀스에서 CDR 데이터 추출.\"\"\"\n    chain_imgt = Chain(chain_seq, scheme=\"imgt\", cdr_definition=\"imgt\", assign_germline=True)\n    chain_kabat = Chain(chain_seq, scheme=\"kabat\", cdr_definition=\"kabat\")\n\n    chain_type = (\n        \"Heavy\"\n        if chain_imgt.is_heavy_chain()\n        else \"Kappa_light\"\n        if chain_imgt.is_kappa_light_chain()\n        else \"Lambda_light\"\n        if chain_imgt.is_lambda_light_chain()\n        else \"None\"\n    )\n\n    return {\n        \"species\": chain_imgt.species,\n        \"chain\": chain_type,\n        \"germline\": chain_imgt.v_gene,\n        \"imgt_CDR1\": chain_imgt.cdr1_seq,\n        \"imgt_CDR2\": chain_imgt.cdr2_seq,\n        \"imgt_CDR3\": chain_imgt.cdr3_seq,\n        \"kabat_CDR1\": chain_kabat.cdr1_seq,\n        \"kabat_CDR2\": chain_kabat.cdr2_seq,\n        \"kabat_CDR3\": chain_kabat.cdr3_seq,\n        \"full_sequence\": chain_seq,\n    }\n\n\nfasta_string = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\nseq = parse_fasta(fasta_string)\ndata = [{\"id\": seq_id, **extract_cdr_data(chain_seq)} for seq_id, chain_seq in seq]\ndf = pd.DataFrame(data)\ndf.head()\n\n\n\n\n\n\n\n\nid\nspecies\nchain\ngermline\nimgt_CDR1\nimgt_CDR2\nimgt_CDR3\nkabat_CDR1\nkabat_CDR2\nkabat_CDR3\nfull_sequence\n\n\n\n\n0\nCBK51939\nhuman\nKappa_light\nIGKV1D-16*01\nQGISSW\nAAS\nQQYYSYPRT\nRASQGISSWLA\nAASSLQS\nQQYYSYPRT\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKS...\n\n\n1\n7WSL_L\nhuman\nKappa_light\nIGKV1-9*01\nQDVGTA\nWAS\nQHYSSYPWT\nKASQDVGTAVA\nWASTLHT\nQHYSSYPWT\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKL...\n\n\n2\n8AS0_C\nhuman\nKappa_light\nIGKV1-39*01\nQSISSY\nAAS\nQQDYGLPFT\nRASQSISSYLN\nAASSLQS\nQQDYGLPFT\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKL...\n\n\n3\n7CGW_B\nhuman\nKappa_light\nIGKV4-1*01\nESVSND\nYAF\nHQAYSSPYT\nKSSESVSNDVA\nYAFHRFT\nHQAYSSPYT\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKL...\n\n\n4\n5JXE_C\nhuman\nKappa_light\nIGKV3-11*01\nKGVSTSGYSY\nLAS\nQHSRDLPLT\nRASKGVSTSGYSYLH\nLASYLES\nQHSRDLPLT\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQ...\n\n\n\n\n\n\n\n\n\n3.4.4 CDR 표시한 단백질 서열 정렬 시각화\n\nimport io\n\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom biotite.application.clustalo import ClustalOmegaApp\nfrom matplotlib.colors import LinearSegmentedColormap\n\n\ndef create_similarity_colormap():\n    \"\"\"시각화에 사용할 컬러맵 생성\"\"\"\n    return LinearSegmentedColormap.from_list(\"similarity_cmap\", [(1.0, 0.3, 0.3), (1.0, 1.0, 1.0)])\n\n\ndef plot_sequence_features(ax, alignment, features, num_sequences, line_length, spacing):\n    \"\"\"서열 특징 정보를 시각화하는 도우미 함수\"\"\"\n    for row_index in range(1 + len(alignment) // line_length):\n        row_start = line_length * row_index\n        row_end = min(line_length * (row_index + 1), len(alignment))\n\n        seq_start = alignment.trace[row_start, 1]\n        seq_end = alignment.trace[row_end - 1, 1] + 1\n        base_y = (num_sequences + spacing) * row_index + num_sequences\n\n        for feat_name, (feat_start, feat_end) in features.items():\n            start = feat_start - 1\n            end = feat_end\n\n            if start &lt; seq_end and end &gt; seq_start:\n                x_start = np.clip(start - seq_start, 0, line_length)\n                x_end = np.clip(end - seq_start, 0, line_length)\n                x_center = (x_start + x_end) / 2\n\n                # 특징 표시 선 및 텍스트\n                ax.plot(\n                    [x_start, x_end],\n                    [base_y + 0.3] * 2,\n                    color=\"black\",\n                    linewidth=2,\n                    clip_on=False,\n                )\n                ax.text(\n                    x_center,\n                    base_y + 0.6,\n                    feat_name,\n                    fontsize=8,\n                    va=\"top\",\n                    ha=\"center\",\n                )\n\n\ndef perform_alignment(sequences, use_input_order):\n    \"\"\"서열 정렬 수행 함수\"\"\"\n    if len(sequences) == 2:\n        matrix = align.SubstitutionMatrix.std_protein_matrix()\n        alignments, _ = align.align_optimal(\n            sequences[0],\n            sequences[1],\n            matrix=matrix,\n            gap_penalty=-10,\n            terminal_penalty=False,\n        )\n        return alignments, [0, 1]\n    else:\n        app = ClustalOmegaApp(sequences)\n        app.start()\n        app.join()\n        return app.get_alignment(), app.get_alignment_order()\n\n\ndef visualize_alignment_with_features(\n    fasta_string: str,\n    sequence_features: dict[str, tuple[int, int]] | None = None,\n    use_input_sequence_order: bool = True,\n    figure_size: tuple[int, int] = (8, 4),\n    sequence_line_length: int = 40,\n    feature_spacing: int = 3,\n) -&gt; None:\n    \"\"\"\n    FASTA 서열 정렬 및 특징 시각화 함수\n\n    Parameters:\n    fasta_string: FASTA 형식의 서열 문자열\n    sequence_features: 첫 번째 서열의 특징 위치 정보 (시작, 끝)\n    use_input_sequence_order: 입력 순서 유지 여부\n    figure_size: 출력 이미지 크기 (가로, 세로)\n    sequence_line_length: 줄당 표시할 서열 길이\n    feature_spacing: 특징 표시 간격\n    \"\"\"\n\n    # FASTA 데이터 파싱\n    fasta_file = io.StringIO(fasta_string)\n    seq_dict = fasta.get_sequences(fasta.FastaFile.read(fasta_file))\n    sequences = list(seq_dict.values())\n    seq_ids = list(seq_dict.keys())\n\n    # 서열 정렬 수행\n    alignments, order = perform_alignment(sequences, use_input_sequence_order)\n    ordered_ids = [seq_ids[i] for i in order]\n\n    # 시각화 설정\n    fig, ax = plt.subplots(figsize=figure_size)\n    colormap = create_similarity_colormap()\n\n    # 정렬 결과 플롯\n    graphics.plot_alignment_similarity_based(\n        ax,\n        alignments,\n        matrix=align.SubstitutionMatrix.std_protein_matrix(),\n        symbols_per_line=sequence_line_length,\n        labels=ordered_ids,\n        show_numbers=True,\n        cmap=colormap,\n        label_size=9,\n        number_size=9,\n        symbol_size=7,\n        spacing=feature_spacing,\n    )\n\n    # 특징 정보 표시\n    if sequence_features:\n        plot_sequence_features(\n            ax,\n            alignments,\n            sequence_features,\n            len(sequences),\n            sequence_line_length,\n            feature_spacing,\n        )\n\n    plt.tight_layout()\n    plt.show()\n\n\n# 사용 예시\nfasta_sequence_data = \"\"\"\n&gt;CBK51939\nDIQMTQSPSSLSASVGDRVTITCRASQGISSWLAWYQQKPEKAPKSLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQYYSYPRTFGQGTKVEIK\n&gt;7WSL_L\nDIQLTQSPSFLSAYVGDRVTITCKASQDVGTAVAWYQQKPGKAPKLLIYWASTLHTGVPSRFSGSGSGTEFTLTISSLQPEDFATYYCQHYSSYPWTFGQGTKLEIK\n&gt;8AS0_C\nDIQMTQSPSSLSASVGDRVTITCRASQSISSYLNWYQQKPGKAPKLLIYAASSLQSGVPSRFSGSGSGTDFTLTISSLQPEDFATYYCQQDYGLPFTFGQGTKVEIK\n&gt;7CGW_B\nDIVMTQSPDSLAVSLGERATINCKSSESVSNDVAWYQQKPGQPPKLLINYAFHRFTGVPDRFSGSGYGTDFTLTISSLQAEDVAVYYCHQAYSSPYTFGQGTKLEIK\n&gt;5JXE_C\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n&gt;5B8C_A\nEIVLTQSPATLSLSPGERATLSCRASKGVSTSGYSYLHWYQQKPGQAPRLLIYLASYLESGVPARFSGSGSGTDFTLTISSLEPEDFAVYYCQHSRDLPLTFGGGTKVEIK\n\"\"\"\n\nfirst_sequence_features = {\n    \"CDR1\": (27, 35),\n    \"CDR2\": (50, 52),\n    \"CDR3\": (89, 98),\n}\n\nvisualize_alignment_with_features(\n    fasta_sequence_data,\n    sequence_features=first_sequence_features,\n    figure_size=(6, 4),\n    sequence_line_length=51,\n    feature_spacing=2,\n)\n\n\n\n\n\n\n\n\n\n\n3.4.5 CDR 서열 로고 시각화\nCDR 서열 로고는 항체 또는 T 세포 수용체의 상보성 결정 영역(CDR) 서열을 시각적으로 표현하는 데 사용됩니다.CDR 서열 로고는 다음과 같은 여러 가지 이점을 제공합니다.\n\n시각적 요약: 긴 CDR 서열의 핵심 특징과 다양성을 한눈에 파악할 수 있습니다.\n보존된 모티프 식별: 특정 위치에서 빈번하게 나타나는 아미노산 잔기를 강조하여 기능적으로 중요한 모티프를 식별하는 데 도움을 줍니다.\n서열 비교: 여러 CDR 서열 그룹의 로고를 비교하여 다양성 패턴과 보존된 영역의 차이를 시각적으로 확인할 수 있습니다.\n\n\nimport io\n\nimport biotite.application.clustalo as clustalo\nimport biotite.sequence as seq\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport matplotlib.pyplot as plt\nimport pandas as pd  # pandas 라이브러리 추가\n\n\ndef visualize_sequence_logo(fasta_string, title, figsize=(6, 3)):\n    \"\"\"\n    주어진 FASTA 문자열로부터 시퀀스 로고를 생성하고 시각화합니다.\n\n    Args:\n        fasta_string (str): FASTA 형식의 서열 문자열.\n    \"\"\"\n\n    # FASTA 문자열을 시퀀스 딕셔너리로 변환\n    fasta_file = io.StringIO(fasta_string)\n    fasta_sequences = fasta.FastaFile.read(fasta_file)\n    sequences_dict = fasta.get_sequences(fasta_sequences)\n\n    # 다중 서열 정렬 (MSA) 생성\n    alignment = clustalo.ClustalOmegaApp.align(list(sequences_dict.values()))\n\n    # 시퀀스 프로파일 생성\n    profile = seq.SequenceProfile.from_alignment(alignment)\n\n    # 시퀀스 로고 플롯\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111)\n    graphics.plot_sequence_logo(ax, profile, scheme=\"flower\")\n\n    # 플롯 설정\n    ax.set_title(title)\n    ax.set_xlabel(\"\")\n    ax.set_ylabel(\"Bits\")\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    fig.tight_layout()\n\n    plt.show()\n\n\ndef dataframe_to_fasta(df, id_col=\"id\", seq_col=\"kabat_CDR1\"):\n    \"\"\"데이터프레임을 FASTA 형식의 문자열로 변환합니다.\"\"\"\n    return \"\".join(f\"&gt;{row[id_col]}\\n{row[seq_col]}\\n\" for _, row in df.iterrows())\n\n\ncdr_regions = [\"kabat_CDR1\", \"kabat_CDR2\", \"kabat_CDR3\"]\n\nfor cdr in cdr_regions:\n    fasta_string = dataframe_to_fasta(df, seq_col=cdr)\n    visualize_sequence_logo(fasta_string, title=cdr, figsize=(5, 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4.6 단백질 서열에 에피토프 매핑 데이터 시각화\n펩타이드 어레이 실험을 통애 얻은 에피토프에 대한 정보를 단백질 서열에 시각화해봅니다. 이 예시에서는 스크리닝된 항원의 색상 코딩된 서열 정렬 표현을 사용하여 두 가지 에피토프 매핑 연구의 데이터를 사용하겠습니다. 스크리닝된 항원은 말라리아 원충(Plasmodium falciparum)의 병독성 인자인 VAR2CSA의 세포외 도메인에 걸쳐 있으며 FCR3 (1-2659번 잔기)와 NF54 (1-2652번 잔기)에 해당합니다.\n\nimport biotite.sequence as seq\nimport biotite.sequence.align as align\nimport biotite.sequence.graphics as graphics\nimport biotite.sequence.io.fasta as fasta\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n\ndef process_epitope_mapping(\n    array_seq_path,\n    sample1_file_path,\n    sample2_file_path,\n    pep_len=20,\n    score_res=20,\n    combine_method=\"max\",\n    threshold=0,\n    overlap_step=1,\n    label_size=8,\n    number_size=8,\n    symbol_size=4,\n    cbar_label_size=8,\n    cbar_tick_size=8,\n):\n    \"\"\"\n    에피토프 매핑 데이터를 처리하고 시각화합니다.\n\n    Args:\n        array_seq_path (str): Array_Seq.txt 파일 경로.\n        sample1_file_path (str): 첫 번째 샘플 에피토프 스캔 데이터 CSV 파일 경로.\n        sample2_file_path (str): 두 번째 샘플 에피토프 스캔 데이터 CSV 파일 경로.\n        pep_len (int, optional): 펩타이드 길이. 기본값은 20.\n        score_res (int, optional): 점수 잔기 위치. 기본값은 20.\n        combine_method (str, optional): 점수 결합 방식 (\"max\" 또는 \"mean\"). 기본값은 \"max\".\n        threshold (int, optional): 신호 점수에 대한 임계값. 기본값은 0.\n        overlap_step (int, optional): 중첩 펩타이드의 스텝 크기. 기본값은 1.\n        label_size (int, optional): 축 레이블 크기. 기본값은 8.\n        number_size (int, optional): 서열 번호 크기. 기본값은 8.\n        symbol_size (int, optional): 서열 글자 크기. 기본값은 4.\n        cbar_label_size (int, optional): 컬러바 레이블 크기. 기본값은 8.\n        cbar_tick_size (int, optional): 컬러바 눈금 크기. 기본값은 8.\n\n    Returns:\n        None: 결과를 시각적으로 표시합니다.\n    \"\"\"\n\n    # 에피토프 스캔 데이터 처리 함수\n    def read_scan(filename, peptide_length=20, score_residue=20):\n        \"\"\"파일에서 에피토프 스캔 데이터를 읽어와 처리합니다.\"\"\"\n        if not isinstance(peptide_length, int):\n            raise TypeError(\"peptide_length: 정수만 허용됩니다.\")\n        elif not isinstance(score_residue, int):\n            raise TypeError(\"score_residue: 정수만 허용됩니다.\")\n        elif peptide_length &lt; score_residue:\n            raise ValueError(\"score_residue는 peptide_length보다 클 수 없습니다.\")\n\n        s = (\n            (score_residue) - peptide_length - 1\n            if peptide_length != 20 or score_residue != 20\n            else -1\n        )\n\n        df = pd.read_csv(filename)\n        score_residues = df[\"Seq\"].str[s]\n        df[\"s_res\"] = score_residues\n        return df\n\n    # 복제 점수 결합 함수\n    def combine_scores(dataframe, combine=\"max\", flag_noisy=True):\n        \"\"\"복제된 점수를 결합하고 노이즈가 있는 데이터를 표시합니다.\"\"\"\n        df = dataframe.copy()\n        df[\"ave\"] = df[[\"r1\", \"r2\"]].mean(axis=1)\n        df[\"avedev\"] = ((df.r1 - df.ave).abs() + (df.r2 - df.ave).abs()) / 2\n        df[\"dev_ratio\"] = df.apply(lambda x: 0 if x.avedev == 0 else x.avedev / x.ave, axis=1)\n\n        if combine == \"max\":\n            df[\"comb_signal\"] = df.apply(\n                lambda x: max(x.r1, x.r2) if x.dev_ratio &gt;= 0.4 else x.ave, axis=1\n            )\n        elif combine == \"mean\":\n            df[\"comb_signal\"] = df.apply(lambda x: x.ave if x.dev_ratio &lt;= 0.4 else 0, axis=1)\n\n        if flag_noisy:\n            df[\"flag\"] = df.apply(lambda x: 0 if x.dev_ratio &lt;= 0.4 else 1, axis=1)\n        return df\n\n    # 데이터 변환 함수\n    def data_transform(dataframe, threshold=0):\n        \"\"\"데이터프레임의 신호 값을 변환합니다.\"\"\"\n        df = dataframe.copy()\n        t = threshold\n        df[\"cubic\"] = df.apply(lambda x: np.cbrt(max(0, x.comb_signal - t)), axis=1)\n        df[\"signal_plot\"] = df.apply(lambda x: x.cubic / df[\"cubic\"].max(), axis=1)\n        return df\n\n    # 갭 서열 생성 함수\n    def gapped_seq(dataframe, seq_trace, peptide_length, overlap_step=1):\n        \"\"\"정렬 추적과 연결하는 갭 서열을 생성합니다.\"\"\"\n        template = seq_trace\n        df = dataframe\n        _step = overlap_step\n        gapped = list(zip(df.s_res, df.signal_plot))\n        lk1 = df[\"s_res\"].values.tolist()\n        plen = peptide_length\n\n        x, b, c, p = 0, 0, 0, 0\n        for b in range(len(lk1)):\n            for a in template[x:]:\n                if c &lt; plen - 1:\n                    if a is None:\n                        gapped.insert(x, (template[x], 0))\n                        x += 1\n                    elif a != lk1[b]:\n                        gapped.insert(x, (template[x], 0))\n                        x += 1\n                        c += 1\n                    elif p == 0:\n                        gapped.insert(x, (template[x], 0))\n                        x += 1\n                        c += 1\n                    else:\n                        x += 1\n                        c += 1\n                        break\n                else:\n                    c = 0\n                    p += 1\n                    x += 1\n                    break\n\n        # 끝 부분의 갭 처리\n        if len(gapped) &lt; len(template) and template[len(gapped) + 1] is None:\n            gapped_tail = [(\"None\", 0)] * (len(template) - len(gapped))\n            gapped.extend(gapped_tail)\n\n        return gapped\n\n    # 신호 맵 생성 함수\n    def signal_map(gapped_seq1, gapped_seq2):\n        \"\"\"두 갭 서열에서 신호 점수의 매핑을 생성합니다.\"\"\"\n        if gapped_seq1 is None or gapped_seq2 is None:\n            return None\n        gapd_s1 = gapped_seq1\n        gapd_s2 = gapped_seq2\n        fl_score = np.zeros((len(gapd_s1), 2))\n\n        for v1 in range(len(gapd_s1)):\n            fl_score[v1, 0] = gapd_s1[v1][1]\n            fl_score[v1, 1] = gapd_s2[v1][1]\n\n        return fl_score\n\n    def draw_colorbar(\n        axes,\n        array1,\n        array2,\n        colormap,\n        orient=None,\n        title=None,\n        label_size=10,\n        tick_size=10,\n    ):\n        \"\"\"주어진 축에 컬러바를 그립니다.\"\"\"\n        df1 = array1\n        df2 = array2\n        cmp = colormap\n        ax = axes\n        orientation = orient\n        label = title\n\n        vmiA = df1[\"comb_signal\"].min() if \"comb_signal\" in df1 else 0\n        vmiB = df2[\"comb_signal\"].min() if \"comb_signal\" in df2 else 0\n        vmxA = df1[\"comb_signal\"].max() if \"comb_signal\" in df1 else 1\n        vmxB = df2[\"comb_signal\"].max() if \"comb_signal\" in df2 else 1\n\n        norm = mpl.colors.PowerNorm(gamma=0.33, vmin=min(vmiA, vmiB), vmax=max(vmxA, vmxB))\n\n        fig = mpl.pyplot.figure()\n        cbar = fig.colorbar(\n            mpl.cm.ScalarMappable(norm=norm, cmap=cmp),\n            cax=ax,\n            orientation=orientation,\n            label=label,\n        )\n        cbar.ax.tick_params(labelsize=tick_size)\n        cbar.ax.set_xlabel(cbar.ax.get_xlabel(), fontsize=label_size)\n        return cbar\n\n    # 1. 데이터 로드 및 전처리\n    sample1_scan = read_scan(sample1_file_path, pep_len, score_res)\n    sample2_scan = read_scan(sample2_file_path, pep_len, score_res)\n\n    # 2. 복제 점수 결합 및 노이즈 처리\n    dfa = (\n        combine_scores(sample1_scan, combine=combine_method, flag_noisy=True)\n        if sample1_scan is not None\n        else None\n    )\n    dfb = (\n        combine_scores(sample2_scan, combine=combine_method, flag_noisy=True)\n        if sample2_scan is not None\n        else None\n    )\n\n    # 3. 데이터 변환 (큐빅 지수 사용)\n    if dfa is not None:\n        dfa = data_transform(dfa, threshold=threshold)\n    if dfb is not None:\n        dfb = data_transform(dfb, threshold=threshold)\n\n    # 4. FASTA 파일 읽기 및 서열 정렬\n    fasta_file = fasta.FastaFile.read(array_seq_path)\n\n    # FCR3와 NF54 단백질 서열 파싱 (추출)\n    sequences = []\n    for sequence in fasta_file.values():\n        sequences.append(seq.ProteinSequence(sequence))\n\n    matrix = align.SubstitutionMatrix.std_protein_matrix()\n    alignments = []\n\n    for i in range(len(sequences)):\n        for j in range(i + 1, len(sequences)):\n            alignment = align.align_optimal(\n                sequences[i],\n                sequences[j],\n                matrix,\n                gap_penalty=(-10, -1),\n                terminal_penalty=False,\n            )\n            alignments.append(alignment[0])\n\n    # 5. 갭 서열 생성\n    trace_a = align.get_symbols(alignments[0])[0]\n    trace_b = align.get_symbols(alignments[0])[1]\n\n    gapd_s1 = (\n        gapped_seq(dfa, trace_a, pep_len, overlap_step)\n        if dfa is not None and trace_a is not None\n        else None\n    )\n    gapd_s2 = (\n        gapped_seq(dfb, trace_b, pep_len, overlap_step)\n        if dfb is not None and trace_b is not None\n        else None\n    )\n\n    # 6. 신호 맵 생성\n    score = signal_map(gapd_s1, gapd_s2) if gapd_s1 is not None and gapd_s2 is not None else None\n\n    # 7. 시각화\n    fig = plt.figure(figsize=(8, 12))\n    ax = fig.add_subplot(111)\n    if score is not None:\n        graphics.plot_alignment_array(\n            ax,\n            alignments[0],\n            fl_score=score,\n            labels=[\"Sample 1\", \"Sample 2\"],\n            show_numbers=True,\n            symbols_per_line=80,\n            show_line_position=True,\n            label_size=label_size,\n            number_size=number_size,\n            symbol_size=symbol_size,\n        )\n\n        ax2 = fig.add_axes([0.13, 0.07, 0.8, 0.01])\n        ax2.set_frame_on(False)\n\n        colormap = graphics.ArrayPlotter(ax2, score).get_cmap()\n\n        if dfa is not None and dfb is not None and colormap is not None:\n            cbar = draw_colorbar(\n                ax2,\n                dfa,\n                dfb,\n                colormap,\n                orient=\"horizontal\",\n                title=\"Fluorescence Intensity [AU]\",\n                label_size=cbar_label_size,\n                tick_size=cbar_tick_size,\n            )\n\n            labels = cbar.ax.get_xticklabels()\n            plt.setp(\n                labels,\n                rotation=45,\n                horizontalalignment=\"center\",\n                fontsize=cbar_tick_size,\n            )\n\n\n# 사용 예시\narray_seq_path = \"../../input/Array_Seq.txt\"\nsample1_file_path = \"../../input/FCR3_10ug.csv\"\nsample2_file_path = \"../../input/NF54_10ug.csv\"\n\nprocess_epitope_mapping(\n    array_seq_path,\n    sample1_file_path,\n    sample2_file_path,\n    label_size=8,\n    number_size=8,\n    symbol_size=6,\n    cbar_label_size=8,\n    cbar_tick_size=8,\n)\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;"
  },
  {
    "objectID": "posts/ipynb/bio_biotite.html#단백질-구조-분석-관련",
    "href": "posts/ipynb/bio_biotite.html#단백질-구조-분석-관련",
    "title": "파이썬을 사용한 각종 Bioinformatic 시각화 스니펫",
    "section": "3.5 단백질 구조 분석 관련",
    "text": "3.5 단백질 구조 분석 관련\n\n3.5.1 이차구조 시각화\n단백질 서열에 대한 이차 구조 예측은 s4pred에서 계산된 것입니다.\n\nimport biotite\nimport biotite.sequence as seq\nimport biotite.sequence.graphics as graphics\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom biotite.sequence import Annotation, Feature, Location\nfrom biotite.sequence.graphics import plot_feature_map\nfrom matplotlib.patches import Rectangle\n\n\n## 헬릭스 구조를 그리는 클래스\nclass HelixPlotter(graphics.FeaturePlotter):\n    def matches(self, feature):\n        return feature.key == \"SecStr\" and feature.qual.get(\"sec_str_type\") == \"helix\"\n\n    def draw(self, axes, feature, bbox, loc, style_param):\n        n_turns = np.ceil((loc.last - loc.first + 1) / 3.6)\n        x_val = np.linspace(0, n_turns * 2 * np.pi, 100)\n        y_val = (-0.4 * np.sin(x_val) + 1) / 2\n\n        x_val = x_val * bbox.width / (n_turns * 2 * np.pi) + bbox.x0\n        y_val = y_val * bbox.height + bbox.y0\n\n        background = Rectangle(bbox.p0, bbox.width, bbox.height, color=\"white\", linewidth=0)\n        axes.add_patch(background)\n        axes.plot(x_val, y_val, linewidth=3, color=\"#FF7979\")  # 부드러운 붉은색\n\n\n## 시트 구조를 그리는 클래스\nclass SheetPlotter(graphics.FeaturePlotter):\n    def __init__(self, head_width=0.8, tail_width=0.5):\n        self._head_width = head_width\n        self._tail_width = tail_width\n\n    def matches(self, feature):\n        return feature.key == \"SecStr\" and feature.qual.get(\"sec_str_type\") == \"sheet\"\n\n    def draw(self, axes, feature, bbox, loc, style_param):\n        x, y = bbox.x0, bbox.y0 + bbox.height / 2\n        dx, dy = bbox.width, 0\n\n        draw_head = not (loc.defect & seq.Location.Defect.MISS_RIGHT)\n\n        axes.add_patch(\n            biotite.AdaptiveFancyArrow(\n                x,\n                y,\n                dx,\n                dy,\n                self._tail_width * bbox.height,\n                self._head_width * bbox.height,\n                head_ratio=0.5,\n                draw_head=draw_head,\n                color=\"#FFB74D\",\n                linewidth=0,\n            )\n        )\n\n\n## 2차 구조를 시각화하는 함수\ndef visualize_secondary_structure(sse, first_id, seq_name):\n    def _add_sec_str(annotation, first, last, str_type):\n        if str_type in [\"a\", \"b\"]:\n            feature = Feature(\n                \"SecStr\",\n                [Location(first, last)],\n                {\"sec_str_type\": \"helix\" if str_type == \"a\" else \"sheet\"},\n            )\n            annotation.add_feature(feature)\n\n    annotation = Annotation()\n    curr_start = None\n    for i, curr_sse in enumerate(sse):\n        if curr_start is None:\n            curr_start = i\n        elif curr_sse != sse[i - 1]:\n            _add_sec_str(annotation, curr_start + first_id, i - 1 + first_id, sse[i - 1])\n            curr_start = i\n    _add_sec_str(annotation, curr_start + first_id, i + first_id, curr_sse)\n\n    # 서열 길이에 따라 피겨의 높이 계산\n    symbols_per_line = 100  # 줄당 서열의 수\n    num_lines = -(-len(sse) // symbols_per_line)  # 올림 나눗셈\n    fig_height = 1 + num_lines * 0.5  # 기본 높이 1에 줄 수에 따라 높이 추가\n\n    fig, ax = plt.subplots(figsize=(8.0, fig_height))\n    plot_feature_map(\n        ax,\n        annotation,\n        symbols_per_line=symbols_per_line,\n        loc_range=(first_id, first_id + len(sse)),\n        show_numbers=True,\n        show_line_position=True,\n        feature_plotters=[HelixPlotter(), SheetPlotter()],\n    )\n\n    # 서열 이름을 플롯의 제목으로 추가\n    plt.title(seq_name, fontsize=14)\n\n    fig.tight_layout()\n    plt.show()\n\n\n# 입력 문자열 파싱 및 2차 구조 시각화\ninput_string = \"\"\"\n&gt;AI_SYNTH_1\nMSEIQVRLNPDDGSKFEYTYTITTESELEKVLNELMDYIKKQGAKRVRISITARTKKEAEKFAAILIKVFAELGYNDINVTFDGDTVTVEGQLQGAKRVRISITARTKKEAEKFAAILIKVFAELGYNDINVTFDGDTVTVEGQLMSEIQVRLNPDDGSKFEYTYTITTESELEKVLNELMDYIKKNVTFDGDTVTVEGQLMSEIQVRLNPDDGSKFEYTYTITTESELEKVLNELMDYIKKQGAKRVRISITARTKKEAEKFAAILIKVFAELGYNDI\nCCCEEEEECCCCCCEEEEEEEECCHHHHHHHHHHHHHHHHHCCCCEEEEEEEECCHHHHHHHHHHHHHHHHHCCCCEEEEEEECCEEEEEEEECCCCEEEEEEEECCHHHHHHHHHHHHHHHHHCCCCEEEEEEECCEEEEEEEEEEEEEEEECCCCCCCEEEEEEECCHHHHHHHHHHHHHHHHHCCEECCCEEEEEEEEEEEEEEEECCCCCCEEEEEEEECCHHHHHHHHHHHHHHHHHCCCCEEEEEEEECCHHHHHHHHHHHHHHHHHCCCCCC\n&gt;AI_SYNTH_2\nGSMRQEKVLKSIEETVRKMDVTMETHRSGNEVKVVIKGLHESQQEQLKKDVEETSKKQGVETRIEFHGDTVTIVVREGSMRQEKVLKSIEETVRKMDVTMETHRSGNEVKVVIKGLHESQQEQLKKDVEETSKKQGVETRIEFHGDTVTIVVREGSMRQEKVLKSIEETVRKMDVTMETHRSGNEVKVVIKGLHESQQEQLKKDVEETSKKQGVETRIEFHGDTVTIVVRE\nCCCCHHHHHHHHHHHHHHCCCEEEEEECCCEEEEEEECCCHHHHHHHHHHHHHHHHHCCCEEEEEEECCEEEEEEECCCCCHHHHHHHHHHHHHHCCCEEEEEECCCEEEEEEECCCHHHHHHHHHHHHHHHHHCCCEEEEEEECCEEEEEEECCCCCHHHHHHHHHHHHHHCCCEEEEEECCCEEEEEEECCCHHHHHHHHHHHHHHHHHCCCCEEEEEECCEEEEEEEC\n&gt;AI_SYNTH_3\nGKSPTEVLLELIAEASGTTREEVKEKFLKELRKGKSPTEVLLELIAEASGTTKEEVKEKFLKELSFGKSPTEVLLELIAEASGTTKEEVKKKFWKELSLGKSPTEVLLELIAEASGTTREEVKEKFLKELRKGKSPTEVLLELIAEASGTTKEEVKEKFLKELSFGKSPTEVLLELIAEASGTTKEEVKKKFWKELSLGKSPTEVLLELIAEASGTTREEVKEKFLKELRKGKSPTEVLLELIAEASGTTKEEVKEKFLKELSFGKSPTEVLLELIAEASGTTKEEVKKKFWKELSL\nCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHHCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHCCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHCCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHHCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHCCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHCCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHHCCCCHHHHHHHHHHHHHCCCHHHHHHHHHHHHCCCCCHHHHHHHHHHHHCCCCHHHHHHHHHHHCCC\n\"\"\"\n\n# 입력 문자열에서 서열 정보 추출\nsequences = {}\nfor line in input_string.strip().split(\"\\n\"):\n    if line.startswith(\"&gt;\"):\n        current_seq = line[1:]\n        sequences[current_seq] = []\n    else:\n        sequences[current_seq].append(line)\n\n# DSSP 표기법을 ABC 표기법으로 변환\ndssp_to_abc = {\"H\": \"a\", \"E\": \"b\", \"C\": \"c\"}\n\n# 각 서열에 대해 2차 구조 시각화\nfor seq_name, seq_data in sequences.items():\n    sequence, sse = seq_data\n    sse = np.array([dssp_to_abc[e] for e in sse], dtype=\"U1\")\n    visualize_secondary_structure(sse, 1, seq_name)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.5.2 라마찬드란 플롯 (Ramachandran Plot)\n아래 코드는 스크립트는 라마찬드란 플롯을 생성합니다. 라마찬드란 플롯은 단백질 구조 분석에 사용되는 중요한 그래프입니다. 단백질을 구성하는 아미노산 잔기의 회전각(dihedral angle) 중 두 가지, 즉 파이(φ, phi) 각과 싸이(ψ, psi) 각의 가능한 조합을 시각적으로 나타냅니다.\n\n파이(φ) 각: 하나의 아미노산 잔기 내에서 질소 원자(N)와 알파 탄소 원자(Cα) 사이의 결합을 축으로 하는 회전각입니다. 이전 아미노산의 카르보닐 탄소(C’)와 현재 아미노산의 아미노 질소(N)로 정의됩니다.\n싸이(ψ) 각: 하나의 아미노산 잔기 내에서 알파 탄소 원자(Cα)와 카르보닐 탄소 원자(C’) 사이의 결합을 축으로 하는 회전각입니다. 현재 아미노산의 알파 탄소(Cα)와 카르보닐 탄소(C’) 그리고 다음 아미노산의 아미노 질소(N)로 정의됩니다.\n\n이 두 각도의 조합은 폴리펩타이드 사슬의 국소적인 형태, 즉 2차 구조에 큰 영향을 미칩니다. 라마찬드란 플롯은 이론적으로 가능한 파이-싸이 각도 조합 중에서 실제로 단백질 구조에서 관찰되는 각도 분포를 보여줍니다.\n\n3.5.2.1 플롯의 의미:\n\n플롯 상의 점 하나는 단백질 내의 하나의 아미노산 잔기에 해당하며, 그 점의 위치는 해당 잔기의 파이 각과 싸이 각 값을 나타냅니다.\n플롯에는 일반적으로 허용된 영역(allowed regions)과 금지된 영역(disallowed regions)이 표시됩니다. 이는 아미노산의 입체적인 충돌 때문에 특정 각도 조합이 불가능하거나 매우 드물게 나타나기 때문입니다.\n알파-나선(alpha-helix) 구조를 갖는 아미노산 잔기들은 플롯의 특정 영역에 집중되어 나타납니다.\n베타-병풍(beta-sheet) 구조를 갖는 아미노산 잔기들은 또 다른 특정 영역에 집중되어 나타납니다.\n기타 구조(예: 루프, 턴)를 갖는 잔기들은 플롯의 다양한 영역에 분포할 수 있습니다.\n\n\nfrom tempfile import gettempdir\n\nimport biotite.database.rcsb as rcsb\nimport biotite.structure as struc\nimport biotite.structure.io as strucio\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 단백질 구조 데이터 다운로드 및 처리\nfile = rcsb.fetch(\"3av0\", \"cif\", gettempdir())\natom_array = strucio.load_structure(file)\npeptide = atom_array[struc.filter_amino_acids(atom_array)]\nchain = peptide[peptide.chain_id == \"B\"]\n\n# 이면각 계산\nphi, psi, omega = struc.dihedral_backbone(chain)\nphi, psi = np.rad2deg(phi)[1:-1], np.rad2deg(psi)[1:-1]\n\n# 라마찬드란 플롯 생성\nfigure, ax = plt.subplots(figsize=(5, 4))\nh, xed, yed, image = ax.hist2d(phi, psi, bins=(50, 50), cmap=\"viridis\", cmin=1)\n\n# 컬러바 설정\ncbar = figure.colorbar(image, orientation=\"vertical\")\ncbar.set_label(\"Count\")\n\n# 플롯 스타일 설정\nax.set_aspect(\"equal\")\nax.set_xlim(-180, 180)\nax.set_ylim(-180, 180)\nax.set_xlabel(r\"$\\phi$\")\nax.set_ylabel(r\"$\\psi$\")\nax.set_title(\"Ramachandran plot\")\n\n# 플롯 표시\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n3.5.3 인접 행렬(adjacency matrix) 시각화하기\n인접 행렬(Adjacency Matrix)은 그래프 이론에서 사용되는 개념으로 그래프 내의 노드(vertex)들이 서로 어떻게 연결되어 있는지(adjacent)를 나타내는 정사각 행렬입니다. 생물학, 특히 단백질 구조 분석에서는 원자 또는 아미노산 잔기를 노드로 간주하고 특정 기준(예: 거리)에 따라 서로 연결되어 있다고 정의할 때 유용하게 활용할 수 있습니다.\n\nfrom tempfile import gettempdir\n\nimport biotite\nimport biotite.database.rcsb as rcsb\nimport biotite.structure as struc\nimport biotite.structure.io as strucio\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef download_and_load_structure(pdb_id):\n    \"\"\"PDB ID를 이용하여 단백질 구조를 다운로드하고 Biotite Structure 객체로 로드합니다.\"\"\"\n    file_name = rcsb.fetch(pdb_id, \"cif\", gettempdir())\n    array = strucio.load_structure(file_name)\n    return array\n\n\ndef select_ca_atoms(structure, chain_id):\n    \"\"\"Biotite Structure 객체에서 특정 chain ID의 CA (알파 탄소) 원자만 선택합니다.\"\"\"\n    chain = structure[structure.chain_id == chain_id]\n    ca = chain[chain.atom_name == \"CA\"]\n    return ca\n\n\ndef calculate_distance_matrix(atom_array):\n    \"\"\"Biotite AtomArray에서 CA 원자 간의 거리 행렬을 계산합니다.\"\"\"\n    coords = atom_array.coord\n    n_atoms = coords.shape[0]\n    distances = np.zeros((n_atoms, n_atoms))\n    for i in range(n_atoms):\n        for j in range(i, n_atoms):\n            dist = np.linalg.norm(coords[i] - coords[j])\n            distances[i, j] = dist\n            distances[j, i] = dist\n    return distances\n\n\ndef visualize_distance_matrix(distance_matrix, title=\"CA atom distance map\", cmap=\"viridis_r\"):\n    \"\"\"행렬을 컬러맵을 사용하여 시각화하고 컬러바를 추가합니다.\"\"\"\n    fig, ax = plt.subplots(figsize=(5, 4))  # 컬러바 공간 고려하여 figsize 조정\n    im = ax.imshow(distance_matrix, cmap=cmap, origin=\"lower\")\n\n    # 컬러바 크기 줄이기\n    cbar = fig.colorbar(im, ax=ax, shrink=0.6)\n    cbar.set_label(\"Distance (Å)\")\n\n    ax.xaxis.tick_bottom()\n    ax.set_aspect(\"equal\")\n    ax.set_xlabel(\"Residue number\")\n    ax.set_ylabel(\"Residue number\")\n    ax.set_title(title)\n    fig.tight_layout()\n    plt.show()\n\n\npdb_id = \"8z8v\"\nchain_id = \"A\"\n\nstructure = download_and_load_structure(pdb_id)\nca_atoms = select_ca_atoms(structure, chain_id)\ndistance_matrix = calculate_distance_matrix(ca_atoms)\nvisualize_distance_matrix(\n    distance_matrix, title=f\"CA atom distance map of {pdb_id} - Chain {chain_id}\"\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4 단백질의 지름 측정\n아래 코드는 단백질의 지름을 최대 원자 간 쌍 거리로 정의하여 계산합니다. 이는 단백질 내에 존재하는 모든 원자 쌍 사이의 거리를 계산한 후, 그 중 가장 큰 거리를 단백질의 지름으로 정의하는 방식입니다.\n\nfrom tempfile import gettempdir\n\nimport biotite.database.rcsb as rcsb\nimport biotite.structure as struc\nimport biotite.structure.io as strucio\nimport numpy as np\n\n\ndef get_diameter(pdb_id):\n    # PDB 파일 다운로드\n    file_name = rcsb.fetch(pdb_id, \"bcif\", gettempdir())\n    atom_array = strucio.load_structure(file_name)\n\n    # 아미노산만 남기고 나머지 제거\n    atom_array = atom_array[struc.filter_amino_acids(atom_array)]\n\n    # 원자 좌표 추출\n    coord = atom_array.coord\n\n    # 모든 쌍별 차이 벡터 계산\n    diff = coord[:, np.newaxis, :] - coord[np.newaxis, :, :]\n\n    # 차이 벡터의 절대값 계산 -&gt; 제곱 거리\n    sq_dist = np.sum(diff * diff, axis=-1)\n\n    # 최대 거리가 지름\n    diameter = np.sqrt(np.max(sq_dist))\n\n    return diameter\n\n\nprint(\"1IGT(항체)의 지름:\", get_diameter(\"1IGT\"), \"Angstrom\")\n\n1IGT(항체)의 지름: 166.0276 Angstrom\n\n\n\n\n3.5.5 단백질 구조가 풀리지 않은 식별\n아래 코드는 단백질 구조에서 발견된 갭(gap), 즉 정보가 없는 부분을 나타내는 막대 그래프를 생성합니다. 위쪽 막대는 최근 결정 구조(PDB 코드: 5LUQ)에서 누락된 아미노산 잔기를 보여주고 아래쪽 막대는 최근 저온 전자 현미경(cryo-EM) 구조(PDB 코드: 5W1R)에서 누락된 아미노산 잔기를 보여줍니다.\n\n초록색: 공간적으로 구조가 밝혀진 아미노산 잔기\n노란색: 단순히 폴리알라닌으로만 주석 처리된 아미노산 잔기 (정확한 측쇄 정보 없음)\n빨간색: 구조가 해결되지 않아 정보가 없는 아미노산 잔기\n\n\nfrom tempfile import gettempdir\n\nimport biotite.database.rcsb as rcsb\nimport biotite.structure.io as strucio\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.patches import Rectangle\n\n\ndef plot_gaps(pdb_id, chain_id, ax):\n    # 구조 파일 다운로드 및 파싱\n    path = rcsb.fetch(pdb_id, \"bcif\", gettempdir())\n    atom_array = strucio.load_structure(path)\n\n    # 지정된 체인만 고려\n    atom_array = atom_array[atom_array.chain_id == chain_id]\n\n    # 각 잔기의 상태를 저장할 배열 (0: 없음, 1: 폴리알라닌, 2: 존재)\n    states = np.zeros(atom_array.res_id[-1], dtype=int)\n\n    # 각 잔기의 상태 결정\n    for i in range(len(states)):\n        residue = atom_array[atom_array.res_id == i + 1]\n        if len(residue) == 0:\n            states[i] = 0  # 잔기 없음\n        elif residue.res_name[0] == \"UNK\":\n            states[i] = 1  # 폴리알라닌\n        else:\n            states[i] = 2  # 잔기 존재\n\n    # 각 상태의 연속된 구간 찾기\n    state_intervals = []\n    curr_start = None\n    for i in range(len(states)):\n        if curr_start is None:\n            curr_start = i\n        elif states[i] != states[i - 1]:\n            state_intervals.append((curr_start, i, states[i - 1]))\n            curr_start = i\n    state_intervals.append((curr_start, len(states), states[-1]))\n\n    # 상태 구간을 색상으로 표시 (Nord 테마의 Aurora 색상 사용)\n    colors = [\"#BF616A\", \"#EBCB8B\", \"#A3BE8C\"]  # Nord 색상: Red, Yellow, Green\n    for start, stop, state in state_intervals:\n        ax.add_patch(\n            Rectangle(\n                (start + 1 - 0.5, 0),\n                stop - start,\n                1,\n                edgecolor=\"None\",\n                facecolor=colors[state],\n            )\n        )\n\n    # 그래프 스타일 설정\n    ax.spines[\"left\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.yaxis.set_visible(False)\n    ax.set_xlim(0.5, len(states) + 0.5)\n    ax.set_ylim(0, 2)\n\n\n# 메인 그래프 생성\nfig = plt.figure(figsize=(6, 2))\n\n# 5luq 구조 그래프\nax = fig.add_subplot(211)\nax.set_title(\"5luq\", loc=\"left\")\nplot_gaps(\"5luq\", \"A\", ax)\n\n# 5w1r 구조 그래프\nax = fig.add_subplot(212)\nax.set_title(\"5w1r\", loc=\"left\")\nplot_gaps(\"5w1r\", \"A\", ax)\nax.set_xlabel(r\"$Residue \\ number$\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3.5.6 당화된 아미노산 시각화\n이 예시에서는 임의의 단백질에서 아미노산 잔기의 당화(glycosylation)를 시각적으로 나타냅니다. 먼저, 당류에 속하는 잔기 이름 목록이 필요합니다. 이러한 목록을 만드는 것은 상당히 번거롭습니다. 여기에서는 Mol* 소프트웨어 에서 목록을 가져와 사용하겠습니다.\n\nfrom tempfile import gettempdir\n\nimport biotite.database.rcsb as rcsb\nimport biotite.sequence as seq\nimport biotite.structure as struc\nimport biotite.structure.io.pdbx as pdbx\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\nfrom matplotlib.lines import Line2D\nfrom networkx.drawing.nx_pydot import graphviz_layout\n\n# 상수 정의\nNODE_SIZE = 50\nHORIZONTAL_NODE_DISTANCE = 3\nLINE_WIDTH = 0.5\nSACCHARIDE_NAMES = {\n    res_name: common_name\n    for common_name, res_names in [\n        (\"Glc\", [\"GLC\", \"BGC\", \"Z8T\", \"TRE\", \"MLR\"]),\n        (\"Man\", [\"MAN\", \"BMA\"]),\n        (\"Gal\", [\"GLA\", \"GAL\", \"GZL\", \"GXL\", \"GIV\"]),\n        (\"Gul\", [\"4GL\", \"GL0\", \"GUP\", \"Z8H\"]),\n        (\"Alt\", [\"Z6H\", \"3MK\", \"SHD\"]),\n        (\"All\", [\"AFD\", \"ALL\", \"WOO\", \"Z2D\"]),\n        (\"Tal\", [\"ZEE\", \"A5C\"]),\n        (\"Ido\", [\"ZCD\", \"Z0F\", \"4N2\"]),\n        (\"GlcNAc\", [\"NDG\", \"NAG\", \"NGZ\"]),\n        (\"ManNAc\", [\"BM3\", \"BM7\"]),\n        (\"GalNAc\", [\"A2G\", \"NGA\", \"YYQ\"]),\n        (\"GulNAc\", [\"LXB\"]),\n        (\"AllNAc\", [\"NAA\"]),\n        (\"IdoNAc\", [\"LXZ\"]),\n        (\"GlcN\", [\"PA1\", \"GCS\"]),\n        (\"ManN\", [\"95Z\"]),\n        (\"GalN\", [\"X6X\", \"1GN\"]),\n        (\"GlcA\", [\"GCU\", \"BDP\"]),\n        (\"ManA\", [\"MAV\", \"BEM\"]),\n        (\"GalA\", [\"ADA\", \"GTR\", \"GTK\"]),\n        (\"GulA\", [\"LGU\"]),\n        (\"TalA\", [\"X1X\", \"X0X\"]),\n        (\"IdoA\", [\"IDR\"]),\n        (\"Qui\", [\"G6D\", \"YYK\"]),\n        (\"Rha\", [\"RAM\", \"RM4\", \"XXR\"]),\n        (\"6dGul\", [\"66O\"]),\n        (\"Fuc\", [\"FUC\", \"FUL\", \"FCA\", \"FCB\"]),\n        (\"QuiNAc\", [\"Z9W\"]),\n        (\"FucNAc\", [\"49T\"]),\n        (\"Oli\", [\"DDA\", \"RAE\", \"Z5J\"]),\n        (\"Tyv\", [\"TYV\"]),\n        (\"Abe\", [\"ABE\"]),\n        (\"Par\", [\"PZU\"]),\n        (\"Dig\", [\"Z3U\"]),\n        (\"Ara\", [\"64K\", \"ARA\", \"ARB\", \"AHR\", \"FUB\", \"BXY\", \"BXX\"]),\n        (\"Lyx\", [\"LDY\", \"Z4W\"]),\n        (\"Xyl\", [\"XYS\", \"XYP\", \"XYZ\", \"HSY\", \"LXC\"]),\n        (\"Rib\", [\"YYM\", \"RIP\", \"RIB\", \"BDR\", \"0MK\", \"Z6J\", \"32O\"]),\n        (\"Kdn\", [\"KDM\", \"KDN\"]),\n        (\"Neu5Ac\", [\"SIA\", \"SLB\"]),\n        (\"Neu5Gc\", [\"NGC\", \"NGE\"]),\n        (\"LDManHep\", [\"GMH\"]),\n        (\"Kdo\", [\"KDO\"]),\n        (\"DDManHep\", [\"289\"]),\n        (\"MurNAc\", [\"MUB\", \"AMU\"]),\n        (\"Mur\", [\"1S4\", \"MUR\"]),\n        (\"Api\", [\"XXM\"]),\n        (\"Fru\", [\"BDF\", \"Z9N\", \"FRU\", \"LFR\"]),\n        (\"Tag\", [\"T6T\"]),\n        (\"Sor\", [\"SOE\"]),\n        (\"Psi\", [\"PSV\", \"SF6\", \"SF9\"]),\n    ]\n    for res_name in res_names\n}\nSACCHARIDE_REPRESENTATION = {\n    \"Glc\": (\"o\", \"royalblue\"),\n    \"Man\": (\"o\", \"forestgreen\"),\n    \"Gal\": (\"o\", \"gold\"),\n    \"Gul\": (\"o\", \"darkorange\"),\n    \"Alt\": (\"o\", \"pink\"),\n    \"All\": (\"o\", \"purple\"),\n    \"Tal\": (\"o\", \"lightsteelblue\"),\n    \"Ido\": (\"o\", \"chocolate\"),\n    \"GlcNAc\": (\"s\", \"royalblue\"),\n    \"ManNAc\": (\"s\", \"forestgreen\"),\n    \"GalNAc\": (\"s\", \"gold\"),\n    \"GulNAc\": (\"s\", \"darkorange\"),\n    \"AllNAc\": (\"s\", \"purple\"),\n    \"IdoNAc\": (\"s\", \"chocolate\"),\n    \"GlcN\": (\"1\", \"royalblue\"),\n    \"ManN\": (\"1\", \"forestgreen\"),\n    \"GalN\": (\"1\", \"gold\"),\n    \"GlcA\": (\"v\", \"royalblue\"),\n    \"ManA\": (\"v\", \"forestgreen\"),\n    \"GalA\": (\"v\", \"gold\"),\n    \"GulA\": (\"v\", \"darkorange\"),\n    \"TalA\": (\"v\", \"lightsteelblue\"),\n    \"IdoA\": (\"v\", \"chocolate\"),\n    \"Qui\": (\"^\", \"royalblue\"),\n    \"Rha\": (\"^\", \"forestgreen\"),\n    \"6dGul\": (\"^\", \"darkorange\"),\n    \"Fuc\": (\"^\", \"crimson\"),\n    \"QuiNAc\": (\"P\", \"royalblue\"),\n    \"FucNAc\": (\"P\", \"crimson\"),\n    \"Oli\": (\"X\", \"royalblue\"),\n    \"Tyv\": (\"X\", \"forestgreen\"),\n    \"Abe\": (\"X\", \"darkorange\"),\n    \"Par\": (\"X\", \"pink\"),\n    \"Dig\": (\"X\", \"purple\"),\n    \"Ara\": (\"*\", \"forestgreen\"),\n    \"Lyx\": (\"*\", \"gold\"),\n    \"Xyl\": (\"*\", \"darkorange\"),\n    \"Rib\": (\"*\", \"pink\"),\n    \"Kdn\": (\"D\", \"forestgreen\"),\n    \"Neu5Ac\": (\"D\", \"mediumvioletred\"),\n    \"Neu5Gc\": (\"D\", \"turquoise\"),\n    \"LDManHep\": (\"H\", \"forestgreen\"),\n    \"Kdo\": (\"H\", \"gold\"),\n    \"DDManHep\": (\"H\", \"pink\"),\n    \"MurNAc\": (\"H\", \"purple\"),\n    \"Mur\": (\"H\", \"chocolate\"),\n    \"Api\": (\"p\", \"royalblue\"),\n    \"Fru\": (\"p\", \"forestgreen\"),\n    \"Tag\": (\"p\", \"gold\"),\n    \"Sor\": (\"p\", \"darkorange\"),\n    \"Psi\": (\"p\", \"pink\"),\n    # 기본 표현\n    None: (\"h\", \"black\"),\n}\n\n\ndef load_structure_data(pdb_id):\n    \"\"\"\n    PDB ID를 기반으로 단백질 구조 데이터를 다운로드하고 로드합니다.\n    \"\"\"\n    try:\n        pdbx_file = pdbx.BinaryCIFFile.read(rcsb.fetch(pdb_id, \"bcif\", gettempdir()))\n        structure = pdbx.get_structure(pdbx_file, model=1, include_bonds=True)\n        return structure\n    except Exception as e:\n        print(f\"Error loading structure {pdb_id}: {e}\")\n        return None\n\n\ndef filter_structure(structure):\n    \"\"\"\n    구조체에서 탄수화물 및 아미노산만 필터링합니다.\n    \"\"\"\n    return structure[struc.filter_carbohydrates(structure) | struc.filter_amino_acids(structure)]\n\n\ndef create_residue_graph(structure):\n    \"\"\"\n    구조체에서 잔기 간의 연결을 나타내는 그래프를 생성합니다.\n    \"\"\"\n    graph = nx.Graph()\n    graph.add_nodes_from(struc.get_residue_starts(structure))\n    bonds = structure.bonds.as_array()[:, :2]\n    connected = struc.get_residue_starts_for(structure, bonds.flatten()).reshape(bonds.shape)\n    connected = connected[connected[:, 0] != connected[:, 1]]\n    graph.add_edges_from(connected)\n    return graph\n\n\ndef draw_initial_graph(graph, is_glycan):\n    \"\"\"\n    전체 구조 그래프를 그립니다.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(4.0, 4.0))\n    nx.draw(\n        graph,\n        ax=ax,\n        node_size=10,\n        node_color=[\"crimson\" if is_glycan[atom_i] else \"royalblue\" for atom_i in graph.nodes()],\n    )\n    return fig, ax\n\n\ndef remove_non_glycan_edges(graph, is_glycan):\n    \"\"\"\n    글리칸이 아닌 잔기 간의 엣지를 제거합니다.\n    \"\"\"\n    for atom_i, atom_j in list(graph.edges):\n        if not is_glycan[atom_i] and not is_glycan[atom_j]:\n            graph.remove_edge(atom_i, atom_j)\n\n\ndef get_glycan_subgraphs(graph):\n    \"\"\"\n    글리칸을 포함하는 연결된 서브그래프를 가져옵니다.\n    \"\"\"\n    return [\n        graph.subgraph(nodes).copy() for nodes in nx.connected_components(graph) if len(nodes) &gt; 1\n    ]\n\n\ndef draw_glycan_details(structure, glycan_graphs, is_amino_acid, is_glycan):\n    \"\"\"\n    개별 글리칸 그래프를 그리고 세부 정보를 표시합니다.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(8.0, 2.5))\n    glycosylated_residue_ids = []\n    glycosylated_residue_symbols = []\n    legend_elements = {}\n\n    for glycan_graph in glycan_graphs:\n        glycan_graph = nx.DiGraph(\n            [(min(atom_i, atom_j), max(atom_i, atom_j)) for atom_i, atom_j in glycan_graph.edges()]\n        )\n        root = [atom_i for atom_i in glycan_graph.nodes() if is_amino_acid[atom_i]]\n        if not root:\n            continue\n        root = root[0]\n        glycosylated_residue_ids.append(structure.res_id[root])\n        glycosylated_residue_symbols.append(\n            seq.ProteinSequence.convert_letter_3to1(structure.res_name[root])\n        )\n        root_neighbor = list(glycan_graph.neighbors(root))[0]\n        pos = graphviz_layout(glycan_graph, prog=\"dot\")\n        nodes = [int(key) for key in pos.keys()]\n        pos_array = np.array(list(pos.values()))\n        pos_array -= pos_array[nodes.index(root)]\n        pos_array[:, 1] /= (\n            pos_array[nodes.index(root_neighbor), 1] - pos_array[nodes.index(root), 1]\n        )\n        non_zero_dist = np.abs(pos_array[(pos_array[:, 0] != 0), 0])\n        if len(non_zero_dist) != 0:\n            pos_array[:, 0] *= HORIZONTAL_NODE_DISTANCE / np.min(non_zero_dist)\n        pos_array[:, 0] += structure.res_id[root]\n        pos = {node: tuple(coord) for node, coord in zip(nodes, pos_array)}\n\n        nx.draw_networkx_edges(\n            glycan_graph, pos, ax=ax, arrows=False, node_size=0, width=LINE_WIDTH\n        )\n\n        for atom_i in glycan_graph.nodes():\n            if not is_glycan[atom_i]:\n                continue\n            common_name = SACCHARIDE_NAMES.get(structure.res_name[atom_i])\n            shape, color = SACCHARIDE_REPRESENTATION[common_name]\n            ax.scatter(\n                pos[atom_i][0],\n                pos[atom_i][1],\n                s=NODE_SIZE,\n                marker=shape,\n                facecolor=color,\n                edgecolor=\"black\",\n                linewidths=LINE_WIDTH,\n            )\n            legend_elements[common_name] = Line2D(\n                [0],\n                [0],\n                label=common_name,\n                linestyle=\"None\",\n                marker=shape,\n                markerfacecolor=color,\n                markeredgecolor=\"black\",\n                markeredgewidth=LINE_WIDTH,\n            )\n\n    ax.legend(handles=legend_elements.values(), loc=\"upper right\")\n    ax.spines[\"left\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(True)\n    ax.tick_params(axis=\"x\", bottom=True, labelbottom=True)\n    ax.tick_params(axis=\"y\", left=False, labelleft=False)\n    ax.set_xticks(glycosylated_residue_ids)\n    ax.set_xticklabels(\n        [\n            symbol + str(res_id)\n            for symbol, res_id in zip(glycosylated_residue_symbols, glycosylated_residue_ids)\n        ],\n        rotation=45,\n    )\n    ax.set_xlim(1, np.max(structure.res_id[is_amino_acid]))\n    ax.set_ylim(0, 7)\n    return fig, ax\n\n\nPDB_ID = \"1IGT\"  # 항체 PDB ID\nstructure = filter_structure(load_structure_data(PDB_ID))\nis_glycan = struc.filter_carbohydrates(structure)\nis_amino_acid = struc.filter_amino_acids(structure)\n\ngraph = create_residue_graph(structure)\nremove_non_glycan_edges(graph, is_glycan)\nglycan_graphs = get_glycan_subgraphs(graph)\n\nfig, ax = draw_glycan_details(structure, glycan_graphs, is_amino_acid, is_glycan)\n\nfig.suptitle(f\"Glycan Analysis of {PDB_ID}\")\nfig.tight_layout(rect=[0, 0.03, 1, 0.95])  # 제목을 위한 공간 확보\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html",
    "href": "posts/ipynb/da_statistics_testing.html",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "",
    "text": "통계적 추론이라는 것은 제한된 실험 데이터에서 얻은 결과를 모집단에도 적용하려는 것입니다. 이번 포스트에서는 통계적 추론에 사용되는 검정법을 배워봅니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html#순열-검정을-통한-ab-검정",
    "href": "posts/ipynb/da_statistics_testing.html#순열-검정을-통한-ab-검정",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "2.1 순열 검정을 통한 A/B 검정",
    "text": "2.1 순열 검정을 통한 A/B 검정\n\n순열검정(permutaion test): 두 개 이상의 표본을 함께 결합하여 관측값들을 무작위로 재표본으로 추출하는 과정을 말한다.\n\n파이썬에서 순열 검정을 구현하기 위해 아래와 같이 perm_fun 함수를 정의합니다.\n\n# Permutation test example with stickiness\ndef perm_fun(x, nA, nB):\n    n = nA + nB\n    idx_B = set(random.sample(range(n), nB))\n    idx_A = set(range(n)) - idx_B\n    return x.loc[idx_B].mean() - x.loc[idx_A].mean()\n\n\nnA = session_times[session_times.Page == \"Page A\"].shape[0]\nnB = session_times[session_times.Page == \"Page B\"].shape[0]\nprint(perm_fun(session_times.Time, nA, nB))\n\n24.23809523809524\n\n\n단 한번의 계산을 통해서 24초라는 차이가 발생하였습니다. 계산을 반복해서 페이지A와 페이지B 사이의 시간 차이에 대한 도수 분포표를 그려봅시다.\n\nrandom.seed(1)\nperm_diffs = [perm_fun(session_times.Time, nA, nB) for _ in range(1000)]\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax.hist(perm_diffs, bins=11, rwidth=0.9)\nax.axvline(x=mean_b - mean_a, color=\"black\", lw=2)\nax.text(50, 190, \"Observed\\ndifference\", bbox={\"facecolor\": \"white\"})\nax.set_xlabel(\"Session time differences (in seconds)\")\nax.set_ylabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n위 그림에서 수직선은 관측된 차이입니다. 이것을 통해 순열 검정에서 가끔 실제 관찰된 차이를 넘어가는 것을 알 수 있습니다. 그렇다면 어느정도의 확률로 그런 일이 벌어질까요?\n\nprint(np.mean(perm_diffs &gt; mean_b - mean_a))\n\n0.121\n\n\n답은 12.1% 입니다. 이것을 통해 페이지A와 페이지B의 차이인 36초가 통계적으로 봤을때는 차이가 없어도 약 12% 확률로 발생할 수 있다는 결론을 얻었습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html#t-test를-사용한-ab-검정",
    "href": "posts/ipynb/da_statistics_testing.html#t-test를-사용한-ab-검정",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "2.2 T-test를 사용한 A/B 검정",
    "text": "2.2 T-test를 사용한 A/B 검정\n\nt-test 또는 스튜던트 t-테스트(Student’s t-test)는 검정통계량이 귀무가설 하에서 t-분포를 따르는 통계적 가설 검정법이다. t-테스트는 일반적으로 검정통계량이 정규 분포를 따르며 분포와 관련된 스케일링 변숫값들이 알려진 경우에 사용한다. 이때 모집단의 분산과 같은 스케일링 항을 알 수 없으나, 이를 데이터를 기반으로 한 추정값으로 대체하면 검정통계량은 t-분포를 따른다. 예를 들어 t-테스트를 사용하여 두 데이터 세트(집단)의 평균이 서로 유의하게 다른지 여부를 판별할 수 있다. -wiki\n\n파이썬에서는 ttest_ind 함수를 사용하면 손쉽게 구해볼 수 있습니다.\n\nres = stats.ttest_ind(\n    session_times[session_times.Page == \"Page A\"].Time,\n    session_times[session_times.Page == \"Page B\"].Time,\n    equal_var=False,\n)\nprint(f\"p-value for single sided test: {res.pvalue / 2:.4f}\")\n\np-value for single sided test: 0.1408\n\n\n결과 값이 앞서 구한 순열 검정의 확률인 12%과 유사한 수치인 14%임을 확인 할 수 있습니다. 컴퓨터가 보급되기 전에 순열 검정은 실용적이지 않았고 그래서 통계학자들에게 t-Test가 널리 사용되었습니다.\n\ntstat, pvalue, df = sm.stats.ttest_ind(\n    session_times[session_times.Page == \"Page A\"].Time,\n    session_times[session_times.Page == \"Page B\"].Time,\n    usevar=\"unequal\",\n    alternative=\"smaller\",\n)\nprint(f\"p-value: {pvalue:.4f}\")\n\np-value: 0.1408"
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html#p-value-구하기",
    "href": "posts/ipynb/da_statistics_testing.html#p-value-구하기",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "3.1 p-value 구하기",
    "text": "3.1 p-value 구하기\np-value는 순열 검정에서 얻은 결과 중에 관찰된 차이와 같거나 더 큰 차이를 보이는 경우의 비율이라고 할 수 있기에 다음과 같이 추정할 수 있습니다.\n\nprint(np.mean([diff &gt; obs_pct_diff for diff in perm_diffs]))\n\n0.332\n\n\n예상한 것처럼 30%의 확률로 우연에 의해서 나타날 수 있는 차이였습니다. 따라서 페이지A와 페이지B의 차이는 통계적으로 유의미하지 않다고 말할 수 있겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html#순열검정을-통한-one-way-anova",
    "href": "posts/ipynb/da_statistics_testing.html#순열검정을-통한-one-way-anova",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "4.1 순열검정을 통한 one-way ANOVA",
    "text": "4.1 순열검정을 통한 one-way ANOVA\n파이썬에서는 다음 코드를 사용해 순열 검정을 통해 ANOVA 분석을 진행할 수 있습니다.\n\nobserved_variance = four_sessions.groupby(\"Page\").mean().var()[0]\nprint(\"Observed means:\", four_sessions.groupby(\"Page\").mean().values.ravel())\nprint(\"Variance:\", observed_variance)\n\n\n# Permutation test example with stickiness\ndef perm_test(df):\n    df = df.copy()\n    df[\"Time\"] = np.random.permutation(df[\"Time\"].values)\n    return df.groupby(\"Page\").mean().var()[0]\n\n\nprint(perm_test(four_sessions))\n\nObserved means: [172.8 182.6 175.6 164.6]\nVariance: 55.426666666666655\n57.02666666666678\n\n\n\nrandom.seed(1)\nperm_variance = [perm_test(four_sessions) for _ in range(3000)]\nprint(\"Pr(Prob)\", np.mean([var &gt; observed_variance for var in perm_variance]))\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax.hist(perm_variance, bins=11, rwidth=0.9)\nax.axvline(x=observed_variance, color=\"black\", lw=2)\nax.text(60, 200, \"Observed\\nvariance\", bbox={\"facecolor\": \"white\"})\nax.set_xlabel(\"Variance\")\nax.set_ylabel(\"Frequency\")\n\nplt.tight_layout()\nplt.show()\n\nPr(Prob) 0.07766666666666666\n\n\n\n\n\n\n\n\n\nPr(Prob)의 값은 p-value이며 결과는 0.07입니다. 통상적인 임계 p-value 값인 0.05이상임으로 네 페이지간의 차이가 우연히 발생할 수 있다고 결론 내릴 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_testing.html#f-통계량을-통한-one-way-anova",
    "href": "posts/ipynb/da_statistics_testing.html#f-통계량을-통한-one-way-anova",
    "title": "파이썬 statsmodels로 통계분석",
    "section": "4.2 F-통계량을 통한 one-way ANOVA",
    "text": "4.2 F-통계량을 통한 one-way ANOVA\nF-통계량은 잔차 오류에 인한 분산과 그룹 평균의 분산에 대한 비율을 기초로 합니다. 비율이 높으면 통계적으로 유의미 하다고 할 수 있고 이를 토대로 p-value를 계산할 수 있습니다.\n\nmodel = smf.ols(\"Time ~ Page\", data=four_sessions).fit()\n\naov_table = sm.stats.anova_lm(model)\nprint(aov_table)\n\n            df  sum_sq     mean_sq         F    PR(&gt;F)\nPage       3.0   831.4  277.133333  2.739825  0.077586\nResidual  16.0  1618.4  101.150000       NaN       NaN\n\n\ndf는 자유도, sum_sq는 제곱합, mean_sq는 평균제곱, F는 F-통계량을 나타냅니다.\n\nres = stats.f_oneway(\n    four_sessions[four_sessions.Page == \"Page 1\"].Time,\n    four_sessions[four_sessions.Page == \"Page 2\"].Time,\n    four_sessions[four_sessions.Page == \"Page 3\"].Time,\n    four_sessions[four_sessions.Page == \"Page 4\"].Time,\n)\nprint(f\"F-Statistic: {res.statistic / 2:.4f}\")\nprint(f\"p-value: {res.pvalue / 2:.4f}\")\n\nF-Statistic: 1.3699\np-value: 0.0388\n\n\nF-통계량을 사용한 방법은 p-value 값이 더 적게나와 임계값인 0.05 이하입니다. 그러나 ANOVA 분석의 p-value가 낮게 나왔다고 해서 모든 그룹에서 통계적으로 차이가 있다고 할 수는 없습니다. 추가적인 Ad hoc 분석을 진행해 어떤 그룹에서 차이가 있는지 확인해보아야 합니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html",
    "href": "posts/ipynb/da_scanpy_workshop_03.html",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "",
    "text": "scRNA-seq 기술의 발달로 개별 세포 수준에서의 유전자 발현 데이터를 얻는 것이 가능해졌습니다. 세포 수준의 데이터는 생명과학 연구에서 세포 유형 및 기능적 특성을 이해하는데 중요한 정보를 제공합니다. 그러나 동시에 데이터가 너무 방대하고 복잡해 새로운 분석 도구와 알고리즘이 필요하게 되었습니다. 이번 강좌는 scanpy를 활용하여 그래프 커뮤니티 감지 알고리즘을 통해 세포를 그룹화하고 각 세포 집단의 기능적 특성을 파악하는 방법을 살펴보겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#라이덴leiden",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#라이덴leiden",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "2.1 라이덴(Leiden)",
    "text": "2.1 라이덴(Leiden)\n라이덴은 루바인 알고리즘의 개선 버전으로 연결성과 높은 모듈성, 세분화 단계를 추가해 더 정확한 커뮤니티를 탐지하는 것으로 알려져 있습니다. 따라서 라이덴을 사용하는 것을 권장합니다.\n\nsc.tl.leiden(adata, key_added=\"leiden_1.0\")  # default resolution in 1.0\nsc.tl.leiden(adata, resolution=0.6, key_added=\"leiden_0.6\")\nsc.tl.leiden(adata, resolution=0.4, key_added=\"leiden_0.4\")\nsc.tl.leiden(adata, resolution=1.4, key_added=\"leiden_1.4\")\n\n시각화를 해보면 설정된 해상도 값이 높아질수록 클러스터가 세분화 된다는 것을 알 수 있습니다.\n\nsc.pl.umap(\n    adata,\n    color=[\"leiden_0.4\", \"leiden_0.6\", \"leiden_1.0\", \"leiden_1.4\"],\n    ncols=2,\n)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#루바인louvain",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#루바인louvain",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "2.2 루바인(Louvain)",
    "text": "2.2 루바인(Louvain)\n루바인 알고리즘은 네트워크 그래프에서 클러스터를 탐지하는 데 사용되는 방법으로 주로 네트워크 모듈성 최적화를 통해 작동됩니다.\n\nsc.tl.louvain(adata, key_added=\"louvain_1.0\")  # default resolution in 1.0\nsc.tl.louvain(adata, resolution=0.6, key_added=\"louvain_0.6\")\nsc.tl.louvain(adata, resolution=0.4, key_added=\"louvain_0.4\")\nsc.tl.louvain(adata, resolution=1.4, key_added=\"louvain_1.4\")\n\nsc.pl.umap(\n    adata,\n    color=[\"louvain_0.4\", \"louvain_0.6\", \"louvain_1.0\", \"louvain_1.4\"],\n    ncols=2,\n)\n\n\n\n\n\n\n\n\n루바인도 라이덴과 마찬가지로 해상도 값이 높아지면 클러스터가 세분화됩니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#k-평균-클러스터링",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#k-평균-클러스터링",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "2.3 K-평균 클러스터링",
    "text": "2.3 K-평균 클러스터링\nK-평균 클러스터링은 다양한 분야에서 일반적으로 사용되어온 전통적인 클러스터링 알고리즘입니다. 클러스터 수를 미리 정의해야 한다는 점이 다르며 클러스터링 결과는 초기 클러스터 중심 값(nstart)에 따라 달라지므로 여러가지 값으로 시도해보는 것이 좋습니다. 여기에서는 scikit learn패키지의 KMeans함수를 이용해 구현하겠습니다.\n\n# 저장된 PCA값을 사용\nX_pca = adata.obsm[\"Scanorama\"]\n\n# kmeans with k=5\nkmeans = KMeans(n_clusters=5, random_state=0).fit(X_pca)\nadata.obs[\"kmeans5\"] = kmeans.labels_.astype(str)\n\n# kmeans with k=10\nkmeans = KMeans(n_clusters=10, random_state=0).fit(X_pca)\nadata.obs[\"kmeans10\"] = kmeans.labels_.astype(str)\n\n# kmeans with k=15\nkmeans = KMeans(n_clusters=15, random_state=0).fit(X_pca)\nadata.obs[\"kmeans15\"] = kmeans.labels_.astype(str)\n\nsc.pl.umap(\n    adata,\n    color=[\"kmeans5\", \"kmeans10\", \"kmeans15\"],\n    ncols=2,\n)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#계층적-클러스터링",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#계층적-클러스터링",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "2.4 계층적 클러스터링",
    "text": "2.4 계층적 클러스터링\n또 다른 일반적인 형태의 클러스터링으로 계층적 클러스터링(Hierarchical clustering)을 사용해봅니다. 계층적 클러스터링은 다음 단계로 수행됩니다.\n\n샘플 사이의 거리를 정의합니다. 가장 일반적인 방법은 유클리드 거리(두 점 사이의 직선 거리) 또는 상관 계수입니다.\n클러스터 간 거리 측정값을 연결 기준이라고 정의합니다. 예를 들어 클러스터 간의 평균 거리가 될 수 있습니다. 일반적으로 사용되는 방법은 단일, 완전, 평균, 중앙값, 중심 및 방향입니다.\n상향식 또는 하향식 방식을 사용하여 전체 샘플 중 덴드로그램을 정의합니다. 상향식은 샘플이 자체 클러스터로 시작하여 하나의 클러스터만 남을 때까지 한 쌍씩 병합하는 방식입니다. 하향식은 샘플이 모두 동일한 클러스터에서 시작하여 각 샘플이 자체 클러스터를 가질 때까지 2개로 분할되는 방식입니다.\n\n여기에서는 scikit learn패키지의 AgglomerativeClustering함수를 이용해 구현하겠습니다. K-평균 클러스터링과 마찬가지로 클러스터의 수를 지정해야 하며 사용된 매개변수인 linkage=\"ward\"은 병합되는 클러스터의 편차를 최소화하기 위함입니다.\n\ncluster = AgglomerativeClustering(n_clusters=5, linkage=\"ward\")\nadata.obs[\"hclust_5\"] = cluster.fit_predict(X_pca).astype(str)\n\ncluster = AgglomerativeClustering(n_clusters=10, linkage=\"ward\")\nadata.obs[\"hclust_10\"] = cluster.fit_predict(X_pca).astype(str)\n\ncluster = AgglomerativeClustering(n_clusters=15, linkage=\"ward\")\nadata.obs[\"hclust_15\"] = cluster.fit_predict(X_pca).astype(str)\n\nsc.pl.umap(adata, color=[\"hclust_5\", \"hclust_10\", \"hclust_15\"], ncols=2)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#t-test",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#t-test",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "4.1 T-test",
    "text": "4.1 T-test\nt-test는 두 집단 간의 평균 차이를 비교하는 통계적 검정입니다. scRNA-seq 데이터에서는 두 그룹(예: 서로 다른 세포 유형 또는 조건) 간에 특정 유전자의 발현 수준이 유의하게 다른지 확인하는 데 사용됩니다.\n\n장점: 간단하고 계산이 빠르며, 데이터가 정규 분포를 따를 때 강력한 성능을 발휘합니다.\n단점: 데이터가 정규 분포를 따르지 않거나 분산이 다를 때 성능이 저하될 수 있습니다.\n\n\nadata.X = adata.layers[\"log1p\"].copy()\n\nsc.tl.rank_genes_groups(adata, \"louvain_0.6\", method=\"t-test\", key_added=\"t-test\")\nsc.pl.rank_genes_groups(\n    adata,\n    n_genes=25,\n    sharey=False,\n    key=\"t-test\",\n    ncols=3,\n)\n\n# 결과는 adata.uns[\"t-test\"] 슬롯에 저장됩니다.\nadata\n\n\n\n\n\n\n\n\nAnnData object with n_obs × n_vars = 7227 × 19094\n    obs: 'type', 'sample', 'batch', 'n_counts', 'leiden_1.0', 'leiden_0.6', 'leiden_0.4', 'leiden_1.4', 'louvain_1.0', 'louvain_0.6', 'louvain_0.4', 'louvain_1.4', 'kmeans5', 'kmeans10', 'kmeans15', 'hclust_5', 'hclust_10', 'hclust_15'\n    var: 'gene_ids', 'feature_types', 'genome', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std', 'highly_variable_nbatches', 'highly_variable_intersection'\n    uns: 'hvg', 'log1p', 'neighbors', 'pca', 'sample_colors', 'tsne', 'umap', 'leiden_1.0', 'leiden_0.6', 'leiden_0.4', 'leiden_1.4', 'leiden_0.4_colors', 'leiden_0.6_colors', 'leiden_1.0_colors', 'leiden_1.4_colors', 'louvain_1.0', 'louvain_0.6', 'louvain_0.4', 'louvain_1.4', 'louvain_0.4_colors', 'louvain_0.6_colors', 'louvain_1.0_colors', 'louvain_1.4_colors', 'kmeans5_colors', 'kmeans10_colors', 'kmeans15_colors', 'hclust_5_colors', 'hclust_10_colors', 'hclust_15_colors', 't-test'\n    obsm: 'Scanorama', 'X_pca', 'X_tsne', 'X_umap'\n    varm: 'PCs'\n    layers: 'counts', 'log1p'\n    obsp: 'connectivities', 'distances'"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#과대추정-분산을-고려한-t-test",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#과대추정-분산을-고려한-t-test",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "4.2 과대추정 분산을 고려한 T-test",
    "text": "4.2 과대추정 분산을 고려한 T-test\n이 방법은 표준 t-test의 변형으로, 분산을 과대추정하여 보수적인 결과를 도출합니다. 이는 특히 소규모 표본에서 통계적 검정의 신뢰도를 높이는 데 도움이 됩니다.\n\n장점: 소규모 표본에서의 검정의 신뢰도를 높이고, 분산이 과대추정될 때 발생할 수 있는 문제를 완화합니다.\n단점: 분산을 과대추정함으로 인해 실제 차이가 있는 유전자도 덜 민감하게 검출될 수 있습니다.\n\n\nsc.tl.rank_genes_groups(adata, \"louvain_0.6\", method=\"t-test_overestim_var\", key_added=\"t-test_ov\")\nsc.pl.rank_genes_groups(\n    adata,\n    n_genes=25,\n    sharey=False,\n    key=\"t-test_ov\",\n    ncols=3,\n)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#윌콕슨-순위-합계",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#윌콕슨-순위-합계",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "4.3 윌콕슨 순위 합계",
    "text": "4.3 윌콕슨 순위 합계\n윌콩슨(wilcoxon) 순위 합계 검정은 비모수 검정으로, 두 독립된 집단의 순위합을 비교하여 차이를 평가합니다. 이는 데이터가 정규 분포를 따르지 않을 때 유용합니다.\n\n장점: 데이터가 정규 분포를 따르지 않아도 사용할 수 있으며, 이상치에 덜 민감합니다.\n단점: 순위 기반 방법이기 때문에 데이터의 세밀한 차이를 반영하지 못할 수 있습니다.\n\n\nsc.tl.rank_genes_groups(adata, \"louvain_0.6\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(\n    adata,\n    n_genes=25,\n    sharey=False,\n    key=\"wilcoxon\",\n    ncols=3,\n)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#유전자-리스트-비교",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#유전자-리스트-비교",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "4.4 유전자 리스트 비교",
    "text": "4.4 유전자 리스트 비교\n위에서 얻은 T-test, T-test_ov, Wilcox 결과를 비교해보죠. 클러스터 0에 대한 DEG 리스트를 가져와 벤다이어 그램을 그려봅니다.\n\n# cluster 0 DEG 비교, 기본적으로 상위 100개만 저장합니다.\nwc = sc.get.rank_genes_groups_df(adata, group=\"0\", key=\"wilcoxon\", pval_cutoff=0.01, log2fc_min=0)[\n    \"names\"\n]\ntt = sc.get.rank_genes_groups_df(adata, group=\"0\", key=\"t-test\", pval_cutoff=0.01, log2fc_min=0)[\n    \"names\"\n]\ntt_ov = sc.get.rank_genes_groups_df(\n    adata, group=\"0\", key=\"t-test_ov\", pval_cutoff=0.01, log2fc_min=0\n)[\"names\"]\n\n\nvenn3_unweighted([set(wc), set(tt), set(tt_ov)], (\"Wilcox\", \"T-test\", \"T-test_ov\"))\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를에서 알수 있듯이 많은 DEG들은 중복됩니다. 특히 분산이 과대 추정된 T-test와 T-test 결과는 매우 유사합니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#특정-클러스터간-비교",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#특정-클러스터간-비교",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "5.1 특정 클러스터간 비교",
    "text": "5.1 특정 클러스터간 비교\n개별 클러스터를 하나의 클러스터 또는 여러 클러스터에 대해 쌍으로 비교할 수도 있습니다. 예를 들어, 클러스터 1과 2를 비교하는 방법은 아래와 같습니다.\n\nsc.tl.rank_genes_groups(\n    adata,\n    \"louvain_0.6\",\n    groups=[\"1\"],\n    reference=\"2\",\n    method=\"wilcoxon\",\n)\nsc.pl.rank_genes_groups(adata, groups=[\"1\"], n_genes=20)\n\n\n\n\n\n\n\n\n이 두 그룹을 바이올린으로 플롯합니다.\n\n# 모든 데이터 집합에 걸쳐 바이올린과 동일한 유전자를 플롯.\nsc.pl.rank_genes_groups_violin(adata, groups=\"1\", n_genes=10)\n\n\n\n\n\n\n\n\n\n# numpy.recarray를 리스트로 변환.\nmynames = [x[0] for x in adata.uns[\"rank_genes_groups\"][\"names\"][:10]]\nsc.pl.stacked_violin(adata, mynames, groupby=\"louvain_0.6\")"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#조건에-따른-dge-분석",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#조건에-따른-dge-분석",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "5.2 조건에 따른 DGE 분석",
    "text": "5.2 조건에 따른 DGE 분석\n하나의 클러스터 내에서 조건에 따라 어떤 유전자가 차등적으로 발현되는지에 대한 답을 구하는 방법을 알아보죠. 예를 들면 특정 세포 유형에서 환자와 대조군에서 어떤 유전자가 가장 많은 영향을 받는지 알고 싶다고 가정하는 것입니다.\n분석을 위해서는 먼저 원하는 세포 클러스터에 대한 데이터만 하위 집합하고 비교 변수(현재 우리의 경우 Covid과 Ctrl)로 type 값을 변경합니다.\n\ncl1 = adata[adata.obs[\"louvain_0.6\"] == \"4\", :]\ncl1.obs[\"type\"].value_counts()\n\nsc.tl.rank_genes_groups(cl1, \"type\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(cl1, n_genes=25, sharey=False, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\nwith rc_context({\"figure.figsize\": (5, 3)}):\n    sc.pl.rank_genes_groups_violin(\n        cl1, n_genes=10, key=\"wilcoxon\", split=True, use_raw=False, size=0\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n또한 모든 클러스터에서 이러한 유전자를 유형별로 분할해 다른 세포에서도 유전자가 상향/하향 조절되는지 확인할 수 있습니다.\n\ngenes1 = sc.get.rank_genes_groups_df(cl1, group=\"Covid\", key=\"wilcoxon\")[\"names\"][:3]\ngenes2 = sc.get.rank_genes_groups_df(cl1, group=\"Ctrl\", key=\"wilcoxon\")[\"names\"][:3]\ngenes = genes1.tolist() + genes2.tolist()\ndf = sc.get.obs_df(adata, genes + [\"louvain_0.6\", \"type\"], use_raw=False)\ndf2 = df.melt(id_vars=[\"louvain_0.6\", \"type\"], value_vars=genes)\n\nwith sns.axes_style(\"white\"):\n    ax = sns.catplot(\n        x=\"louvain_0.6\",\n        y=\"value\",\n        hue=\"type\",\n        kind=\"violin\",\n        inner=None,\n        split=True,\n        col=\"variable\",\n        col_wrap=2,\n        data=df2,\n    )\n\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를 보면 상위 DEG 중에는 성염색체 관련 유전자가 많이 있습니다. 이것은 시료의 성별 분포가 불균형했기 때문이며 코로나 바이러스 감염 여부와는 관련이 없습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#성염색체-유전자-데이터-제거",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#성염색체-유전자-데이터-제거",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "5.3 성염색체 유전자 데이터 제거",
    "text": "5.3 성염색체 유전자 데이터 제거\n시료의 성별 불균형으로 인한 편향성을 제거하기 위해 성염색체 관련 유전자를 제거합니다. 다시 바이오마트(biomart)패키지를 사용해 알려진 성염색체의 목록을 불러오고 데이터에서 제외시킵니다.\n\nannot = sc.queries.biomart_annotations(\n    \"hsapiens\",\n    [\n        \"ensembl_gene_id\",\n        \"external_gene_name\",\n        \"start_position\",\n        \"end_position\",\n        \"chromosome_name\",\n    ],\n).set_index(\"external_gene_name\")\n\nchrY_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"Y\"])\nchrX_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"X\"])\n\nsex_genes = chrY_genes.union(chrX_genes)\nall_genes = cl1.var.index.tolist()\nkeep_genes = [x for x in all_genes if x not in sex_genes]\ncl1 = cl1[:, keep_genes].copy()\nprint(f\"전체 유전자의 수: {len(all_genes)}\")\nprint(f\"알려진 성염색체 유전자의 수: {len(sex_genes)}\")\nprint(f\"남겨진 유전자의 수: {len(keep_genes)}\")\n\n전체 유전자의 수: 19094\n알려진 성염색체 유전자의 수: 544\n남겨진 유전자의 수: 18550\n\n\n이제 다시 DEG 찾기를 실행합니다.\n\nsc.tl.rank_genes_groups(cl1, \"type\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(cl1, n_genes=25, sharey=False, key=\"wilcoxon\")"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_03.html#샘플별-배치-효과",
    "href": "posts/ipynb/da_scanpy_workshop_03.html#샘플별-배치-효과",
    "title": "Scanpy로 scRNA-seq 분석 03",
    "section": "5.4 샘플별 배치 효과",
    "text": "5.4 샘플별 배치 효과\nCovid 과 대조군(Control) 사이의 DEG를 찾고 그룹 안에서 개인별로 상위 DGE가 어떻게 표현되는지 확인해봅니다.\n\ngenes1 = sc.get.rank_genes_groups_df(cl1, group=\"Covid\", key=\"wilcoxon\")[\"names\"][:4]\ngenes2 = sc.get.rank_genes_groups_df(cl1, group=\"Ctrl\", key=\"wilcoxon\")[\"names\"][:4]\n# genes = genes1.tolist() + genes2.tolist()\n\nprint(\"Covid vs Ctrl\")\nsc.pl.violin(cl1, genes1[:3], groupby=\"sample\", rotation=90)\nsc.pl.violin(cl1, genes2[:3], groupby=\"sample\", rotation=90)\n\nCovid vs Ctrl\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n위 결과에서 보이듯이 Covid에서 DEG로 검출된 유전자가 한 명의 환자(covid_17)에게만 값이 높습니다. 닷플랏을 그려서 좀 더 확인해보죠.\n\nsc.tl.filter_rank_genes_groups(\n    cl1,\n    # min_in_group_fraction=0.2,\n    # max_out_group_fraction=0.2,\n    key=\"wilcoxon\",\n    key_added=\"wilcoxon_filtered\",\n)\n\nsc.pl.rank_genes_groups_dotplot(\n    cl1,\n    groupby=\"sample\",\n    standard_scale=\"var\",\n    n_genes=10,\n    key=\"wilcoxon_filtered\",\n    dendrogram=False,\n)\n\n\n\n\n\n\n\n\n닷플랏을 보면 분명 covid_17 샘플에서만 높게 발현되는 유전자의 패턴이 보입니다. 이상하군요. 각 샘플의 수를 확인해보죠.\n\ncl1.obs[\"sample\"].value_counts()\n\nsample\nctrl_14     146\nctrl_13     132\ncovid_17    101\nctrl_5       93\ncovid_15     70\ncovid_1      37\nctrl_19      34\ncovid_16      9\nName: count, dtype: int64\n\n\n위 출력을 보면 다른 환자에 비해 covid_17 환자의 샘플 수가 현저히 많아서 발생한 현상이라는 것을 알 수 있습니다.\n\n5.4.1 다운 샘플링\nDEG 분석을 할때 반드시 고려해야 할 사항은 샘플당 동일한 갯수의 세포를 사용해야 결과가 단일 샘플에 의해 영향받지 않는다는 것입니다. 따라서 이 경우에는 모든 샘플을 34개의 세포로 다운 샘플링합니다.\n\ntarget_cells = 37\n\ntmp = [cl1[cl1.obs[\"sample\"] == s] for s in cl1.obs[\"sample\"].cat.categories]\n\nfor dat in tmp:\n    if dat.n_obs &gt; target_cells:\n        sc.pp.subsample(dat, n_obs=target_cells)\n\ncl1_sub = tmp[0].concatenate(*tmp[1:])\n\ncl1_sub.obs[\"sample\"].value_counts()\n\nsample\ncovid_1     37\ncovid_15    37\ncovid_17    37\nctrl_5      37\nctrl_13     37\nctrl_14     37\nctrl_19     34\ncovid_16     9\nName: count, dtype: int64\n\n\n\nsc.tl.rank_genes_groups(cl1_sub, \"type\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(cl1_sub, n_genes=25, sharey=False, key=\"wilcoxon\")\n\n\n\n\n\n\n\n\n\nsc.tl.filter_rank_genes_groups(\n    cl1_sub,\n    key=\"wilcoxon\",\n    key_added=\"wilcoxon_filtered\",\n)\n\nsc.pl.rank_genes_groups_dotplot(\n    cl1_sub,\n    groupby=\"sample\",\n    standard_scale=\"var\",\n    n_genes=10,\n    key=\"wilcoxon_filtered\",\n    dendrogram=False,\n)\n\n\n\n\n\n\n\n\n훨씬 나아졌습니다. 하지만 여전히 한 환자에 의해 지배되는 일부 유전자가 있다는 것을 알 수 있습니다.\n이런 샘플의 배치 효과 문제를 해결하는 방법에는 여러 가지가 있지만 여기서는 다루지 않습니다. 자세한 것은 sc-best-practice을 참고하세요."
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html",
    "href": "posts/ipynb/tool_R_ggpubr.html",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "",
    "text": "모든 내용은 공식문서에서 간추린 것입니다. 자세한것은 공식문서를 읽어주세요.\nggpubr은 ggplot2에 기반한 R 패키지입니다. 연구자들이 쉽게 높은 질의 도표를 그리는 것을 목표로 하고 있는 시각화 패키지죠. 주요 특징은 다음과 같습니다:\n\nggplot2 패키지를 기반으로해서 좀 더 명확한 문법으로 보다 쉽게 사용할 수 있습니다.\nR 언어를 잘 모르더라도 높은 질의 도표를 만들수 있습니다.\n자동으로 p-values 나 통계적 유의성을 표시할 할 수 있습니다.\n여러 도표를 한 페이지에 배열 할 수 있는 기능을 가지고 있습니다.\n레이블이나 색상을 쉽게 변경할 수 있습니다.\n\n먼저 ggpubr 로 시각화를 하는 간단한 방법을 살펴보고, 이후에 다양한 예시 도표를 보여드리겠습니다."
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#데이터-불러오기",
    "href": "posts/ipynb/tool_R_ggpubr.html#데이터-불러오기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "4.1 3.1. 데이터 불러오기",
    "text": "4.1 3.1. 데이터 불러오기\n\n# 필요한  패키지 불러오기\n# suppressPackageStartupMessages(library(tidyverse))\nlibrary(\"dplyr\") \nlibrary(\"ggpubr\")\noptions(warn=-1) # 경고메세지 무시하기\n\ndata(\"ToothGrowth\") # 예제 데이터 불러오기\nhead(ToothGrowth,4) # 데이터 테이블 확인\n\n\n\n\nlen\nsupp\ndose\n\n\n\n\n4.2\nVC\n0.5\n\n\n11.5\nVC\n0.5\n\n\n7.3\nVC\n0.5\n\n\n5.8\nVC\n0.5"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#시각화-설정하기",
    "href": "posts/ipynb/tool_R_ggpubr.html#시각화-설정하기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "4.2 3.2. 시각화 설정하기",
    "text": "4.2 3.2. 시각화 설정하기\n\noptions(repr.plot.width = 6, repr.plot.height = 4)\n\nggline(ToothGrowth, x = \"dose\", y = \"len\", add = \"mean_se\", # 각각의 축설정 \n      color = \"supp\", palette = \"npg\")+  # 색상 설정하기\n      stat_compare_means(aes(group = supp), label = \"p.signif\", label.y = c(16, 25, 29)) + # 통계적 유의성 표시\n      labs(list(x = 'Dose', y = 'Length', fill = 'Supp')) # 레이블 변경"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#한페이지에-여러-도표-넣기",
    "href": "posts/ipynb/tool_R_ggpubr.html#한페이지에-여러-도표-넣기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "4.3 3.3. 한페이지에 여러 도표 넣기",
    "text": "4.3 3.3. 한페이지에 여러 도표 넣기\n여러 도표를 한페이지에 넣는 기능은 ggarrange()입니다. cowplot의 plot_grid()함수에 기반하고 있죠. 그래서 사용법도 동일합니다. 아래의 예시 코드를 확인하세요.\nggarrange(a, b, c ,  \n          labels = c(\"A\", \"B\", \"C\"),\n          ncol = 2, nrow = 2)"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#분포distribution-시각화",
    "href": "posts/ipynb/tool_R_ggpubr.html#분포distribution-시각화",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "5.1 4.1. 분포(Distribution) 시각화",
    "text": "5.1 4.1. 분포(Distribution) 시각화\n\n# 예제 데이터 만들기\nset.seed(1234)\nwdata = data.frame(\n   sex = factor(rep(c(\"F\", \"M\"), each=200)),\n   weight = c(rnorm(200, 55), rnorm(200, 58)))\nhead(wdata, 4)\n\n\n\n\nsex\nweight\n\n\n\n\nF\n53.79293\n\n\nF\n55.27743\n\n\nF\n56.08444\n\n\nF\n52.65430\n\n\n\n\n\n\na1 &lt;- ggdensity(wdata, x = \"weight\",\n   add = \"mean\", rug = TRUE, # Density plot with mean lines and marginal rug\n   color = \"sex\", fill = \"sex\",  # Change outline and fill colors by groups (\"sex\")\n   palette = c(\"#00AFBB\", \"#E7B800\")) # Use custom palette\n\na2 &lt;- gghistogram(wdata, x = \"weight\",\n   add = \"mean\", rug = TRUE,\n   color = \"sex\", fill = \"sex\",\n   palette = c(\"#00AFBB\", \"#E7B800\"))\n\na3 &lt;- ggdensity(wdata, x = \"weight\",\n   add = \"mean\", rug = TRUE,\n   fill = \"lightgray\")\n\n# Combine histogram and density plots\na4 &lt;-  gghistogram(wdata, x = \"weight\",\n   add = \"mean\", rug = FALSE,\n   fill = \"sex\", palette = c(\"#00AFBB\", \"#E7B800\"),\n   add_density = TRUE)\n\n# 한페이지에 넣기\nggarrange(a1, a2, a3 , a4,\n          labels = c(\"A\", \"B\", \"C\", \"D\"),\n          ncol = 2, nrow = 2)"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#막대-그래프bar-plots",
    "href": "posts/ipynb/tool_R_ggpubr.html#막대-그래프bar-plots",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "6.1 4.3. 막대 그래프(Bar plots)",
    "text": "6.1 4.3. 막대 그래프(Bar plots)\n\n6.1.1 4.3.1 간단한 막대 그래프\n\n# example Data\ndf &lt;- data.frame(dose=c(\"D0.5\", \"D1\", \"D2\"),\n   len=c(4.2, 10, 29.5))\ndf2 &lt;- data.frame(supp=rep(c(\"VC\", \"OJ\"), each=3),\n   dose=rep(c(\"D0.5\", \"D1\", \"D2\"),2),\n   len=c(6.8, 15, 33, 4.2, 10, 29.5))\ndf3 &lt;- ToothGrowth\n\n# Change position: Interleaved (dodged) bar plot\np1 &lt;- ggbarplot(df2, \"dose\", \"len\",\n        fill = \"supp\", color = \"supp\", palette = \"Paired\",\n        position = position_dodge(0.8))\n\n# Change fill and outline color add labels inside bars\np2 &lt;- ggbarplot(df, \"dose\", \"len\",\n        fill = \"dose\", color = \"dose\",\n        palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n        label = TRUE, lab.pos = \"in\", lab.col = \"white\")\n\n# Add jitter points and errors (mean_se)\np3 &lt;- ggbarplot(df3, x = \"dose\", y = \"len\",\n        add = c(\"mean_se\", \"jitter\"))\n\n# Multiple groups with error bars and jitter point\np4 &lt;- ggbarplot(df3, x = \"dose\", y = \"len\", color = \"supp\",\n         add = \"mean_se\", palette = c(\"#00AFBB\", \"#E7B800\"),\n         position = position_dodge(0.8))\n\nggarrange(p1, p2, p3, p4,\n          labels = c(\"A\", \"B\", \"C\", \"D\"),\n          ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.1.2 4.3.2 정돈된(Ordered) 바 그래프\ncyl에 따라서 그룹화하고, 전체적으로 정렬한 그래프(A)와 그룹별로 정렬한 그래프(B)의 시각화입니다.\n\n# 샘플 데이터 불러오기\ndata(\"mtcars\")\ndfm &lt;- mtcars\ndfm$cyl &lt;- as.factor(dfm$cyl) # Convert the cyl variable to a factor\ndfm$name &lt;- rownames(dfm) # Add the name colums\nhead(dfm[, c(\"name\", \"wt\", \"mpg\", \"cyl\")]) # 데이터 살펴보기\n\n\n\n\n\nname\nwt\nmpg\ncyl\n\n\n\n\nMazda RX4\nMazda RX4\n2.620\n21.0\n6\n\n\nMazda RX4 Wag\nMazda RX4 Wag\n2.875\n21.0\n6\n\n\nDatsun 710\nDatsun 710\n2.320\n22.8\n4\n\n\nHornet 4 Drive\nHornet 4 Drive\n3.215\n21.4\n6\n\n\nHornet Sportabout\nHornet Sportabout\n3.440\n18.7\n8\n\n\nValiant\nValiant\n3.460\n18.1\n6\n\n\n\n\n\n\na1 &lt;- ggbarplot(dfm, x = \"name\", y = \"mpg\",\n          fill = \"cyl\",               # change fill color by cyl\n          color = \"white\",            # Set bar border colors to white\n          palette = \"jco\",            # jco journal color palett. see ?ggpar\n          sort.val = \"desc\",          # Sort the value in dscending order\n          sort.by.groups = FALSE,     # Don't sort inside each group\n          x.text.angle = 90)           # Rotate vertically x axis texts\n\na2 &lt;- ggbarplot(dfm, x = \"name\", y = \"mpg\",\n          fill = \"cyl\",               # change fill color by cyl\n          color = \"white\",            # Set bar border colors to white\n          palette = \"jco\",            # jco journal color palett. see ?ggpar\n          sort.val = \"asc\",           # Sort the value in dscending order\n          sort.by.groups = TRUE,      # Sort inside each group\n          x.text.angle = 90)           # Rotate vertically x axis texts\n\nggarrange(a1, a2,\n          labels = c(\"A\", \"B\"),\n          ncol = 1, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.1.3 4.3.3. 편차(Deviation) 그래프\n편차(deviation) 그래프는 각각의 값들이 평균값 대비 얼마나 차이가 나는지를 시각화 합니다. 여기서는 연비 평균값에 비교해서 각 차량의 편차가 얼마인지 계산해(Z-score) 도표를 그려보겠습니다.\n\n# Calculate the z-score of the mpg data\ndfm$mpg_z &lt;- (dfm$mpg -mean(dfm$mpg))/sd(dfm$mpg)\ndfm$mpg_grp &lt;- factor(ifelse(dfm$mpg_z &lt; 0, \"low\", \"high\"), \n                     levels = c(\"low\", \"high\"))\n# Inspect the data\nhead(dfm[, c(\"name\", \"wt\", \"mpg\", \"mpg_z\", \"mpg_grp\", \"cyl\")])\n\n\n\n\n\nname\nwt\nmpg\nmpg_z\nmpg_grp\ncyl\n\n\n\n\nMazda RX4\nMazda RX4\n2.620\n21.0\n0.1508848\nhigh\n6\n\n\nMazda RX4 Wag\nMazda RX4 Wag\n2.875\n21.0\n0.1508848\nhigh\n6\n\n\nDatsun 710\nDatsun 710\n2.320\n22.8\n0.4495434\nhigh\n4\n\n\nHornet 4 Drive\nHornet 4 Drive\n3.215\n21.4\n0.2172534\nhigh\n6\n\n\nHornet Sportabout\nHornet Sportabout\n3.440\n18.7\n-0.2307345\nlow\n8\n\n\nValiant\nValiant\n3.460\n18.1\n-0.3302874\nlow\n6\n\n\n\n\n\n\n# Create an ordered bar plot, colored according to the level of mpg:\nggbarplot(dfm, x = \"name\", y = \"mpg_z\",\n          fill = \"mpg_grp\",           # change fill color by mpg_level\n          color = \"white\",            # Set bar border colors to white\n          palette = \"jco\",            # jco journal color palett. see ?ggpar\n          sort.val = \"desc\",          # Sort the value in descending order\n          sort.by.groups = FALSE,     # Don't sort inside each group\n          x.text.angle = 90,          # Rotate vertically x axis texts\n          ylab = \"MPG z-score\",\n          legend.title = \"MPG Group\",\n          rotate = TRUE,\n          ggtheme = theme_minimal())"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#막대사탕lollipop-plot",
    "href": "posts/ipynb/tool_R_ggpubr.html#막대사탕lollipop-plot",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.1 4.4.1 막대사탕(Lollipop) plot",
    "text": "7.1 4.4.1 막대사탕(Lollipop) plot\n막대사탕 그래프는 많은 양의 데이터를 시각화하는데 적합합니다. 아래 예시에서는 cyl 그룹에 맞춰서 색상을 구분하였습니다.\n\nggdotchart(dfm, x = \"name\", y = \"mpg\",\n           color = \"cyl\",                                # Color by groups\n           palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # Custom color palette\n           sorting = \"descending\",                       # Sort value in descending order\n           add = \"segments\",                             # Add segments from y = 0 to dots\n           rotate = TRUE,                                # Rotate vertically\n           group = \"cyl\",                                # Order by groups\n           dot.size = 6,                                 # Large dot size\n           label = round(dfm$mpg),                        # Add mpg values as dot labels\n           font.label = list(color = \"white\", size = 9, \n           vjust = 0.5),               # Adjust label parameters\n           ggtheme = theme_pubr())                        # ggplot2 theme"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#도표에-설명figure-legend-넣기",
    "href": "posts/ipynb/tool_R_ggpubr.html#도표에-설명figure-legend-넣기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.2 4.5. 도표에 설명(figure legend) 넣기",
    "text": "7.2 4.5. 도표에 설명(figure legend) 넣기\n도표 밑에 설명을 넣는 방법입니다. 한줄단위로 내용을 끊어서 작성해야, 산출물에서 줄이 잘 맞게 할 수 있습니다. 아래의 예시 코드를 확인하세요.\nggparagraph(text, color = NULL, size = NULL, face = NULL, family = NULL,\n  lineheight = NULL)\n# S3 method for splitText\ndrawDetails(x, recording)\n\n# Density plot\ndensity.p &lt;- ggdensity(iris, x = \"Sepal.Length\",\n                      fill = \"Species\", palette = \"jco\")\n# Text plot\ntext &lt;- paste(\"Iris data set gives the measurements in cm\",\n             \"of the variables sepal length and width\",\n             \"and petal length and width, respectively,\",\n             \"for 50 flowers from each of 3 species of iris.\",\n             \"The species are Iris setosa, versicolor, and virginica.\", sep = \" \")\ntext.p &lt;- ggparagraph(text, face = \"italic\", size = 12)\n\n# Arrange the plots on the same page\nggarrange(density.p, text.p,\n         ncol = 1, nrow = 2,\n         heights = c(1, 0.3))"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#선-그래프",
    "href": "posts/ipynb/tool_R_ggpubr.html#선-그래프",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.3 4.6. 선 그래프",
    "text": "7.3 4.6. 선 그래프\n\n# Data: ToothGrowth data set we'll be used.\ndf3 &lt;- ToothGrowth\n# Add error bars: mean_se\n# (other values include: mean_sd, mean_ci, median_iqr, ....)\n# Add labels\np1 &lt;- ggline(df3, x = \"dose\", y = \"len\", add = \"mean_se\")\n# Add jitter points and errors (mean_se)\np2 &lt;- ggline(df3, x = \"dose\", y = \"len\",\n add = c(\"mean_se\",'jitter'))\n# Multiple groups with error bars\np3 &lt;- ggline(df3, x = \"dose\", y = \"len\", color = \"supp\",\n add = \"mean_se\", palette = c(\"#00AFBB\", \"#FC4E07\"))\n\nggarrange(p1, p2, p3,\n          labels = c(\"A\", \"B\", \"C\"),\n          ncol = 2, nrow = 2)"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#히스토그램과-산포도scatter-plot-with-histograms",
    "href": "posts/ipynb/tool_R_ggpubr.html#히스토그램과-산포도scatter-plot-with-histograms",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.4 4.7. 히스토그램과 산포도(Scatter Plot with Histograms)",
    "text": "7.4 4.7. 히스토그램과 산포도(Scatter Plot with Histograms)\n히스토그램과 산포도를 하나의 도표에 합쳐서 그려보도록 하겠습니다.\n\n# Grouped data\nggscatterhist(\n iris, x = \"Sepal.Length\", y = \"Sepal.Width\",\n color = \"Species\", size = 3, alpha = 0.6,\n palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n margin.params = list(fill = \"Species\", color = \"black\", size = 0.2))"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#상관분석correlation-coefficients과-p-values-추가하기",
    "href": "posts/ipynb/tool_R_ggpubr.html#상관분석correlation-coefficients과-p-values-추가하기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.5 4.8. 상관분석(Correlation Coefficients)과 P-values 추가하기",
    "text": "7.5 4.8. 상관분석(Correlation Coefficients)과 P-values 추가하기\n산포도에 상관분석과 p-values를 추가하는 방법입니다.\n\n# Load data\ndata(\"mtcars\")\ndf &lt;- mtcars\ndf$cyl &lt;- as.factor(df$cyl)\n\n# Scatter plot with correlation coefficient\nsp &lt;- ggscatter(df, x = \"wt\", y = \"mpg\",\n   add = \"reg.line\",  # Add regressin line\n   add.params = list(color = \"blue\", fill = \"lightgray\"), # Customize reg. line\n   conf.int = TRUE) # Add confidence interval\n# Add correlation coefficient\np1 &lt;- sp + stat_cor(method = \"pearson\", label.x = 3, label.y = 30)\n# Color by groups and facet\nsp &lt;- ggscatter(df, x = \"wt\", y = \"mpg\",\n   color = \"cyl\", palette = \"jco\",\n   add = \"reg.line\", conf.int = TRUE)\np2 &lt;- sp + stat_cor(aes(color = cyl), label.x = 3)\n# Scatter plot with ellipses and group mean points\np3 &lt;- ggscatter(df, x = \"wt\", y = \"mpg\",\n   color = \"cyl\", shape = \"cyl\",\n   mean.point = TRUE, ellipse = TRUE)+\n   stat_stars(aes(color = cyl))\n\nggarrange(p1, p2, p3,\n          labels = c(\"A\", \"B\", \"C\"),\n          ncol = 2, nrow = 2)"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#plot-paired-data",
    "href": "posts/ipynb/tool_R_ggpubr.html#plot-paired-data",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.6 4.9. Plot Paired Data",
    "text": "7.6 4.9. Plot Paired Data\n\n# Example data\nbefore &lt;-c(200.1, 190.9, 192.7, 213, 241.4, 196.9, 172.2, 185.5, 205.2, 193.7)\nafter &lt;-c(392.9, 393.2, 345.1, 393, 434, 427.9, 422, 383.9, 392.3, 352.2)\n\nd &lt;- data.frame(before = before, after = after)\np1 &lt;- ggpaired(d, cond1 = \"before\", cond2 = \"after\", width = 0.0,\n    line.color = \"gray\", line.size = 0.4, palette = \"npg\")\np2 &lt;- ggpaired(d, cond1 = \"before\", cond2 = \"after\", width = 0.2,\n    line.color = \"gray\", line.size = 0.4, palette = \"aaas\")\np3 &lt;- ggpaired(d, cond1 = \"before\", cond2 = \"after\", width = 0.2,\n    line.color = \"gray\", line.size = 0.4, fill = \"condition\",palette = \"npg\")\nggarrange(p1, p2, p3,\n          labels = c(\"A\", \"B\", \"C\"),\n          ncol = 2, nrow = 2)"
  },
  {
    "objectID": "posts/ipynb/tool_R_ggpubr.html#p-values-를-박스-그래프에-추가하기",
    "href": "posts/ipynb/tool_R_ggpubr.html#p-values-를-박스-그래프에-추가하기",
    "title": "ggpubr로 논문에 사용할 플랏그리기",
    "section": "7.7 4.10. P-values 를 박스 그래프에 추가하기",
    "text": "7.7 4.10. P-values 를 박스 그래프에 추가하기\n\n# Load data\ndata(\"ToothGrowth\")\nhead(ToothGrowth)\n\n\n\n\nlen\nsupp\ndose\n\n\n\n\n4.2\nVC\n0.5\n\n\n11.5\nVC\n0.5\n\n\n7.3\nVC\n0.5\n\n\n5.8\nVC\n0.5\n\n\n6.4\nVC\n0.5\n\n\n10.0\nVC\n0.5\n\n\n\n\n\n\n# Two independent groups\np &lt;- ggboxplot(ToothGrowth, x = \"supp\", y = \"len\",\n    color = \"supp\", palette = \"npg\", add = \"jitter\")\n\n#  Add p-value\np1 &lt;- p + stat_compare_means(method = \"t.test\")\n\n# Paired samples\np2 &lt;- ggpaired(ToothGrowth, x = \"supp\", y = \"len\",\n    color = \"supp\", line.color = \"gray\", line.size = 0.4,\n    palette = \"npg\")+\n    stat_compare_means(paired = TRUE, method = \"t.test\")\n\n# More than two groups, Pairwise comparisons: Specify the comparisons you want\nmy_comparisons &lt;- list( c(\"0.5\", \"1\"), c(\"1\", \"2\"), c(\"0.5\", \"2\") )\np3 &lt;- ggboxplot(ToothGrowth, x = \"dose\", y = \"len\",\n          color = \"dose\", palette = \"npg\")+\n# Add pairwise comparisons p-value\n    stat_compare_means(comparisons = my_comparisons, label.y = c(29, 35, 40))+\n    stat_compare_means(label.y = 45)     # Add global Anova p-value\n\n# Multiple pairwise test against a reference group\np4 &lt;- ggboxplot(ToothGrowth, x = \"dose\", y = \"len\",\n    color = \"dose\", palette = \"npg\")+\n    stat_compare_means(method = \"anova\", label.y = 40)+ # Add global p-value\n    stat_compare_means(aes(label = ..p.signif..),\n                      method = \"t.test\", ref.group = \"0.5\")\n\nggarrange(p1, p2, p3, p4,  ncol = 2, nrow = 2,\n          labels = c(\"A\", \"B\",\"C\",\"D\"))\n\n\n\n\n\n\n\n\n\n\n\n\n# Multiple grouping variables\np &lt;- ggboxplot(ToothGrowth, x = \"supp\", y = \"len\",\n              color = \"supp\", palette = \"npg\",\n              add = \"jitter\",\n              facet.by = \"dose\", short.panel.labs = FALSE)\n# Use only p.format as label. Remove method name.\np5 &lt;- p + stat_compare_means(aes(label = paste0(\"p = \", ..p.format..)))\np5"
  },
  {
    "objectID": "posts/ipynb/da_statistics_decision.html",
    "href": "posts/ipynb/da_statistics_decision.html",
    "title": "데이터 기반 의사 결정을 위한 시각화",
    "section": "",
    "text": "이번 글에서는 데이터 기반 의사 결정(Data-Driven Decision Making)에 대해 이야기해 보려고 합니다. 데이터 기반 의사 결정은 객관적인 데이터를 분석하고 해석하여 결정을 내리는 방식으로 직관이나 경험에 의존하는 것보다 더욱 합리적인 판단을 가능하게 하여 연구 및 비즈니스 분야에서 그 중요성이 점점 커지고 있습니다.\n하지만 실제 데이터를 수집하다 보면 변수(차원)가 지나치게 많아져 어떤 변수가 실제로 중요한 영향을 미치는지 파악하기 어려울 때가 많습니다. 이럴 때는 고차원 데이터의 차원을 축소하여 시각화하면 숨겨진 패턴을 발견하고 의사 결정에 도움을 얻을 수 있습니다. 따라서 이번 글에서는 항체 후보 물질 분석 사례를 통해 데이터 기반 의사 결정 시 시각화가 어떻게 기여하는지 구체적으로 살펴보겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_decision.html#예시-데이터-생성",
    "href": "posts/ipynb/da_statistics_decision.html#예시-데이터-생성",
    "title": "데이터 기반 의사 결정을 위한 시각화",
    "section": "1.1 예시 데이터 생성",
    "text": "1.1 예시 데이터 생성\n우선 예시 데이터를 임의로 생성하겠습니다. 실제로는 실험을 통해 데이터를 얻어야 합니다. 그런 다음 데이터 분석 시 분석 결과의 편향을 방지하기 위해 각 데이터를 정규화하는 과정이 필요합니다. 이는 수집된 데이터의 종류에 따라 값의 범위가 다르기 때문에 발생하는 문제를 해결하기 위함입니다.\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster.hierarchy import fcluster, linkage, to_tree\nfrom scipy.spatial.distance import pdist\n\nnord_colors = [\"#BF616A\", \"#D08770\", \"#EBCB8B\", \"#A3BE8C\", \"#B48EAD\"]\n\n\ndef generate_candidate_dataframe(num_candidates):\n    \"\"\"주어진 개수의 후보 물질에 대한 가짜 데이터를 생성하고 DataFrame을 반환합니다.\"\"\"\n\n    candidates = [f\"mAb{i}\" for i in range(1, num_candidates + 1)]\n\n    data = {\n        \"SEC_main\": np.random.normal(loc=10, scale=2, size=num_candidates),\n        \"SEC_RT\": np.random.normal(loc=5, scale=1, size=num_candidates),\n        \"pI\": np.random.uniform(low=4, high=9, size=num_candidates),\n        \"HIC_RT\": np.random.normal(loc=7, scale=1.5, size=num_candidates),\n        \"AC_SIN_Ace\": np.random.normal(loc=0.5, scale=0.1, size=num_candidates),\n        \"AC_SINS_PBS\": np.random.normal(loc=0.7, scale=0.1, size=num_candidates),\n        \"PSR\": np.random.normal(loc=100, scale=15, size=num_candidates),\n        \"ELISA\": np.random.normal(loc=200, scale=30, size=num_candidates),\n        \"BVP\": np.random.normal(loc=0.8, scale=0.2, size=num_candidates),\n        \"Tm\": np.random.normal(loc=70, scale=5, size=num_candidates),\n        \"Tagg\": np.random.normal(loc=75, scale=6, size=num_candidates),\n        \"DSR\": np.random.normal(loc=0.3, scale=0.05, size=num_candidates),\n        \"KD\": np.random.normal(loc=1e-9, scale=1e-10, size=num_candidates),\n        \"CE_SDS\": np.random.normal(loc=1, scale=0.2, size=num_candidates),\n        \"Titer\": np.random.normal(loc=5, scale=1, size=num_candidates),\n    }\n\n    return pd.DataFrame(data, index=candidates)\n\n\n# 데이터프레임 생성\ndf = generate_candidate_dataframe(24)\ndf.head()\n\n\n\n\n\n\n\n\nSEC_main\nSEC_RT\npI\nHIC_RT\nAC_SIN_Ace\nAC_SINS_PBS\nPSR\nELISA\nBVP\nTm\nTagg\nDSR\nKD\nCE_SDS\nTiter\n\n\n\n\nmAb1\n7.716622\n4.533963\n6.248699\n7.440337\n0.561915\n0.711327\n84.064097\n225.218601\n0.974259\n71.659902\n74.373305\n0.287697\n1.031917e-09\n1.322444\n3.856274\n\n\nmAb2\n9.612681\n3.405297\n7.883553\n4.965127\n0.705750\n0.556172\n106.424606\n216.402007\n0.530804\n70.952498\n73.987070\n0.257838\n1.134045e-09\n1.179368\n5.108560\n\n\nmAb3\n8.566355\n5.513600\n4.326831\n7.699645\n0.502079\n0.791923\n97.192836\n192.832037\n0.825276\n73.547259\n75.420313\n0.408547\n8.124828e-10\n0.946294\n4.966770\n\n\nmAb4\n6.266927\n4.467299\n6.437856\n6.946538\n0.427200\n0.633186\n114.785950\n188.995268\n1.187786\n67.822568\n81.971270\n0.291206\n1.011503e-09\n0.821762\n4.791883\n\n\nmAb5\n9.834639\n3.830083\n4.168068\n4.577302\n0.481710\n0.887330\n117.810791\n188.247256\n0.599934\n72.565529\n69.435881\n0.306160\n9.839867e-10\n0.569637\n4.871462\n\n\n\n\n\n\n\n앞서 제시된 테이블을 보면 각 후보 항체에 대해 다양한 실험을 통해 얻은 데이터 값들이 나열되어 있는 것을 확인할 수 있습니다. 이때 어떤 항체가 우리가 원하는 특성을 갖추고 있는지 명확히 판단하기 어렵다는 점을 쉽게 이해하실 수 있을 겁니다. 그 이유는 첫째, 모든 면에서 완벽한 값을 나타내는 후보 물질은 존재하지 않기 때문이고 둘째, 어떤 특성 값이 가장 중요한지를 우리가 아직 정확히 알지 못하기 때문입니다."
  },
  {
    "objectID": "posts/ipynb/da_statistics_decision.html#데이터-분석-및-시각화",
    "href": "posts/ipynb/da_statistics_decision.html#데이터-분석-및-시각화",
    "title": "데이터 기반 의사 결정을 위한 시각화",
    "section": "1.2 데이터 분석 및 시각화",
    "text": "1.2 데이터 분석 및 시각화\n분석 결과를 덴드로그램이나 네트워크 그래프와 같은 시각적인 형태로 표현하여 후보 물질들 간의 유사성을 직관적으로 파악할 수 있도록 돕습니다. 아래 코드를 통해 예시 데이터를 분석하고 시각화를 해보겠습니다.\n\n# 데이터 정규화\ndf_normalized = (df - df.min()) / (df.max() - df.min())\n\n# 거리 행렬 계산\ndistance_matrix = pdist(df_normalized, metric=\"euclidean\")\n\n# 계층적 군집화를 통해 트리 생성\nlinkage_matrix = linkage(distance_matrix, method=\"average\")\n\n# 클러스터 할당 (5개의 주요 그룹으로 분할)\nclusters = fcluster(linkage_matrix, t=5, criterion=\"maxclust\")\ncandidates = df.index.tolist()\nlabel_colors = {\n    candidates[i]: nord_colors[clusters[i] % len(nord_colors)] for i in range(len(candidates))\n}\n\n# 트리를 NetworkX 그래프로 변환\nroot, nodes = to_tree(linkage_matrix, rd=True)\nG = nx.Graph()\n\n\ndef add_edges(node, parent=None):\n    if node is not None:\n        G.add_node(node.id, label=candidates[node.id] if node.id &lt; len(candidates) else \"\")\n        if parent is not None:\n            G.add_edge(parent.id, node.id)\n        add_edges(node.left, node)\n        add_edges(node.right, node)\n\n\nadd_edges(root)\n\n# 그래프 시각화\nfig, ax = plt.subplots(figsize=(5, 4))\nax.axis(\"off\")\npos = nx.kamada_kawai_layout(G)\nnx.draw_networkx_edges(G, pos, ax=ax)\n\n# 노드 라벨 추가 (색상 적용)\nlabels = {n: G.nodes[n][\"label\"] for n in G.nodes if G.nodes[n][\"label\"]}\nfor n in labels:\n    plt.text(\n        pos[n][0],\n        pos[n][1],\n        labels[n],\n        fontsize=8,\n        color=label_colors.get(labels[n], \"black\"),\n        bbox={\"facecolor\": \"white\", \"edgecolor\": \"none\", \"boxstyle\": \"round,pad=0.2\"},\n    )\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n다양한 실험 결과를 테이블 형태로 보는 것은 정보를 얻는 데 도움이 되지만, 많은 정보를 한눈에 파악하기는 쉽지 않습니다. 하지만 앞선 예시에서처럼 데이터를 시각화하면 후보 항체들이 어떤 무리(클러스터)를 형성하고 있는지 직관적으로 확인할 수 있습니다. 시각화는 데이터를 효과적으로 요약하여 다음과 같은 유용한 정보를 제공합니다.\n\n유사성 파악: 어떤 후보 항체들이 서로 비슷한 특성을 나타내는지 시각적으로 보여주어 그룹별 특징을 분석하는 데 용이합니다.\n이상치 식별: 다른 후보 항체들과 뚜렷하게 구별되는 특성을 가진 이상치를 발견하고, 이에 대한 추가적인 분석이나 실험을 진행할 수 있습니다.\n선택 근거 제시: 시각화된 결과를 통해 최종 후보 선택의 타당한 근거를 명확하게 제시할 수 있습니다. 예를 들어, 특정 그룹에 속한 후보 항체들이 높은 결합력과 뛰어난 안정성을 보인다는 점을 시각적으로 보여줄 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_05.html",
    "href": "posts/ipynb/da_scanpy_workshop_05.html",
    "title": "Scanpy로 scRNA-seq 분석 05",
    "section": "",
    "text": "클러스터링으로 scRNA-seq 데이터를 여러 그룹으로 나눈 뒤에는 해당 그룹이 어떤 세포인지 아는 것은 분석 결과를 해석할 때 중요합니다. 세포 유형을 예측하는 방법에는 크게 두 가지 방법이 있습니다. 레퍼런스 scRNA-seq 데이터를 사용해 유사도를 비교하는 방법과 알려진 마커 유전자를 사용해 직접 세포 유형을 지정하는 방법입니다. 레퍼런스 데이터는 이미 세포 유형의 전사체 표현 데이터를 말합니다. 이 데이터를 사용하여 클러스터링된 세포들의 전사체 표현 패턴을 레퍼런스 데이터와 비교하여 가장 유사한 세포 유형을 예측합니다. 여기서는 가장 간단한 ingest 방법을 사용해봅니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_05.html#over-representation-analysis-ora",
    "href": "posts/ipynb/da_scanpy_workshop_05.html#over-representation-analysis-ora",
    "title": "Scanpy로 scRNA-seq 분석 05",
    "section": "7.1 Over-representation analysis (ORA)",
    "text": "7.1 Over-representation analysis (ORA)\nORA는 주어진 유전자 목록에서 특정 기능이나 경로에 속하는 유전자들이 과발현 되는지를 평가하는 방법입니다. ORA는 특정 생물학적 기능이나 경로와 관련된 유전자들이 관심 있는 유전자 목록에서 통계적으로 유의미하게 많이 포함되어 있는지 확인합니다. 이를 통해 특정 생물학적 기능이나 경로가 실험 조건에서 중요한 역할을 하는지 파악할 수 있습니다. ORA을 하면 유의미성을 나타내는 p-value와 함께 과도하게 나타나는 유전자 집합 결과를 얻습니다. 다만 유전자 발현 수준이나 경로의 구조를 고려하지 않는다는 한계점이 있습니다.\n이제 예시로 코로나 환자의 DEG를 사용하여 면역 반응, 염증 경로, 바이러스 복제와 관련된 경로들이 유의미하게 변화하는지를 살펴보겠습니다.\n\nsc.tl.rank_genes_groups(adata, \"type\", method=\"wilcoxon\", key_added=\"wilcoxon\")\nsc.pl.rank_genes_groups(\n    adata,\n    n_genes=25,\n    sharey=False,\n    key=\"wilcoxon\",\n    ncols=3,\n)\n\n\n\n\n\n\n\n\n앞서 구한 DEG 목록을 gseapy에 넘겨서 ORA 분석을 진행합니다. 많이 사용되는 몇가지 데이터베이스 목록은 아래와 같습니다.\n\nGO_Biological_Process_2018\nKEGG_2019_Human\nKEGG_2019_Mouse\nWikiPathways_2019_Human\nWikiPathways_2019_Mouse\n\n\n# 가능한 데이터베이스 : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’\ngene_set_names = gseapy.get_library_name(organism=\"Human\")\n\n# ?gseapy.enrichr\nglist = (\n    sc.get.rank_genes_groups_df(\n        adata, group=\"Covid\", key=\"wilcoxon\", log2fc_min=0.25, pval_cutoff=0.05\n    )[\"names\"]\n    .squeeze()\n    .str.strip()\n    .tolist()\n)\n\n간단한 막대그래프를 사용해 결과를 시각화합니다.\n\ndef plot_ora(\n    glist,\n    gene_set=\"GO_Biological_Process_2018\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n):\n    enr_res = gseapy.enrichr(\n        gene_list=glist,\n        organism=\"Human\",\n        gene_sets=gene_set,\n        cutoff=0.5,\n    )\n    if truncate:\n        # True 시 뒤의 코드명 일부 제거.\n        enr_res.res2d[\"Term\"] = enr_res.res2d[\"Term\"].apply(lambda x: \" \".join(x.split(\" \")[:-1]))\n    ax = gseapy.barplot(\n        enr_res.res2d,\n        title=gene_set,\n        figsize=size,\n        color=color,\n    )\n    ax.grid(False)\n    return ax\n\n\nax = plot_ora(\n    glist,\n    gene_set=\"GO_Biological_Process_2018\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n)\nplt.show()\n\n\n\n\n\n\n\n\n\nax = plot_ora(glist, gene_set=\"KEGG_2019_Human\", size=(5, 4), color=\"darkred\", truncate=False)\nplt.show()\n\n\n\n\n\n\n\n\n\nax = plot_ora(\n    glist,\n    gene_set=\"WikiPathways_2019_Human\",\n    size=(4, 4),\n    color=\"darkred\",\n    truncate=True,\n)\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_05.html#functional-class-scoring-fcs-분석",
    "href": "posts/ipynb/da_scanpy_workshop_05.html#functional-class-scoring-fcs-분석",
    "title": "Scanpy로 scRNA-seq 분석 05",
    "section": "7.2 Functional Class Scoring (FCS) 분석",
    "text": "7.2 Functional Class Scoring (FCS) 분석\nORA외에도 Functional Class Scoring(FCS) 분석을 진행 할 수 있습니다. FCS는 유전자 집합 내 발현 변화 또한 고려한 방법입니다. FCS 분석 중 유명한 방법이 유전자 세트 강화 분석(GSEA)입니다. GSEA는 각 유전자에 발현 변화(예: 로그 폴드 변화)를 기준으로 점수를 부여하고, 이 점수를 유전자 집합 내에서 합산하거나 평균을 구한 후, 무작위 분포(퍼뮤테이션 기반 또는 파라메트릭)와 비교합니다. 그 결과 (일반적으로 폴드 변화를 기반으로) 순위가 매겨진 유전자 목록을 점수화하고 순열 테스트를 계산하여 특정 유전자 세트가 상향 조절된 유전자에 더 많이 존재하는지, 하향 조절된 유전자에 더 많이 존재하는지, 아니면 차등 조절되지 않는지를 확인할 수 있습니다. 이 방법의 장점은 발현 수준을 고려하기 때문에 미묘한 효과도 포착할 수 있다는 것입니다. 다만 집합내 유전자들이 서로 독립이라는 가정해야 한다는 한계점이 있습니다.\nGSEA를 수행하기 위해서는 모든 차등 발현 유전자(DEG)와 그 로그 폴드 체인지를 포함한 테이블이 필요합니다.\n\n# Available databases : ‘Human’, ‘Mouse’, ‘Yeast’, ‘Fly’, ‘Fish’, ‘Worm’\ngene_set_names = gseapy.get_library_name(organism=\"Human\")\n\ngene_rank = sc.get.rank_genes_groups_df(adata, group=\"Covid\", key=\"wilcoxon\")[\n    [\"names\", \"logfoldchanges\"]\n]\ngene_rank.sort_values(by=[\"logfoldchanges\"], inplace=True, ascending=False)\n\n# 계산_qc_metrics는 유전자당 세포 수를 계산합니다.\nsc.pp.calculate_qc_metrics(adata, percent_top=None, log1p=False, inplace=True)\n\n# 최소 30개 이상의 세포에서 발현되는 유전자를 필터링합니다.\ngene_rank = gene_rank[gene_rank[\"names\"].isin(adata.var_names[adata.var.n_cells_by_counts &gt; 30])]\n\ngene_rank\n\n\n\n\n\n\n\n\nnames\nlogfoldchanges\n\n\n\n\n2800\nCCL7\n24.208344\n\n\n2868\nIL1A\n24.117874\n\n\n2360\nCYP19A1\n23.754789\n\n\n2903\nPRTN3\n23.376261\n\n\n1107\nNXF3\n9.236358\n\n\n...\n...\n...\n\n\n16567\nENHO\n-4.197762\n\n\n15497\nLYNX1\n-4.719684\n\n\n15466\nC5orf17\n-5.105195\n\n\n17113\nLYPD2\n-5.713926\n\n\n18516\nAC004556.1\n-26.306053\n\n\n\n\n13553 rows × 2 columns\n\n\n\n다음으로 GSEA를 실행합니다. 그러면 여러 경로에 대한 정보가 포함된 테이블이 생성됩니다. 이 테이블을 p-value 또는 정규화된 강화 점수(NES) 기준으로 정렬하고 필터링하여 상위 경로만 시각화할 수 있습니다. 이 분석은 실험 조건에서 중요한 역할을 하는 주요 경로를 식별하고 분석할 수 있습니다.\n\nres = gseapy.prerank(rnk=gene_rank, gene_sets=\"KEGG_2021_Human\")\n\nterms = res.res2d.Term\nprint(terms[:10])\n\n0                              IL-17 signaling pathway\n1                                 Rheumatoid arthritis\n2    Viral protein interaction with cytokine and cy...\n3               Cytokine-cytokine receptor interaction\n4    AGE-RAGE signaling pathway in diabetic complic...\n5                          Chemokine signaling pathway\n6                                           Amoebiasis\n7               Fluid shear stress and atherosclerosis\n8                           Osteoclast differentiation\n9                                            Pertussis\nName: Term, dtype: object\n\n\n\ngseapy.gseaplot(rank_metric=res.ranking, term=terms[0], **res.results[terms[0]])\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를 보면 KEGG 데이터베이스의 IL-17 signaling pathway 경로가 과발현 되어 있다는 것을 알 수있습니다. IL-17은 염증 반응을 조절하는 중요한 사이토카인입니다. 이 경로의 상향 조절은 강한 염증 반응을 나타내며, 면역계가 병원체와 싸우는 과정에서 중요한 역할을 합니다. 따라서 이런 경로의 상향 조절은 염증, 면역 반응, 감염 및 대사질환과 관련된 중요한 생물학적 변화를 시사합니다.\n마지막으로, 다른 분석을 위해 데이터를 저장해 보겠습니다.\n\nsave_file = \"./output/covid/results/scanpy_covid_annot.h5ad\"\nadata.write_h5ad(save_file, compression=\"gzip\")"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html",
    "href": "posts/ipynb/ml_autogluon_basics.html",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "",
    "text": "AWS AI가 개발한 AutoGluon은 머신러닝 작업을 자동화하여 애플리케이션에서 강력한 예측 성능을 쉽게 달성할 수 있도록 지원합니다. 단 몇 줄의 코드만으로 이미지, 텍스트, 시계열 및 테이블 형식 데이터에 대해 높은 정확도의 머신러닝 및 딥러닝 모델을 학습하고 배포할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#예제-데이터",
    "href": "posts/ipynb/ml_autogluon_basics.html#예제-데이터",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "2.1 예제 데이터",
    "text": "2.1 예제 데이터\n이 튜토리얼에서는 Nature 7887호의 커버 스토리인 수학 정리에 대한 AI 기반 직관의 데이터셋을 사용합니다. 목표는 매듭의 속성을 기반으로 매듭의 시그니처를 예측하는 것입니다. 원본 데이터에서 10K개의 학습 예제와 5K개의 테스트 예제를 샘플링했습니다. 샘플링된 데이터셋을 사용하면 이 튜토리얼을 빠르게 실행할 수 있지만, 원한다면 AutoGluon은 전체 데이터셋도 처리할 수 있습니다.\n이 데이터셋을 URL에서 직접 로드합니다. AutoGluon의 TabularDataset은 pandas DataFrame의 하위 클래스이므로 모든 DataFrame 메서드를 TabularDataset에서도 사용할 수 있습니다.\n\ndata_url = \"https://raw.githubusercontent.com/mli/ag-docs/main/knot_theory/\"\ntrain_data = TabularDataset(f\"{data_url}train.csv\")\ntrain_data.head()\n\n\n\n\n\n\n\n\nUnnamed: 0\nchern_simons\ncusp_volume\nhyperbolic_adjoint_torsion_degree\nhyperbolic_torsion_degree\ninjectivity_radius\nlongitudinal_translation\nmeridinal_translation_imag\nmeridinal_translation_real\nshort_geodesic_imag_part\nshort_geodesic_real_part\nSymmetry_0\nSymmetry_D3\nSymmetry_D4\nSymmetry_D6\nSymmetry_D8\nSymmetry_Z/2 + Z/2\nvolume\nsignature\n\n\n\n\n0\n70746\n0.090530\n12.226322\n0\n10\n0.507756\n10.685555\n1.144192\n-0.519157\n-2.760601\n1.015512\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n11.393225\n-2\n\n\n1\n240827\n0.232453\n13.800773\n0\n14\n0.413645\n10.453156\n1.320249\n-0.158522\n-3.013258\n0.827289\n0.0\n0.0\n0.0\n0.0\n0.0\n1.0\n12.742782\n0\n\n\n2\n155659\n-0.144099\n14.761030\n0\n14\n0.436928\n13.405199\n1.101142\n0.768894\n2.233106\n0.873856\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n15.236505\n2\n\n\n3\n239963\n-0.171668\n13.738019\n0\n22\n0.249481\n27.819496\n0.493827\n-1.188718\n-2.042771\n0.498961\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n17.279890\n-8\n\n\n4\n90504\n0.235188\n15.896359\n0\n10\n0.389329\n15.330971\n1.036879\n0.722828\n-3.056138\n0.778658\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n16.749298\n4\n\n\n\n\n\n\n\n우리의 목표는 18개의 고유한 정수를 가진 “signature” 열에 저장됩니다. pandas가 이 데이터 유형을 범주형으로 올바르게 인식하지 못했지만 AutoGluon이 이 문제를 해결할 것입니다.\n\nlabel = \"signature\"\ntrain_data[label].describe()\n\ncount    10000.000000\nmean        -0.022000\nstd          3.025166\nmin        -12.000000\n25%         -2.000000\n50%          0.000000\n75%          2.000000\nmax         12.000000\nName: signature, dtype: float64"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#학습",
    "href": "posts/ipynb/ml_autogluon_basics.html#학습",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "2.2 학습",
    "text": "2.2 학습\n이제 레이블 열 이름을 지정하여 TabularPredictor를 구성한 다음 TabularPredictor.fit()으로 데이터셋에 대해 학습합니다. 다른 매개변수를 지정할 필요가 없습니다. AutoGluon은 이것이 다중 클래스 분류 작업임을 인식하고, 자동 특성 공학을 수행하고, 여러 모델을 학습한 다음, 모델을 앙상블하여 최종 예측기를 생성합니다.\n\npredictor = TabularPredictor(label=label, verbosity=0).fit(train_data)\n\n모델 학습은 CPU에 따라 몇 분 또는 그 이하가 소요됩니다. time_limit 인수를 지정하여 학습 속도를 높일 수 있습니다. 예를 들어, fit(..., time_limit=60)은 60초 후에 학습을 중지합니다. 일반적으로 시간 제한이 길수록 예측 성능이 향상되며, 시간 제한이 너무 낮으면 AutoGluon이 합리적인 모델 세트를 학습하고 앙상블하는 것을 방해합니다."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#예측",
    "href": "posts/ipynb/ml_autogluon_basics.html#예측",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "2.3 예측",
    "text": "2.3 예측\n학습 데이터셋에 대해 학습된 예측기가 있으면 예측 및 평가에 사용할 별도의 데이터 세트를 로드할 수 있습니다.\n\ntest_data = TabularDataset(f\"{data_url}test.csv\")\n\ny_pred = predictor.predict(test_data.drop(columns=[label]))\ny_pred.head()\n\n0   -4\n1    0\n2    0\n3    4\n4    2\nName: signature, dtype: int64"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#평가",
    "href": "posts/ipynb/ml_autogluon_basics.html#평가",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "2.4 평가",
    "text": "2.4 평가\nevaluate() 함수를 사용하여 테스트 데이터셋에서 예측기를 평가할 수 있습니다. 이 함수는 모델 학습에 사용되지 않은 데이터에 대해 예측기가 얼마나 잘 수행되는지 측정합니다.\n\npredictor.evaluate(test_data, silent=True)\n\n{'accuracy': 0.9482,\n 'balanced_accuracy': np.float64(0.7448082022363894),\n 'mcc': np.float64(0.936511530000817)}\n\n\nAutoGluon의 TabularPredictor는 또한 leaderboard() 함수를 제공하여 테스트 데이터에 대한 각 개별 학습 모델의 성능을 평가할 수 있습니다.\n\npredictor.leaderboard(test_data)\n\n\n\n\n\n\n\n\nmodel\nscore_test\nscore_val\neval_metric\npred_time_test\npred_time_val\nfit_time\npred_time_test_marginal\npred_time_val_marginal\nfit_time_marginal\nstack_level\ncan_infer\nfit_order\n\n\n\n\n0\nWeightedEnsemble_L2\n0.9482\n0.964965\naccuracy\n0.498636\n0.403077\n8.703081\n0.004810\n0.000391\n0.042636\n2\nTrue\n14\n\n\n1\nLightGBM\n0.9456\n0.955956\naccuracy\n0.019126\n0.003349\n1.833650\n0.019126\n0.003349\n1.833650\n1\nTrue\n5\n\n\n2\nXGBoost\n0.9448\n0.956957\naccuracy\n0.095466\n0.010777\n3.124414\n0.095466\n0.010777\n3.124414\n1\nTrue\n11\n\n\n3\nLightGBMLarge\n0.9444\n0.949950\naccuracy\n0.077716\n0.014079\n5.836701\n0.077716\n0.014079\n5.836701\n1\nTrue\n13\n\n\n4\nCatBoost\n0.9432\n0.955956\naccuracy\n0.024575\n0.002570\n7.570538\n0.024575\n0.002570\n7.570538\n1\nTrue\n8\n\n\n5\nRandomForestEntr\n0.9384\n0.949950\naccuracy\n0.189795\n0.174759\n0.604675\n0.189795\n0.174759\n0.604675\n1\nTrue\n7\n\n\n6\nNeuralNetFastAI\n0.9376\n0.944945\naccuracy\n0.053981\n0.005054\n3.912081\n0.053981\n0.005054\n3.912081\n1\nTrue\n3\n\n\n7\nExtraTreesGini\n0.9360\n0.946947\naccuracy\n0.154584\n0.212095\n1.019274\n0.154584\n0.212095\n1.019274\n1\nTrue\n9\n\n\n8\nExtraTreesEntr\n0.9358\n0.942943\naccuracy\n0.165139\n0.191926\n0.821660\n0.165139\n0.191926\n0.821660\n1\nTrue\n10\n\n\n9\nNeuralNetTorch\n0.9352\n0.949950\naccuracy\n0.013011\n0.003917\n126.092729\n0.013011\n0.003917\n126.092729\n1\nTrue\n12\n\n\n10\nRandomForestGini\n0.9352\n0.944945\naccuracy\n0.061000\n0.176905\n0.607355\n0.061000\n0.176905\n0.607355\n1\nTrue\n6\n\n\n11\nLightGBMXT\n0.9320\n0.945946\naccuracy\n0.036335\n0.005550\n2.252661\n0.036335\n0.005550\n2.252661\n1\nTrue\n4\n\n\n12\nKNeighborsDist\n0.2210\n0.213213\naccuracy\n0.014668\n0.014991\n0.017095\n0.014668\n0.014991\n0.017095\n1\nTrue\n2\n\n\n13\nKNeighborsUnif\n0.2180\n0.223223\naccuracy\n0.015354\n0.016935\n0.019544\n0.015354\n0.016935\n0.019544\n1\nTrue\n1"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#예제-데이터-1",
    "href": "posts/ipynb/ml_autogluon_basics.html#예제-데이터-1",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "3.1 예제 데이터",
    "text": "3.1 예제 데이터\n이 튜토리얼에서는 PetFinder 데이터셋의 단순화 및 서브샘플링된 버전을 사용합니다. 목표는 입양 프로필을 기반으로 애완동물 입양률을 예측하는 것입니다. 이 단순화된 버전에서 입양 속도는 0(느림)과 1(빠름)의 두 가지 범주로 그룹화됩니다. 먼저 petfinder 데이터셋이 포함된 zip 파일을 다운로드하고 현재 작업 디렉토리에 압축을 풉니다.\n\nfrom autogluon.core.utils.loaders import load_zip\n\ndownload_dir = \"./ag_multimodal_tutorial\"\nzip_file = \"https://automl-mm-bench.s3.amazonaws.com/petfinder_for_tutorial.zip\"\n\nload_zip.unzip(zip_file, unzip_dir=download_dir)\n\n다음으로, pandas를 사용하여 데이터셋의 CSV 파일을 DataFrames으로 읽어들입니다. 예측하려는 열은 “AdoptionSpeed”입니다.\n\nimport pandas as pd\n\ndataset_path = f\"{download_dir}/petfinder_for_tutorial\"\n\ntrain_data = pd.read_csv(f\"{dataset_path}/train.csv\", index_col=0)\ntest_data = pd.read_csv(f\"{dataset_path}/test.csv\", index_col=0)\n\nlabel_col = \"AdoptionSpeed\"\nimage_col = \"Images\"\n\ntrain_data[image_col] = train_data[image_col].apply(lambda ele: ele.split(\";\")[0])\ntest_data[image_col] = test_data[image_col].apply(lambda ele: ele.split(\";\")[0])\n\n\ndef path_expander(path, base_folder):\n    path_l = path.split(\";\")\n    return \";\".join([os.path.abspath(os.path.join(base_folder, path)) for path in path_l])\n\n\ntrain_data[image_col] = train_data[image_col].apply(\n    lambda ele: path_expander(ele, base_folder=dataset_path)\n)\ntest_data[image_col] = test_data[image_col].apply(\n    lambda ele: path_expander(ele, base_folder=dataset_path)\n)\n\nPetFinder 데이터셋에는 이미지 디렉토리가 있으며, 데이터의 일부 레코드에는 여러 이미지가 연결되어 있습니다. AutoGluon의 멀티모달 데이터프레임 형식에서는 이미지 열에 단일 이미지 파일 경로인 문자열이 포함되어야 합니다. 이 예에서는 이미지 특성 열을 첫 번째 이미지로만 제한하고 현재 디렉토리 구조에 맞게 모든 것을 올바르게 설정하기 위해 약간의 경로 조작이 필요합니다.\n각 동물의 입양 프로필에는 사진, 텍스트 설명, 나이, 품종, 이름, 색상 등과 같은 다양한 테이블 형식 특성이 포함됩니다. 예제 데이터 행의 사진과 설명을 살펴보겠습니다.\n\nfrom IPython.display import Image, display\n\nexample_row = train_data.iloc[0]\nexample_image = example_row[image_col]\n\npil_img = Image(filename=example_image)\ndisplay(pil_img)\n\nexample_row[\"Description\"]\n\n\n\n\n\n\n\n\n\"I rescued Yumi Hamasaki at a food stall far away in Kelantan. At that time i was on my way back to KL, she was suffer from stomach problem and looking very2 sick.. I send her to vet & get the treatment + vaccinated and right now she's very2 healthy.. About yumi : - love to sleep with ppl - she will keep on meowing if she's hugry - very2 active, always seeking for people to accompany her playing - well trained (poo+pee in her own potty) - easy to bathing - I only feed her with these brands : IAMS, Kittenbites, Pro-formance Reason why i need someone to adopt Yumi: I just married and need to move to a new house where no pets are allowed :( As Yumi is very2 special to me, i will only give her to ppl that i think could take care of her just like i did (especially on her foods things)..\""
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#학습-1",
    "href": "posts/ipynb/ml_autogluon_basics.html#학습-1",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "3.2 학습",
    "text": "3.2 학습\n이제 데이터가 적절한 형식이 되었으므로 학습 데이터에 대해 MultiModalPredictor를 학습시킬 수 있습니다. 여기서는 이 빠른 데모를 위해 짧은 학습 시간 예산을 설정합니다. 학습 시간이 길수록 예측 성능이 향상되지만 짧은 시간 안에 놀라울 정도로 좋은 성능을 얻을 수 있습니다.\n\nfrom autogluon.multimodal import MultiModalPredictor\n\npredictor = MultiModalPredictor(label=label_col, verbosity=0).fit(\n    train_data=train_data, time_limit=120\n)\n\nINFO: Seed set to 0\nINFO: Using 16bit Automatic Mixed Precision (AMP)\nINFO: GPU available: True (cuda), used: True\nINFO: TPU available: False, using: 0 TPU cores\nINFO: HPU available: False, using: 0 HPUs\nINFO: You are using a CUDA device ('NVIDIA GeForce RTX 4090') that has Tensor Cores. To properly utilize them, you should set `torch.set_float32_matmul_precision('medium' | 'high')` which will trade-off precision for performance. For more details, read https://pytorch.org/docs/stable/generated/torch.set_float32_matmul_precision.html#torch.set_float32_matmul_precision\nINFO: LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\nINFO: \n  | Name              | Type                | Params | Mode \n------------------------------------------------------------------\n0 | model             | MultimodalFusionMLP | 207 M  | train\n1 | validation_metric | BinaryAUROC         | 0      | train\n2 | loss_func         | CrossEntropyLoss    | 0      | train\n------------------------------------------------------------------\n207 M     Trainable params\n0         Non-trainable params\n207 M     Total params\n828.307   Total estimated model params size (MB)\n1171      Modules in train mode\n0         Modules in eval mode\n\n\nEpoch 0:  50%|█████     | 30/60 [00:03&lt;00:03,  8.10it/s]                   \n\n\nINFO: Epoch 0, global step 1: 'val_roc_auc' reached 0.56208 (best 0.56208), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=0-step=1.ckpt' as top 3\n\n\nEpoch 0: 100%|██████████| 60/60 [00:12&lt;00:00,  4.99it/s]\n\n\nINFO: Epoch 0, global step 4: 'val_roc_auc' reached 0.75111 (best 0.75111), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=0-step=4.ckpt' as top 3\n\n\nEpoch 1:  50%|█████     | 30/60 [00:02&lt;00:02, 11.48it/s]\n\n\nINFO: Epoch 1, global step 5: 'val_roc_auc' reached 0.76056 (best 0.76056), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=1-step=5.ckpt' as top 3\n\n\nEpoch 1: 100%|██████████| 60/60 [00:11&lt;00:00,  5.39it/s]\n\n\nINFO: Epoch 1, global step 8: 'val_roc_auc' reached 0.78417 (best 0.78417), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=1-step=8.ckpt' as top 3\n\n\nEpoch 2:  50%|█████     | 30/60 [00:02&lt;00:02, 11.62it/s]\n\n\nINFO: Epoch 2, global step 9: 'val_roc_auc' reached 0.78306 (best 0.78417), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=2-step=9.ckpt' as top 3\n\n\nEpoch 2: 100%|██████████| 60/60 [00:11&lt;00:00,  5.27it/s]\n\n\nINFO: Epoch 2, global step 12: 'val_roc_auc' reached 0.79056 (best 0.79056), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=2-step=12.ckpt' as top 3\n\n\nEpoch 3:  50%|█████     | 30/60 [00:02&lt;00:02, 11.77it/s]\n\n\nINFO: Epoch 3, global step 13: 'val_roc_auc' reached 0.78417 (best 0.79056), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=3-step=13.ckpt' as top 3\n\n\nEpoch 3: 100%|██████████| 60/60 [00:11&lt;00:00,  5.36it/s]\n\n\nINFO: Epoch 3, global step 16: 'val_roc_auc' reached 0.78806 (best 0.79056), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=3-step=16.ckpt' as top 3\n\n\nEpoch 4:  50%|█████     | 30/60 [00:02&lt;00:02, 11.22it/s]\n\n\nINFO: Epoch 4, global step 17: 'val_roc_auc' reached 0.79222 (best 0.79222), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=4-step=17.ckpt' as top 3\n\n\nEpoch 4: 100%|██████████| 60/60 [00:11&lt;00:00,  5.13it/s]\n\n\nINFO: Epoch 4, global step 20: 'val_roc_auc' reached 0.79111 (best 0.79222), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=4-step=20.ckpt' as top 3\n\n\nEpoch 5:  50%|█████     | 30/60 [00:02&lt;00:02, 11.55it/s]\n\n\nINFO: Epoch 5, global step 21: 'val_roc_auc' was not in top 3\n\n\nEpoch 5: 100%|██████████| 60/60 [00:08&lt;00:00,  7.18it/s]\n\n\nINFO: Epoch 5, global step 24: 'val_roc_auc' reached 0.80014 (best 0.80014), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=5-step=24.ckpt' as top 3\n\n\nEpoch 6:  50%|█████     | 30/60 [00:02&lt;00:02, 11.40it/s]\n\n\nINFO: Epoch 6, global step 25: 'val_roc_auc' reached 0.79764 (best 0.80014), saving model to '/mnt/c4a1c56d-0589-48cd-9717-f6c33a86fa3b/Tools/learn_autogluon/AutogluonModels/ag-20250718_065554/epoch=6-step=25.ckpt' as top 3\n\n\nEpoch 6: 100%|██████████| 60/60 [00:11&lt;00:00,  5.26it/s]\n\n\nINFO: Epoch 6, global step 28: 'val_roc_auc' was not in top 3\n\n\nEpoch 7:  50%|█████     | 30/60 [00:02&lt;00:02, 11.35it/s]\n\n\nINFO: Epoch 7, global step 29: 'val_roc_auc' was not in top 3\nINFO: Time limit reached. Elapsed time is 0:02:02. Signaling Trainer to stop.\n\n\nEpoch 7:  52%|█████▏    | 31/60 [00:06&lt;00:05,  4.98it/s]\n\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00,  8.12it/s]\n\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00,  8.38it/s]\n\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00,  8.34it/s]\n\n\n내부적으로 MultiModalPredictor는 문제 유형(분류 또는 회귀)을 자동으로 유추하고, 특성 양식을 감지하고, 멀티모달 모델 풀에서 모델을 선택하고, 선택된 모델을 학습합니다. 여러 백본이 사용되는 경우 MultiModalPredictor는 그 위에 후기 융합 모델(MLP 또는 트랜스포머)을 추가합니다."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#예측-1",
    "href": "posts/ipynb/ml_autogluon_basics.html#예측-1",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "3.3 예측",
    "text": "3.3 예측\n모델을 학습시킨 후, 이를 사용하여 보류된 테스트 데이터셋의 레이블을 예측합니다.\n\npredictions = predictor.predict(test_data.drop(columns=label_col))\npredictions[:5]\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00, 11.89it/s]\n\n\n8     0\n70    1\n82    1\n28    0\n63    1\nName: AdoptionSpeed, dtype: int64\n\n\n분류 작업의 경우 각 출력 클래스에 대한 예측 확률을 쉽게 얻을 수 있습니다.\n\nprobs = predictor.predict_proba(test_data.drop(columns=label_col))\nprobs[:5]\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00, 12.30it/s]\n\n\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n8\n0.998383\n0.001617\n\n\n70\n0.000966\n0.999034\n\n\n82\n0.000547\n0.999453\n\n\n28\n0.999870\n0.000130\n\n\n63\n0.005271\n0.994729"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#평가-1",
    "href": "posts/ipynb/ml_autogluon_basics.html#평가-1",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "3.4 평가",
    "text": "3.4 평가\n마지막으로, 보류된 테스트 데이터셋에서 다른 성능 메트릭, 이 경우 roc_auc에 대해 예측기를 평가할 수 있습니다.\n\nscores = predictor.evaluate(test_data, metrics=[\"roc_auc\"])\nscores\n\nINFO: 💡 Tip: For seamless cloud uploads and versioning, try installing [litmodels](https://pypi.org/project/litmodels/) to enable LitModelCheckpoint, which syncs automatically with the Lightning model registry.\n\n\nPredicting DataLoader 0: 100%|██████████| 4/4 [00:00&lt;00:00, 11.93it/s]\n\n\n{'roc_auc': np.float64(0.8976)}"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#시계열-데이터를-timeseriesdataframe으로-로드하기",
    "href": "posts/ipynb/ml_autogluon_basics.html#시계열-데이터를-timeseriesdataframe으로-로드하기",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "4.1 시계열 데이터를 TimeSeriesDataFrame으로 로드하기",
    "text": "4.1 시계열 데이터를 TimeSeriesDataFrame으로 로드하기\n먼저 필요한 모듈을 가져옵니다.\n\nimport pandas as pd\nfrom autogluon.timeseries import TimeSeriesDataFrame, TimeSeriesPredictor\n\nautogluon.timeseries를 사용하려면 다음 두 클래스만 필요합니다:\n\nTimeSeriesDataFrame은 여러 시계열로 구성된 데이터셋을 저장합니다.\nTimeSeriesPredictor는 최상의 예측 모델을 피팅, 튜닝 및 선택하고 새로운 예측을 생성하는 작업을 처리합니다.\n\nM4 시간별 데이터셋의 하위 집합을 pandas.DataFrame으로 로드합니다.\n\ndf = pd.read_csv(\n    \"https://autogluon.s3.amazonaws.com/datasets/timeseries/m4_hourly_subset/train.csv\"\n)\ndf.head()\n\n\n\n\n\n\n\n\nitem_id\ntimestamp\ntarget\n\n\n\n\n0\nH1\n1750-01-01 00:00:00\n605.0\n\n\n1\nH1\n1750-01-01 01:00:00\n586.0\n\n\n2\nH1\n1750-01-01 02:00:00\n586.0\n\n\n3\nH1\n1750-01-01 03:00:00\n559.0\n\n\n4\nH1\n1750-01-01 04:00:00\n511.0\n\n\n\n\n\n\n\nAutoGluon은 시계열 데이터를 long format으로 예상합니다. 데이터 프레임의 각 행에는 다음으로 표시되는 단일 시계열의 단일 관측(타임스텝)이 포함됩니다.\n\n시계열의 고유 ID(\"item_id\") (int 또는 str)\n관측의 타임스탬프(\"timestamp\") (pandas.Timestamp 또는 호환 형식)\n시계열의 숫자 값(\"target\")\n\n원본 데이터셋은 항상 고유 ID, 타임스탬프 및 대상 값에 대한 최소 세 개의 열이 있는 이 형식을 따라야 하지만 이러한 열의 이름은 임의로 지정할 수 있습니다. 그러나 AutoGluon에서 사용하는 TimeSeriesDataFrame을 구성할 때 열 이름을 제공하는 것이 중요합니다. 데이터가 예상 형식과 일치하지 않으면 AutoGluon에서 예외가 발생합니다.\n\ntrain_data = TimeSeriesDataFrame.from_data_frame(\n    df, id_column=\"item_id\", timestamp_column=\"timestamp\"\n)\ntrain_data.head()\n\n\n\n\n\n\n\n\n\ntarget\n\n\nitem_id\ntimestamp\n\n\n\n\n\nH1\n1750-01-01 00:00:00\n605.0\n\n\n1750-01-01 01:00:00\n586.0\n\n\n1750-01-01 02:00:00\n586.0\n\n\n1750-01-01 03:00:00\n559.0\n\n\n1750-01-01 04:00:00\n511.0\n\n\n\n\n\n\n\nTimeSeriesDataFrame에 저장된 각 개별 시계열을 _item_이라고 합니다. 예를 들어, 항목은 수요 예측의 다른 제품에 해당하거나 금융 데이터셋의 다른 주식에 해당할 수 있습니다. 이 설정은 시계열의 _패널_이라고도 합니다. 이것은 다변량 예측과 동일하지 않습니다. AutoGluon은 다른 항목(시계열) 간의 상호 작용을 모델링하지 않고 각 시계열에 대해 개별적으로 예측을 생성합니다.\nTimeSeriesDataFrame은 pandas.DataFrame에서 상속되므로 pandas.DataFrame의 모든 속성과 메서드를 TimeSeriesDataFrame에서 사용할 수 있습니다. 또한 다양한 데이터 형식에 대한 로더와 같은 다른 유틸리티 기능도 제공합니다."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#timeseriespredictor.fit으로-시계열-모델-학습",
    "href": "posts/ipynb/ml_autogluon_basics.html#timeseriespredictor.fit으로-시계열-모델-학습",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "4.2 TimeSeriesPredictor.fit으로 시계열 모델 학습",
    "text": "4.2 TimeSeriesPredictor.fit으로 시계열 모델 학습\n시계열의 미래 값을 예측하려면 TimeSeriesPredictor 객체를 만들어야 합니다. autogluon.timeseries의 모델은 시계열을 미래의 _여러 단계_로 예측합니다. 우리는 작업에 따라 이러한 단계의 수, 즉 예측 길이(_예측 기간_이라고도 함)를 선택합니다. 예를 들어 우리 데이터셋에는 시간별 _빈도_로 측정된 시계열이 포함되어 있으므로 prediction_length = 48로 설정하여 미래 48시간까지 예측하는 모델을 학습합니다.\nAutoGluon에 학습된 모델을 ./autogluon-m4-hourly 폴더에 저장하도록 지시합니다. 또한 AutoGluon이 평균 절대 스케일 오차(MASE)에 따라 모델 순위를 매겨야 하며 예측하려는 데이터가 TimeSeriesDataFrame의 \"target\" 열에 저장되도록 지정합니다.\n\npredictor = TimeSeriesPredictor(\n    prediction_length=48,\n    path=\"autogluon-m4-hourly\",\n    target=\"target\",\n    eval_metric=\"MASE\",\n    verbosity=0,\n)\n\npredictor.fit(train_data, presets=\"medium_quality\", time_limit=600)\n\n&lt;autogluon.timeseries.predictor.TimeSeriesPredictor at 0x73aacd597390&gt;\n\n\n여기서는 \"medium_quality\" 사전 설정을 사용하고 학습 시간을 10분(600초)으로 제한했습니다. 사전 설정은 AutoGluon이 학습할 모델에 대한 파라미터를 정의합니다. medium_quality 사전 설정의 경우 다음과 같습니다.\n\n간단한 기준선(Naive, SeasonalNaive)\n통계 모델(ETS, Theta)\nLightGBM 기반 트리 기반 모델(RecursiveTabular, DirectTabular)\n딥러닝 모델 TemporalFusionTransformer\n그리고 이들을 결합한 가중 앙상블입니다.\n\nTimeSeriesPredictor에 사용할 수 있는 다른 사전 설정은\n\n\"fast_training\", \"high_quality\" 및 \"best_quality\" 등이 있습니다.\n\n\n사전 설정들은 일반적으로 더 정확한 예측을 생성하지만 학습하는 데 시간이 더 오래 걸립니다.\n\nAutoGluon은 fit() 을 통해 주어진 시간 제한 내에서 가능한 한 많은 모델을 학습합니다. 그런 다음 학습된 모델은 내부 검증 세트에서의 성능을 기반으로 순위가 매겨집니다. 기본적으로 이 검증 세트는 train_data의 각 시계열에서 마지막 prediction_length 타임스텝을 제외하여 구성됩니다."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#timeseriespredictor.predict로-예측-생성",
    "href": "posts/ipynb/ml_autogluon_basics.html#timeseriespredictor.predict로-예측-생성",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "4.3 TimeSeriesPredictor.predict로 예측 생성",
    "text": "4.3 TimeSeriesPredictor.predict로 예측 생성\n이제 학습된 TimeSeriesPredictor를 사용하여 미래 시계열 값을 예측할 수 있습니다. 기본적으로 AutoGluon은 내부 검증 세트에서 가장 좋은 점수를 받은 모델을 사용하여 예측합니다. 예측에는 항상 train_data의 각 시계열 끝에서 시작하여 다음 prediction_length 타임스텝에 대한 예측이 포함됩니다.\n\npredictions = predictor.predict(train_data)\npredictions.head()\n\n\n\n\n\n\n\n\n\nmean\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n\n\nitem_id\ntimestamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nH1\n1750-01-30 04:00:00\n622.354942\n598.425139\n606.981886\n613.221995\n617.991382\n622.354942\n627.043820\n631.702888\n637.264877\n645.002394\n\n\n1750-01-30 05:00:00\n563.318481\n537.515631\n547.162459\n553.498017\n558.639161\n563.318481\n567.705346\n572.642124\n578.556409\n587.001385\n\n\n1750-01-30 06:00:00\n521.525187\n494.325763\n504.013476\n511.095175\n516.550982\n521.525187\n526.583225\n532.032613\n538.334244\n547.525425\n\n\n1750-01-30 07:00:00\n490.088652\n461.432323\n471.588108\n478.747585\n484.678311\n490.088652\n495.704356\n501.733837\n508.553248\n519.106916\n\n\n1750-01-30 08:00:00\n465.376269\n435.200758\n445.454704\n452.924012\n459.572474\n465.376269\n470.925032\n477.133554\n484.607983\n495.218336\n\n\n\n\n\n\n\nAutoGluon은 확률적 예측을 생성합니다. 미래의 시계열의 평균(기대값)을 예측하는 것 외에도 모델은 예측 분포의 분위수를 제공합니다. 분위수 예측은 가능한 결과의 범위에 대한 아이디어를 제공합니다. 예를 들어, \"0.1\" 분위수가 500.0과 같으면 모델은 대상 값이 500.0 미만일 확률이 10%라고 예측합니다.\n이제 데이터셋의 시계열 중 하나에 대한 예측과 실제 관측값을 시각화합니다. 잠재적 결과의 범위를 표시하기 위해 평균 예측과 10% 및 90% 분위수를 플로팅합니다.\n\ntest_data = TimeSeriesDataFrame.from_path(\n    \"https://autogluon.s3.amazonaws.com/datasets/timeseries/m4_hourly_subset/test.csv\"\n)\n\npredictor.plot(\n    test_data, predictions, quantile_levels=[0.1, 0.9], max_history_length=200, max_num_item_ids=4\n);"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#다양한-모델의-성능-평가",
    "href": "posts/ipynb/ml_autogluon_basics.html#다양한-모델의-성능-평가",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "4.4 다양한 모델의 성능 평가",
    "text": "4.4 다양한 모델의 성능 평가\nleaderboard() 메서드를 통해 AutoGluon이 학습한 각 모델의 성능을 볼 수 있습니다. 테스트 데이터 세트를 리더보드 함수에 제공하여 학습된 모델이 보이지 않는 테스트 데이터에서 얼마나 잘 수행되는지 확인합니다. 리더보드에는 내부 검증 데이터셋에서 계산된 검증 점수도 포함됩니다.\n테스트 데이터에는 예측 기간(각 시계열의 마지막 prediction_length 값)과 과거 데이터(마지막 prediction_last 값을 제외한 모든 값)가 모두 포함됩니다.\nAutoGluon 리더보드에서 점수가 높을수록 항상 더 나은 예측 성능에 해당합니다. 따라서 MASE 점수에 -1을 곱하여 “음수 MASE”가 높을수록 더 정확한 예측에 해당하도록 합니다.\n\npredictor.leaderboard(test_data)\n\n\n\n\n\n\n\n\nmodel\nscore_test\nscore_val\npred_time_test\npred_time_val\nfit_time_marginal\nfit_order\n\n\n\n\n0\nWeightedEnsemble\n-0.697607\n-0.791366\n13.339781\n8.644861\n0.386227\n9\n\n\n1\nChronos[bolt_small]\n-0.725739\n-0.812070\n1.574927\n1.777771\n0.084811\n7\n\n\n2\nRecursiveTabular\n-0.862797\n-0.933874\n0.488657\n0.336368\n3.245855\n3\n\n\n3\nSeasonalNaive\n-1.022854\n-1.216909\n0.133975\n0.105367\n0.061909\n2\n\n\n4\nDirectTabular\n-1.605700\n-1.292127\n0.160719\n0.166876\n3.339360\n4\n\n\n5\nETS\n-1.806136\n-1.966098\n10.985835\n6.286225\n0.059151\n5\n\n\n6\nTheta\n-1.905367\n-2.142551\n0.287385\n0.309614\n0.060678\n6\n\n\n7\nTemporalFusionTransformer\n-2.065762\n-2.403856\n0.125047\n0.077620\n33.022607\n8\n\n\n8\nNaive\n-6.696079\n-6.662942\n0.119962\n1.052629\n0.064250\n1"
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#요약",
    "href": "posts/ipynb/ml_autogluon_basics.html#요약",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "4.5 요약",
    "text": "4.5 요약\nautogluon.timeseries를 사용하여 M4 시간별 데이터셋에 대한 확률적 다단계 예측을 수행했습니다. 시계열 예측을 위한 AutoGluon의 고급 기능에 대해 알아보려면 시계열 예측 - 심층 분석을 확인하십시오."
  },
  {
    "objectID": "posts/ipynb/ml_autogluon_basics.html#참고-자료",
    "href": "posts/ipynb/ml_autogluon_basics.html#참고-자료",
    "title": "AutoGluon을 사용한 AutoML",
    "section": "5.1 참고 자료",
    "text": "5.1 참고 자료\n\nAutoGluon 공식 문서\nGitHub 저장소"
  },
  {
    "objectID": "posts/ipynb/tool_seurat_RDS2mtx.html#umap-그리기",
    "href": "posts/ipynb/tool_seurat_RDS2mtx.html#umap-그리기",
    "title": "RDS 객체를 10X MEX 형식으로 저장하기",
    "section": "4.1 UMAP 그리기",
    "text": "4.1 UMAP 그리기\nUMAP을 그리기 위해 아래 코드들을 실행합니다.\n\n# 데이터 정규화\nseurat_obj &lt;- NormalizeData(object = seurat_obj, verbose = FALSE)\n\n# 변수 특징 찾기\nseurat_obj &lt;- FindVariableFeatures(object = seurat_obj, verbose = FALSE)\n\n# 데이터 스케일링\nseurat_obj &lt;- ScaleData(object = seurat_obj, verbose = FALSE)\n\n# 주성분 분석 실행\nseurat_obj &lt;- RunPCA(\n    object = seurat_obj,\n    features = VariableFeatures(object = seurat_obj),\n    verbose = FALSE\n)\n\n# 이웃 찾기\nseurat_obj &lt;- FindNeighbors(\n    object = seurat_obj, dims = 1:10, verbose = FALSE\n)\n\n# 클러스터 찾기\nseurat_obj &lt;- FindClusters(\n    object = seurat_obj, resolution = 0.5, verbose = FALSE\n)\n\n# UMAP 실행\nseurat_obj &lt;- RunUMAP(\n    object = seurat_obj, dims = 1:10, verbose = FALSE\n)\n\n\nDimPlot(\n    object = seurat_obj,\n    label = TRUE,          # 각 데이터 포인트에 레이블 표시 여부\n    reduction = \"umap\"    # UMAP 데이터 사용\n) + NoLegend()            # 범례 숨기기\n\n\n\n\n\n\n\n\n메타 데이터도 살펴봅니다.\n\nhead(seurat_obj[[]])\n\n\nA data.frame: 6 × 6\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\npercent.mt\nRNA_snn_res.0.5\nseurat_clusters\n\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;dbl&gt;\n&lt;fct&gt;\n&lt;fct&gt;\n\n\n\n\nAAACATACAACCAC-1\npbmc3k\n2419\n779\n3.0177759\n2\n2\n\n\nAAACATTGAGCTAC-1\npbmc3k\n4903\n1352\n3.7935958\n3\n3\n\n\nAAACATTGATCAGC-1\npbmc3k\n3147\n1129\n0.8897363\n2\n2\n\n\nAAACCGTGCTTCCG-1\npbmc3k\n2639\n960\n1.7430845\n1\n1\n\n\nAAACCGTGTATGCG-1\npbmc3k\n980\n521\n1.2244898\n6\n6\n\n\nAAACGCACTGGTAC-1\npbmc3k\n2163\n781\n1.6643551\n2\n2\n\n\n\n\n\nseurat_clusters들이 숫자로 되어 있습니다. 이것을 cell type annotation작을 통해 아래와 같이 값을 바꿔줍니다.\n\n# 클러스터 이름 재할당\nseurat_obj[[]] &lt;- seurat_obj[[]] %&gt;%\n  mutate(seurat_clusters = recode(\n    seurat_clusters,\n    `0` = \"Naive CD4 T\",\n    `1` = \"CD14+ Mono\",\n    `2` = \"Memory CD4 T\",\n    `3` = \"B\",\n    `4` = \"CD8 T\",\n    `5` = \"FCGR3A+ Mono\",\n    `6` = \"NK\",\n    `7` = \"DC\",\n    `8` = \"Platelet\"\n  ))\n\n# 수정된 클러스터 정보 확인\nhead(seurat_obj[[]])\n\n\nA data.frame: 6 × 6\n\n\n\norig.ident\nnCount_RNA\nnFeature_RNA\npercent.mt\nRNA_snn_res.0.5\nseurat_clusters\n\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;dbl&gt;\n&lt;fct&gt;\n&lt;fct&gt;\n\n\n\n\nAAACATACAACCAC-1\npbmc3k\n2419\n779\n3.0177759\n2\nMemory CD4 T\n\n\nAAACATTGAGCTAC-1\npbmc3k\n4903\n1352\n3.7935958\n3\nB\n\n\nAAACATTGATCAGC-1\npbmc3k\n3147\n1129\n0.8897363\n2\nMemory CD4 T\n\n\nAAACCGTGCTTCCG-1\npbmc3k\n2639\n960\n1.7430845\n1\nCD14+ Mono\n\n\nAAACCGTGTATGCG-1\npbmc3k\n980\n521\n1.2244898\n6\nNK\n\n\nAAACGCACTGGTAC-1\npbmc3k\n2163\n781\n1.6643551\n2\nMemory CD4 T\n\n\n\n\n\n다시 UMAP을 그려보겠습니다.\n\nDimPlot(\n  seurat_obj,\n  reduction = \"umap\",\n  label=TRUE,\n  group.by=\"seurat_clusters\") + NoLegend()\n\n\n\n\n\n\n\n\n이제 RDS파일로 객체를 저장합니다.\n\noutput_path &lt;- \"../output/pbmc3k/\"\n\n# Seurat 객체를 RDS 파일로 저장\nsaveRDS(\n    seurat_obj,\n    file = paste0(output_path, \"pbmc3k.rds\")\n)"
  },
  {
    "objectID": "posts/ipynb/da_typecount.html",
    "href": "posts/ipynb/da_typecount.html",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "",
    "text": "문득 타이핑이 얼마나 많은 칼로리를 소모하는지 궁금해졌습니다. 하루 종일 키보드를 두드리면 꽤 많은 운동이 되지 않을까 하는 생각이 들었고 찾아보니 이미 계산해본 사람이 있었습니다.[^1] 이 글은 사실상 원저자의 글을 번역하고 추가로 코드 작성을 한 것입니다. 타이핑으로 소모되는 칼로리를 알아보기 위해 다음과 같은 단계로 계산해 보았습니다."
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#파이썬-코드",
    "href": "posts/ipynb/da_typecount.html#파이썬-코드",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "1.1 파이썬 코드",
    "text": "1.1 파이썬 코드\nimport tkinter as tk\nfrom pynput.keyboard import Listener\nimport csv\nfrom datetime import date\nimport os\n\nclass TypingCounter:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"Typing Counter v0.2.0\")\n        master.geometry(\"200x200+100+100\")\n\n        self.count = 0\n        self.is_counting = False\n        self.csv_file = \"typing_count.csv\"\n\n        self.label = tk.Label(master, text=\"Count: 0\")\n        self.label.pack(pady=20)\n\n        self.start_button = tk.Button(master, text=\"Start\", command=self.start_counting)\n        self.start_button.pack()\n\n        self.stop_button = tk.Button(master, text=\"Stop\", command=self.stop_counting, state=tk.DISABLED)\n        self.stop_button.pack()\n\n        self.save_button = tk.Button(master, text=\"Save\", command=self.save_count)\n        self.save_button.pack()\n\n        self.quit_button = tk.Button(master, text=\"Quit\", command=master.quit)\n        self.quit_button.pack()\n\n        self.listener = None\n\n    def start_counting(self):\n        self.is_counting = True\n        self.start_button.config(state=tk.DISABLED)\n        self.stop_button.config(state=tk.NORMAL)\n        self.listener = Listener(on_press=self.on_press)\n        self.listener.start()\n\n    def stop_counting(self):\n        self.is_counting = False\n        self.start_button.config(state=tk.NORMAL)\n        self.stop_button.config(state=tk.DISABLED)\n        if self.listener:\n            self.listener.stop()\n\n    def on_press(self, key):\n        if self.is_counting:\n            self.count += 1\n            self.label.config(text=f\"Count: {self.count}\")\n\n    def save_count(self):\n        today = date.today().isoformat()\n        data = [today, self.count]\n        \n        file_exists = os.path.isfile(self.csv_file)\n        \n        with open(self.csv_file, 'a', newline='') as f:\n            writer = csv.writer(f)\n            if not file_exists:\n                writer.writerow([\"Date\", \"Count\"])\n            writer.writerow(data)\n        \n        print(f\"Data saved: {data}\")\n\nroot = tk.Tk()\napp = TypingCounter(root)\nroot.mainloop()\n이 코드는 다음과 같은 기능을 제공합니다:\n\n시작 버튼: 타이핑 카운트를 시작합니다.\n종료 버튼: 타이핑 카운트를 중지합니다.\n저장 버튼: 현재 날짜와 타이핑 횟수를 CSV 파일에 저장합니다.\n종료 버튼: 프로그램을 종료합니다.\n\nCSV 파일 (‘typing_count.csv’)은 스크립트가 있는 폴더에 생성되며, 이미 파일이 존재하면 새로운 데이터를 추가합니다. 파일이 없으면 새로 생성하고 헤더를 추가합니다.이 프로그램은 사용자가 시작 버튼을 누를 때부터 타이핑 횟수를 세기 시작하고, 종료 버튼을 누르면 카운팅을 중지합니다. 저장 버튼을 누르면 현재 날짜와 카운트를 CSV 파일에 저장합니다."
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#심박수-기반의-칼로리-소모량-측정-공식",
    "href": "posts/ipynb/da_typecount.html#심박수-기반의-칼로리-소모량-측정-공식",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "1.2 심박수 기반의 칼로리 소모량 측정 공식",
    "text": "1.2 심박수 기반의 칼로리 소모량 측정 공식\n타이핑 중 소모되는 칼로리를 측정하기 위해 심박수를 기준으로 삼았습니다. 일반적으로 사용되는 공식은 다음과 같습니다:\n\\[\n\\text{소모 칼로리 (kcal/min)} = \\frac{\\text{심박수 (bpm)} \\times \\text{체중 (kg)} \\times 0.6309}{1000}\n\\]\n\nA: 안정시 심박수에서 소모된 칼로리\nB: 타이핑 중 심박수에 의해 소모되는 칼로리"
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#apple-watch로-심박수-측정",
    "href": "posts/ipynb/da_typecount.html#apple-watch로-심박수-측정",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "1.3 Apple Watch로 심박수 측정",
    "text": "1.3 Apple Watch로 심박수 측정\n\n안정시 심박수: 88 bpm\n타이핑 중 심박수: 97 bpm"
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#분-타이핑으로-소모된-칼로리-계산",
    "href": "posts/ipynb/da_typecount.html#분-타이핑으로-소모된-칼로리-계산",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "1.4 1분 타이핑으로 소모된 칼로리 계산",
    "text": "1.4 1분 타이핑으로 소모된 칼로리 계산\n체중은 65kg으로 가정합니다.\n\nA: 안정시 심박수에서 소모된 칼로리 \\[\n\\text{소모 칼로리} = \\frac{88 \\times 65 \\times 0.6309}{1000} \\approx 3.6087 \\text{ Kcal}\n\\]\nB: 타이핑 중 소모된 칼로리 \\[\n\\text{소모 칼로리} = \\frac{97 \\times 65 \\times 0.6309}{1000} \\approx 3.9778 \\text{ Kcal}\n\\]\nAB: 약 1분 동안의 차이는 \\[\n3.9778 - 3.6087 \\approx 0.3691 \\text{ Kcal}\n\\]\n한 번의 타이핑으로 소모되는 칼로리는 \\[\n\\frac{0.3691}{222} \\approx 0.0016 \\text{ Kcal}\n\\]\n\n결과적으로 한 번의 타이핑으로 약 0.0016 Kcal를 소비하는 것으로 나타났습니다."
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#평균-타이핑-시각화",
    "href": "posts/ipynb/da_typecount.html#평균-타이핑-시각화",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "2.1 평균 타이핑 시각화",
    "text": "2.1 평균 타이핑 시각화\n\n# 전체 평균값 계산\noverall_mean = df[\"Count\"].mean()\n\n# 서브플롯 생성 (비율 조정)\nfig = plt.figure(figsize=(8, 3))\ngs = fig.add_gridspec(1, 5)  # 4:1 비율로 그리드 설정\n\n# 첫 번째 플롯: 선 그래프 (4칸 차지)\nax1 = fig.add_subplot(gs[0, :4])\nax1.plot(df[\"Date\"], df[\"Count\"], marker=\"o\")\nax1.spines[\"top\"].set_visible(False)\nax1.spines[\"right\"].set_visible(False)\nax1.set_xlabel(\"\", fontsize=12)\nax1.set_ylabel(\"Count\", fontsize=12)\nax1.grid(True, linestyle=\"--\", alpha=0.7)\nfig.autofmt_xdate()\nax1.set_ylim(bottom=0)\nfor i, count in enumerate(df[\"Count\"]):\n    ax1.annotate(\n        str(count),\n        (df[\"Date\"][i], count),\n        textcoords=\"offset points\",\n        xytext=(0, 7),\n        ha=\"center\",\n    )\n\n# 두 번째 플롯: 스웜 플롯 (1칸 차지)\nax2 = fig.add_subplot(gs[0, 4])\nsns.swarmplot(x=[\"All Dates\"] * len(df), y=\"Count\", data=df, ax=ax2)\nax2.spines[\"top\"].set_visible(False)\nax2.spines[\"right\"].set_visible(False)\nax2.axhline(y=overall_mean, color=\"red\", linestyle=\"--\", label=f\"Mean: {overall_mean:.2f}\")\nax2.set_xlabel(\"\")\nax2.set_ylabel(\"Count\", fontsize=12)\nax2.grid(True, linestyle=\"--\", alpha=0.7)\n\n# 레이아웃 조정 및 출력\nplt.tight_layout()\nplt.show()\n\n# 평균값 출력\nprint(f\"Overall Mean: {overall_mean:.2f}\")\n\n\n\n\n\n\n\n\nOverall Mean: 18511.13\n\n\n위 결과를 통해 하루에 타이핑으로 소비되는 총 칼로리를 계산 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_typecount.html#결론",
    "href": "posts/ipynb/da_typecount.html#결론",
    "title": "타이핑으로 소비되는 칼로리",
    "section": "3.1 결론",
    "text": "3.1 결론\n29.6 Kcal는 제 예상보다는 높은 수치지만 초콜릿 한 조각에 해당하는 열량이라고 합니다. 만약 운동으로 이 정도의 칼로리를 소모하려면 걷기 10분 정도가 필요하다고 합니다. 역시 앉아서 타이핑만 하지 말고 좀 걸어야 겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_sankey.html",
    "href": "posts/ipynb/da_visualization_sankey.html",
    "title": "파이썬으로 Sankey diagram그리기",
    "section": "",
    "text": "Sankey 다이어그램은 한 값 집합에서 다른 값 집합으로의 흐름을 시각화하는 도구로 열 손실에 비례하는 너비를 가진 화살표를 사용하여 증기 엔진 효율을 시각화했던 Sankey 선장의 이름을 따서 명명되었습니다. Sankey 다이어그램은 서로 다른 고객 세그먼트 간의 전환이나 흐름을 보여주는 데 효과적이며 노드(연결되는 항목)와 링크(연결)로 구성됩니다.\nSankey 다이어그램은 두 도메인 간의 다대다 매핑이나 여러 경로를 통해 트래픽이 이동하는 방식을 나타내는 데 유용합니다. 예를 들어, 대학과 전공 간의 관계를 시각화하거나 웹사이트 내에서 페이지 간의 트래픽 흐름을 보여줄 수 있습니다.\n\n1 기본 Sankey 다이어그램 그리기\n간단한 Sankey 다이어그램을 구현하는 방법을 이해하기 위해 Plotly를 사용해 기본적인 다이어그램을 만들어 보겠습니다. Plotly에서 Sankey 다이어그램은 세 개의 리스트로 정의됩니다. 세 가지 리스트는 source(출발점), target(도착점), values(값)입니다. Plotly는 각 노드를 0부터 시작하여 전체 노드 수에서 1을 뺀 숫자까지 인덱싱합니다. source와 target 리스트는 노드 간의 연결을 정의합니다. 아래 코드를 살펴보면 이해하기 더 쉬울 것입니다.\n\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\n# Define node and link data\nlabels: list[str] = [\"A\", \"B\", \"X\", \"Y\", \"Z\"]\nsource_indices: list[int] = [\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n]  # A -&gt; X, A -&gt; Y, A -&gt; Z, B -&gt; X, B -&gt; Y, B -&gt; Z\ntarget_indices: list[int] = [2, 3, 4, 2, 3, 4]  # X, Y, Z\nvalues: list[int] = [5, 7, 6, 2, 9, 4]  # Weights for each link\n\n# Define colors\ncolor_dict: dict[str, str] = {\n    \"A\": \"rgba(252,65,94,0.7)\",\n    \"B\": \"rgba(255,162,0,0.7)\",\n    \"X\": \"rgba(55,178,255,0.7)\",\n    \"Y\": \"rgba(200,200,200,0.7)\",\n    \"Z\": \"rgba(200,200,200,0.7)\",\n}\n\ncolor_dict_link: dict[str, str] = {\n    \"A\": \"rgba(252,65,94,0.4)\",\n    \"B\": \"rgba(255,162,0,0.4)\",\n    \"X\": \"rgba(55,178,255,0.4)\",\n    \"Y\": \"rgba(200,200,200,0.4)\",\n    \"Z\": \"rgba(200,200,200,0.4)\",\n}\n\n# Create node color list\nnode_colors: list[str] = [color_dict[label] for label in labels]\n\n# Create link color list based on source nodes\nlink_colors: list[str] = [\n    (\n        color_dict_link[\"A\"]\n        if source == 0\n        else color_dict_link[\"B\"]\n        if source == 1\n        else color_dict_link[\"X\"]\n    )\n    for source in source_indices\n]\n\n# Create Sankey diagram\nfig = go.Figure(\n    data=[\n        go.Sankey(\n            node={\n                \"pad\": 15,\n                \"thickness\": 20,\n                \"line\": {\"color\": \"black\", \"width\": 0.5},\n                \"label\": labels,\n                \"color\": node_colors,\n            },\n            link={\n                \"source\": source_indices,\n                \"target\": target_indices,\n                \"value\": values,\n                \"color\": link_colors,\n            },\n        )\n    ]\n)\n\n# Update layout\nfig.update_layout(\n    title_text=\"Sankey Diagram with Custom Colors for A and B\",\n    font_size=10,\n    width=600,\n    height=400,\n)\n\n# Show diagram\nfig.show()\n\n                                                \n\n\n\n\n2 고급 Sankey 다이어그램 그리기\nSankey 다이어그램을 위해서는 먼저 데이터를 전처리하는 것부터 시작해야 합니다. 아래는 pandas를 사용해 데이터를 불러오고 노드와 링크 데이터를 만들고 시각화하는 코드입니다.\n\nimport pandas as pd\n\ndf = pd.read_csv(\"../../input/estimated-us-energy-cons.csv\")\ndf.head()\n\n\n\n\n\n\n\n\nCategory\nSankey demo series (from)\nSankey demo series (to)\nSankey demo series (weight)\n\n\n\n\n0\nhighcharts-k3rhrdv-1\nNet Import\nElectricity & Heat\n0.14\n\n\n1\nhighcharts-k3rhrdv-2\nSolar\nElectricity & Heat\n1.28\n\n\n2\nhighcharts-k3rhrdv-3\nNuclear\nElectricity & Heat\n8.05\n\n\n3\nhighcharts-k3rhrdv-4\nHydro\nElectricity & Heat\n2.31\n\n\n4\nhighcharts-k3rhrdv-5\nWind\nElectricity & Heat\n3.84\n\n\n\n\n\n\n\n\n# 노드 및 링크 데이터 준비\n# 고유한 'to' 노드를 포함하여 모든 노드를 정의합니다.\nto_nodes = df[\"Sankey demo series (to)\"].unique().tolist()\nlabels = df[\"Sankey demo series (from)\"].tolist() + to_nodes\n\n# 출발 노드 인덱스 (source)\nsource_indices = df[\"Sankey demo series (from)\"].map(lambda x: labels.index(x)).tolist()\n\n# 도착 노드 인덱스 (target)\ntarget_indices = [labels.index(to_node) for to_node in df[\"Sankey demo series (to)\"]]\n\n# 링크의 가중치\nvalues = df[\"Sankey demo series (weight)\"].tolist()\n\n# 색상 정의\ncolor_dict = {\n    \"Net Import\": \"rgba(252,65,94,0.7)\",  # Red\n    \"Solar\": \"rgba(255,162,0,0.7)\",  # Orange\n    \"Nuclear\": \"rgba(55,178,255,0.7)\",  # Light Blue\n    \"Hydro\": \"rgba(0,128,0,0.7)\",  # Green\n    \"Wind\": \"rgba(75,0,130,0.7)\",  # Indigo\n    \"Geothermal\": \"rgba(255,105,180,0.7)\",  # Hot Pink\n    \"Natural Gas\": \"rgba(255,215,0,0.7)\",  # Gold\n    \"Coal\": \"rgba(105,105,105,0.7)\",  # Dim Gray\n    \"Biomass\": \"rgba(139,69,19,0.7)\",  # Saddle Brown\n    \"Petroleum\": \"rgba(173,216,230,0.7)\",  # Pastel Blue\n    \"Electricity & Heat\": \"rgba(200,200,200,0.7)\",  # Gray for target node\n    \"Residential\": \"rgba(173,216,230,0.7)\",  # Light Blue for Residential\n    \"Commercial\": \"rgba(144,238,144,0.7)\",  # Light Green for Commercial\n    \"Industrial\": \"rgba(255,182,193,0.7)\",  # Light Pink for Industrial\n    \"Transportation\": \"rgba(255,140,0,0.7)\",  # Dark Orange for Transportation\n}\n\n# 노드 색상 리스트 생성\nnode_colors = [color_dict.get(label, \"rgba(200,200,200,0.7)\") for label in labels]\n\n# 링크 색상 리스트 생성 (출발 노드에 따라 색상 결정)\nlink_colors = [color_dict[df[\"Sankey demo series (from)\"].iloc[i]] for i in range(len(df))]\n\n# Sankey 다이어그램 생성\nfig = go.Figure(\n    data=[\n        go.Sankey(\n            node={\n                \"pad\": 15,\n                \"thickness\": 20,\n                \"line\": {\"color\": \"black\", \"width\": 0.5},\n                \"label\": labels,\n                \"color\": node_colors,\n            },\n            link={\n                \"source\": source_indices,\n                \"target\": target_indices,\n                \"value\": values,\n                \"color\": link_colors,  # 링크 색상 적용\n            },\n        )\n    ]\n)\n\n\n# 레이아웃 업데이트\nfig.update_layout(\n    title_text=\"Sankey Diagram for Energy Sources\",\n    font_size=10,\n    width=600,\n    height=500,\n)\n\n# 다이어그램 표시\nfig.show()\n\n                                                \n\n\n\n\n3 마치며\nSankey 다이어그램은 데이터 분석과 시각화에 있어 매우 유용한 도구입니다. 고객 세그먼트 간 전환, 웹사이트 트래픽 흐름, 에너지 소비 등 다양한 분야에서 활용될 수 있습니다. Python과 Plotly를 사용하면 복잡한 데이터셋도 쉽게 Sankey 다이어그램으로 표현할 수 있어, 데이터 기반의 의사결정과 인사이트 도출에 큰 도움이 될 것입니다. Sankey 다이어그램의 구현 방법을 익히고 실제 데이터에 적용해 보면서, 여러분의 데이터 시각화 스킬을 한 단계 더 발전시켜 보시기 바랍니다."
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html",
    "href": "posts/ipynb/tool_marsilea.html",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "",
    "text": "이 튜토리얼은 Python의 기본 지식을 갖고 있고 NumPy와 Matplotlib을 사용하는 방법을 알고 있다고 가정합니다. 특히 Matplotlib에서 Figure 및 Axes의 개념에 대해 알고 있는 것이 좋습니다.\nimport warnings\n\nimport marsilea as ma\nimport marsilea.plotter as mp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# 경고 무시\nwarnings.filterwarnings(\"ignore\")\nnp.random.seed(42)"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#그룹화grouping",
    "href": "posts/ipynb/tool_marsilea.html#그룹화grouping",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.1 그룹화(Grouping)",
    "text": "1.1 그룹화(Grouping)\n그룹화(Grouping)를 사용하면 데이터를 그룹으로 분류하고 각 그룹에 대한 시각화를 할 수 있습니다. 우리는 vsplit() 함수를 사용하여 캔버스를 세 그룹으로 나눕니다. labels 매개변수는 각 열에 대한 그룹을 지정합니다. order 매개변수는 플롯에 표시될 그룹의 순서를 지정합니다. 이제 그룹을 시각적으로 더 명확하게 만들기 위해 측면 플롯을 추가해 봅시다. 여기서 spacing은 캔버스 너비의 일부분을 나타냅니다."
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#추가-구성-요소로-그룹-주석-달기",
    "href": "posts/ipynb/tool_marsilea.html#추가-구성-요소로-그룹-주석-달기",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.2 추가 구성 요소로 그룹 주석 달기",
    "text": "1.2 추가 구성 요소로 그룹 주석 달기\n우리는 add_top()을 사용하여 캔버스 상단에 Chunk 플롯을 추가합니다. Chunk 플롯은 그룹을 주석 처리하는 데 사용되는 주석 플롯입니다. 추가로 size 및 pad 매개변수를 사용하여 플롯의 크기와 플롯 간의 간격을 조정할 수 있습니다. 단위는 인치입니다.\n\n\n\n\n\n\nNote\n\n\n\n텍스트를 그리는 Chunk와 같은 플롯의 경우 플롯의 크기가 자동으로 텍스트에 맞게 조정되므로 플롯의 크기를 지정할 필요가 없습니다.\n\n\n\ncb.vsplit(labels=[\"c1\", \"c1\", \"c2\", \"c2\", \"c3\", \"c3\"], order=[\"c1\", \"c2\", \"c3\"], spacing=0.08)\n\ngroup_labels = mp.Chunk([\"c1\", \"c2\", \"c3\"], [\"#FF6D60\", \"#F7D060\", \"#F3E99F\"])\ncb.add_top(group_labels, size=0.2, pad=0.1)\ncb.render()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#계층적-클러스터링",
    "href": "posts/ipynb/tool_marsilea.html#계층적-클러스터링",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.3 계층적 클러스터링",
    "text": "1.3 계층적 클러스터링\nadd_dendrogram()를 사용하여 캔버스 하단에 덴드로그램을 추가합니다. 덴드로그램은 계층적 클러스터링 과정을 기록한 나무 모양의 다이어그램입니다. Marsilea에서는 클러스터링이 히트맵에만 국한되지 않고 다양한 시각화에서 수행될 수 있습니다.\n여기서 주목할 점은 그룹의 순서와 그룹 내 순서가 클러스터링 결과에 따라 자동으로 변경된다는 것입니다.\n\ncb.add_dendrogram(\"bottom\", colors=\"g\")\ncb.render()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#하단-플롯-및-제목-추가",
    "href": "posts/ipynb/tool_marsilea.html#하단-플롯-및-제목-추가",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.4 하단 플롯 및 제목 추가",
    "text": "1.4 하단 플롯 및 제목 추가\n우리는 메인 시각화에 더 많은 플롯을 추가할 수 있습니다. 여기서는 바 플롯을 하단에 추가하고 add_title()을 사용하여 맨 위에 제목을 추가합니다.\n\ncb.add_bottom(ma.plotter.Bar(data, color=\"#577D86\"), size=2, pad=0.1)\ncb.add_title(top=\"My First Marsilea Example\")\ncb.render()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#저장하기",
    "href": "posts/ipynb/tool_marsilea.html#저장하기",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.5 저장하기",
    "text": "1.5 저장하기\nsave()를 사용하여 파일로 저장할 수 있습니다.\ncb.save(\"my_first_marsilea_example.png\")\n또는 모든 맷플롯립 그림을 저장하는 방식과 동일하게 저장할 수 있습니다. .figure.로 figure 객체에 액세스할 수 있습니다. 잘려나가는 것을 피하기 위해 bbox_inches=\"tight\" 모드로 저장하는 것이 권장됩니다. 또는 캔버스의 여백을 늘릴 수도 있습니다.\ncb.figure.savefig(\"my_first_marsilea_example.png\", bbox_inches=\"tight\")"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#요약",
    "href": "posts/ipynb/tool_marsilea.html#요약",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "1.6 요약",
    "text": "1.6 요약\nMarsilea에서 시각화를 제어하는 데 사용할 수 있는 메서드 목록입니다.\n\n메인 레이어에 추가: add_layer()\n측면에 추가:\n\n왼쪽: add_left()\n오른쪽: add_right()\n위쪽: add_top()\n아래쪽: add_bottom()\n\n그룹화:\n\n수직 그룹화: hsplit()\n수평 그룹화: vsplit()\n\n덴드로그램 추가: add_dendrogram()\n제목 추가: add_title()\n범례 추가: add_legends()\n플롯 저장: save()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#데이터-불러오기",
    "href": "posts/ipynb/tool_marsilea.html#데이터-불러오기",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "3.1 데이터 불러오기",
    "text": "3.1 데이터 불러오기\n데이터를 불러와서 각 아미노산의 높이를 계산합니다. 관련 정보는 위키를 참조하세요.\n\nfrom collections import Counter\n\nseq = ma.load_data(\"seq_align\")\nseq = seq.iloc[:, 130:175]\n\ncollect = []\nfor _, col in seq.items():\n    collect.append(Counter(col))\n\nhm = pd.DataFrame(collect)\ndel hm[\"-\"]\nhm = hm.T.fillna(0.0)\nhm.columns = seq.columns\nhm /= hm.sum(axis=0)\n\nn = hm.shape[1]\ns = 20\nEn = (1 / np.log(2)) * ((s - 1) / (2 * n))\n\nheights = []\nfor _, col in hm.items():\n    H = -(np.log2(col) * col).sum()\n    R = np.log2(20) - (H + En)\n    heights.append(col * R)\n\nlogo = pd.DataFrame(heights).T\nlogo.head()\n\n\n\n\n\n\n\n\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n...\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n\n\n\n\nF\n2.636345\n0.000000\n0.000000\n0.00000\n0.0\n0.000000\n0.000000\n0.0\n0.336123\n0.000000\n...\n0.0\n0.000000\n0.000000\n0.0\n0.979395\n0.00000\n0.00000\n0.00000\n0.00000\n0.0\n\n\nA\n0.659086\n2.636345\n0.000000\n0.00000\n0.0\n0.753879\n0.753879\n0.0\n0.336123\n1.344492\n...\n0.0\n0.000000\n0.376939\n0.0\n0.000000\n0.00000\n0.00000\n0.26218\n0.00000\n0.0\n\n\nT\n0.000000\n0.659086\n0.000000\n0.28342\n0.0\n0.000000\n0.000000\n0.0\n0.336123\n0.000000\n...\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n1.50868\n0.00000\n0.00000\n0.00000\n0.0\n\n\nN\n0.000000\n0.000000\n1.305860\n0.28342\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.0\n2.066042\n0.000000\n0.0\n0.000000\n0.00000\n0.00000\n0.00000\n0.29169\n0.0\n\n\nM\n0.000000\n0.000000\n0.979395\n0.00000\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.000000\n...\n0.0\n0.000000\n0.000000\n0.0\n0.000000\n0.00000\n0.25217\n0.00000\n0.00000\n0.0\n\n\n\n\n5 rows × 45 columns"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#색상-팔레트-및-데이터-준비",
    "href": "posts/ipynb/tool_marsilea.html#색상-팔레트-및-데이터-준비",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "3.2 색상 팔레트 및 데이터 준비",
    "text": "3.2 색상 팔레트 및 데이터 준비\n\ncolor_encode = {\n    \"A\": \"#f76ab4\",\n    \"C\": \"#ff7f00\",\n    \"D\": \"#e41a1c\",\n    \"E\": \"#e41a1c\",\n    \"F\": \"#84380b\",\n    \"G\": \"#f76ab4\",\n    \"H\": \"#3c58e5\",\n    \"I\": \"#12ab0d\",\n    \"K\": \"#3c58e5\",\n    \"L\": \"#12ab0d\",\n    \"M\": \"#12ab0d\",\n    \"N\": \"#972aa8\",\n    \"P\": \"#12ab0d\",\n    \"Q\": \"#972aa8\",\n    \"R\": \"#3c58e5\",\n    \"S\": \"#ff7f00\",\n    \"T\": \"#ff7f00\",\n    \"V\": \"#12ab0d\",\n    \"W\": \"#84380b\",\n    \"Y\": \"#84380b\",\n    \"-\": \"white\",\n}\n\nmax_aa = []\nfreq = []\n\nfor _, col in hm.items():\n    ix = np.argmax(col)\n    max_aa.append(hm.index[ix])\n    freq.append(col[ix])\n\nposition = []\nmock_ticks = []\nfor i in seq.columns:\n    if int(i) % 10 == 0:\n        position.append(i)\n        mock_ticks.append(\"^\")\n    else:\n        position.append(\"\")\n        mock_ticks.append(\"\")\n\nprint(position)\n\n['130', '', '', '', '', '', '', '', '', '', '140', '', '', '', '', '', '', '', '', '', '150', '', '', '', '', '', '', '', '', '', '160', '', '', '', '', '', '', '', '', '', '170', '', '', '', '']"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#시각화",
    "href": "posts/ipynb/tool_marsilea.html#시각화",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "3.3 시각화",
    "text": "3.3 시각화\n\nheight = 2\nwidth = height * seq.shape[1] / seq.shape[0]\n\nch = ma.CatHeatmap(seq.to_numpy(), palette=color_encode, height=height, width=width)\nch.add_layer(ma.plotter.TextMesh(seq.to_numpy()))\nch.add_top(ma.plotter.SeqLogo(logo, color_encode=color_encode), pad=0.1, size=2)\nch.add_left(ma.plotter.Labels(seq.index), pad=0.1)\nch.add_bottom(ma.plotter.Labels(mock_ticks, rotation=0), pad=0.1)\nch.add_bottom(ma.plotter.Labels(position, rotation=0))\nch.add_bottom(\n    ma.plotter.Numbers(freq, width=0.9, color=\"#FFB11B\", show_value=False),\n    name=\"freq_bar\",\n    size=2,\n)\nch.add_bottom(ma.plotter.Labels(max_aa, rotation=0), pad=0.1)\nch.render()\n\nch.get_ax(\"freq_bar\").set_axis_off()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#데이터-불러오기-1",
    "href": "posts/ipynb/tool_marsilea.html#데이터-불러오기-1",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "4.1 데이터 불러오기",
    "text": "4.1 데이터 불러오기\n\ndata = ma.load_data(\"les_miserables\")\nnodes = data[\"nodes\"]\nlinks = data[\"links\"]\n\nsizes = nodes[\"value\"].to_numpy().reshape(1, -1)\ncolors = nodes[\"group\"].to_numpy().reshape(1, -1)\ndata\n\n{'nodes':                name  group  value\n 0            Myriel      1     31\n 1          Napoleon      1      0\n 2   Mlle.Baptistine      1      9\n 3      Mme.Magloire      1      3\n 4      CountessdeLo      1      0\n ..              ...    ...    ...\n 72        Toussaint      5      0\n 73           Child1     10      3\n 74           Child2     10      0\n 75           Brujon      4      0\n 76    Mme.Hucheloup      8      0\n \n [77 rows x 3 columns],\n 'links':      source  target\n 0         1       0\n 1         2       0\n 2         3       0\n 3         3       2\n 4         4       0\n ..      ...     ...\n 249      76      66\n 250      76      63\n 251      76      62\n 252      76      48\n 253      76      58\n \n [254 rows x 2 columns]}"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#아크-다이어그램-그리기",
    "href": "posts/ipynb/tool_marsilea.html#아크-다이어그램-그리기",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "4.2 아크 다이어그램 그리기",
    "text": "4.2 아크 다이어그램 그리기\n\npalette = {\n    0: \"#3C486B\",\n    1: \"#F0F0F0\",\n    2: \"#F9D949\",\n    3: \"#F45050\",\n    4: \"#F2E3DB\",\n    5: \"#41644A\",\n    6: \"#E86A33\",\n    7: \"#009FBD\",\n    8: \"#77037B\",\n    9: \"#4F4557\",\n    10: \"#B0DAFF\",\n}\n\nlink_colors = [palette[nodes.iloc[i].group] for i in links[\"source\"]]\n\nheight = 0.5\nwidth = height * len(nodes) / 3\n\nsh = ma.SizedHeatmap(\n    sizes,\n    colors,\n    palette=palette,\n    sizes=(10, 200),\n    frameon=False,\n    height=height,\n    width=width,\n)\nsh.add_bottom(mp.Labels(nodes[\"name\"], fontsize=8))\narc = mp.Arc(nodes.index, links.to_numpy(), colors=link_colors, lw=0.5, alpha=0.5)\nsh.add_top(arc, size=3)\nsh.add_title(top=\"Character relationships in Les Miserables\", align=\"right\", fontstyle=\"italic\")\nsh.render()"
  },
  {
    "objectID": "posts/ipynb/tool_marsilea.html#데이터셋-불러오기-및-전처리",
    "href": "posts/ipynb/tool_marsilea.html#데이터셋-불러오기-및-전처리",
    "title": "Marsilea로 복잡한 시각화 처리하기",
    "section": "5.1 데이터셋 불러오기 및 전처리",
    "text": "5.1 데이터셋 불러오기 및 전처리\n\nfrom legendkit import cat_legend\nfrom matplotlib.colors import LinearSegmentedColormap\n\nembryo = ma.load_data(\"mouse_embryo\")\n\nxmax = embryo[\"cell_x\"].max()\nymax = embryo[\"cell_y\"].max()\nxstart, xend = -xmax * 0.05, xmax * 1.05\nystart, yend = -ymax * 0.05, ymax * 1.05\n\nxrange = np.linspace(xstart, xend, 200)\nyrange = np.linspace(ystart, yend, 200)\n\nxmid = (xrange[1:] + xrange[:-1]) / 2\nymid = (yrange[1:] + yrange[:-1]) / 2\n\n\ndef get_xy_hist(ct):\n    x = embryo[embryo[\"cell_type\"] == ct][\"cell_x\"].to_numpy()\n    y = embryo[embryo[\"cell_type\"] == ct][\"cell_y\"].to_numpy()\n    xhist, _ = np.histogram(x, bins=xrange)\n    yhist, _ = np.histogram(y, bins=yrange)\n    return xhist, yhist\n\n\nembryo\n\n\n\n\n\n\n\n\ncell_x\ncell_y\ncell_type\ntimepoint\ncolors\n\n\n\n\n0\n133.599963\n316.800580\nCavity\nE12.5\n#6d32e6\n\n\n1\n132.733938\n316.300580\nCavity\nE12.5\n#6d32e6\n\n\n2\n131.867912\n315.800580\nBrain\nE12.5\n#bf024f\n\n\n3\n131.001887\n315.300580\nBrain\nE12.5\n#bf024f\n\n\n4\n130.135861\n314.800580\nBrain\nE12.5\n#bf024f\n\n\n...\n...\n...\n...\n...\n...\n\n\n51360\n4.928203\n243.666605\nCavity\nE12.5\n#6d32e6\n\n\n51361\n4.062178\n243.166605\nCavity\nE12.5\n#6d32e6\n\n\n51362\n3.196152\n242.666605\nCavity\nE12.5\n#6d32e6\n\n\n51363\n2.330127\n242.166605\nCavity\nE12.5\n#6d32e6\n\n\n51364\n1.464102\n241.666605\nCavity\nE12.5\n#6d32e6\n\n\n\n\n51365 rows × 5 columns\n\n\n\n각 세포 유형에 대한 색상을 지정하고 시각화합니다.\n\ncolormap = {\n    \"Cavity\": \"#6d32e6\",\n    \"Brain\": \"#bf024f\",\n    \"Meninges\": \"#d147a3\",\n    \"Choroid plexus\": \"#b3a726\",\n    \"Cartilage primordium\": \"#103a14\",\n    \"Jaw and tooth\": \"#ef833a\",\n    \"Connective tissue\": \"#b38b5c\",\n    \"Epidermis\": \"#35586d\",\n    \"Lung primordium\": \"#3cb44b\",\n    \"Sympathetic nerve\": \"#dfdce0\",\n    \"Liver\": \"#bd3add\",\n    \"Mucosal epithelium\": \"#0bd3b1\",\n    \"GI tract\": \"#ff4374\",\n    \"Mesentery\": \"#b74c11\",\n    \"Dorsal root ganglion\": \"#036df4\",\n    \"Muscle\": \"#dd7936\",\n    \"Mesothelium\": \"#5c5ca6\",\n    \"Blood vessel\": \"#be9b72\",\n    \"Urogenital ridge\": \"#d3245a\",\n    \"Heart\": \"#03fff4\",\n    \"Pancreas\": \"#f062f9\",\n    \"Kidney\": \"#62cfe8\",\n    \"Ovary\": \"#c923b1\",\n}\n\nwidth = 5\nheight = width * (yend - ystart) / (xend - xstart)\nb = ma.WhiteBoard(height=height, width=width)\n\ncell_types = [\"Brain\", \"Cartilage primordium\", \"Liver\", \"Heart\", \"GI tract\"]\nfor n in cell_types:\n    b.add_canvas(\"bottom\", size=0.2, pad=0.1, name=f\"{n}-x\")\n    b.add_canvas(\"right\", size=0.2, pad=0.1, name=f\"{n}-y\")\nb.render()\n\n# Draw cell\nax = b.get_main_ax()\npoints = ax.scatter(embryo[\"cell_x\"], embryo[\"cell_y\"], s=1, c=embryo[\"colors\"])\npoints.set_rasterized(True)\nax.set_xlim(xstart, xend)\nax.set_ylim(ystart, yend)\nax.set_title(\"Mouse Embryo E12.5\")\nax.set_axis_off()\n\ncolors = list(colormap.values())\nlabels = list(colormap.keys())\ncat_legend(colors=colors, labels=labels, ax=ax, loc=\"out left center\", fontsize=10)\n\nfor n in cell_types:\n    xh, yh = get_xy_hist(n)\n    cmap = LinearSegmentedColormap.from_list(n, [\"white\", colormap[n]])\n    x_ax = b.get_ax(f\"{n}-x\")\n    x_ax.pcolormesh(xh.reshape(1, -1), cmap=cmap)\n    x_ax.set_axis_off()\n    x_ax.text(0, 0.5, n, va=\"center\", ha=\"right\", transform=x_ax.transAxes)\n\n    y_ax = b.get_ax(f\"{n}-y\")\n    y_ax.pcolormesh(yh.reshape(-1, 1), cmap=cmap)\n    y_ax.set_axis_off()\n    y_ax.text(0.5, 0, n, va=\"top\", ha=\"center\", rotation=90, transform=y_ax.transAxes)"
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#anndata-객체에-대하여",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#anndata-객체에-대하여",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "1.1 AnnData 객체에 대하여",
    "text": "1.1 AnnData 객체에 대하여\nScanpy는 고차원 단일세포 RNA 시퀀싱 데이터를 다루기 위한 파이썬 라이브러리입니다. 이 라이브러리는 데이터를 저장하고 관리하기 위해 AnnData 객체를 활용합니다. 이번 포스트는 Scanpy를 사용하여 10x Genomics 에서 제공하는 텍스트 형식의 데이터를 먼저 불러오고 UMAP을 그린다음 다시 텍스트 형식의 데이터로 내보내는 작업을 해보겠습니다. 이런 방법을 알게 되면 Seurat으로 데이터를 변환하는 작업도 훨씬 쉬워집니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#mtx-형식에-대하여",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#mtx-형식에-대하여",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "1.2 mtx 형식에 대하여",
    "text": "1.2 mtx 형식에 대하여\nscRNA-seq count 데이터는 희소 행렬입니다. 다시 말해 대부분의 데이터가 0인 형태입니다. 이런 형태의 데이터를 효율적으로 저장하기 위해서 우리는 MEX(Market Exchange Format)을 사용합니다.\n\nMEX 형식은 행렬 데이터의 교환을 쉽게 할 수 있도록 고안되었습니다. 가능한 쉽게 분석할 수 있도록 최소한의 ASCII 형식을 가진 파일로 구성 됩니다.\n\n공개된 scRNA-seq 데이터에서 mtx로 저장되어 있는 것을 많이 볼 수 있습니다. 간략하게 설명하자면 matrix.mtx파일은 생성된 유전자 x 세포 count 행렬을 나타내며, 각 유전자의 발현 수준을 담고 있습니다.\n추가로 각 행과 열 인덱스에 해당하는 유전자 및 바코드 시퀀스가 TSV(Tab separated values) 형식 파일로 포함됩니다. TSV파일은 가장 단순하고 범용적인 파일 형식으로, 각 유전자의 이름과 세포 데이터가 텝으로 구분되어 저장되어 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#기본적인-데이터-qc-하기",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#기본적인-데이터-qc-하기",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "3.1 기본적인 데이터 QC 하기",
    "text": "3.1 기본적인 데이터 QC 하기\n\n# 기본 필터링: 최소 유전자가 200개 이상인 세포 필터링\nsc.pp.filter_cells(adata, min_genes=200)\n# 최소 3개 이상의 세포에서 발현되는 유전자 필터링\nsc.pp.filter_genes(adata, min_cells=3)\n\n# 미토콘드리아 유전자 그룹을 \"mt\"로 주석\nadata.var[\"mt\"] = adata.var_names.str.startswith(\"MT-\")\n\n# QC 지표 계산\nsc.pp.calculate_qc_metrics(adata, qc_vars=[\"mt\"], percent_top=None, log1p=False, inplace=True)\n\n# 유전자 별 발현 수가 2500개 미만인 데이터 선택\nadata = adata[adata.obs.n_genes_by_counts &lt; 2500, :]\n# 미토콘드리아 발현 비율이 5% 미만인 데이터 선택 후 복사\nadata = adata[adata.obs.pct_counts_mt &lt; 5, :].copy()\n\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 13714\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts'\n\n\n위 결과를 통해 데이터 QC를 거치자 데이터가 조금 감소한 것(바코드 2,638개, 유전자 13,714개)을 알 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#데이터-정규화하기",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#데이터-정규화하기",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "3.2 데이터 정규화하기",
    "text": "3.2 데이터 정규화하기\nUMAP을 그리기 위해 원시 데이터를 정규화하고 highly variable 유전자만 남긴 다음 클러스터링을 수행합니다. 계산량을 줄이기 위해 전체 유전자중 일부 highly variable 유전자만으로 진행합니다.\n\n\n\n\n\n\nNote\n\n\n\n전체 유전자를 다 사용한 것과 클러스터링 결과는 동일합니다.\n\n\n\n# 총 카운트 정규화\nsc.pp.normalize_total(adata, target_sum=1e4)\n# 데이터 로그 스케일 변환\nsc.pp.log1p(adata)\n# 고변동성 유전자 식별\nsc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)\n\n# 나중에 사용하기 위해 AnnData 객체의 .raw 속성을 정규화되고 로그 스케일링된 원시 유전자 발현으로 설정\nadata.raw = adata\n\n# 필터링 실행\nadata = adata[:, adata.var.highly_variable]\n\n# 각 세포의 총 카운트 및 발현된 미토콘드리아 유전자의 백분율 효과를 회귀로 제거하고 데이터를 단위 분산으로 스케일링\nsc.pp.regress_out(adata, [\"total_counts\", \"pct_counts_mt\"])\n# 각 유전자를 단위 분산으로 스케일링하고 표준 편차가 10을 초과하는 값을 클리핑\nsc.pp.scale(adata, max_value=10)\n# PCA 수행\nsc.tl.pca(adata, svd_solver=\"arpack\")\n# 이웃 찾기\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\n# UMAP 수행\nsc.tl.umap(adata)\n# Leiden 알고리즘을 사용하여 클러스터링 수행\nsc.tl.leiden(\n    adata,\n    resolution=0.4,\n    random_state=42,\n)\n\n# 처리된 데이터셋 반환\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 1838\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors', 'umap', 'leiden'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    obsp: 'distances', 'connectivities'\n\n\n이제 유전자의 갯수가 13,714개에서 1,838개로 줄어다는 것을 알 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#umap-그리기",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#umap-그리기",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "3.3 UMAP 그리기",
    "text": "3.3 UMAP 그리기\n\n# UMAP 시각화\nsc.pl.umap(\n    adata,\n    color=\"leiden\",  # 클러스터링 결과에 따라 색상 지정\n    add_outline=True,  # 클러스터 경계 추가\n    legend_loc=\"on data\",  # 범례 위치 설정\n    legend_fontsize=12,  # 범례 글꼴 크기 설정\n    legend_fontoutline=2,  # 범례 글꼴 외곽선 굵기 설정\n    frameon=False,  # 테두리 제거\n    palette=\"Set1\",  # 색상 팔레트 설정\n)\n\n\n\n\n\n\n\n\n이 데이터셋은 이미 많이 알려진 것이라. 클러스터에 대한 마커 유전자를 찾고 어떤 세포인지 알아내는 과정은 생략하겠습니다.\n아래와 같이 수동으로 이름을 지정해줍니다. 숫자로 표시되는 각각의 클러스터에 대하여 아래 코드를 통해 이름을 붙여줍니다.\n\nnew_cluster_names = [\n    \"CD4T\",  # CD4T 세포\n    \"Monocytes\",  # 단핵구\n    \"CD8T\",  # CD8T 세포\n    \"B cells\",  # B 세포\n    \"Dendritic\",  # 수상돌기세포\n    \"Megakaryocytes\",  # 거대혈소판세포\n]\nadata.rename_categories(\"leiden\", new_cluster_names)\n\n# 클러스터링된 세포의 UMAP 다시 시각화\nsc.pl.umap(\n    adata,\n    color=\"leiden\",  # 클러스터링 결과에 따라 색상 지정\n    add_outline=True,  # 클러스터 경계 추가\n    legend_loc=\"on data\",  # 범례 위치 설정\n    legend_fontsize=12,  # 범례 글꼴 크기 설정\n    legend_fontoutline=2,  # 범례 글꼴 외곽선 굵기 설정\n    frameon=False,  # 테두리 제거\n    palette=\"Set1\",  # 색상 팔레트 설정\n)\n\n\n\n\n\n\n\n\n이후 데이터를 다시 읽어왔을때와 동일한지 확인하기 위해 adata 객체에 포함되어 있는 메타데이터의 데이터형을 확인합니다.\n\n# adata 메타데이터의 데이터 타입\nadata.obs.dtypes\n\nn_genes                 int64\nn_genes_by_counts       int32\ntotal_counts          float32\ntotal_counts_mt       float32\npct_counts_mt         float32\nleiden               category\ndtype: object"
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#h5ad-파일로-저장하기",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#h5ad-파일로-저장하기",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "3.4 H5AD 파일로 저장하기",
    "text": "3.4 H5AD 파일로 저장하기\nAnnData 객체를 저장할때는 H5AD(Hierarchical Data Format 5) 파일을 사용합니다. 이 파일 형식은 대용량 데이터셋의 주요 구성 요소(예: 표현형 데이터, 주석, 메타데이터)를 계층적으로 구조화해서 효율적으로 저장하고 처리할 수 있게 해 줍니다.\n\n# 분석 결과를 저장할 파일 경로\noutput_path = \"../output/pbmc3k/\"\n# `compression='gzip'`는 디스크 공간을 절약하지만 쓰기와 이후의 읽기가 약간 느려집니다.\nadata.write(output_path + \"pbmc3k.h5ad\", compression=\"gzip\")"
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#h5ad-파일-다시-불러오기",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#h5ad-파일-다시-불러오기",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "3.5 H5AD 파일 다시 불러오기",
    "text": "3.5 H5AD 파일 다시 불러오기\nsc.read_h5ad 함수는 H5AD 파일 형식을 AnnData 객체로 직접 불러옵니다.\n\n# 저장했던 h5ad파일을 다시 불러옵니다.\nadata = sc.read_h5ad(output_path + \"pbmc3k.h5ad\")\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 1838\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'\n    uns: 'hvg', 'leiden', 'leiden_colors', 'log1p', 'neighbors', 'pca', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    obsp: 'connectivities', 'distances'\n\n\n데이터를 다시 불러와보니 유전자의 갯수가 1,838개입니다. highly variable 유전자가 아닌 원래 유전자 데이터로 되돌리려면 아래와 같이 해줍니다.\n\n# AnnData 객체를 불러온 후 원시 데이터로 변환\nadata = adata.raw.to_adata()\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 13714\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'hvg', 'leiden', 'leiden_colors', 'log1p', 'neighbors', 'pca', 'umap'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'connectivities', 'distances'\n\n\n이제 유전자의 갯수가 13,714개로 돌아왔습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#read_10x_mtx함수-사용",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#read_10x_mtx함수-사용",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "5.1 read_10x_mtx()함수 사용",
    "text": "5.1 read_10x_mtx()함수 사용\n만약 다른 분석 도구를 통해 처리된 데이터의 경우라면 그리 추천하지는 않는 방법입니다.\n\n# 데이터 읽기\nadata = sc.read_10x_mtx(\n    output_path,  # `.mtx` 파일이 있는 디렉토리\n    var_names=\"gene_symbols\",  # 변수 이름에 유전자 기호 사용 (변수 축 인덱스)\n)\n\n# `sc.read_10x_mtx`에서 `var_names='gene_ids'`를 사용하는 경우 이 작업이 필요하지 않음\nadata.var_names_make_unique()\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 13714\n    var: 'gene_ids'\n\n\nadata.var 출력을 확인해 정상적으로 유전자 이름을 불러왔는지도 확인합니다.\n\nadata.var\n\n\n\n\n\n\n\n\ngene_ids\n\n\n\n\nAL627309.1\nENSG00000237683\n\n\nAP006222.2\nENSG00000228463\n\n\nRP11-206L10.2\nENSG00000228327\n\n\nRP11-206L10.9\nENSG00000237491\n\n\nLINC00115\nENSG00000225880\n\n\n...\n...\n\n\nAC145212.1\nENSG00000215750\n\n\nAL592183.1\nENSG00000220023\n\n\nAL354822.1\nENSG00000215615\n\n\nPNRC2-1\nENSG00000215700\n\n\nSRSF10-1\nENSG00000215699\n\n\n\n\n13714 rows × 1 columns\n\n\n\n기존에 작업한 메타데이터와 UMAP 좌표 정보도 불러옵니다.\n\n# 세포 메타데이터 불러오기\ncell_meta = pd.read_csv(output_path + \"metadata.tsv\", sep=\"\\t\", index_col=0)\n# AnnData 객체에 메타데이터 및 변수 이름 설정\nadata.obs = cell_meta\n\n# UMAP 데이터 불러오기\numap = pd.read_csv(\n    output_path + \"UMAP.tsv\",\n    sep=\"\\t\",\n    index_col=0,\n)\n# UMAP 데이터 설정\nadata.obsm[\"X_umap\"] = umap.loc[adata.obs.index].values\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 13714\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'gene_ids'\n    obsm: 'X_umap'\n\n\n위 결과를 통해 정상적으로 데이터를 불러왔음을 확인 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/tool_scanpy_adata2mtx.html#수작업으로-anndata-객체를-만드는-방법",
    "href": "posts/ipynb/tool_scanpy_adata2mtx.html#수작업으로-anndata-객체를-만드는-방법",
    "title": "AnnData 객체를 10X MEX 형식으로 저장하기",
    "section": "5.2 수작업으로 Anndata 객체를 만드는 방법",
    "text": "5.2 수작업으로 Anndata 객체를 만드는 방법\n수작업을 통해 만드는 방법을 해봅니다. 10X MEX format과 동일하지는 않지만 유사한 형태의 경우에는 이 방법이 유용합니다.\n\n# mtx 희소 행렬 불러오기\nX = mmread(output_path + \"matrix.mtx\")\n\n# AnnData 객체 생성\nadata = anndata.AnnData(X=X.transpose().tocsr())\n\n# 세포 메타데이터 불러오기\ncell_meta = pd.read_csv(output_path + \"metadata.tsv\", sep=\"\\t\", index_col=0)\n\n# 유전자 이름 불러오기\ngene_names = pd.read_csv(\n    output_path + \"genes.tsv\",\n    sep=\"\\t\",\n    index_col=None,\n    header=None,\n    names=[\"gene_ids\", \"gene_symbols\"],\n)\n\n# 바코드 불러오기\nbarcodes = pd.read_csv(\n    input_path + \"barcodes.tsv\",\n    sep=\"\\t\",\n    index_col=0,\n    header=None,\n)\n\n# AnnData 객체에 메타데이터 및 변수 이름 설정\nadata.obs = cell_meta\nadata.obs.index = list(barcodes.index)\nadata.var.index = gene_names[\"gene_symbols\"].values\nadata.var[\"gene_ids\"] = gene_names[\"gene_ids\"].values\n\n# UMAP 데이터 불러오기\numap = pd.read_csv(\n    output_path + \"UMAP.tsv\",\n    sep=\"\\t\",\n    index_col=0,\n)\n# UMAP 데이터 설정\nadata.obsm[\"X_umap\"] = umap.loc[adata.obs.index].values\n\n# adata 데이터 확인\nadata\n\nAnnData object with n_obs × n_vars = 2638 × 13714\n    obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'\n    var: 'gene_ids'\n    obsm: 'X_umap'\n\n\n\n5.2.1 메타 데이터의 데이터형 확인하기\n위의 방법을 통해 메타 데이터를 불러오면 데이터의 형이 잘못 지정되는 경우가 있습니다.\n\n# adata.obs의 데이터 타입 확인\nadata.obs.dtypes\n\nn_genes                int64\nn_genes_by_counts      int64\ntotal_counts         float64\ntotal_counts_mt      float64\npct_counts_mt        float64\nleiden                object\ndtype: object\n\n\n예를 들면 leiden 클러스터는 기본적으로 숫자로 지정되는데 다시 불러오는 과정 중에 category가 아닌 int형으로 되는 경우가 있습니다. 이번에는 object로 되어 있습니다. 아래와 같이 category로 수정해줍니다.\n\n# adata.obs의 'leiden' 열을 범주형으로 변환한 후 데이터 타입 확인\nadata.obs.astype({\"leiden\": \"category\"}).dtypes\n\nn_genes                 int64\nn_genes_by_counts       int64\ntotal_counts          float64\ntotal_counts_mt       float64\npct_counts_mt         float64\nleiden               category\ndtype: object\n\n\nUMAP을 그려서 마지막으로 확인해 봅니다.\n\n# UMAP 시각화\nsc.pl.umap(\n    adata,\n    color=\"leiden\",  # 클러스터링 결과에 따라 색상 지정\n    add_outline=True,  # 클러스터 경계 추가\n    legend_loc=\"on data\",  # 범례 위치 설정\n    legend_fontsize=12,  # 범례 글꼴 크기 설정\n    legend_fontoutline=2,  # 범례 글꼴 외곽선 굵기 설정\n    frameon=False,  # 테두리 제거\n    palette=\"Set1\",  # 색상 팔레트 설정\n)\n\n\n\n\n\n\n\n\nUMAP이 문제없이 재현되는 것을 확인 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html",
    "href": "posts/ipynb/da_scanpy_workshop_01.html",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "",
    "text": "단일 세포 RNA 시퀀싱(single-cell RNA sequencing, scRNA-seq)은 개별 세포의 전사체(transcriptome)를 분석하여 세포 간의 이질성을 탐구하는 강력한 도구이지만, 기술적 잡음과 변동성이 높아 데이터 품질 저하의 위험이 큽니다. 따라서 낮은 품질의 데이터를 사용하면 잘못된 생물학적 결론을 도출할 수 있으며 이는 후속 연구 및 임상 적용에 부정적인 영향을 미칠 수 있습니다. 그러므로 이번 글에서 scRNA-seq 데이터의 품질 관리에 대해서 알아보겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#품질-지표-계산하기",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#품질-지표-계산하기",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.1 품질 지표 계산하기",
    "text": "3.1 품질 지표 계산하기\n데이터가 확보되면 이제 몇 가지 데이터 품질 지표를 계산합니다. 예를 들어 세포당 미토콘드리아 유전자의 비율, 세포당 리보솜 유전자의 비율, 세포당 헤모글로빈 유전자의 비율(적혈구 오염을 나타낼 수 있습니다.)등을 계산해 메타데이터에 추가해보죠. 이것들은 계산하는 방법에는 여러 가지가 있지만 기본적으로 calculate_qc_metrics함수를 사용하는게 편리합니다.\n일반적으로 사용되는 품질 지표의 이름과 설명은 아래 목록을 참고하세요.\n\nn_genes_by_counts: 각 세포에서 1개 이상 검출된 유전자의 수. Seurat에서는 nFeature_RNA에 해당합니다.\ntotal_counts: 각 세포에서 읽은 Read의 수. Seurat에서는 nCount_RNA에 해당합니다.\npct_counts_mt: total counts 중 미토콘드리아 유전자의 비율.\n\n\n\n\n\n\n\nNote\n\n\n\ntotal_counts와 n_genes_by_counts는 같은 의미가 아닙니다. 예를 들어 두개의 세포를 하나로 잘못 인식한 이중체(Doublet)의 경우 total_counts수는 높지만 검출된 유전자의 수는 상대적으로 적겠죠.\n\n\n\n# 미토콘드리아 유전자\nadata.var[\"mt\"] = adata.var_names.str.startswith(\"MT-\")\n# 리보솜 유전자\nadata.var[\"ribo\"] = adata.var_names.str.startswith((\"RPS\", \"RPL\"))\n# 적혈구 유전자\nadata.var[\"hb\"] = adata.var_names.str.contains(\"^HB[^(P|E|S)]\")\n\nsc.pp.calculate_qc_metrics(\n    adata, qc_vars=[\"mt\", \"ribo\", \"hb\"], percent_top=None, log1p=True, inplace=True\n)\n\n이제 메타데이터 슬롯에 데이터 품질 지표가 추가되었습니다. 바이올린 플롯을 통해 발현된 전체 유전자의 수, 셀당 총 유전자의 수, 미토콘드리아 유전자의 비율을 살펴보죠."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#qc-플롯",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#qc-플롯",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.2 QC 플롯",
    "text": "3.2 QC 플롯\n\nsc.pl.violin(\n    adata,\n    [\n        \"n_genes_by_counts\",\n        \"total_counts\",\n        \"pct_counts_mt\",\n        \"pct_counts_ribo\",\n        \"pct_counts_hb\",\n    ],\n    jitter=0.4,\n    groupby=\"sample\",\n    rotation=90,\n    multi_panel=True,\n)\n\n\n\n\n\n\n\n\n위 그림에서 알 수 있듯이 샘플의 품질에 상당한 차이가 있습니다. 예를 들어 covid_15와 covid_16 샘플은 미토콘드리아 함량이 더 많은 세포를 가지고 있습니다. 반면에 리보솜 유전자의 비율은 다른 샘플보다 적게 검출되었습니다.\n다른 시각화 방법으로 QC 측정값을 산점도로 표시해봅니다.\n\nsc.pl.scatter(adata, x=\"total_counts\", y=\"n_genes_by_counts\", color=\"pct_counts_mt\")\n\n\n\n\n\n\n\n\n위 그림을 보면 미토콘드리아 유전자의 비율이 높은 세포들은 total_counts와 n_genes_by_counts의 수가 적음을 알 수 있습니다. 이것을 통해 해당 세포들의 상태가 좋지 않다는 것을 유추할 수 있습니다.\n따라서 임계값을 설정해 미토콘드리아 유전자가 너무 많이 발현되거나 유전자의 총 개수가 너무 많은 세포들을 제거합니다. 여기서 주의할 점은 가끔 QC 지표가 좋지 않은 것처럼 보이는 세포도 생물학적 의미를 가지고 있을 수 있다는 것입니다. 그러므로 가능하다면 관대한 필터링를 적용하면서 시작하는 게 좋습니다. 뿐만 아니라 여러 배치가 포함된 데이터셋의 경우 임계값이 배치 간에 매우 크게 달라질 수 있어서 각 배치에 대해서 개별적으로 데이터 품질 관리를 수행해야 합니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#필터링",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#필터링",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.3 필터링",
    "text": "3.3 필터링\n필터링은 임계값 이하의 데이터들을 제거하는 단계입니다. 데이터의 노이즈를 줄이는 것이라고도 생각할 수 있습니다.\n\n3.3.1 검출 기반 필터링\n검출 기반 필터링은 판독 횟수가 적은 세포와 최소 지정된 수의 세포에 존재하는 유전자를 필터링하는 것입니다. 일반적으로 200개 이상의 유전자가 검출된 세포와 유전자는 최소 3개 이상의 세포 조건을 많이 사용합니다. 이 값은 사용된 라이브러리 준비 방법에 따라 크게 달라질 수 있다는 점을 염두해 두세요.\n\nsc.pp.filter_cells(adata, min_genes=200)\nsc.pp.filter_genes(adata, min_cells=3)\n\n# 데이터 추가\nnew_data = {\n    \"단계\": \"검출 기반 필터링\",\n    \"바코드의 수\": adata.n_obs,\n    \"유전자의 수\": adata.n_vars,\n}\ndf_report = pd.concat([df_report, pd.DataFrame([new_data])], ignore_index=True)\ndf_report\n\n\n\n\n\n\n\n\n단계\n바코드의 수\n유전자의 수\n\n\n\n\n0\n원본\n12000\n33538\n\n\n1\n검출 기반 필터링\n10664\n19491\n\n\n\n\n\n\n\n결과를 보니 바코드의 수와 유전자의 수가 동시에 줄어들었다는 것을 알 수 있습니다. 이제 어떤 유전자가 시퀀서에서 많이 읽혔는지도 확인해보죠.\n\nsc.pl.highest_expr_genes(adata, n_top=20)\n\n\n\n\n\n\n\n\n위 결과를 통해 MALAT1라는 유전자가 아주 많이 읽혔다는 것을 알 수 있으며 다른 상위 유전자들은 미토콘드리아 혹은 리보솜 유전자라는 것을 확인할 수 있습니다.\n\nMALAT1은 poly-A 서열을 가지고 있어 scRNA-seq에서 상대적으로 높게 검출되는 것으로 알려져 있습니다.\n\n이제 품질 관리 및 필터링에 중요한 몇가지 유전자에 대한 정보를 모아보겠습니다.\n\n\n3.3.2 미토콘드리아/리보솜 유전자 필터링\n미토콘드리아와 리보솜 유전자에 관련된 필터링에 대한 3가지 접근법이 있습니다.\n\n미토콘드리아 유전자 비율이 높고 리보솜 유전자 비율이 낮은 세포를 제거하기.\n데이터에서 미토콘드리아 유전자 정보를 제거하고 나머지 유전자 데이터만 사용하기.\n데이터를 스케일링을 할 때 percent_mito를 회귀시키기.(다만 이 경우 일부 세포에서 유전자 발현 정보가 매우 적게 남을 가능성이 있습니다.)\n\n만약 필터링 후에도 충분한 세포가 남아 있다면 첫번째 방법을 사용하는게 가장 현명한 방법입니다. 이 예제의 경우 대부분의 세포가 미토콘드리아 판독값이 20% 미만이기 때문에 이 값을 임계값으로 사용해 제거하겠습니다. 리보솜 유전자도 마찬가지로 판독률이 5% 미만인 세포는 제거합니다.\n\n# 미토콘드리아 유전자 필터\nadata = adata[adata.obs[\"pct_counts_mt\"] &lt; 20, :]\n\n# 리보솜 유전자 필터\nadata = adata[adata.obs[\"pct_counts_ribo\"] &gt; 5, :]\n\n# 데이터 추가\nnew_data = {\n    \"단계\": \"MT/Ribo 유전자 비율 필터링\",\n    \"바코드의 수\": adata.n_obs,\n    \"유전자의 수\": adata.n_vars,\n}\ndf_report = pd.concat([df_report, pd.DataFrame([new_data])], ignore_index=True)\ndf_report\n\n\n\n\n\n\n\n\n단계\n바코드의 수\n유전자의 수\n\n\n\n\n0\n원본\n12000\n33538\n\n\n1\n검출 기반 필터링\n10664\n19491\n\n\n2\nMT/Ribo 유전자 비율 필터링\n7431\n19491\n\n\n\n\n\n\n\n미토콘드리아와 리보솜 유전자 비율에 대한 필터링으로 바코드의 수가 감소되었다는 것을 알 수 있습니다. 다만 유전자의 수는 그대로입니다. 이제 환자 샘플별로 얼마나 줄었는지 확인해보겠습니다. 처음 바코드의 숫자는 1500개였다는 기억하세요.\n\nprint(adata.obs[\"sample\"].value_counts())\n\nsample\nctrl_13     1173\nctrl_19     1170\ncovid_17    1101\nctrl_14     1063\nctrl_5      1052\ncovid_1      900\ncovid_15     599\ncovid_16     373\nName: count, dtype: int64\n\n\n역시 covid_15, 16 샘플에서 많은 데이터가 필터링 되었네요.\n\n\n3.3.3 유전자 데이터 필터링\n이 예제 데이터에서는 미토콘드리아, 적혈구(HB) 그리고 MALAT1 유전자는 주로 기술적인 문제에 의한 것으로 보입니다. 따라서 해당 유전자에 대한 데이터를 필터링하는것이 현명해 보입니다. 아래는 해당 유전자의 데이터를 제거하는 코드입니다.\n\nmalat1 = adata.var_names.str.startswith(\"MALAT1\")\n# 미토콘드리아 유전자를 처음에 정의한 이후 다시 정의해야 합니다.\n# 발현이 낮은 유전자를 제거하기 전에 전체 오브젝트에서 계산한 값입니다.\nmito_genes = adata.var_names.str.startswith(\"MT-\")\nhb_genes = adata.var_names.str.contains(\"^HB[^(P|E|S)]\")\n\nremove = np.add(mito_genes, malat1)\nremove = np.add(remove, hb_genes)\nkeep = np.invert(remove)\n\nadata = adata[:, keep]\n\n# 행이나 열방향으로 0으로만 존재하는 값이 있는지 확인\nprint(np.any(adata.X.sum(axis=0) == 0))\nprint(np.any(adata.X.sum(axis=1) == 0))\n\nTrue\nFalse\n\n\n위 결과를 보니 유전자를 전혀 포함하지 않는 바코드 데이터가 (np.any(adata.X.sum(axis=0) == 0)값이 True임으로) 존재하는 것 같네요. 다시 filter_genes을 적용하고 확인합니다.\n\nsc.pp.filter_genes(adata, min_cells=3)\n\n# 행이나 열방향으로 0으로만 존재하는 값이 있는지 확인\nprint(np.any(adata.X.sum(axis=0) == 0))\nprint(np.any(adata.X.sum(axis=1) == 0))\n\nFalse\nFalse\n\n\n이제 모두 False임으로 문제가 없습니다. 얼마나 많은 유전자 데이터가 필터링 되었는지 확인해봅시다.\n\n# 데이터 추가\nnew_data = {\n    \"단계\": \"특정 유전자 필터링\",\n    \"바코드의 수\": adata.n_obs,\n    \"유전자의 수\": adata.n_vars,\n}\ndf_report = pd.concat([df_report, pd.DataFrame([new_data])], ignore_index=True)\ndf_report\n\n\n\n\n\n\n\n\n단계\n바코드의 수\n유전자의 수\n\n\n\n\n0\n원본\n12000\n33538\n\n\n1\n검출 기반 필터링\n10664\n19491\n\n\n2\nMT/Ribo 유전자 비율 필터링\n7431\n19491\n\n\n3\n특정 유전자 필터링\n7431\n19094\n\n\n\n\n\n\n\n유전자의 수가 약 400개 정도 감소하였습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#이중체doublet-예측",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#이중체doublet-예측",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.4 이중체(Doublet) 예측",
    "text": "3.4 이중체(Doublet) 예측\n드롭렛(Droplet)을 만들어 분석하는 scRNA-seq 기술에서 동일한 드롭렛에 여러개의 세포가 들어가는 것은 생각보다 자주 발생하는 문제이며 이중체(Doublet)라고 부릅니다. 10X genomics사의 일반적인 Single Cell 3’ Gene Expression v3.1 assay 실험법의 경우 이중체의 비율은 세포의 양에 선형적으로 비례한다고 알려져 있습니다. 아래는 사용자 가이드에 명시된 더블렛의 비율입니다.\n\n\n\nMultiplet Rate (%)\n# of Cells Loaded\n# of Cells Recovered\n\n\n\n\n0.4%\n~825\n~500\n\n\n0.8%\n~1,650\n~1,000\n\n\n2.4%\n~4,950\n~3,000\n\n\n3.2%\n~6,300\n~4,000\n\n\n4.0%\n~8,250\n~5,000\n\n\n5.6%\n~11,550\n~7,000\n\n\n6.4%\n~13,200\n~8000\n\n\n7.2%\n~14,850\n~9,000\n\n\n8.0%\n~16,500\n~10,000\n\n\n\n예시 데이터셋은 샘플당 약 5,000개의 세포가 있었습니다. 따라서 약 9,000개 세포로 드롭렛을 만들었다고 보여지며 약 4%의 더블렛이 포함되어 있을 것으로 예측됩니다.\n하나의 세포에서 검출된 유전자 총 수가 너무 많은 경우는 이중체(Doublet; 2개의 세포가 1개로 분석되는 경우)일 가능성이 있습니다. 그러나 세포 유형 구성에 따라 더 많은 수의 유전자를 가진 세포가 있을 수도 있기 때문에 문제가 복잡해집니다.\n이중체를 예측하는 방법에는 여러가지가 있지만 최신 버전 Scanpy에는 이중체 감지를 위한 Scrublet 패키지가 포함되어 있습니다. Scrublet은 관찰된 전사체와 시뮬레이션된 이중체의 KNN을 만들어 이중체를 예측합니다. sc.pp.scrublet함수를 사용하면 doublet_score와 predicted_doublet을 .obs에 추가되고 바로 필터링하거나 클러스터링을 하고나서 나중에 doublet_score를 사용해 높은 이중점수를 가진 클러스터를 필터링할 수 있습니다.\n\n\n\n\n\n\nNote\n\n\n\n더블렛 감지를 위한 다른 방법으로 scverse 생태계에는 DoubletDetection 및 SOLO가 있습니다. 더 자세한 내용은 sc-best-practice 문서에서 확인할 수 있습니다.\n\n\n아래 코드를 사용해 이중체를 예측하고 감지된 세포의 수를 나타내겠습니다.\n\nsc.pp.scrublet(adata, batch_key=\"sample\")\nnum_doublet = sum(adata.obs[\"predicted_doublet\"])\nprint(f\"이중체로 감지된 세포의 수: {num_doublet}\")\n\n이중체로 감지된 세포의 수: 204\n\n\n이중체로 예측된 세포에서 더 많은 유전자가 검출되는지 시각화를 통해 살펴보죠.\n\n# 참/거짓 대신 싱글렛/더블렛으로 열에 추가합니다.\nadata.obs[\"doublet_info\"] = adata.obs[\"predicted_doublet\"].astype(str)\nsc.pl.violin(adata, \"n_genes_by_counts\", size=0, groupby=\"doublet_info\", rotation=45)\n\n\n\n\n\n\n\n\n확실히 이중체로 예측된 세포들이 n_genes_by_counts 값이 높다는 것을 알 수 있습니다. 이제 데이터들을 클러스터링 해서 이중체가 독자적인 클러스터를 형성하는지 확인해보죠. 가장 먼저 유전자 카운트 데이터를 정규화해야 합니다.\n\n# 카운트 데이터 저장\nadata.layers[\"counts\"] = adata.X.copy()\n# 총 개수 중앙값으로 정규화\nsc.pp.normalize_total(adata)\n# 로그값으로 변환\nsc.pp.log1p(adata)"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#특징feature-선택",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#특징feature-선택",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.5 특징(Feature) 선택",
    "text": "3.5 특징(Feature) 선택\n사실 scRNA-seq 데이터에 포함된 많은 유전자들은 모든 세포에서 발현량이 높거나 낮아서 생물학적으로 큰 의미는 없고 데이터셋의 차원(크기)을 높이기만 하는 경우가 많습니다. 따라서 특징 선택이라는 단계를 통해서 차이가 있는 유전자들만 남겨서 이후 분석의 계산량을 줄여줍니다. 여기서는 차이가 큰 유전자(highly variable genes) 2000개를 고릅니다.\n\n\n\n\n\n\nNote\n\n\n\n예전 버전의 scanpy에서는 특징 선택후 adata객체를 subset하는 과정(adata = adata[:, adata.var.highly_variable])이 필요했지만 최근 버전에는 불필요하게 변경되었습니다.\n\n\n\nsc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=\"sample\")\nsc.pl.highly_variable_genes(adata)\n\n\n\n\n\n\n\n\n\n# `regress_out` 함수를 사용한 회귀는 데이터셋에 따라 정보가 소실될 수 있습니다.\n# 따라서 여기서는 사용하지 않고 아래 코드를 주석 처리하였습니다.\n# sc.pp.regress_out(adata, [\"total_counts\", \"pct_counts_mt\"])\n# sc.pp.scale(adata, max_value=10)\n\nsc.tl.pca(adata)\nsc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)\nsc.tl.umap(adata)\n\n\nsc.pl.umap(adata, color=[\"doublet_score\", \"doublet_info\", \"sample\"])\n\n\n\n\n\n\n\n\n위 그림을 비교해보면 이중체 점수가 높은 세포들은 샘플 혹은 클러스터와 연관은 없어보입니다. 따라서 doublet_info값을 사용해 예상되는 이중체를 모두 제거해 보겠습니다.\n\nadata = adata[adata.obs[\"doublet_info\"] == \"False\", :]\n\n# 데이터 추가\nnew_data = {\n    \"단계\": \"이중체 필터링\",\n    \"바코드의 수\": adata.n_obs,\n    \"유전자의 수\": adata.n_vars,\n}\ndf_report = pd.concat([df_report, pd.DataFrame([new_data])], ignore_index=True)\ndf_report\n\n\n\n\n\n\n\n\n단계\n바코드의 수\n유전자의 수\n\n\n\n\n0\n원본\n12000\n33538\n\n\n1\n검출 기반 필터링\n10664\n19491\n\n\n2\nMT/Ribo 유전자 비율 필터링\n7431\n19491\n\n\n3\n특정 유전자 필터링\n7431\n19094\n\n\n4\n이중체 필터링\n7227\n19094\n\n\n\n\n\n\n\n이중체 필터링을 통해 대략적으로 200개의 바코드가 감소하였습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#성염색체-편향bias-확인",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#성염색체-편향bias-확인",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.6 성염색체 편향(Bias) 확인",
    "text": "3.6 성염색체 편향(Bias) 확인\n분석 결과에 성염색체에 의한 바이어스가 포함되지 않도록 애초에 scRNA-seq 실험을 계획 할때 단일한 성별로 제한하는 것이 이상적입니다. 그렇지 않다면 아래 같이 추가적인 작업을 통해 성염색체에 대한 편향 확인이 필요합니다. 예를들어 염색체Y(수컷)와 X(주로 여성) 발현량을 샘플별로 파악해보면 샘플의 성별을 쉽게 파악할 수 있습니다. 또한 샘플 메타데이터에 성별 정보가 있다면 예측 결과와 비교해 레이블이 잘못되었는지 확인할 수 있습니다.\n유전자의 염색체 위치 정보는 서열 데이터를 alingment할 때 사용한 gtf파일에서 가져오는 것이 가장 이상적입니다. 그러나 여기에서는 Biomart 도구를 사용해 염색체의 위치 정보를 얻어오는 작업을 해봅니다.\n\n# pybiomart 설치 필요\nannot = sc.queries.biomart_annotations(\n    \"hsapiens\",\n    [\n        \"ensembl_gene_id\",\n        \"external_gene_name\",\n        \"start_position\",\n        \"end_position\",\n        \"chromosome_name\",\n    ],\n).set_index(\"external_gene_name\")\n\n# adata.var[annot.columns] = annot\n\n이제 염색체 정보를 얻었으므로 세포당 염색체 Y에서 나온 읽기 비율을 계산할 수 있습니다.\n\nchrY_genes = adata.var_names.intersection(annot.index[annot.chromosome_name == \"Y\"])\n\nadata.obs[\"percent_chrY\"] = (\n    np.sum(adata[:, chrY_genes].X, axis=1).A1 / np.sum(adata.X, axis=1).A1 * 100\n)\n\n# 플랏을 위한 색상을 추가합니다.\nadata.obs[\"XIST-counts\"] = adata.X[:, adata.var_names.str.match(\"XIST\")].toarray()\n\n바이올린 플롯을 그려 XIST과 chrY 비율을 살펴보죠.\n\nsc.pl.violin(adata, [\"XIST-counts\", \"percent_chrY\"], jitter=0.4, groupby=\"sample\", rotation=45)\n\n\n\n\n\n\n\n\n위 그림을 통해 남성의 시료가 3개 여성의 시료가 5개임을 알 수 있습니다. 다행히도 한 쪽에 쏠려있지는 않아서 성염색체에 의한 편향은 무시해도 괜찮을 것 같습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#세포-주기-예측",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#세포-주기-예측",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.7 세포 주기 예측",
    "text": "3.7 세포 주기 예측\n이제 세포 주기에 대한 예측을 해봅니다. 세포 주기를 예측하는 원리는 세포 주기 참조 유전자의 목록과 비교해서 유전자의 평균 발현에 대한 차이를 계산하는 것입니다. 따라서 세포 주기 참조 유전자 목록이 필요합니다. 여기에서는 Regev 연구소에서 만든 파일을 사용해 메타데이터에 S 단계에 대한 점수, G2M 단계에 대한 점수, 예측된 세포 주기 단계를 추가하겠습니다.\n\ncell_cycle_genes = [x.strip() for x in open(path_parent + \"/regev_lab_cell_cycle_genes.txt\")]\n\n# 2개의 목록으로 분할\ns_genes = cell_cycle_genes[:43]\ng2m_genes = cell_cycle_genes[43:]\n\ncell_cycle_genes = [x for x in cell_cycle_genes if x in adata.var_names]\nprint(f\"포함되어 있는 세포 주기 유전자의 수: {len(cell_cycle_genes)}\")\n\n포함되어 있는 세포 주기 유전자의 수: 94\n\n\n세포 주기를 예측하기 전에 먼저 유전자 카운트 데이터를 정규화해야 합니다. 이미 앞선 코드에서 정규화 및 로그 변환까지 되어 있는 상황임으로 데이터 스케일링만 실행하고 세포 주기를 예측합니다.\n\nsc.pp.scale(adata, max_value=10)\n# 세포 주기 예측\nsc.tl.score_genes_cell_cycle(adata, s_genes=s_genes, g2m_genes=g2m_genes)\n\n세포 주기 점수에 대해 시각화를 해봅니다. 일반적인 세포 주기는 다음 3가지로 구분됩니다.\n\nG1: 단백질 합성기, 세포의 성장기.\nS: DNA 복제기, DNA의 양이 두배가 된다.\nG2: 세포 분열 준비기\n\n\n# 바이올린 플랏\n# sc.pl.violin(adata, [\"S_score\", \"G2M_score\"], jitter=0.4, groupby=\"sample\", rotation=60)\n# 산포도 플랏\nsc.pl.scatter(adata, x=\"S_score\", y=\"G2M_score\", color=\"phase\")\n\n\n\n\n\n\n\n\n일반적인 사람 세포들은 G1기가 가장 긴것으로 알려져있습니다. 그러나 예시 데이터셋에는 G1기의 세포가 상대적으로 적어 보입니다. 이것은 세포 주기 예측의 기본 임계값이 0으로 고정되어 있기 때문으로 임계값 수정이 필요하다고 말할 수 있습니다. 따라서 세포 주기 예측은 결과 해석을 할 때 항상 주의해야 합니다.\n이제 QC과정을 거치면서 제거된 데이터들의 비율을 계산해보죠. 이것을 통해 어떤 단계를 다시 조정하는 것이 좋을지 판단할 수 있습니다.\n\n# 첫 번째 행의 바코드 수와 유전자 수 값 저장\ninitial_num_barcode = df_report.loc[0, \"바코드의 수\"]\ninitial_num_gene = df_report.loc[0, \"유전자의 수\"]\n\n# 비율 계산 후 새로운 열 추가\ndf_report[\"바코드 필터 비율\"] = df_report[\"바코드의 수\"] / initial_num_barcode\ndf_report[\"유전자 필터 비율\"] = df_report[\"유전자의 수\"] / initial_num_gene\n\ndf_report\n\n\n\n\n\n\n\n\n단계\n바코드의 수\n유전자의 수\n바코드 필터 비율\n유전자 필터 비율\n\n\n\n\n0\n원본\n12000\n33538\n1.0\n1.0\n\n\n1\n검출 기반 필터링\n10664\n19491\n0.888667\n0.581162\n\n\n2\nMT/Ribo 유전자 비율 필터링\n7431\n19491\n0.61925\n0.581162\n\n\n3\n특정 유전자 필터링\n7431\n19094\n0.61925\n0.569324\n\n\n4\n이중체 필터링\n7227\n19094\n0.60225\n0.569324\n\n\n\n\n\n\n\n위를 통해 검출 기반 필터링과 유전자 비율 필터링에서 많은 데이터가 제거되었다는 것을 알 수 있습니다. 따라서 다시 시작한다면 그 쪽의 매개변수를 조절해보는 것이 좋겠습니다."
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#데이터-정리하기",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#데이터-정리하기",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.8 데이터 정리하기",
    "text": "3.8 데이터 정리하기\n파일을 저장하기전 전체 파일의 크기를 줄이기 위해 필요하지 않아 보이는 데이터를 제거합니다.\n\n# 정규화 된 값을 원본 Count값으로 다시 되돌리기\nadata.X = adata.layers[\"counts\"].copy()\ndel adata.layers[\"counts\"]\n\n# 필요한 obs와 var 컬럼 지정\nrequired_obs_columns = [\"type\", \"sample\", \"batch\"]  # 실제 필요한 열로 대체\nrequired_var_columns = [\"gene_ids\", \"feature_types\", \"genome\"]  # 실제 필요한 열로 대체\n\n# obs에서 필요한 열만 남기고 삭제\nobs_columns_to_drop = [col for col in adata.obs.columns if col not in required_obs_columns]\nadata.obs.drop(columns=obs_columns_to_drop, inplace=True)\n\n# var에서 필요한 열만 남기고 삭제\nvar_columns_to_drop = [col for col in adata.var.columns if col not in required_var_columns]\nadata.var.drop(columns=var_columns_to_drop, inplace=True)\n\n# uns, obsm, varm, obsp 속성 삭제\nadata.uns = {}\nadata.obsm = {}\nadata.varm = {}\nadata.obsp = {}\n\n# 데이터 확인\nprint(adata)\n\nAnnData object with n_obs × n_vars = 7227 × 19094\n    obs: 'type', 'sample', 'batch'\n    var: 'gene_ids', 'feature_types', 'genome'"
  },
  {
    "objectID": "posts/ipynb/da_scanpy_workshop_01.html#데이터-저장",
    "href": "posts/ipynb/da_scanpy_workshop_01.html#데이터-저장",
    "title": "Scanpy로 scRNA-seq 분석 01",
    "section": "3.9 데이터 저장",
    "text": "3.9 데이터 저장\n마지막으로 QC된 데이터를 저장해 이후 분석에 사용합니다. Scanpy는 기본적으로 h5ad형식으로 파일을 저장합니다.\n\nadata.write_h5ad(\"./output/covid/results/scanpy_covid_qc.h5ad\", compression=\"gzip\")"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html",
    "href": "posts/ipynb/ml_LLM_pretraining.html",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "",
    "text": "이 글은 deeplearning.ai의 Pre-training LLM 강의를 듣고 나름대로 정리를 해본 글입니다. 자세한 내용은 강의를 참고해주세요. LLM 사전 학습은 컴퓨팅 파워가 많이 필요하기 때문에 사실상 개인이 수행하기에는 어려운 작업이지만, 이 글을 통해 LLM 사전 학습에 대한 전반적인 이해를 얻을 수 있을 것입니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#일반-사전학습-모델-불러오기",
    "href": "posts/ipynb/ml_LLM_pretraining.html#일반-사전학습-모델-불러오기",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "1.1 일반 사전학습 모델 불러오기",
    "text": "1.1 일반 사전학습 모델 불러오기\n여기서 예시로 다루는 TinySolar-248m-4k 모델은 248M 매개변수(GPT2와 비슷한 규모)와 4096 토큰 컨텍스트 윈도우를 가진 작은 디코더 전용 소형 모델입니다. 이 모델은 Hugging Face 모델 라이브러리에서 링크 확인 할 수 있습니다.\n모델을 불러오는 과정은 다음 세 단계로 이루어집니다: 1. Hugging Face 모델 라이브러리에서 모델 경로 지정하기 2. transformers 라이브러리의 AutoModelforCausalLM을 사용하여 모델 불러오기 3. 같은 모델 경로에서 모델의 토크나이저 불러오기"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#hugging-face에서-데이터-다운로드",
    "href": "posts/ipynb/ml_LLM_pretraining.html#hugging-face에서-데이터-다운로드",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "2.1 Hugging Face에서 데이터 다운로드",
    "text": "2.1 Hugging Face에서 데이터 다운로드\n여기서 다운로드하는 upstage/Pretraining_Dataset 데이터셋은 Red Pajama라는 훨씬 더 큰(1조 토큰 규모) 데이터셋의 서브셋입니다. 전체 데이터셋은 Hugging Face의 이 링크에서 확인할 수 있습니다.\n\nfrom datasets import load_dataset\n\npretraining_dataset = load_dataset(\"upstage/Pretraining_Dataset\", split=\"train\")\npretraining_dataset = pretraining_dataset.select_columns([\"text\"])\nprint(pretraining_dataset)\n\nDataset({\n    features: ['text'],\n    num_rows: 60000\n})\n\n\n\nprint(pretraining_dataset[\"text\"][0])\n\nIn 1793 Zaman Shah, a grandson of Ahmad Shah Durrani, won a brief war of succession to become ruler of Afghanistan. The support of Painda Khan, chief of the Baraksai branch of the Durrani tribe, was decisive in his victory. In the next fifty year., the brothers of Zaman shah and the sons of Painda Khan were to dominate the affairs of Afghanistan. The Durrani tribe was very large with several branches and numerous clans. 1 Abmad Shah and his successors belonged to the Sadozai clan, but other clans, such as the Mohammedzai of Painda Khan, were larger and more powerful and this situation caused many problems.\nMahmud had revolted unsuccessfully several times with Persian backing, but now with Fateh Khan's help he was able to defeat Zaman who was captured and blinded. Mahmud's position was insecure however. Persian invasions threatened, the tribes were discontented, and another brother of Zaman, Shuja-ul-Mulk, was in arms against him. In 1803 Shuja succeeded in toppling Mahmud after three years in power. But Shuja's rule was effective only in Kabul and Peshawar since Mahmud's brother Firuz held Herat, and Fateh Khan controUed the country around Kandahar. Mahmud escaped from the prison where he had been confined and in 1809 he and Fateh Khan defeated Shuja, who eventually fled to India where he was given a pension by the British, and Mabmud returned to power.\nDuring his years in power Fateh Khan had made many enemies including Mabmud's son Kamran, and most recently Firuz. At this point Fath Ali Shah of Persia sent Mahmud an ultimatum to dispose of Fateh Khan or face a massive Persian invasion. 5 These combined factors, persuaded Mahmud to sacrifice his vizier. Fateh Khan was seized, blinded, kept prisoner, and finally cut to pieces in 1818. 6 Like Zaman, Mabmud had destroyed the man who was keeping him on the throne and his fall was equally swift. Fateh Khan's brothers led a general revolt and assumed control themselves while Mabmud, Kamran, and Firuz fled to Herat.\nThese continued civil wars and the division of royal authority were disastrous for Afghanistan. Herat was cast adrift and now isolated and surrounded by enemies. On the west, the Persians were eager to make good their long-standing claim to the city. On the east, only the disunity of Fateh Khan's brothers prevented them from avenging him. Herat might have fallen to either one if it had not first begun to arouse the interest of outside powers.\n\n\n\n2.1.1 사전 학습 및 미세 조정 데이터 세트 비교\n다음 셀에서는 위에서 로드한 사전 학습 데이터 세트와 대조할 미세 조정 데이터 세트를 다운로드합니다. Alpaca 모델 및 명령어 튜닝 데이터 세트에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\n\nfrom datasets import load_dataset\n\ninstruction_dataset = load_dataset(\"c-s-ale/alpaca-gpt4-data\", split=\"train\")\n\ni = 0\n\nprint(f\"\"\"Instruction: {instruction_dataset[i][\"instruction\"]}\nInput: {instruction_dataset[i][\"input\"]}\nOutput: {instruction_dataset[i][\"output\"]}\"\"\")\n\nInstruction: Give three tips for staying healthy.\nInput: \nOutput: 1. Eat a balanced and nutritious diet: Make sure your meals are inclusive of a variety of fruits and vegetables, lean protein, whole grains, and healthy fats. This helps to provide your body with the essential nutrients to function at its best and can help prevent chronic diseases.\n\n2. Engage in regular physical activity: Exercise is crucial for maintaining strong bones, muscles, and cardiovascular health. Aim for at least 150 minutes of moderate aerobic exercise or 75 minutes of vigorous exercise each week.\n\n3. Get enough sleep: Getting enough quality sleep is crucial for physical and mental well-being. It helps to regulate mood, improve cognitive function, and supports healthy growth and immune function. Aim for 7-9 hours of sleep each night.\n\n\n사전 학습 데이터가 단순한 원시 텍스트로 구성된 것과 달리 미세 조정용 데이터 세트는 질문-답변 쌍이나 명령어-응답 형태로 구조화되어 있다는 것을 알 수 있습니다. 또한 필요한 경우 추가 입력 컨텍스트를 포함할 수도 있습니다. 다만 여기에서는 앞으로는 비구조화된 사전 학습 데이터 세트만 사용할 것입니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#직접-데이터-스크랩해오기",
    "href": "posts/ipynb/ml_LLM_pretraining.html#직접-데이터-스크랩해오기",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "2.2 직접 데이터 스크랩해오기",
    "text": "2.2 직접 데이터 스크랩해오기\n\nfrom datasets import Dataset, concatenate_datasets\n\n# 스크랩된 텍스트 데이터를 저장할 리스트 초기화\nscrap_text = []\nsource_dir = Path(\"../data/input/scraped_text\")\n\n# 디렉토리 내 모든 파일 읽기\nfor file_path in source_dir.iterdir():\n    if file_path.is_file():  # 파일인지 확인\n        with file_path.open(\"r\", encoding=\"utf-8\") as file:\n            scrap_text.append({\"text\": file.read()})\n\n# 리스트를 Dataset 객체로 변환\nscrap_text_dataset = Dataset.from_list(scrap_text)\n\n# 기존 데이터셋과 새로 만든 데이터셋 결합\ndataset = concatenate_datasets([pretraining_dataset, scrap_text_dataset])\n\n# 결과 출력\nprint(dataset)\n\nDataset({\n    features: ['text'],\n    num_rows: 60004\n})"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#데이터-정리",
    "href": "posts/ipynb/ml_LLM_pretraining.html#데이터-정리",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "2.3 데이터 정리",
    "text": "2.3 데이터 정리\n이제 다음과 같은 데이터 정리 단계를 수행합니다:\n\n너무 짧은 데이터 필터링\n\n하나의 텍스트 내에서 반복된 부분 제거\n\n중복된 문서 제거\n\n비영어 텍스트를 제거하는 품질 필터 적용\n\n\n2.3.1 너무 짧은 데이터 제거\n짧은 데이터는 모델이 학습하는 데 도움이 되지 않을 수 있습니다. 따라서 이번 단계에서는 너무 짧은 데이터를 제거합니다. 여기서는 3개 이하의 토큰을 가진 데이터를 제거합니다.\n\nimport heapq\nimport re\n\n\ndef paragraph_length_filter(example):\n    \"\"\"페이지의 줄 수가 너무 적거나 줄 길이가 너무 짧으면 False를 반환합니다.\"\"\"\n    lines = example[\"text\"].split(\"\\n\")\n    # 가장 긴 3개의 줄의 길이를 계산하고, 그 중 최소 길이가 3보다 작은 경우 False 반환\n    if len(lines) &lt; 3 or min(heapq.nlargest(3, [len(line) for line in lines])) &lt; 3:\n        return False\n    return True\n\n\nprint(f\"데이터 정리 전 데이터의 수: {dataset.num_rows}\")\n\n# 필터링 작업 수행\ndataset = dataset.filter(paragraph_length_filter, load_from_cache_file=False)\n\nprint(f\"데이터 정리 후 데이터의 수: {dataset.num_rows}\")\n\n데이터 정리 전 데이터의 수: 60004\n\n\n\n\n\n데이터 정리 후 데이터의 수: 52355\n\n\n\n\n2.3.2 훈련 샘플 내 반복된 텍스트 제거\n여기서는 각 샘플 내에서 반복된 텍스트를 제거합니다. 이를 통해 모델이 반복된 텍스트를 학습하는 것을 방지할 수 있습니다.\n\ndef find_duplicates(paragraphs: list[str]) -&gt; tuple[int, int]:\n    \"\"\"중복된 단락의 수와 문자 수를 계산합니다.\"\"\"\n    unique_paragraphs = set()\n    duplicate_chars = 0\n    duplicate_count = 0\n\n    for paragraph in paragraphs:\n        if paragraph in unique_paragraphs:\n            duplicate_chars += len(paragraph)\n            duplicate_count += 1\n        else:\n            unique_paragraphs.add(paragraph)\n\n    return duplicate_count, duplicate_chars\n\n\ndef paragraph_repetition_filter(example: dict[str, str]) -&gt; bool:\n    \"\"\"페이지에 중복이 너무 많으면 False를 반환합니다.\"\"\"\n    text = example[\"text\"]\n    paragraphs = re.compile(r\"\\n{2,}\").split(text.strip())\n\n    duplicate_count, duplicate_chars = find_duplicates(paragraphs)\n\n    if duplicate_count / len(paragraphs) &gt; 0.3:\n        return False\n    if duplicate_chars / len(text) &gt; 0.2:\n        return False\n\n    return True\n\n\n# 데이터셋에 필터 적용\nfiltered_dataset = dataset.filter(paragraph_repetition_filter, load_from_cache_file=False)\nprint(f\"필터링 후 데이터셋 크기: {filtered_dataset.num_rows}\")\n\n\n\n\n필터링 후 데이터셋 크기: 52326\n\n\n\n\n2.3.3 중복 제거\n이 섹션에서는 전체 데이터 세트에서 중복된 샘플을 제거합니다. (이전 단계에서는 각 샘플 내에서 반복된 텍스트만 제거했습니다.)\n\ndef deduplication(dataset: Dataset) -&gt; Dataset:\n    unique_texts = set()\n\n    def dedup_func(example: dict[str, Any]) -&gt; bool:\n        \"\"\"중복된 텍스트 항목을 제거합니다.\"\"\"\n        if example[\"text\"] in unique_texts:\n            return False\n        unique_texts.add(example[\"text\"])\n        return True\n\n    deduplicated_dataset = dataset.filter(dedup_func, load_from_cache_file=False, num_proc=1)\n\n    print(f\"원래 데이터셋 크기: {dataset.num_rows}\")\n    print(f\"중복 제거 후 데이터셋 크기: {deduplicated_dataset.num_rows}\")\n\n    return deduplicated_dataset\n\n\ndataset = deduplication(dataset)\n\n\n\n\n원래 데이터셋 크기: 52355\n중복 제거 후 데이터셋 크기: 43621\n\n\n\n\n2.3.4 언어 필터링\n여기서는 영어가 아닌 텍스트 샘플을 제거합니다. 이를 위해 lingua-py라는 언어 감지 라이브러리를 사용합니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\nfrom lingua import Language, LanguageDetectorBuilder\n\n# 영어와 한국어 감지를 위한 언어 감지기 생성\ndetector = LanguageDetectorBuilder.from_languages(Language.ENGLISH, Language.KOREAN).build()\n\n# 데이터셋에서 영어 텍스트만 필터링\ndataset = dataset.filter(\n    lambda x: detector.detect_language_of(x[\"text\"].replace(\"\\n\", \"\")) == Language.ENGLISH,\n    load_from_cache_file=False,\n    num_proc=1,\n)\n\n# 필터링 후 데이터셋 크기 출력\nprint(f\"제거 후 데이터셋 크기: {dataset.num_rows}\")\n\nParameter 'function'=&lt;function &lt;lambda&gt; at 0x7388a02aa7a0&gt; of the transform datasets.arrow_dataset.Dataset.filter@2.0.1 couldn't be hashed properly, a random hash was used instead. Make sure your transforms and parameters are serializable with pickle or dill for the dataset fingerprinting and caching to work. If you reuse this transform, the caching mechanism will consider it to be different from the previous calls and recompute everything. This warning is only showed once. Subsequent hashing failures won't be showed.\n\n\n\n\n\n제거 후 데이터셋 크기: 43322"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#데이터-세트를-디스크에-저장",
    "href": "posts/ipynb/ml_LLM_pretraining.html#데이터-세트를-디스크에-저장",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "2.4 데이터 세트를 디스크에 저장",
    "text": "2.4 데이터 세트를 디스크에 저장\nParquet 데이터 형식에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\n\noutput_dir = Path(\"../data/output\")\nfile_name = \"preprocessed_dataset.parquet\"\nfile_path = output_dir / file_name\n\n# 디렉토리가 존재하지 않으면 생성\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# 파케이 파일로 저장\ndataset.to_parquet(file_path)\n\nprint(f\"데이터셋이 성공적으로 저장되었습니다: {file_path}\")\n\n\n\n\n데이터셋이 성공적으로 저장되었습니다: ../data/output/preprocessed_dataset.parquet\n\n\n이제 데이터 세트를 모델 학습에 사용할 수 있도록 패키징하는 방법을 배웁니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#토큰화-및-input_ids-만들기",
    "href": "posts/ipynb/ml_LLM_pretraining.html#토큰화-및-input_ids-만들기",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "3.1 토큰화 및 input_ids 만들기",
    "text": "3.1 토큰화 및 input_ids 만들기\n이전 단계에서 저장한 데이터 세트를 불러오는 것부터 시작합니다.\n\nimport datasets\n\ndataset = datasets.load_dataset(\"parquet\", data_files=file_path.as_posix(), split=\"train\")\nprint(dataset)\n\n\n\n\nDataset({\n    features: ['text'],\n    num_rows: 43322\n})\n\n\nHugging Face Dataset 객체의 shard 메서드를 사용하여 데이터 세트를 10개의 더 작은 조각(shards)으로 분할합니다. (shard는 깨진 유리 조각처럼 데이터를 나누는 개념입니다.) Sharding에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\n\ndataset = dataset.shard(num_shards=10, index=0)\nprint(dataset)\n\nDataset({\n    features: ['text'],\n    num_rows: 4333\n})\n\n\n토크나이저를 불러오고, input_ids를 생성하는 데 사용할 수 있습니다. 이 과정은 데이터를 토큰화하고 토큰을 input_ids로 변환하는 과정입니다.\n\nfrom transformers import AutoTokenizer\n\nmodel_path_or_name = \"upstage/SOLAR-10.7B-v1.0\"\ntokenizer = AutoTokenizer.from_pretrained(\n    model_path_or_name,\n    use_fast=False,  # 참고: 긴 텍스트 샘플이 때때로 멈추는 경향이 있어 빠른 토큰화를 비활성화합니다. 대신 병렬 처리를 위해 map 함수와 datasets 라이브러리를 사용하겠습니다.\n)\ntokenizer.tokenize(\"I'm a short sentence\")\n\n\n# 헬퍼 함수 생성:\ndef tokenization(example):\n    # 토큰화\n    tokens = tokenizer.tokenize(example[\"text\"])\n    # 토큰을 ID로 변환\n    token_ids = tokenizer.convert_tokens_to_ids(tokens)\n    # &lt;bos&gt;, &lt;eos&gt; 토큰을 token_ids의 앞과 뒤에 추가\n    # bos: 시퀀스 시작, eos: 시퀀스 끝\n    token_ids = [tokenizer.bos_token_id] + token_ids + [tokenizer.eos_token_id]\n    example[\"input_ids\"] = token_ids\n\n    # 최종 데이터셋의 총 토큰 수를 계산하는 데 이 열을 사용할 것입니다.\n    example[\"num_tokens\"] = len(token_ids)\n    return example\n\n사전 학습 데이터 세트의 모든 예제를 토큰화 합니다.\n\n이 과정은 시간이 오래 걸릴 수 있습니다.\n\n\n# 데이터셋의 각 예제에 tokenization 함수를 적용합니다.\n# load_from_cache_file=False 옵션은 캐시된 결과를 사용하지 않고 항상 새로 계산하도록 합니다.\ndataset = dataset.map(tokenization, load_from_cache_file=False)\n\n# 변환된 데이터셋의 정보를 출력합니다.\nprint(dataset)\n\n\n\n\nDataset({\n    features: ['text', 'input_ids', 'num_tokens'],\n    num_rows: 4333\n})\n\n\n\nsample = dataset[3]  # 데이터셋에서 네 번째 샘플을 선택합니다.\n\nprint(\"text\", sample[\"text\"][:30])  # 샘플 텍스트의 처음 30자를 출력합니다.\nprint(\"\\ninput_ids\", sample[\"input_ids\"][:30])  # 토큰화된 입력 ID의 처음 30개를 출력합니다.\nprint(\"\\nnum_tokens\", sample[\"num_tokens\"])  # 샘플의 총 토큰 수를 출력합니다.\n\ntext A cool look at climate\nIan Sin\n\ninput_ids [1, 330, 5106, 913, 438, 11259, 13, 28737, 276, 318, 1505, 992, 2261, 2308, 302, 272, 1830, 11259, 2268, 11725, 297, 272, 6194, 684, 767, 6768, 905, 304, 5780, 1580]\n\nnum_tokens 3731\n\n\n데이터셋의 총 토큰 수를 확인합니다.\n\nimport numpy as np\n\ntotal_tokens = np.sum(dataset[\"num_tokens\"])\nprint(f\"총 토큰 수: {total_tokens}\")\n\n총 토큰 수: 5689564"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#데이터-패킹",
    "href": "posts/ipynb/ml_LLM_pretraining.html#데이터-패킹",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "3.2 데이터 패킹",
    "text": "3.2 데이터 패킹\n데이터 패킹은 여러 데이터를 효율적으로 하나의 데이터 블록으로 결합하는 과정입니다. 이 기술은 특히 자연어 처리(NLP) 작업에서 배치 처리 효율성을 높이는 데 중요합니다. 아래 다이어그램은 일반적인 워크플로우를 보여줍니다.\n\n\n\n\n\ngraph TD;\n    B[Load Dataset];\n    B --&gt; C[Tokenize Each Example];\n    C --&gt; D[Create input_ids];\n    D --&gt; E[Pad Sequences to Max Length];\n    E --&gt; F[Pack Tokens into Batches];\n\n\n\n\n\n\n\n데이터셋 로드: 원시 텍스트 데이터를 메모리에 불러옵니다.\n토큰화: 각 예제 텍스트를 개별 토큰으로 분할합니다. 이는 단어, 하위 단어 또는 문자 수준에서 수행될 수 있습니다.\ninput_ids 생성: 토큰을 해당하는 정수 ID로 변환합니다. 이는 모델이 이해할 수 있는 형식입니다.\n시퀀스 패딩: 배치 내의 모든 시퀀스가 동일한 길이를 갖도록 짧은 시퀀스에 패딩을 추가합니다.\n배치로 토큰 패킹: 여러 예제의 토큰을 하나의 배치로 결합합니다.\n\n마지막 단계에서 모든 예제의 input_ids를 하나의 리스트로 연결하는 것은 메모리 효율성과 처리 속도를 향상시키는 중요한 최적화 기법입니다. 이렇게 하면 모델이 한 번에 여러 예제를 처리할 수 있습니다. 이러한 패킹 기법은 GPU 메모리 사용을 최적화하고 병렬 처리 능력을 최대한 활용할 수 있어 전체적인 훈련 시간을 단축시킬 수 있습니다.\n\n# dataset의 \"input_ids\" 배열을 연결하여 하나의 배열로 만듭니다.\ninput_ids = np.concatenate(dataset[\"input_ids\"])\n\n# 연결된 배열의 길이를 출력합니다.\nprint(f\"연결된 배열의 길이 {len(input_ids)}\")\n\n# 최대 시퀀스 길이를 설정합니다.\nmax_seq_length = 32\n\n# 총 길이를 계산합니다. input_ids의 길이에서 max_seq_length로 나누어 나머지를 뺀 값입니다.\ntotal_length = len(input_ids) - len(input_ids) % max_seq_length\n\n# 계산된 총 길이를 출력합니다.\nprint(f\"계산된 총 길이: {total_length}\")\n\n연결된 배열의 길이 5689564\n계산된 총 길이: 5689536\n\n\n리스트 끝에서 추가 토큰을 버려서 토큰의 수가 max_seq_length로 정확하게 나누어지도록 합니다.\n\n# input_ids 배열을 total_length 길이만큼 자릅니다.\ninput_ids = input_ids[:total_length]\n\n# 잘린 배열의 shape(형상)을 출력합니다.\nprint(f\"input_ids의 shape: {input_ids.shape}\")\n\n# input_ids 배열을 (행: -1, 열: max_seq_length) 형태로 재구조화하고, 데이터 타입을 int32로 변환합니다.\ninput_ids_reshaped = input_ids.reshape(-1, max_seq_length).astype(np.int32)\n\n# 재구조화된 배열의 shape(형상)을 출력합니다.\nprint(f\"input_ids_reshaped의 shape: {input_ids_reshaped.shape}\")\n\n# 재구조화된 배열의 데이터 타입을 출력합니다.\nprint(f\"input_ids_reshaped의 데이터 타입: {type(input_ids_reshaped)}\")\n\ninput_ids의 shape: (5689536,)\ninput_ids_reshaped의 shape: (177798, 32)\ninput_ids_reshaped의 데이터 타입: &lt;class 'numpy.ndarray'&gt;\n\n\nHugging Face 데이터 세트로 변환하려면 다음과 같이 합니다.\n\n# input_ids_reshaped를 리스트로 변환합니다.\ninput_ids_list = input_ids_reshaped.tolist()\n\n# 변환된 리스트를 사용하여 새로운 Dataset 객체를 생성합니다.\npackaged_pretrain_dataset = datasets.Dataset.from_dict({\"input_ids\": input_ids_list})\n\n# 생성된 Dataset 객체의 정보를 출력합니다.\nprint(f\"생성된 Dataset 객체: {packaged_pretrain_dataset}\")\n\n생성된 Dataset 객체: Dataset({\n    features: ['input_ids'],\n    num_rows: 177798\n})"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#패킹된-데이터-세트-디스크에-저장",
    "href": "posts/ipynb/ml_LLM_pretraining.html#패킹된-데이터-세트-디스크에-저장",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "3.3 패킹된 데이터 세트 디스크에 저장",
    "text": "3.3 패킹된 데이터 세트 디스크에 저장\nHugging Face Dataset 객체를 디스크에 저장하는 방법은 다음과 같습니다.\n\nto_parquet() 메서드는 데이터를 Parquet 파일 형식으로 저장합니다. Parquet는 효율적인 컬럼 기반 저장 형식으로, 대규모 데이터를 저장하고 처리하는 데 최적화되어 있습니다. Parquet 형식은 다른 데이터 분석 툴(예: pandas, Apache Spark 등)과 쉽게 호환됩니다. 데이터 세트를 다른 시스템 또는 다른 툴과 공유할 때 유용하며 압축과 성능 최적화 측면에서 효율적입니다.\n\n\nfile_name = \"packaged_pretrain_dataset.parquet\"\nfile_path = output_dir / file_name\n\n# 디렉토리가 존재하지 않으면 생성\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# 파케이 파일로 저장\npackaged_pretrain_dataset.to_parquet(file_path)\n\nprint(f\"데이터셋이 성공적으로 저장되었습니다: {file_path}\")\n\n\n\n\n데이터셋이 성공적으로 저장되었습니다: ../data/output/packaged_pretrain_dataset.parquet\n\n\n\npackaged_pretrain_dataset\n\nDataset({\n    features: ['input_ids'],\n    num_rows: 177798\n})\n\n\n\nprint(packaged_pretrain_dataset[0][\"input_ids\"][0:10])\n\n[1, 560, 28705, 28740, 28787, 28774, 28770, 1054, 14886, 23452]"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#모델-구성",
    "href": "posts/ipynb/ml_LLM_pretraining.html#모델-구성",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "4.1 모델 구성",
    "text": "4.1 모델 구성\nMeta의 Llama 모델 계열을 기반으로 모델을 구성할 것입니다. transformers 라이브러리에는 이 모델들과 함께 작업할 수 있는 여러 도구가 있으며, 이에 대해 여기에서 읽을 수 있습니다.\n시작은 LlamaConfig 객체를 생성하여 모델의 아키텍처를 구성하는 것입니다.\n\nfrom transformers import LlamaConfig, LlamaForCausalLM\n\n\ndef print_nparams(model):\n    \"\"\"모델의 총 파라미터 개수를 계산하여 출력합니다.\"\"\"\n    nparams = sum(p.numel() for p in model.parameters())\n    print(f\"모델의 총 파라미터 개수: {nparams}\")\n\n\n# LlamaConfig 객체를 생성합니다.\nconfig = LlamaConfig()\nprint(f\"기본 설정: {config}\")\n\n기본 설정: LlamaConfig {\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"bos_token_id\": 1,\n  \"eos_token_id\": 2,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 4096,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 11008,\n  \"max_position_embeddings\": 2048,\n  \"model_type\": \"llama\",\n  \"num_attention_heads\": 32,\n  \"num_hidden_layers\": 32,\n  \"num_key_value_heads\": 32,\n  \"pretraining_tp\": 1,\n  \"rms_norm_eps\": 1e-06,\n  \"rope_scaling\": null,\n  \"rope_theta\": 10000.0,\n  \"tie_word_embeddings\": false,\n  \"transformers_version\": \"4.37.2\",\n  \"use_cache\": true,\n  \"vocab_size\": 32000\n}\n\n\n\n\n# 모델 아키텍처를 변경하기 위해 설정 값을 업데이트합니다:\nconfig.num_hidden_layers = 12  # 기본값 32에서 12로 감소\nconfig.hidden_size = 1024  # 기본값 4096에서 1024로 감소 (1/4 축소)\nconfig.intermediate_size = 4096  # 기본값 11008에서 4096으로 감소 (MLP 표현 차원, 약 1/3 축소)\nconfig.num_key_value_heads = 8  # 기본값 num_attention_heads=32에서 8로 감소 (1/4 축소)\nconfig.torch_dtype = \"bfloat16\"  # 정밀도를 감소\nconfig.use_cache = False  # `True`는 gradient checkpointing과 호환되지 않음\nprint(f\"업데이트된 설정: {config}\")\n\n업데이트된 설정: LlamaConfig {\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"bos_token_id\": 1,\n  \"eos_token_id\": 2,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 1024,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 4096,\n  \"max_position_embeddings\": 2048,\n  \"model_type\": \"llama\",\n  \"num_attention_heads\": 32,\n  \"num_hidden_layers\": 12,\n  \"num_key_value_heads\": 8,\n  \"pretraining_tp\": 1,\n  \"rms_norm_eps\": 1e-06,\n  \"rope_scaling\": null,\n  \"rope_theta\": 10000.0,\n  \"tie_word_embeddings\": false,\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.37.2\",\n  \"use_cache\": false,\n  \"vocab_size\": 32000\n}"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#가중치-초기화",
    "href": "posts/ipynb/ml_LLM_pretraining.html#가중치-초기화",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "4.2 가중치 초기화",
    "text": "4.2 가중치 초기화\n모델 훈련을 위한 가중치 초기화 방법에는 다음 4가지가 있습니다. 각각을 간략히 설명하고 4번째 방법인 depth upscaling 방법을 사용해 학습을 진행하겠습니다.\n\n4.2.1 가중치 랜덤 초기화\n모델의 가중치를 랜덤으로 초기화하는 방법입니다. 모든 가중치는 평균이 0이고 표준 편차가 0.02인 절단된 정규 분포(truncated normal distribution)에서 값을 설정합니다. 평균에서 2시그마(2σ)를 초과하는 값은 0으로 설정됩니다.\n장점:\n\n대칭성을 깨뜨려 뉴런이 서로 다르게 학습할 수 있도록 도움.\n다양한 초기값으로 파라미터 공간 탐색 가능.\n\n단점: - 초기값이 너무 크거나 작으면 기울기 폭주(exploding gradient) 또는 소실(vanishing gradient) 문제가 발생할 수 있음. - 깊은 네트워크에서는 비효율적일 수 있음.\n\n\n4.2.2 기존 모델에 추가 사전 훈련\n기존 공개된 모델을 로드하여 새로운 데이터로 추가 학습을 진행하는 방법입니다.\n장점:\n\n기존 모델의 강점을 유지하면서 새로운 데이터에 맞게 업데이트 가능.\n학습 시간이 단축될 수 있음.\n\n단점:\n\n기존 모델이 새로운 데이터와 충분히 유사하지 않다면 성능 저하 가능.\n추가 훈련 시 과적합(overfitting) 위험 발생 가능.\n\n\n\n4.2.3 기존 학습된 모델 축소\n예를 들면 tinySolar-248m-4k 모델을 12개 레이어에서 10개 레이어로 축소합니다.\n장점: - 모델 크기를 줄여 계산 비용 감소. - 간단한 작업에 더 적합하게 조정 가능.\n단점: - 복잡한 문제에서는 성능 저하 가능. - 중요한 정보가 손실될 수 있음.\n\n\n4.2.4 기존 학습된 모델 확장\n예를 들면 tinySolar-248m-4k 모델을 12개 레이어에서 16개 레이어로 확장할 것입니다. 이는 복잡한 문제를 해결하기 위해 모델의 표현력을 높이는 데 효과적이며, 기존 사전 학습된 가중치를 활용해 효율적으로 확장할 수 있는 장점이 있습니다.\n장점: - 더 복잡한 문제를 처리할 수 있는 능력 향상. - 기존 모델의 성능을 확장하여 더 많은 데이터를 활용 가능.\n단점: - 계산 비용 증가 및 학습 시간 연장. - 레이어를 잘못 추가하면 과적합 위험 증가.\n\n4.2.4.1 실습\n이제 12개 레이어의 tinySolar-248m-4k 모델을 16개 레이어로 확장하는 방법을 알아보도록 하겠습니다. 레이어 선택 전략: 원본 12개 레이어 중 하위 8개(초기 특징 추출) + 상위 8개(고수준 추상화)를 중복 추출하는 방법을 사용하겠습니다. 이를 통해 계산 효율성(전체 레이어 재학습 대신 기존 레이어 재활용으로 학습 시간 단축)과 호환성이 보장(임베딩/분류 레이어 유지로 입력-출력 구조 일관성 확보)됩니다. 수행할 단계는 다음과 같습니다:\n\n16개 레이어 모델 구성 및 랜덤 가중치 초기화\n\n16개 레이어 구조의 새 모델을 생성하고 랜덤 가중치로 초기화합니다.\n\n12개 레이어를 가진 tinySolar-248m-4k 모델 메모리 로드\n\n기존 12개 레이어 모델을 메모리에 불러옵니다.\n\n레이어 복제 및 가중치 덮어쓰기\n\n원본 12개 레이어 모델에서 하위 8개 레이어와 상위 8개 레이어를 복사하여 16개 레이어 모델의 랜덤 가중치를 대체합니다.\n\n임베딩/분류 레이어 복제\n\n원본 모델의 임베딩 레이어(embedding layers)와 분류 레이어(classifying layers)를 새 모델의 랜덤 초기화된 해당 레이어에 복사합니다.\n\n\n\nfrom copy import deepcopy\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, LlamaConfig, TextStreamer\n\n# LLaMA 모델 구성 설정\nconfig = LlamaConfig(\n    num_hidden_layers=16,  # 최종적으로 16개의 레이어를 가진 모델을 원함\n    hidden_size=1024,\n    intermediate_size=4096,\n    num_attention_heads=32,\n    num_key_value_heads=8,\n    torch_dtype=\"bfloat16\",\n    use_cache=False,\n)\nprint(config)\n\n# 새로운 모델 생성 및 bfloat16으로 변환\nmodel = LlamaForCausalLM(config)\nmodel = model.to(dtype=torch.bfloat16)\nprint_nparams(model)  # 308839424 =&gt; 308M\n\n# 사전 학습된 모델 로드\nmodel_name_or_path = \"upstage/TinySolar-248m-4k\"\npretrained_model = AutoModelForCausalLM.from_pretrained(\n    model_name_or_path,\n    device_map=\"cpu\",\n    torch_dtype=torch.bfloat16,\n)\ntokenizer = AutoTokenizer.from_pretrained(model_name_or_path)\n\nprint_nparams(pretrained_model)  # 248013824 =&gt; 248M\n\n# 사전 학습된 모델의 레이어를 새 모델로 복사\nmodel.model.layers = deepcopy(pretrained_model.model.layers[:-4]) + deepcopy(\n    pretrained_model.model.layers[4:]\n)\n\n# 임베딩 레이어 복사\nmodel.model.embed_tokens = deepcopy(pretrained_model.model.embed_tokens)\n\n# 언어 모델 헤드 복사\nmodel.lm_head = deepcopy(pretrained_model.lm_head)\n\nprint(model.config)\n\n# 간단한 추론 실행으로 학습되지 않은 모델 테스트\nprompt = \"I am an engineer. I love\"\n\ninputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n\nstreamer = TextStreamer(tokenizer, skip_prompt=True, skip_special_tokens=True)\n\noutputs = model.generate(\n    **inputs, streamer=streamer, use_cache=True, max_new_tokens=128, do_sample=False\n)\n\nLlamaConfig {\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"bos_token_id\": 1,\n  \"eos_token_id\": 2,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 1024,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 4096,\n  \"max_position_embeddings\": 2048,\n  \"model_type\": \"llama\",\n  \"num_attention_heads\": 32,\n  \"num_hidden_layers\": 16,\n  \"num_key_value_heads\": 8,\n  \"pretraining_tp\": 1,\n  \"rms_norm_eps\": 1e-06,\n  \"rope_scaling\": null,\n  \"rope_theta\": 10000.0,\n  \"tie_word_embeddings\": false,\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.37.2\",\n  \"use_cache\": false,\n  \"vocab_size\": 32000\n}\n\n모델의 총 파라미터 개수: 308839424\n\n\nSetting `pad_token_id` to `eos_token_id`:2 for open-end generation.\n\n\n모델의 총 파라미터 개수: 248013824\nLlamaConfig {\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"bos_token_id\": 1,\n  \"eos_token_id\": 2,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 1024,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 4096,\n  \"max_position_embeddings\": 2048,\n  \"model_type\": \"llama\",\n  \"num_attention_heads\": 32,\n  \"num_hidden_layers\": 16,\n  \"num_key_value_heads\": 8,\n  \"pretraining_tp\": 1,\n  \"rms_norm_eps\": 1e-06,\n  \"rope_scaling\": null,\n  \"rope_theta\": 10000.0,\n  \"tie_word_embeddings\": false,\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.37.2\",\n  \"use_cache\": false,\n  \"vocab_size\": 32000\n}\n\nto work with people who are not afraid to look at the world and are not afraid to look at the world with a little bit of a twist.\nI am a very humble person and I am very fortunate to have a great team of people who work hard to make a difference.\nI am very fortunate to have a great team of people who work hard to make a difference.\nI am very fortunate to have a great team of people who work hard to make a difference.\nI am very fortunate to have a great team of people who work hard to make a difference.\nI am very fortunate to have a great team\n\n\n위의 결과를 통해 학습되지 않은 모델은 성능이 좋지 않다는 것을 알 수 있습니다.(같은 말을 반복) 일단은 해당 모델을 디스크에 저장하겠습니다. 새 모델 이름은 확장된 3억 8백만 개 매개변수(308M)를 반영해 TinySolar-308m-4k-init로 지정하겠습니다.\n\nfile_name = \"TinySolar-308m-4k-init\"\nfile_path = output_dir / file_name\n\n# 디렉토리가 존재하지 않으면 생성\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# 308M 파라미터 모델 저장\nmodel.save_pretrained(file_path)\n\n# 참고: 메모리 제한 환경에서 대규모 모델 실행 시 사용 (메모리 문제 발생 시 실행)\nimport gc\n\ndel model  # 모델 객체 삭제\ngc.collect()  # 가비지 컬렉션 수행\n\n222"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#학습할-모델-로드하기",
    "href": "posts/ipynb/ml_LLM_pretraining.html#학습할-모델-로드하기",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "5.1 학습할 모델 로드하기",
    "text": "5.1 학습할 모델 로드하기\n이전에 만들었던 확장(upscale)한 모델을 다시 불러옵니다.\n\nimport torch\nfrom transformers import AutoModelForCausalLM\n\npretrained_model = AutoModelForCausalLM.from_pretrained(\n    file_path.as_posix(),\n    device_map=\"auto\",\n    torch_dtype=torch.bfloat16,\n    use_cache=False,\n)\npretrained_model\n\nLlamaForCausalLM(\n  (model): LlamaModel(\n    (embed_tokens): Embedding(32000, 1024)\n    (layers): ModuleList(\n      (0-15): 16 x LlamaDecoderLayer(\n        (self_attn): LlamaSdpaAttention(\n          (q_proj): Linear(in_features=1024, out_features=1024, bias=False)\n          (k_proj): Linear(in_features=1024, out_features=256, bias=False)\n          (v_proj): Linear(in_features=1024, out_features=256, bias=False)\n          (o_proj): Linear(in_features=1024, out_features=1024, bias=False)\n          (rotary_emb): LlamaRotaryEmbedding()\n        )\n        (mlp): LlamaMLP(\n          (gate_proj): Linear(in_features=1024, out_features=4096, bias=False)\n          (up_proj): Linear(in_features=1024, out_features=4096, bias=False)\n          (down_proj): Linear(in_features=4096, out_features=1024, bias=False)\n          (act_fn): SiLU()\n        )\n        (input_layernorm): LlamaRMSNorm()\n        (post_attention_layernorm): LlamaRMSNorm()\n      )\n    )\n    (norm): LlamaRMSNorm()\n  )\n  (lm_head): Linear(in_features=1024, out_features=32000, bias=False)\n)\n\n\n위 출력 결과를 통해 레이어가 16개인 것을 확인 할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#데이터셋-로드",
    "href": "posts/ipynb/ml_LLM_pretraining.html#데이터셋-로드",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "5.2 데이터셋 로드",
    "text": "5.2 데이터셋 로드\nDataset 객체의 두 가지 메서드를 업데이트하여 트레이너와 인터페이스할 수 있도록 합니다. 이 메서드들은 생성한 데이터셋을 학습 데이터로 지정할 때 필요 합니다.\n\nimport datasets\nimport torch\nfrom torch.utils.data import Dataset\n\n\nclass CustomDataset(Dataset):\n    def __init__(self, args, split=\"train\"):\n        \"\"\"커스텀 데이터셋 객체를 초기화합니다.\"\"\"\n        self.args = args\n        self.dataset = datasets.load_dataset(\"parquet\", data_files=args.dataset_name, split=split)\n\n    def __len__(self):\n        \"\"\"데이터셋의 샘플 수를 반환합니다.\"\"\"\n        return len(self.dataset)\n\n    def __getitem__(self, idx):\n        \"\"\"\n        지정된 인덱스에서 데이터셋의 단일 데이터 샘플을 검색합니다.\n        \"\"\"\n        # 리스트를 PyTorch용 LongTensor로 변환\n        input_ids = torch.LongTensor(self.dataset[idx][\"input_ids\"])\n        labels = torch.LongTensor(self.dataset[idx][\"input_ids\"])\n\n        # 샘플을 딕셔너리 형태로 반환\n        return {\"input_ids\": input_ids, \"labels\": labels}"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#학습-파라미터-구성",
    "href": "posts/ipynb/ml_LLM_pretraining.html#학습-파라미터-구성",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "5.3 학습 파라미터 구성",
    "text": "5.3 학습 파라미터 구성\n여기서는 모델 학습에 필요한 다양한 매개변수를 정의합니다. 그리고 이전에 준비한 데이터셋을 학습 과정에 연결합니다.\n\nfrom dataclasses import dataclass, field\n\nimport transformers\n\noutput_dir = Path(\"../data/output\")\ndataset_name = \"packaged_pretrain_dataset.parquet\"\ndataset_path = output_dir / dataset_name\n\n\n@dataclass\nclass CustomArguments(transformers.TrainingArguments):\n    # 데이터셋 구성\n    dataset_name: str = field(  # 데이터셋 파일 경로 설정\n        default=dataset_path.as_posix()\n    )\n    num_proc: int = field(default=1)  # 데이터 전처리를 위한 서브 프로세스 수\n    max_seq_length: int = field(default=32)  # 최대 시퀀스 길이\n\n    # 핵심 학습 설정\n    seed: int = field(default=0)  # 초기화를 위한 랜덤 시드, 재현성을 보장\n    optim: str = field(default=\"adamw_torch\")  # 옵티마이저 설정, 여기서는 PyTorch의 AdamW 사용\n    max_steps: int = field(default=10000)  # 최대 학습 스텝 수\n    per_device_train_batch_size: int = field(default=2)  # 각 디바이스에서 학습에 사용되는 배치 크기\n\n    # 기타 학습 설정\n    learning_rate: float = field(default=5e-5)  # 옵티마이저의 초기 학습률 설정\n    weight_decay: float = field(default=0)  # 가중치 감소율 설정\n    warmup_steps: int = field(default=10)  # 학습률 워밍업 단계 수 설정\n    lr_scheduler_type: str = field(default=\"linear\")  # 학습률 스케줄러 유형 설정\n    gradient_checkpointing: bool = field(\n        default=True\n    )  # 메모리 절약을 위한 그래디언트 체크포인트 활성화\n    dataloader_num_workers: int = field(default=2)  # 데이터 로딩을 위한 서브 프로세스 수 설정\n    bf16: bool = field(default=True)  # 지원되는 하드웨어에서 bfloat16 정밀도를 사용하여 학습 수행\n    gradient_accumulation_steps: int = field(\n        default=1\n    )  # 모델 가중치를 업데이트하기 전에 그래디언트를 누적하는 단계 수\n\n    # 로깅 구성\n    logging_steps: int = field(default=1000)  # 학습 정보를 로깅하는 빈도(스텝 단위)\n    report_to: str = field(default=\"none\")  # 로깅 대상(e.g., WandB, TensorBoard)\n\n    # 저장 구성\n    save_strategy: str = field(default=\"steps\")  # \"epoch\"으로 변경 가능 (저장 전략)\n    save_steps: int = field(default=1000)  # 학습 체크포인트를 저장하는 빈도(스텝 단위)\n    save_total_limit: int = field(default=2)  # 저장할 체크포인트의 최대 개수 제한\n\n\n# 사용자 정의 인자를 파싱하고 모델 저장 경로를 설정합니다:\nparser = transformers.HfArgumentParser(CustomArguments)\n(args,) = parser.parse_args_into_dataclasses(args=[f\"--output_dir={output_dir.as_posix()}\"])\n\n# 학습 데이터셋을 설정합니다:\ntrain_dataset = CustomDataset(args=args)\n\n# 데이터셋의 형태를 확인합니다:\nprint(\"Input shape: \", train_dataset[0][\"input_ids\"].shape)\n\n\n\n\nInput shape:  torch.Size([32])"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#트레이너-실행-및-모니터링",
    "href": "posts/ipynb/ml_LLM_pretraining.html#트레이너-실행-및-모니터링",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "5.4 트레이너 실행 및 모니터링",
    "text": "5.4 트레이너 실행 및 모니터링\n먼저, 학습 중 손실 값을 기록하기 위한 콜백을 설정합니다. 이 콜백은 학습 과정에서 발생하는 손실 값을 추적하고 기록하기 위함입니다.\n\n손실 값의 추이를 그래프로 시각화하면 학습 과정을 더 쉽게 이해할 수 있습니다. 급격한 손실 변화나 이상치가 있는지 주의 깊게 관찰하세요. 이는 학습 과정에서의 문제를 나타낼 수 있습니다.\n\n\nfrom transformers import Trainer, TrainerCallback\n\n\n# 손실 값 기록을 위한 커스텀 콜백 정의\nclass LossLoggingCallback(TrainerCallback):\n    def on_log(self, args, state, control, logs=None, **kwargs):\n        \"\"\"학습 중 로그 데이터를 수집합니다\"\"\"\n        if logs is not None:\n            self.logs.append(logs)\n\n    def __init__(self):\n        \"\"\"콜백 초기화 및 로그 저장소 생성\"\"\"\n        self.logs = []\n\n\n# 콜백 객체 생성\nloss_logging_callback = LossLoggingCallback()\n\n그런 다음 transformers 라이브러리에서 Hugging Face Trainer 객체의 인스턴스를 생성합니다. 트레이너의 train() 메서드를 호출하여 학습을 시작합니다:\n\ntrainer = Trainer(\n    model=pretrained_model,\n    args=args,\n    train_dataset=train_dataset,\n    eval_dataset=None,\n    callbacks=[loss_logging_callback],\n)\n\ntrainer.train()\n\n\n      \n      \n      [10000/10000 06:25, Epoch 0/1]\n    \n    \n\n\n\nStep\nTraining Loss\n\n\n\n\n1000\n4.417900\n\n\n2000\n4.274800\n\n\n3000\n4.152300\n\n\n4000\n4.100100\n\n\n5000\n4.017500\n\n\n6000\n3.982000\n\n\n7000\n3.934200\n\n\n8000\n3.971900\n\n\n9000\n3.944800\n\n\n10000\n3.939500\n\n\n\n\n\n\nTrainOutput(global_step=10000, training_loss=4.073491650390625, metrics={'train_runtime': 386.2049, 'train_samples_per_second': 51.786, 'train_steps_per_second': 25.893, 'total_flos': 1060114268160000.0, 'train_loss': 4.073491650390625, 'epoch': 0.11})\n\n\n시각화를 통해 Training loss가 어떻게 줄었는지 확인해보겠습니다.\n\nimport matplotlib.pyplot as plt\n\n# ggplot 스타일 적용\nplt.style.use(\"ggplot\")\n\nlogs = loss_logging_callback.logs\n# loss_logging_callback에서 기록한 손실 값 가져오기\nlosses = [log[\"loss\"] for log in logs if \"loss\" in log]  # 'loss' 키가 있는 로그만 추출\n\nplt.figure(figsize=(6, 4))  # 배경색 설정\nplt.plot(losses)\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Loss\")\nplt.title(\"Training Loss\")\nplt.show()\n\n\n\n\n\n\n\n\n학습을 계속할 수록 손실 값이 줄어드는 것을 확인할 수 있습니다. 이는 모델이 데이터를 더 잘 이해하고 있음을 의미합니다. 그러나 손실 값이 감소하는 속도가 느려지면 학습이 수렴(convergence)하고 있음을 나타낼 수 있습니다. 이 경우 학습률을 조정하거나 다른 하이퍼파라미터를 조정하여 성능을 향상시킬 수 있습니다. 이제 학습된 모델을 저장해보죠.\n\n# 모델 이름 및 저장 경로 설정\nmodel_name = \"TinySolar-308m-4k-finetune\"  # 파인튜닝된 모델 이름\nsave_path = output_dir / model_name  # 모델 저장 경로 생성\n\n# 사전 학습된 모델 저장\npretrained_model.save_pretrained(save_path.as_posix())  # 모델 가중치와 구성 파일 저장\n\n# 토크나이저 저장\ntokenizer.save_pretrained(save_path.as_posix())  # 토크나이저 관련 파일(vocab 등) 저장\n\n('../data/output/TinySolar-308m-4k-finetune/tokenizer_config.json',\n '../data/output/TinySolar-308m-4k-finetune/special_tokens_map.json',\n '../data/output/TinySolar-308m-4k-finetune/tokenizer.model',\n '../data/output/TinySolar-308m-4k-finetune/added_tokens.json',\n '../data/output/TinySolar-308m-4k-finetune/tokenizer.json')"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#모델의-성능-확인",
    "href": "posts/ipynb/ml_LLM_pretraining.html#모델의-성능-확인",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "5.5 모델의 성능 확인",
    "text": "5.5 모델의 성능 확인\n모델 학습을 진행하면서 모델의 체크포인트(임시 저장)를 만들었습니다. 이 체크포인트를 불러와서 사용해보는 코드는 아래와 같습니다. 모델의 토크나이저는 이전과 마찬가지로 Solar 토크나이저를 사용하고 TextStreamer 객체를 설정하여 생성되는 텍스트를 출력합니다.\n\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, TextStreamer\n\n# 1. 토크나이저 설정\nmodel_name_or_path = \"upstage/TinySolar-248m-4k\"\ntokenizer = AutoTokenizer.from_pretrained(model_name_or_path)\n\n# 2. 중간 체크포인트 모델 로드\ncheckpoint_path = \"../data/output/checkpoint-10000\"\nmodel2 = AutoModelForCausalLM.from_pretrained(\n    checkpoint_path,\n    device_map=\"auto\",\n    torch_dtype=torch.bfloat16,\n)\n\n# 3. 프롬프트 설정\nprompt = \"I am an engineer. I love\"\n\n# 4. 입력 토큰화\ninputs = tokenizer(prompt, return_tensors=\"pt\").to(model2.device)\n\n# 5. 텍스트 스트리머 설정\nstreamer = TextStreamer(tokenizer, skip_prompt=True, skip_special_tokens=True)\n\n# 6. 텍스트 생성\noutputs = model2.generate(\n    **inputs,\n    streamer=streamer,\n    use_cache=True,\n    max_new_tokens=64,\n    do_sample=True,\n    temperature=1.0,\n)\n\nSetting `pad_token_id` to `eos_token_id`:2 for open-end generation.\n\n\nwhat I see in people like me and so, for me, my passion is a passion for health and love. As long and as I am an entrepreneur (both in the fields of health marketing and customer sales, there is a difference that must be recognised here. In this issue, I am in charge of what I\n\n\n위의 결과를 보면 처음 시작했던 모델과 비교하면 훨씬 더 자연스러운 텍스트가 생성되는 것을 확인할 수 있습니다. 다만 맥락은 이해하기 어렵네요."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#벤치마크-평가법",
    "href": "posts/ipynb/ml_LLM_pretraining.html#벤치마크-평가법",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "6.1 벤치마크 평가법",
    "text": "6.1 벤치마크 평가법\n벤치마크 평가는 표준화된 데이터셋과 태스크를 사용하여 모델의 성능을 객관적으로 측정합니다.\n\nLM Evaluation Harness: EleutherAI에서 개발한 도구로, 다양한 벤치마크 태스크에 대해 LLM을 평가할 수 있습니다. 다음 GitHub 리포지토리에서 찾을 수 있습니다.\nTruthfulQA: 모델의 진실성과 정확성을 평가하는 벤치마크로, 817개의 질문을 포함하며 건강, 법률, 금융 등 38개 주제를 다룹니다. TruthfulQA 벤치마크에 대한 자세한 내용은 이 논문에서 읽을 수 있으며 구현 코드는 다음 GitHub 리포지토리에서 확인할 수 있습니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#리더보드-평가법",
    "href": "posts/ipynb/ml_LLM_pretraining.html#리더보드-평가법",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "6.2 리더보드 평가법",
    "text": "6.2 리더보드 평가법\n리더보드는 다양한 모델의 성능을 비교할 수 있는 플랫폼을 제공합니다.\n\nHugging Face 리더보드: 다양한 LLM 모델의 성능을 비교할 수 있는 플랫폼입니다. 전문가나 일반 사용자가 직접 모델의 출력을 평가하는 방식입니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_pretraining.html#reference",
    "href": "posts/ipynb/ml_LLM_pretraining.html#reference",
    "title": "LLM 사전 학습에 대한 이해",
    "section": "7.1 Reference",
    "text": "7.1 Reference\n\nPretraining LLMs"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html",
    "href": "posts/ipynb/ml_LLM_classification.html",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "",
    "text": "이메일은 현대 사회의 필수적인 커뮤니케이션 도구입니다. 하지만 스팸 메일의 범람은 사용자들에게 큰 골칫거리가 되고 있습니다. 광고부터 악성 피싱 시도까지 스팸 메일은 생산성을 저하시키고 보안 위험을 초래합니다. 이러한 문제를 해결하기 위해 다양한 스팸 필터링 기술이 개발되어 왔지만 최근 인공지능 기술의 발전으로 더욱 정교하고 효과적인 방법이 등장했습니다.\n바로 대규모 언어 모델(Large Language Model, LLM)을 활용한 스팸 필터링입니다. LLM은 방대한 양의 텍스트 데이터로 사전 학습된 모델로 인간의 언어를 이해하고 생성하는 데 탁월한 성능을 보입니다. 이러한 LLM의 강력한 언어 이해 능력을 스팸 필터링에 적용하면 기존 방식보다 훨씬 더 정확하고 효과적으로 스팸을 탐지할 수 있습니다.\n본 글에서는 LLM 모델을 사용하여 스팸 필터링 시스템을 구축하는 과정을 단계별로 살펴보겠습니다. 데이터 전처리부터 모델 설정, 미세 조정, 그리고 실제 적용까지 과정을 다룰 예정입니다.\nstateDiagram\n    direction LR\n    A: Preprocess dataset\n    B: Create data loaders\n    C: Load pretrained model\n    D: Model setup\n    F: Fine-tune model\n    G: Use model on new data\n    state Stage1{\n         A --&gt; B\n    }\n    Stage1 --&gt; Stage2 \n    state Stage2{\n         C --&gt; D\n    }\n    Stage2 --&gt; Stage3\n    state Stage3{\n        F --&gt; G\n    }\n위 다이어그램은 LLM 모델을 사용하여 스팸 필터링을 위한 분류 미세 조정의 3단계 과정을 보여줍니다. 1단계는 데이터셋을 준비하는 과정입니다. 먼저 스팸 메일과 정상 메일 데이터를 수집하여 데이터셋을 구축합니다. 그런 다음, 데이터셋을 LLM 모델에 적합한 형태로 전처리합니다. 여기에는 불필요한 문자 제거, 텍스트 정규화, 토큰화 등의 작업이 포함될 수 있습니다. 마지막으로, 전처리된 데이터셋을 모델 학습에 사용할 수 있도록 데이터 로더를 생성합니다. 데이터 로더는 데이터를 일괄 처리하고 모델에 공급하는 역할을 합니다.\n2단계는 모델을 설정하는 과정입니다. Hugging Face와 같은 라이브러리를 사용하여 사전 훈련된 LLM 모델을 로드합니다. BERT, RoBERTa와 같은 모델을 사용할 수 있습니다. 그런 다음, 로드한 모델을 스팸 필터링 작업에 맞게 설정합니다. 여기에는 모델의 출력 레이어 수정, 추가적인 레이어 추가 등의 작업이 포함될 수 있습니다.\n3단계는 모델을 미세 조정하고 실제 스팸 필터링에 활용하는 과정입니다. 1단계에서 준비한 데이터셋을 사용하여 2단계에서 설정한 모델을 미세 조정합니다. 미세 조정은 모델이 스팸 메일과 정상 메일을 구분하는 방법을 학습하는 과정입니다. 충분한 미세 조정 후에는 모델을 새로운 데이터에 적용하여 스팸 메일을 분류할 수 있습니다. 이제 단계별로 코드 예제를 다루어 보죠."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html#데이터셋-불균형-해소",
    "href": "posts/ipynb/ml_LLM_classification.html#데이터셋-불균형-해소",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "1.1 데이터셋 불균형 해소",
    "text": "1.1 데이터셋 불균형 해소\n머신러닝 모델 훈련 시 가장 흔하게 마주하는 문제 중 하나는 데이터셋의 불균형입니다. 특히 스팸 필터링과 같이 특정 클래스의 데이터가 현저히 적은 경우 모델의 성능 저하를 야기할 수 있습니다. 이를 해결하기 위해 “ham” 메일과 “spam” 메일의 개수를 동일하게 맞춰줍니다. 구체적으로 “ham” 메일 중에서 “spam” 메일의 개수만큼 무작위로 샘플링하여 두 종류의 메일을 합쳐 균형 잡힌 데이터셋을 생성할 것입니다. 이렇게 생성된 balanced_df는 “ham”을 0, “spam”을 1로 매핑하여 숫자 레이블로 변환합니다.\n\ndef create_balanced_dataset(df):\n    # \"spam\" 인스턴스 개수 세기\n    num_spam = df[df[\"Label\"] == \"spam\"].shape[0]\n\n    # \"spam\" 인스턴스 개수와 일치하도록 \"ham\" 인스턴스 무작위 샘플링\n    ham_subset = df[df[\"Label\"] == \"ham\"].sample(num_spam, random_state=42)\n\n    # \"ham\" 서브셋과 \"spam\" 데이터 결합\n    balanced_df = pd.concat([ham_subset, df[df[\"Label\"] == \"spam\"]])\n\n    return balanced_df\n\n\nbalanced_df = create_balanced_dataset(df)\nbalanced_df[\"Label\"] = balanced_df[\"Label\"].map({\"ham\": 0, \"spam\": 1})\n\nprint(balanced_df[\"Label\"].value_counts())\n\nLabel\n0    747\n1    747\nName: count, dtype: int64"
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html#데이터-로더-생성-creating-data-loaders",
    "href": "posts/ipynb/ml_LLM_classification.html#데이터-로더-생성-creating-data-loaders",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "2.1 데이터 로더 생성 (Creating data loaders)",
    "text": "2.1 데이터 로더 생성 (Creating data loaders)\n앞서 준비한 데이터를 LLM 모델의 학습 데이터로 사용하려면, 메시지 길이가 서로 다르다는 점을 고려해야 합니다. 여러 훈련 예제를 하나의 배치로 묶어 학습하는 과정에서, 메시지 길이가 다르면 문제가 발생할 수 있습니다. 이를 해결하기 위해 다음 두 가지 방법 중 하나를 선택해야 합니다.\n\n데이터셋 또는 배치 내에서 가장 짧은 메시지 길이에 맞춰 모든 메시지를 잘라내는 방법: 이 방법은 간단하지만, 메시지 내용의 일부가 손실될 수 있다는 단점이 있습니다. 특히 중요한 정보가 메시지 앞부분에 위치하는 경우, 정보 손실로 인해 모델 성능이 저하될 수 있습니다.\n데이터셋 또는 배치 내에서 가장 긴 메시지 길이에 맞춰 모든 메시지를 패딩하는 방법: 이 방법은 메시지 내용 손실 없이 모든 메시지를 동일한 길이로 맞출 수 있다는 장점이 있습니다. 다만, 패딩된 부분은 모델 학습에 영향을 미치지 않도록 마스크 처리를 해야 합니다.\n\n본 튜토리얼에서는 2번 방법을 선택하여 모든 메시지를 데이터셋에서 가장 긴 메시지 길이에 맞춰 패딩합니다. 패딩된 부분은 모델 학습 시 마스크 처리를 통해 무시하도록 합니다."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html#사전-훈련된-모델-가중치-초기화-initializing-a-model-with-pretrained-weights",
    "href": "posts/ipynb/ml_LLM_classification.html#사전-훈련된-모델-가중치-초기화-initializing-a-model-with-pretrained-weights",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "2.2 사전 훈련된 모델 가중치 초기화 (Initializing a model with pretrained weights)",
    "text": "2.2 사전 훈련된 모델 가중치 초기화 (Initializing a model with pretrained weights)\n\n2.2.1 모델 선택 (Choosing a model)\n본 튜토리얼에서는 answerdotai/ModernBERT-base 모델을 사용합니다. 이 모델은 허깅페이스(Hugging Face)의 transformers 라이브러리를 사용하면 간단하게 모델을 불러올 수 있습니다.\n\n\n2.2.2 모델 초기화 (Initializing the model)\nAutoModelForSequenceClassification 클래스를 사용하여 사전 훈련된 모델을 불러오고, 원하는 task에 맞게 head 부분을 수정합니다. 본 튜토리얼에서는 스팸 메일 분류를 위해 2개의 label (스팸, 햄)을 가진 classification head를 사용합니다.\n\nimport torch\nfrom torch.utils.data import DataLoader, Dataset\nfrom transformers import (\n    AutoModelForSequenceClassification,\n    AutoTokenizer,\n    Trainer,\n    TrainingArguments,\n)\n\nmodel_id = \"answerdotai/ModernBERT-base\"\n\n# 토크나이저를 데이터셋 생성 또는 멀티프로세싱 전에 전역적으로 초기화합니다.\ntokenizer = AutoTokenizer.from_pretrained(model_id)\n\n\n# 데이터 로더 클래스 정의\nclass CustomDataset(Dataset):\n    def __init__(self, texts, labels, tokenizer):  # 토크나이저를 인자로 추가\n        self.texts = texts\n        self.labels = labels\n        self.tokenizer = tokenizer  # 전달받은 토크나이저 사용\n\n    def __len__(self):\n        return len(self.texts)\n\n    def __getitem__(self, idx):\n        encoding = self.tokenizer(\n            self.texts[idx],\n            truncation=True,\n            padding=\"max_length\",\n            max_length=128,\n            return_tensors=\"pt\",\n        )\n        return {\n            \"input_ids\": encoding[\"input_ids\"].flatten(),\n            \"attention_mask\": encoding[\"attention_mask\"].flatten(),\n            \"labels\": torch.tensor(self.labels[idx], dtype=torch.long),\n        }\n\n\ntexts = balanced_df[\"Text\"].to_list()\nlabels = balanced_df[\"Label\"].to_list()\n\ndataset = CustomDataset(texts, labels, tokenizer)  # 토크나이저 인스턴스 전달\ntrain_loader = DataLoader(dataset, batch_size=16, shuffle=True)\n\n# 모델 로드 및 설정\nif torch.backends.mps.is_available():\n    device = torch.device(\"mps\")\n    print(\"Using MPS\")\nelif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    print(\"Using CUDA\")\nelse:\n    device = torch.device(\"cpu\")\n    print(\"Using CPU\")\n\nmodel = AutoModelForSequenceClassification.from_pretrained(model_id, num_labels=2)\nmodel = model.to(device)\n\n# 모델 학습 설정 및 조정\ntraining_args = TrainingArguments(\n    output_dir=\"../data/output/ModernBERT-spam\",\n    num_train_epochs=3,\n    per_device_train_batch_size=16,\n    logging_dir=\"../data/output/ModernBERT-spam/logs\",\n    logging_steps=40,\n)\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=dataset,\n)\n\nUsing MPS\n\n\nSome weights of ModernBertForSequenceClassification were not initialized from the model checkpoint at answerdotai/ModernBERT-base and are newly initialized: ['classifier.bias', 'classifier.weight']\nYou should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html#모델로-예측하기",
    "href": "posts/ipynb/ml_LLM_classification.html#모델로-예측하기",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "3.1 모델로 예측하기",
    "text": "3.1 모델로 예측하기\n앞서 구축하고 미세 조정한 LLM 모델을 이용하여 실제 환경에서 새로운 이메일에 대한 스팸 여부를 예측해보겠습니다. 이 과정은 모델의 실용성을 검증하는 핵심적인 단계입니다.\n\n# 새로운 데이터에 대한 예측 사용\npredict_texts = [\n    \"CONGRATULATIONS! You've been selected to receive a FREE iPhone 14 Pro Max! Click the link below to claim your prize within the next 30 minutes: bit.ly/free-iphone-claim. Don't miss out on this EXCLUSIVE offer\",  # 스팸\n    \"Hi, how are you? I wanted to catch up and see if you're free for a call sometime this week.\",  # 햄\n    \"Reminder: Don't forget to pick up your dry cleaning today.\",  # 햄\n]\n\n# 예측 시 *동일한* 토크나이저 인스턴스 사용\npredict_encodings = tokenizer(  # 전역적으로 초기화된 토크나이저 사용\n    predict_texts, truncation=True, padding=True, return_tensors=\"pt\"\n)\n\n# 모델 예측\nwith torch.no_grad():\n    outputs = model(\n        input_ids=predict_encodings[\"input_ids\"].to(device),\n        attention_mask=predict_encodings[\"attention_mask\"].to(device),\n    )\n\n# 예측 결과 추출\npredictions = torch.argmax(outputs.logits, dim=-1)\n\n# 예측 결과 해석 및 출력\nfor text, prediction in zip(predict_texts, predictions):\n    if prediction.item() == 1:\n        print(f\"스팸: {text}\")\n    else:\n        print(f\"햄: {text}\")\n\n스팸: CONGRATULATIONS! You've been selected to receive a FREE iPhone 14 Pro Max! Click the link below to claim your prize within the next 30 minutes: bit.ly/free-iphone-claim. Don't miss out on this EXCLUSIVE offer\n햄: Hi, how are you? I wanted to catch up and see if you're free for a call sometime this week.\n햄: Reminder: Don't forget to pick up your dry cleaning today.\n\n\n위의 출력을 보니 성능이 꽤 괜찮은 것 처럼 보이네요."
  },
  {
    "objectID": "posts/ipynb/ml_LLM_classification.html#hugging-face-hub에-모델-저장",
    "href": "posts/ipynb/ml_LLM_classification.html#hugging-face-hub에-모델-저장",
    "title": "LLM을 사용한 스팸 메시지 분류",
    "section": "3.2 Hugging Face Hub에 모델 저장",
    "text": "3.2 Hugging Face Hub에 모델 저장\n이제 미세 조정한 모델을 허깅페이스에 업로드합니다. 이렇게 올려두면 모델을 공유하거나 필요할때 다운로드해서 바로 사용할 수 있습니다.\n\n# 토크나이저 업로드\ntokenizer.push_to_hub(\"ehottl/ModernBERT-spam\")  # 본인 계정 이름과 저장소 이름 작성\n\n# 트레이너를 사용한 모델 업로드\ntrainer.push_to_hub(\"ehottl/ModernBERT-spam\")  # 본인 계정 이름과 저장소 이름 작성\n\nNo files have been modified since last commit. Skipping to prevent empty commit.\n\n\nCommitInfo(commit_url='https://huggingface.co/ehottl/ModernBERT-spam/commit/23f02271322e82762e9c5ca4322dad918205d6bf', commit_message='ehottl/ModernBERT-spam', commit_description='', oid='23f02271322e82762e9c5ca4322dad918205d6bf', pr_url=None, repo_url=RepoUrl('https://huggingface.co/ehottl/ModernBERT-spam', endpoint='https://huggingface.co', repo_type='model', repo_id='ehottl/ModernBERT-spam'), pr_revision=None, pr_num=None)"
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html",
    "href": "posts/ipynb/da_visualization_matplotlib.html",
    "title": "Matplotlib 고급 시각화",
    "section": "",
    "text": "matplotlib의 기본 플롯은 결코 “전문가”처럼 보이지 않기 때문에 사람들은 다른 Plotly와 같은 다른 시각화 라이브러리를 사용하고는 합니다. 그러나 대부분의 경우 matplotlib의 사용자 정의 기능을 사용한다면 충분히 전문가 같은 시각화를 할 수 있습니다.\n아래의 예시는 모두 matplotlib을 사용하여 만들어졌고 두 번째 플롯이 첫번째 플롯보다 훨씬 더 우아하고, 유익하며, 매력적으로 보입니다. 왜냐하면 아래의 조건을 충족하기 때문이죠.\n\n제목과 부제는 메세지를 전달하는 데 크게 도움이 됩니다.\n주석은 기본 플롯에 없는 추가적인 중요 정보를 제공합니다.\n일부 그래프를 굵게 표현해 시각적 주의를 끌고 중요성을 강조합니다.\n\n좋은 시각화는 보는 사람의 입장에서 최소한의 노력이 필요해야 한다는 것입니다. 따라서 전문가 같은 시각화를 위해 추가적인 노력을 기울이는 것이 중요합니다.\n\n추가적인 설명 없이도 시각화 자료가 올바른 스토리를 전달하도록 하세요.\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport matplotlib.ticker as mtick\n\ndef percent_formatter(x, pos):\n    return f\"{x*100:.0f}%\"\n\n# Dummy Data\ndf = pd.DataFrame([['Clothing', 0.1],\n                   ['Home Decor', 0.43],\n                   ['Electronics', 0.13],\n                   ['Stationery', 0.2],\n                   ['Toys', 0.14]], columns = ['Spend_Category', 'Profit_Margin'])\n\n# Define figure\nfig,ax = plt.subplots(figsize = (6.5, 4))\n\n# Create bar plot\nplt.bar(df['Spend_Category'], df['Profit_Margin'])\n\n# Convert y-axis labels to percentage\nax.yaxis.set_major_formatter(mtick.FuncFormatter(percent_formatter))\n\n# show grid\nplt.grid(axis = 'y',alpha = 0.45)\n\n# set title and and x-y label \nplt.title('Profit Margin for top five spend categories')\nplt.ylabel('Profit Margin')\nplt.xlabel('Category')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n# 원본 데이터를 생성하고, 'Profit_Margin' 기준으로 오름차순 정렬합니다.\ndf = pd.DataFrame([\n    ['Clothing', 0.1],\n    ['Home Decor', 0.43],\n    ['Electronics', 0.13],\n    ['Stationery', 0.2],\n    ['Toys', 0.14]\n], columns=['Spend_Category', 'Profit_Margin'])\n\ndf = df.sort_values(\"Profit_Margin\", ascending=True, ignore_index=True)\n\nfig, ax = plt.subplots(figsize=(10, 6))\nfig.set_facecolor('white')  # Figure 전체 배경색\nax.set_facecolor('white')   # 플롯 영역(Axes) 배경색\n\n# 공통 폰트 설정\nTITLE_FONT = 'Noto Sans'\n\n# 메인 제목\nfig.text(\n    0, 0.91,  # x, y 위치 (Figure 좌측 하단이 0,0)\n    'Profit Margin for top five spend categories',\n    fontfamily=TITLE_FONT,\n    fontweight=\"bold\",\n    fontsize=22,\n    ha='left'  # 수평 왼쪽 정렬\n)\n\n# 부제목\nfig.text(\n    0, 0.85,\n    'Consumers are willing to pay higher prices for decorative items for their home.',\n    fontfamily=TITLE_FONT,\n    fontsize=18,\n    ha='left'\n)\n\n# 막대 색상 동적 생성 (마지막 값만 검은색으로 강조)\nn_bars = len(df)\nbar_colors = ['lightgray'] * (n_bars - 1) + ['black']\n\n# 수평 막대 그래프 그리기 (ax 객체 사용)\nbars = ax.barh(\n    df['Spend_Category'],\n    df['Profit_Margin'],\n    color=bar_colors,\n    edgecolor='none'\n)\n\n# 각 막대에 백분율(%) 형식으로 값을 표시합니다.\nax.bar_label(\n    bars,\n    labels=[f'{x:.0%}' for x in bars.datavalues],\n    padding=12,\n    fontsize=15\n)\n\n# y축 여백을 설정하여 그래프가 잘리지 않게 합니다.\nax.margins(y=0.14)\n\n# 모든 축(spines)을 보이지 않게 처리\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['bottom'].set_visible(False)\nax.spines['left'].set_visible(False)\n\n# x축 눈금과 레이블 제거\nax.set_xticks([])\n\n# y축 눈금선 제거 및 레이블 폰트 설정\nax.tick_params(axis='y', left=False) # y축 눈금선(tick line) 제거\n# y축 레이블(Spend_Category) 폰트 설정 (plt.yticks 대신 ax 메서드 사용)\nax.set_yticklabels(df['Spend_Category'], fontsize=14, fontweight='bold')\n\n# (1) 제목 아래 파란색 구분선\nax.plot(\n    [-0.025, .94],           # 선의 시작/끝 x좌표\n    [.8335, .8335],          # 선의 시작/끝 y좌표\n    transform=fig.transFigure, # Figure 기준 좌표계 사용\n    clip_on=False,             # Figure 영역 밖으로 그려도 자르지 않음\n    color='tab:blue',\n    linewidth=3\n)\n\n# (2) 왼쪽 파란색 강조 사각형\nax.add_patch(\n    plt.Rectangle(\n        (-0.03, .95),          # 사각형 좌측 하단 (x, y)\n        0.015, -0.12,          # 너비, 높이\n        facecolor='tab:blue',\n        transform=fig.transFigure,\n        clip_on=False,\n        linewidth=0\n    )\n)\n\n# (3) 각주(Footnote)\nfig.text(\n    0, 0.13,\n    \"*Data from Jan-2022 to Mar-2023\",\n    fontfamily=TITLE_FONT,\n    fontstyle='italic',\n    fontsize=15,\n    ha='left'\n)\n\nplt.show()\n\n/tmp/ipykernel_150474/1225230903.py:73: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.\n  ax.set_yticklabels(df['Spend_Category'], fontsize=14, fontweight='bold')"
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#기본-matplotlib-플랏",
    "href": "posts/ipynb/da_visualization_matplotlib.html#기본-matplotlib-플랏",
    "title": "Matplotlib 고급 시각화",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport matplotlib.ticker as mtick\n\ndef percent_formatter(x, pos):\n    return f\"{x*100:.0f}%\"\n\n# Dummy Data\ndf = pd.DataFrame([['Clothing', 0.1],\n                   ['Home Decor', 0.43],\n                   ['Electronics', 0.13],\n                   ['Stationery', 0.2],\n                   ['Toys', 0.14]], columns = ['Spend_Category', 'Profit_Margin'])\n\n# Define figure\nfig,ax = plt.subplots(figsize = (6.5, 4))\n\n# Create bar plot\nplt.bar(df['Spend_Category'], df['Profit_Margin'])\n\n# Convert y-axis labels to percentage\nax.yaxis.set_major_formatter(mtick.FuncFormatter(percent_formatter))\n\n# show grid\nplt.grid(axis = 'y',alpha = 0.45)\n\n# set title and and x-y label \nplt.title('Profit Margin for top five spend categories')\nplt.ylabel('Profit Margin')\nplt.xlabel('Category')\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#사용자-정의를-곁들인-matplotlib-플랏",
    "href": "posts/ipynb/da_visualization_matplotlib.html#사용자-정의를-곁들인-matplotlib-플랏",
    "title": "Matplotlib 고급 시각화",
    "section": "",
    "text": "# 원본 데이터를 생성하고, 'Profit_Margin' 기준으로 오름차순 정렬합니다.\ndf = pd.DataFrame([\n    ['Clothing', 0.1],\n    ['Home Decor', 0.43],\n    ['Electronics', 0.13],\n    ['Stationery', 0.2],\n    ['Toys', 0.14]\n], columns=['Spend_Category', 'Profit_Margin'])\n\ndf = df.sort_values(\"Profit_Margin\", ascending=True, ignore_index=True)\n\nfig, ax = plt.subplots(figsize=(10, 6))\nfig.set_facecolor('white')  # Figure 전체 배경색\nax.set_facecolor('white')   # 플롯 영역(Axes) 배경색\n\n# 공통 폰트 설정\nTITLE_FONT = 'Noto Sans'\n\n# 메인 제목\nfig.text(\n    0, 0.91,  # x, y 위치 (Figure 좌측 하단이 0,0)\n    'Profit Margin for top five spend categories',\n    fontfamily=TITLE_FONT,\n    fontweight=\"bold\",\n    fontsize=22,\n    ha='left'  # 수평 왼쪽 정렬\n)\n\n# 부제목\nfig.text(\n    0, 0.85,\n    'Consumers are willing to pay higher prices for decorative items for their home.',\n    fontfamily=TITLE_FONT,\n    fontsize=18,\n    ha='left'\n)\n\n# 막대 색상 동적 생성 (마지막 값만 검은색으로 강조)\nn_bars = len(df)\nbar_colors = ['lightgray'] * (n_bars - 1) + ['black']\n\n# 수평 막대 그래프 그리기 (ax 객체 사용)\nbars = ax.barh(\n    df['Spend_Category'],\n    df['Profit_Margin'],\n    color=bar_colors,\n    edgecolor='none'\n)\n\n# 각 막대에 백분율(%) 형식으로 값을 표시합니다.\nax.bar_label(\n    bars,\n    labels=[f'{x:.0%}' for x in bars.datavalues],\n    padding=12,\n    fontsize=15\n)\n\n# y축 여백을 설정하여 그래프가 잘리지 않게 합니다.\nax.margins(y=0.14)\n\n# 모든 축(spines)을 보이지 않게 처리\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.spines['bottom'].set_visible(False)\nax.spines['left'].set_visible(False)\n\n# x축 눈금과 레이블 제거\nax.set_xticks([])\n\n# y축 눈금선 제거 및 레이블 폰트 설정\nax.tick_params(axis='y', left=False) # y축 눈금선(tick line) 제거\n# y축 레이블(Spend_Category) 폰트 설정 (plt.yticks 대신 ax 메서드 사용)\nax.set_yticklabels(df['Spend_Category'], fontsize=14, fontweight='bold')\n\n# (1) 제목 아래 파란색 구분선\nax.plot(\n    [-0.025, .94],           # 선의 시작/끝 x좌표\n    [.8335, .8335],          # 선의 시작/끝 y좌표\n    transform=fig.transFigure, # Figure 기준 좌표계 사용\n    clip_on=False,             # Figure 영역 밖으로 그려도 자르지 않음\n    color='tab:blue',\n    linewidth=3\n)\n\n# (2) 왼쪽 파란색 강조 사각형\nax.add_patch(\n    plt.Rectangle(\n        (-0.03, .95),          # 사각형 좌측 하단 (x, y)\n        0.015, -0.12,          # 너비, 높이\n        facecolor='tab:blue',\n        transform=fig.transFigure,\n        clip_on=False,\n        linewidth=0\n    )\n)\n\n# (3) 각주(Footnote)\nfig.text(\n    0, 0.13,\n    \"*Data from Jan-2022 to Mar-2023\",\n    fontfamily=TITLE_FONT,\n    fontstyle='italic',\n    fontsize=15,\n    ha='left'\n)\n\nplt.show()\n\n/tmp/ipykernel_150474/1225230903.py:73: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.\n  ax.set_yticklabels(df['Spend_Category'], fontsize=14, fontweight='bold')"
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#주석-플롯annotated-plot",
    "href": "posts/ipynb/da_visualization_matplotlib.html#주석-플롯annotated-plot",
    "title": "Matplotlib 고급 시각화",
    "section": "2.1 주석 플롯(Annotated Plot)",
    "text": "2.1 주석 플롯(Annotated Plot)\n주석 플롯은 플롯에 설명 텍스트를 추가하여, 보는 사람의 시선을 특정 영역으로 유도하고 이해를 돕도록 합니다.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport yfinance\n\n# Matplotlib의 날짜 변환기를 pandas용으로 등록 (호환성 향상)\npd.plotting.register_matplotlib_converters()\n\nsns.set()\n\n# -- 0. 데이터 준비 --\n# yfinance 데이터 다운로드 (두 플롯에서 공유)\nraw_data = yfinance.download(tickers=\"^GSPC\", start='2020-01-01',\n                             end='2022-03-31', interval=\"1d\")\n\n# -- 1. Figure 및 2개의 Subplots 생성 (2행 1열) --\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(8, 8))\n\n# 명확성을 위해 각 subplot을 별도 변수에 할당\nax1 = axs[0]\nax2 = axs[1]\n\n# -- 2. 첫 번째 플롯 (ax1) - Usual Plot --\nax1.plot(raw_data.index, raw_data.Close)\n\n# plt.xlabel -&gt; ax1.set_xlabel\nax1.set_xlabel(\"\")\nax1.set_ylabel(\"S&P 500\", size=12)\n# plt.title -&gt; ax1.set_title\nax1.set_title(\"Usual Plot\", size=15)\n\n# plt.xticks -&gt; ax1.tick_params\nax1.tick_params(axis='x', labelsize=10, rotation=45)\nax1.tick_params(axis='y', labelsize=10)\n\n\n# -- 3. 두 번째 플롯 (ax2) - Annotated Plot --\nax2.plot(raw_data.index, raw_data.Close)\n\n# First peak annotation\nax2.annotate('First Wave', (pd.to_datetime('2020-02-20'), 3400), (pd.to_datetime('2020-01-31'), 4000), size=15, va=\"center\", ha=\"center\",\n             arrowprops=dict(arrowstyle=\"simple\", facecolor='orange',\n                             connectionstyle=\"arc3,rad=-0.2\"))\n\n# Second peak annotation\nax2.annotate('Second Wave', xy=(pd.to_datetime('2020-09-23'), 3250), xytext=(pd.to_datetime('2020-11-15'), 2700), size=15, va=\"center\", ha=\"center\",\n             arrowprops=dict(arrowstyle=\"simple\", facecolor='orange',\n                             connectionstyle=\"arc3,rad=-0.2\"))\n\n# Third peak annotation\nax2.annotate('Third Wave', xy=(pd.to_datetime('2020-10-30'), 3450), xytext=(pd.to_datetime('2020-09-15'), 4300), size=15, va=\"center\", ha=\"center\",\n             arrowprops=dict(arrowstyle=\"simple\", facecolor='orange',\n                             connectionstyle=\"arc3,rad=-0.2\"))\n\n# Fourth peak annotation\nax2.annotate('Fourth Wave', xy=(pd.to_datetime('2021-09-30'), 4300), xytext=(pd.to_datetime('2021-07-31'), 3500), size=15, va=\"center\", ha=\"center\",\n             arrowprops=dict(arrowstyle=\"simple\", facecolor='orange',\n                             connectionstyle=\"arc3,rad=0.2\"))\n\n# Fifth peak annotation\nax2.annotate('Fifth Wave', xy=(pd.to_datetime('2022-01-27'), 4300), xytext=(pd.to_datetime('2022-02-28'), 3500), size=15, va=\"center\", ha=\"center\",\n             arrowprops=dict(arrowstyle=\"simple\", facecolor='orange',\n                             connectionstyle=\"arc3,rad=-0.2\"))\n\n# plt.xlabel -&gt; ax2.set_xlabel\nax2.set_xlabel(\"\")\nax2.set_ylabel(\"S&P 500\", size=12)\n# plt.title -&gt; ax2.set_title\nax2.set_title(\"Annotated Plot\", size=15)\n\n# plt.xticks -&gt; ax2.tick_params\nax2.tick_params(axis='x', labelsize=10, rotation=45)\nax2.tick_params(axis='y', labelsize=10)\n\n\n# -- 4. 전체 Figure 표시 --\n# 플롯들이 겹치지 않도록 레이아웃 자동 조정\nplt.tight_layout()\nplt.show()\n\n/tmp/ipykernel_150474/1802525514.py:14: FutureWarning: YF.download() has changed argument auto_adjust default to True\n  raw_data = yfinance.download(tickers=\"^GSPC\", start='2020-01-01',\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\n\n\n\n\n\n또 다른 추가 정보를 제공하는 또 다른 훌륭한 방법은 플롯에 확대된 그림을 추가하는 것입니다. matplotlib에서는 indicate_inset_zoom()을 사용하여 수행할 수 있습니다. 이 함수는 표시 상자(indicator box)를 추가하며, 더 명확하게 보기 위해 확대(zoom-in)할 수 있습니다. 삽입된 플롯은 다른 matplotlib 플롯과 동일하게 취급됩니다. 따라서 필요하다면 축 레이블을 추가할 수도 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#리지라인-플랏은-언제-사용해야-하는가",
    "href": "posts/ipynb/da_visualization_matplotlib.html#리지라인-플랏은-언제-사용해야-하는가",
    "title": "Matplotlib 고급 시각화",
    "section": "4.1 리지라인 플랏은 언제 사용해야 하는가?",
    "text": "4.1 리지라인 플랏은 언제 사용해야 하는가?\n일반적으로 리지라인 플롯은 변수에 3~4개 이상의 그룹이 있을 때 사용하는 것이 합리적입니다. 이는 단일 플롯에서 시각화할 때 발생할 수 있는 겹침을 피하기 위함입니다. 또한, 리지라인 플롯은 그룹 간에 표시되는 연속형 변수에서 다음과 같이 명확한 패턴이나 순위가 있을 때 더 유용합니다.\n\n단조로운 증가(monotonically increasing)\n단조로운 감소(monotonically decreasing)\n증가 후 감소 혹은 감소 후 증가 등\n\n그렇기 때문에 그룹의 분포를 수직으로 쌓는 순서가 매우 중요해집니다.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport warnings\n\nfrom datetime import date, timedelta\nfrom joypy import joyplot  # 'joypy' 라이브러리가 설치되어 있어야 합니다.\nfrom pandas.api.types import CategoricalDtype\n\n# 경고 메시지 무시 (디버깅 시에는 주석 처리하는 것이 좋습니다)\nwarnings.filterwarnings(\"ignore\")\n\n# --- 더미 데이터 (가상 데이터) 정의 ---\n\n# 월별 평균 기온 및 표준 편차\nmax_temps = [20.5, 24.6, 30.4, 36.9, 40.9, 39, 35.8, 34.5, 34.3, 33.1, 28.3, 23]\n# min_temps 리스트의 불필요한 마지막 13번째 값(19)을 제거했습니다.\nmin_temps = [7.6, 10.8, 15.7, 21.3, 25.6, 27.6, 27.3, 26.6, 24.9, 19.3, 12.9, 8.3]\nstd_devs = [1, 2, 3] # 무작위로 선택할 표준 편차\nmonths = ['January', 'February', 'March', 'April', 'May', 'June',\n          'July', 'August', 'September', 'October', 'November', 'December']\n\n\n# --- 데이터 생성 (리팩토링됨) ---\n# df.append() 대신, 리스트에 딕셔너리를 추가한 후 DataFrame을 한 번에 생성합니다.\n\n# 데이터를 저장할 빈 리스트 초기화\ndata_list = []\n\n# 1년 치 각 날짜에 대한 데이터 생성\nstart_date = date(2023, 1, 1)\nend_date = date(2023, 12, 31)\ncurrent_date = start_date\n\nwhile current_date &lt;= end_date:\n    # 리스트 인덱싱을 위해 월을 0부터 시작하도록 조정 (1월 -&gt; 0)\n    month_index = current_date.month - 1\n    \n    # 정규 분포를 따르는 임의의 최고/최저 기온 생성\n    max_temp = np.random.normal(max_temps[month_index], std_devs[np.random.randint(0, 3)])\n    min_temp = np.random.normal(min_temps[month_index], std_devs[np.random.randint(0, 3)])\n\n    # 데이터를 딕셔너리 형태로 리스트에 추가\n    data_list.append({\n        'Day': current_date.day,\n        'Month': months[month_index],\n        'min_temp': min_temp,\n        'max_temp': max_temp\n    })\n\n    # 다음 날짜로 이동\n    current_date += timedelta(days=1)\n\n# 루프 종료 후, 리스트로부터 DataFrame을 한 번에 생성\ndf = pd.DataFrame(data_list)\n\n# 'Month' 컬럼을 월 순서대로 정렬되는 범주형(Categorical) 타입으로 변환\n# (플롯팅 시 월 순서를 보장하기 위함)\nmonth_dtype = CategoricalDtype(categories=months, ordered=True)\ndf['Month'] = df['Month'].astype(month_dtype)\n\n\n# --- Joy Plot (능선도) 생성 ---\n\n# joyplot이 (Figure, Axes) 객체를 반환합니다. (순서 수정: fig, ax)\n# 불필요한 plt.figure() 호출을 제거했습니다.\nfig, ax = joyplot(\n    data=df[['min_temp', 'max_temp', 'Month']], \n    by='Month',                          # 'Month'를 기준으로 그룹화\n    column=['min_temp', 'max_temp'],     # 플롯을 그릴 컬럼들\n    color=['#2471A3', '#fe7c73'],        # 각 컬럼에 대한 색상\n#     legend=True,                         # 범례 (필요시 주석 해제)\n    alpha=0.85,                          # 투명도\n    figsize=(6, 4),                     # Figure 크기\n)\n\n# Figure 전체의 제목 설정 (plt.title 대신 사용)\nfig.suptitle('Min Max Temperature Distribution)', fontsize=12, y=1.01) # y 값으로 제목 위치 조정\n\nplt.show()"
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#knn-대체법knn-imputation",
    "href": "posts/ipynb/da_visualization_matplotlib.html#knn-대체법knn-imputation",
    "title": "Matplotlib 고급 시각화",
    "section": "5.1 kNN 대체법(kNN imputation)",
    "text": "5.1 kNN 대체법(kNN imputation)\n이 방법은 k-최근접 이웃(k-nearest neighbors) 알고리즘을 사용하여 결측값을 대체합니다. 구체적으로는 결측이 아닌 피처 값들에 kNN을 실행하여 결측된 피처를 대체하며 아래의 단계를 따릅니다.\n\n1단계: 결측값이 있는 행 (r)을 선택합니다.\n2단계: 결측이 아닌 피처 값들을 사용하여 해당 행의 k개의 최근접 이웃을 찾습니다.\n3단계: k개의 최근접 이웃 행들에 해당하는 (결측이 아닌) 값들을 사용하여 행 (r)의 결측된 피처를 대체합니다.\n4단계: 결측값이 있는 모든 행에 대해 반복합니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_matplotlib.html#여러-결측치-대체-방법을-비교하는-시각화",
    "href": "posts/ipynb/da_visualization_matplotlib.html#여러-결측치-대체-방법을-비교하는-시각화",
    "title": "Matplotlib 고급 시각화",
    "section": "5.2 여러 결측치 대체 방법을 비교하는 시각화",
    "text": "5.2 여러 결측치 대체 방법을 비교하는 시각화\n\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom sklearn.impute import SimpleImputer, KNNImputer\n\n# 경고 메시지 무시\nwarnings.filterwarnings(\"ignore\")\nsns.set()\n\n# 플롯을 위한 기본 설정\nplt.rcParams['font.family'] = ['Noto Sans', 'sans-serif'] \ncolors = ['#fe7c73', '#2471A3', '#3498DB', '#27AE60', '#82E0AA', '#D35400', \n          '#5D6D7E', '#E74C3C', '#21618C', '#B7950B', '#46C7C7', '#00B9FF', \n          '#FF7051', \"orange\", \"darkorange\", \"tomato\", \"coral\", \"limegreen\", \"lightsalmon\"]\n\n# --- 1. 결측치가 포함된 더미 데이터셋 생성 ---\nsize = 1000\ndata = np.random.normal(loc=2, scale=2, size=(size, 3))  # 정규분포를 따르는 무작위 데이터 생성\nmask = np.random.rand(size, 3) &lt; 0.2  # 20% 확률로 결측치를 만들기 위한 마스크(mask) 생성\ndata[mask] = np.nan  # 마스크를 적용하여 결측치(NaN) 설정\n\n# --- 2. 다양한 방법으로 결측치 대체 ---\n\n# 평균값 대체(Mean Imputation)\nmean_imputer = SimpleImputer(strategy='mean')\ndata_imputed_mean = mean_imputer.fit_transform(data)\n\n# 0으로 대체(Zero Imputation)\nzero_imputer = SimpleImputer(strategy='constant', fill_value=0)\ndata_imputed_zero = zero_imputer.fit_transform(data)\n\n# kNN 대체 (n_neighbors=5)\nknn_imputer = KNNImputer(n_neighbors=5)\ndata_imputed_knn = knn_imputer.fit_transform(data)\n\n# --- 3. Subplot을 사용하여 4개의 플롯을 하나로 합치기 ---\n\n# 2x2 서브플롯 그리드(grid) 생성. figsize로 전체 크기 조절\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(8, 6))\n\n# (0, 0) 위치: 원본 데이터 분포\naxes[0, 0].hist(data.flatten(), bins=45, edgecolor='black', color=colors[1])\naxes[0, 0].set_title(\"Original Distribution\", size=14, pad=10)\naxes[0, 0].set_xlabel(\"Value\", size=12,)\naxes[0, 0].set_ylabel(\"Frequency\", size=12,)\n\n# (0, 1) 위치: 평균값 대체(Mean Imputation) 분포\naxes[0, 1].hist(data_imputed_mean.flatten(), bins=45, edgecolor='black', color=colors[16])\naxes[0, 1].set_title(\"Mean Imputation\", size=14, pad=10)\naxes[0, 1].set_xlabel(\"Value\", size=12,)\naxes[0, 1].set_ylabel(\"Frequency\", size=12,)\n\n# (1, 0) 위치: 0으로 대체(Zero Imputation) 분포\naxes[1, 0].hist(data_imputed_zero.flatten(), bins=45, edgecolor='black', color=colors[16])\naxes[1, 0].set_title(\"Zero Imputation\", size=14, pad=10)\naxes[1, 0].set_xlabel(\"Value\", size=12,)\naxes[1, 0].set_ylabel(\"Frequency\", size=12,)\n\n# (1, 1) 위치: kNN 대체(kNN Imputation) 분포\naxes[1, 1].hist(data_imputed_knn.flatten(), bins=50, edgecolor='black', color=colors[18])\naxes[1, 1].set_title(\"kNN Imputation (k=5)\", size=14, pad=10)\naxes[1, 1].set_xlabel(\"Value\", size=12,)\naxes[1, 1].set_ylabel(\"Frequency\", size=12,)\n\n# 레이아웃 자동 조정 (메인 제목과 겹치지 않도록 rect 파라미터로 상단 여백 확보)\nplt.tight_layout(rect=[0, 0.03, 1, 0.95])\n\n# 모든 플롯을 한 번에 표시\nplt.show()\n\n\n\n\n\n\n\n\n위 결과를 보면 평균(mean) 대체 또는 0(zero) 대체 대비 kNN 대체가 갖는 효과는 위 시각화에서 명확하게 드러납니다. 왼쪽 위에는 결측값이 있는 피처의 분포가 있습니다. 데이터가 MAR(무작위 결측)임을 이미 검증했다고 가정할 때 아래 그림과 같이 평균/0 대체를 사용하면 요약 통계량과 분포가 변경됩니다. 하지만 오른쪽 아래 그림에서 보듯이 kNN 대체(imputer)는 더 신뢰할 수 있는 것으로 보이며 요약 통계량을 보존하고 있습니다."
  },
  {
    "objectID": "posts/ipynb/da_visualization_AKTA.html",
    "href": "posts/ipynb/da_visualization_AKTA.html",
    "title": "AKTA 크로마토그램(chromatogram) 시각화",
    "section": "",
    "text": "AKTA 시스템은 단백질 정제 과정에서 널리 사용되는 크로마토그래피 시스템입니다. 과거에는 GE healthcare에서 현재는 Cytiva사에서 판매되고 있으며 자체 소프트웨어 UNICORN를 제공합니다. 여기서는 UNICORN에서 추출한 스프레드 시트 데이터를 사용해 크로마토그래피 그래프를 생성하는 방법을 알아보겠습니다. 데이터 처리부터 시각화까지 단계별로 파이썬을 사용하였습니다.\nimport os\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\ndef read_and_preprocess_data(file_path: str) -&gt; pd.DataFrame:\n    \"\"\"엑셀 파일을 읽고 전처리하는 함수\"\"\"\n    # 엑셀 파일 읽기 (상위 2행 스킵)\n    df = pd.read_excel(file_path, index_col=False, skiprows=[0, 1])\n\n    # 컬럼 이름 변경\n    new_columns = [\n        \"ml\",\n        \"mAU\",\n        \"ml_1\",\n        \"mS_cm\",\n        \"ml_2\",\n        \"percent\",\n        \"ml_3\",\n        \"%B\",\n        \"ml_4\",\n        \"pH\",\n        \"ml_5\",\n        \"MPa\",\n        \"ml_6\",\n        \"ml_min\",\n        \"ml_7\",\n        \"temperature_C\",\n        \"ml_8\",\n        \"Frac\",\n        \"ml_9\",\n        \"Injections\",\n        \"ml_10\",\n        \"Set_Marks\",\n    ]\n    df.columns = new_columns\n\n    # %B 값 수정\n    elution_start = df[df[\"Set_Marks\"] == \"Block Isocratic_Elution\"][\"ml_10\"].values[0]\n    df[\"%B\"] = df[\"ml\"].apply(lambda x: 100 if x &gt;= elution_start else 0)\n\n    return df\n\n\ndef setup_plot() -&gt; tuple[plt.Figure, plt.Axes]:\n    \"\"\"플롯 초기 설정\"\"\"\n    fig, ax_main = plt.subplots(figsize=(10, 6))\n    plt.subplots_adjust(top=0.85)\n    return fig, ax_main\n\n\ndef plot_mau(ax: plt.Axes, df: pd.DataFrame) -&gt; None:\n    \"\"\"mAU 데이터 플로팅\"\"\"\n    ax.plot(df[\"ml\"], df[\"mAU\"], color=\"blue\", label=\"mAU\")\n    ax.fill_between(df[\"ml\"], df[\"mAU\"], color=\"lightblue\", alpha=0.3)\n    ax.set_xlabel(\"ml\")\n    ax.set_ylabel(\"mAU\", color=\"blue\")\n    ax.set_ylim(0, 2500)\n    ax.tick_params(axis=\"y\", labelcolor=\"blue\")\n\n\ndef plot_b_percentage(ax: plt.Axes, df: pd.DataFrame) -&gt; plt.Axes:\n    \"\"\"%B 데이터 플로팅\"\"\"\n    ax_b = ax.twinx()\n    ax_b.plot(df[\"ml\"], df[\"%B\"], color=\"red\", label=\"%B\")\n    ax_b.set_ylabel(\"%B\", color=\"red\")\n    ax_b.tick_params(axis=\"y\", labelcolor=\"red\")\n    return ax_b\n\n\ndef plot_ph(ax: plt.Axes, df: pd.DataFrame) -&gt; plt.Axes:\n    \"\"\"pH 데이터 플로팅\"\"\"\n    ax_ph = ax.twinx()\n    ax_ph.plot(df[\"ml_4\"], df[\"pH\"], color=\"green\", label=\"pH\")\n    ax_ph.set_ylabel(\"pH\", color=\"green\")\n    ax_ph.set_ylim(0, 12)\n    ax_ph.tick_params(axis=\"y\", labelcolor=\"green\")\n    ax_ph.spines[\"right\"].set_position((\"outward\", 60))\n    return ax_ph\n\n\ndef add_fraction_lines(ax: plt.Axes, df: pd.DataFrame) -&gt; None:\n    \"\"\"분획 정보 표시\"\"\"\n    for _, row in df.iterrows():\n        if pd.notna(row[\"Frac\"]):\n            ax.axvline(x=row[\"ml_8\"], color=\"gray\", linestyle=\"--\", alpha=0.5)\n            ax.text(\n                row[\"ml_8\"],\n                ax.get_ylim()[1],\n                row[\"Frac\"],\n                rotation=90,\n                va=\"top\",\n                ha=\"right\",\n            )\n\n\ndef add_combined_legend(axes: list[plt.Axes]) -&gt; None:\n    \"\"\"모든 축의 범례 통합\"\"\"\n    lines, labels = [], []\n    for ax in axes:\n        ax_lines, ax_labels = ax.get_legend_handles_labels()\n        lines.extend(ax_lines)\n        labels.extend(ax_labels)\n    axes[0].legend(lines, labels, loc=\"upper left\")\n\n\ndef process_and_plot_file(file_path: str) -&gt; None:\n    \"\"\"단일 파일 처리 및 플로팅\"\"\"\n    print(f\"Processing file: {os.path.basename(file_path)}\")\n\n    df = read_and_preprocess_data(file_path)\n    fig, ax_main = setup_plot()\n\n    plot_mau(ax_main, df)\n    ax_b = plot_b_percentage(ax_main, df)\n    ax_ph = plot_ph(ax_main, df)\n    add_fraction_lines(ax_main, df)\n    add_combined_legend([ax_main, ax_b, ax_ph])\n\n    plt.title(f\"{os.path.basename(file_path)} Plot\", y=1.01)\n    ax_main.grid(True, linestyle=\"--\", alpha=0.7)\n    plt.tight_layout()\n    plt.show()\n\n\ndef process_folder(folder_path: str) -&gt; None:\n    \"\"\"폴더 내 모든 .xls 파일 처리\"\"\"\n    for filename in os.listdir(folder_path):\n        if filename.endswith(\".xls\"):\n            file_path = os.path.join(folder_path, filename)\n            process_and_plot_file(file_path)"
  },
  {
    "objectID": "posts/ipynb/da_visualization_AKTA.html#주요-데이터-열-확인하기",
    "href": "posts/ipynb/da_visualization_AKTA.html#주요-데이터-열-확인하기",
    "title": "AKTA 크로마토그램(chromatogram) 시각화",
    "section": "1.1 주요 데이터 열 확인하기",
    "text": "1.1 주요 데이터 열 확인하기\n파일에서 흔히 볼 수 있는 주요 데이터 열은 다음과 같습니다:\n\nml (Volume): 용출 부피\nmAU (UV Absorbance): 자외선 흡광도\nmS/cm (Conductivity): 전도도\n%B (Buffer B Concentration): 버퍼 B의 농도 비율\npH: pH 값\nMPa (Pressure): 시스템 압력\n°C (Temperature): 온도\nFractions: 분획 번호"
  },
  {
    "objectID": "posts/ipynb/tool_cellranger_alignment.html#가상환경-사용하기",
    "href": "posts/ipynb/tool_cellranger_alignment.html#가상환경-사용하기",
    "title": "10X genomics scRNA-seq alignment",
    "section": "1.1 가상환경 사용하기",
    "text": "1.1 가상환경 사용하기\n정확하게는 velocyto를 사용하기 위해 가상환경을 만들어 사용합니다. 먼저 TutorialEnvironment.yml 파일을 다음 명령어로 다운받습니다.\nwget https://cf.10xgenomics.com/supp/cell-exp/neutrophils/TutorialEnvironment.yml\n다음 명령어로 가상환경을 만들어 줍니다.\nconda env create --file TutorialEnvironment.yml\n만들어진 가상환경을 활성화 시킵니다.\nconda activate tutorial\n다운로드 받은 yml파일은 삭제해줍니다.\nrm TutorialEnvironment.yml"
  },
  {
    "objectID": "posts/ipynb/tool_cellranger_alignment.html#system-requirements",
    "href": "posts/ipynb/tool_cellranger_alignment.html#system-requirements",
    "title": "10X genomics scRNA-seq alignment",
    "section": "2.1 System Requirements",
    "text": "2.1 System Requirements\nHardware Cell Ranger pipelines run on Linux systems that meet these minimum requirements:\n\n8-core Intel or AMD processor (16 cores recommended).\n64GB RAM (128GB recommended).\n1TB free disk space.\n64-bit CentOS/RedHat 7.0 or Ubuntu 14.04 - See the 10x Genomics OS Support page for details.\n\n\n2.1.1 Cell Ranger 7.2.0 (Sep 13, 2023)\nChromium Single Cell Software Suite Self-contained, relocatable tar file. Does not require centralized installation. Contains binaries pre-compiled for CentOS/RedHat 7.0 and Ubuntu 14.04. Runs on Linux systems that meets the minimum compute requirements.\n다음 명령어를 통해 cell ranger를 다운로드 합니다.\nwget -O cellranger-7.2.0.tar.gz \"https://cf.10xgenomics.com/releases/cell-exp/cellranger-7.2.0.tar.gz?Expires=1695129121&Key-Pair-Id=APKAI7S6A5RYOXBWRPDA&Signature=ZipqR8Pg4YvVDQ3MvAVuuiPwEOC5c39~Wj0WTAxfoJW6xtrxqIFgIDySFSFnsWcwDpmAovJGrHXU24Y9Cptt88OJSPdEupyFRXoGKJvVzRtDJChmuMbSpVCy-2N-QnMKwxNtd8Yt8Mdp2Vcq4wxx1hVC0Yx54c7U9o~RFXIVsIp48thKR6JnKhJmCAC5U4dFLa86~NcB4s5Ic4HATrQP2KyWexyYZWgmBEw13mlKYtlVRUil0zseoq0-CZyGmE8oB0iDBSUBAyIqo~XMVjv~lkMz4cRcyCbQKBRDr~U36FM2KnE3rhv-Rlp4KD-uXCReRnBsY6N6t-HxpS2YDpN3mQ__\"\n그리고 나서 다음 명령어로 압축을 풀어줍니다.\ntar -xvf cellranger-7.2.0.tar.gz\ncellranger-7.2.0 폴더로 이동하기\ncd cellranger-7.2.0\n정상적으로 되었다면 아래와 같은 폴더 구조를 볼 수 있습니다.\n.\n├── bin\n├── builtwith.json\n├── cellranger -&gt; bin/cellranger\n├── external\n├── lib\n├── LICENSE\n├── mro\n├── probe_sets -&gt; external/tenx_feature_references/targeted_panels\n├── sourceme.bash\n├── sourceme.csh\n└── THIRD-PARTY-LICENSES.cellranger.txt\n\n5 directories, 6 files\n이제 ./cellranger명령어를 입력하면 아래와 같이 cell ranger 실행이 가능합니다.\n./cellranger\ncellranger cellranger-7.2.0\n\nProcess 10x Genomics Gene Expression, Feature Barcode, and Immune Profiling data\n\nUsage: cellranger &lt;COMMAND&gt;\n\nCommands:\n  count           Count gene expression and/or feature barcode reads from a single sample and GEM well\n  multi           Analyze multiplexed data or combined gene expression/immune profiling/feature barcode data\n  multi-template  Output a multi config CSV template\n  vdj             Assembles single-cell VDJ receptor sequences from 10x Immune Profiling libraries\n  aggr            Aggregate data from multiple Cell Ranger runs\n  reanalyze       Re-run secondary analysis (dimensionality reduction, clustering, etc)\n  mkvdjref        Prepare a reference for use with CellRanger VDJ\n  mkfastq         Run Illumina demultiplexer on sample sheets that contain 10x-specific sample index sets\n  testrun         Execute the 'count' pipeline on a small test dataset\n  mat2csv         Convert a gene count matrix to CSV format\n  mkref           Prepare a reference for use with 10x analysis software. Requires a GTF and FASTA\n  mkgtf           Filter a GTF file by attribute prior to creating a 10x reference\n  upload          Upload analysis logs to 10x Genomics support\n  sitecheck       Collect linux system configuration information\n  help            Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version"
  },
  {
    "objectID": "posts/ipynb/tool_cellranger_alignment.html#scanpy-사용",
    "href": "posts/ipynb/tool_cellranger_alignment.html#scanpy-사용",
    "title": "10X genomics scRNA-seq alignment",
    "section": "6.1 Scanpy 사용",
    "text": "6.1 Scanpy 사용\n\n# conda install pandas scanpy\nimport scanpy as sc\n\n# Cell ranger 결과 파일이 들어있는 경로\nfile_path = \"../input/run_count_mNeuron1k/outs/filtered_feature_bc_matrix\"\n\n# read_10x_mtx 함수를 사용\nadata = sc.read_10x_mtx(file_path, var_names=\"gene_symbols\", cache=True)\nadata\n\nAnnData object with n_obs × n_vars = 1311 × 32285\n    var: 'gene_ids', 'feature_types'\n\n\n\n# conda install -c bioconda scvelo\nimport scvelo as scv\n\n# load loom files for spliced/unspliced matrices for each sample\nloom = scv.read(f\"{file_path}/run_count_mNeuron1k.loom\", validate=False, cache=False)\n\n# rename barcodes in order to merge:\nbarcodes = [bc.split(\":\")[1] for bc in loom.obs.index.tolist()]\nbarcodes = [bc[0 : len(bc) - 1] + \"-1\" for bc in barcodes]\nloom.obs.index = barcodes\n\n# make variable names unique\nloom.var_names_make_unique()\n\n# merge matrices into the original adata object\nadata = scv.utils.merge(adata, loom)\nadata\n\nAnnData object with n_obs × n_vars = 1311 × 32285\n    obs: 'initial_size_unspliced', 'initial_size_spliced', 'initial_size'\n    var: 'gene_ids', 'feature_types', 'Accession', 'Chromosome', 'End', 'Start', 'Strand'\n    layers: 'matrix', 'ambiguous', 'spliced', 'unspliced'\n\n\n\nscv.pl.proportions(adata)\n\n\n\n\n\n\n\n\n\nadata.write(\"../output/mNeuron1k.h5ad\", compression=\"gzip\")"
  },
  {
    "objectID": "posts/ipynb/tool_cellranger_alignment.html#seurat-사용",
    "href": "posts/ipynb/tool_cellranger_alignment.html#seurat-사용",
    "title": "10X genomics scRNA-seq alignment",
    "section": "6.2 Seurat 사용",
    "text": "6.2 Seurat 사용\nR에 좀 더 익숙하시다면 Seurat을 사용하세요. 저는 파이썬 문법을 더 좋아하지만 솔직히 분석 도구의 완성도 측면에서는 Seurat이 더 나은 것 같습니다. 아래 코드는 jupyter notebook에서 R코드를 사용하기 위해 필요한 것으로 rStudio를 사용하신다면 %%R이 포함된 셀의 코드만 사용하시면 됩니다.\n\nimport logging\n\nimport rpy2.rinterface_lib.callbacks as rcb\n\n# import rpy2.robjects as ro\n\nrcb.logger.setLevel(logging.ERROR)\n%load_ext rpy2.ipython\n\n\n%%R\nlibrary(dplyr)\nlibrary(Seurat)\n\n\n    WARNING: The R package \"reticulate\" only fixed recently\n    an issue that caused a segfault when used with rpy2:\n    https://github.com/rstudio/reticulate/pull/1188\n    Make sure that you use a version of that package that includes\n    the fix.\n    \n\n\n\n%%R\n# Load dataset\nfile_path &lt;- \"../input/run_count_mNeuron1k/outs/filtered_feature_bc_matrix\"\nneuron_data &lt;- Read10X(data_dir=file_path)\n# Initialize the Seurat object.\nobj &lt;- CreateSeuratObject(counts = neuron_data)\nobj\n\nAn object of class Seurat \n32285 features across 1311 samples within 1 assay \nActive assay: RNA (32285 features, 0 variable features)\n\n\nSeurat object를 파일로 저장하는 방법에도 여러가지가 있지만 R에서 많이 사용되는 *.rds를 사용하는 코드는 아래와 같습니다.\n\n%%R\nsaveRDS(obj, file = \"../output/mNeuron1k.rds\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html",
    "href": "posts/qmd/Rosalind_armory.html",
    "title": "Rosalind Armory 문제풀이",
    "section": "",
    "text": "생물 정보학 분석을 위해 사용할 수 있는 소프트웨어는 이미 많습니다. Rosalind_Stronghold 에서는 알고리즘을 직접 구현했다면, 여기 Rosalind_Armory 에서는 이미 존재하는 도구를 사용하여 비슷한 문제를 풀어봅니다.\nRosalind 는 프로젝트 오일러, 구글 코드 잼 에서 영감을 얻었습니다. 이 프로젝트의 이름은 DNA 이중나선을 발견하는 데 기여한 로잘린드 프랭클린 에서 따왔습니다. Rosalind 는 프로그래밍 실력을 키우고자 하는 생물학자와 분자생물학의 계산 문제를 접해본 적이 없는 프로그래머들에게 도움이 될 것입니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset",
    "title": "Rosalind Armory 문제풀이",
    "section": "1.1 Sample Dataset",
    "text": "1.1 Sample Dataset\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output",
    "href": "posts/qmd/Rosalind_armory.html#sample-output",
    "title": "Rosalind Armory 문제풀이",
    "section": "1.2 Sample Output",
    "text": "1.2 Sample Output\n20 12 17 21"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution",
    "href": "posts/qmd/Rosalind_armory.html#solution",
    "title": "Rosalind Armory 문제풀이",
    "section": "1.3 Solution",
    "text": "1.3 Solution\nfrom collections import Counter\n\ndef count_dna_symbols(dna):\n    # Define the symbols we're interested in\n    symbols = [\"A\", \"C\", \"G\", \"T\"]\n    \n    # Use Counter to count occurrences of each symbol in the DNA\n    dna_counter = Counter(dna)\n    \n    # Create a dictionary with counts for each symbol of interest\n    symbols_count = {symbol: dna_counter.get(symbol, 0) for symbol in symbols}\n    \n    return symbols_count\n\nsample_input = \"\"\"\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\n\"\"\"\n\n# Get the symbols count\nsymbols_count = count_dna_symbols(sample_input)\n\n# Print the counts in the desired format\nprint(\" \".join(str(symbols_count[symbol]) for symbol in [\"A\", \"C\", \"G\", \"T\"]))"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-1",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-1",
    "title": "Rosalind Armory 문제풀이",
    "section": "2.1 Sample Dataset",
    "text": "2.1 Sample Dataset\nAnthoxanthum\n2003/7/25\n2005/12/27"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-1",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-1",
    "title": "Rosalind Armory 문제풀이",
    "section": "2.2 Sample Output",
    "text": "2.2 Sample Output\n7"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-1",
    "href": "posts/qmd/Rosalind_armory.html#solution-1",
    "title": "Rosalind Armory 문제풀이",
    "section": "2.3 Solution",
    "text": "2.3 Solution\nfrom Bio import Entrez\n\ndef get_nucleotide_genbank_entries(genus_name, start_date, end_date):\n    \"\"\"\n    Retrieve the count of Nucleotide GenBank entries for a given genus and date range.\n    \n    Args:\n    genus_name (str): The name of the genus to search for.\n    start_date (str): The start date of the publication range (format: YYYY/MM/DD).\n    end_date (str): The end date of the publication range (format: YYYY/MM/DD).\n    \n    Returns:\n    int: The count of entries found.\n    \"\"\"\n    Entrez.email = \"byterube@gmail.com\"  # Replace with your email\n    \n    query = f'\"{genus_name}\"[Organism] AND (\"{start_date}\"[Publication Date] : \"{end_date}\"[Publication Date])'\n    \n    try:\n        with Entrez.esearch(db=\"nucleotide\", term=query) as handle:\n            record = Entrez.read(handle)\n            return int(record[\"Count\"])\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return 0\n\n# Sample input data\nsample_input = \"\"\"\nAnthoxanthum\n2003/7/25\n2005/12/27\n\"\"\".strip().split(\"\\n\")\n\n# Extracting input values\ngenus_name = sample_input[0]\nstart_date = sample_input[1]\nend_date = sample_input[2]\n\n# Get the count of GenBank entries\ncount = get_nucleotide_genbank_entries(genus_name, start_date, end_date)\n\n# Print the result\nprint(count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-2",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-2",
    "title": "Rosalind Armory 문제풀이",
    "section": "3.1 Sample Dataset",
    "text": "3.1 Sample Dataset\nFJ817486 JX069768 JX469983"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-2",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-2",
    "title": "Rosalind Armory 문제풀이",
    "section": "3.2 Sample Output",
    "text": "3.2 Sample Output\n&gt;JX469983.1 Zea mays subsp. mays clone UT3343 G2-like transcription factor mRNA, partial cds\nATGATGTATCATGCGAAGAATTTTTCTGTGCCCTTTGCTCCGCAGAGGGCACAGGATAATGAGCATGCAA\nGTAATATTGGAGGTATTGGTGGACCCAACATAAGCAACCCTGCTAATCCTGTAGGAAGTGGGAAACAACG\nGCTACGGTGGACATCGGATCTTCATAATCGCTTTGTGGATGCCATCGCCCAGCTTGGTGGACCAGACAGA\nGCTACACCTAAAGGGGTTCTCACTGTGATGGGTGTACCAGGGATCACAATTTATCATGTGAAGAGCCATC\nTGCAGAAGTATCGCCTTGCAAAGTATATACCCGACTCTCCTGCTGAAGGTTCCAAGGACGAAAAGAAAGA\nTTCGAGTGATTCCCTCTCGAACACGGATTCGGCACCAGGATTGCAAATCAATGAGGCACTAAAGATGCAA\nATGGAGGTTCAGAAGCGACTACATGAGCAACTCGAGGTTCAAAGACAACTGCAACTAAGAATTGAAGCAC\nAAGGAAGATACTTGCAGATGATCATTGAGGAGCAACAAAAGCTTGGTGGATCAATTAAGGCTTCTGAGGA\nTCAGAAGCTTTCTGATTCACCTCCAAGCTTAGATGACTACCCAGAGAGCATGCAACCTTCTCCCAAGAAA\nCCAAGGATAGACGCATTATCACCAGATTCAGAGCGCGATACAACACAACCTGAATTCGAATCCCATTTGA\nTCGGTCCGTGGGATCACGGCATTGCATTCCCAGTGGAGGAGTTCAAAGCAGGCCCTGCTATGAGCAAGTC\nA"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-2",
    "href": "posts/qmd/Rosalind_armory.html#solution-2",
    "title": "Rosalind Armory 문제풀이",
    "section": "3.3 Solution",
    "text": "3.3 Solution\nfrom Bio import Entrez, SeqIO\nfrom typing import List\n\ndef get_shortest_sequence(entry_ids: List[str]) -&gt; None:\n    \"\"\"\n    Fetch nucleotide sequences for given entry IDs and print the shortest one in FASTA format.\n\n    Args:\n    entry_ids (List[str]): A list of GenBank entry IDs.\n\n    Raises:\n    Exception: If there's an error fetching or parsing the sequences.\n    \"\"\"\n    Entrez.email = \"byterube@gmail.com\"  # Replace with your email\n\n    try:\n        # Fetch sequences\n        with Entrez.efetch(db=\"nucleotide\", id=entry_ids, rettype=\"fasta\", retmode=\"text\") as handle:\n            records = list(SeqIO.parse(handle, \"fasta\"))\n\n        if not records:\n            print(\"No sequences found for the given entry IDs.\")\n            return\n\n        # Find and print the shortest sequence\n        shortest_record = min(records, key=lambda record: len(record.seq))\n        print(shortest_record.format(\"fasta\"))\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Sample input data\nsample_input = \"\"\"\nFJ817486 JX069768 JX469983\n\"\"\"\nentry_ids = sample_input.split()\n\n# Get and print the shortest sequence\nget_shortest_sequence(entry_ids)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-3",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-3",
    "title": "Rosalind Armory 문제풀이",
    "section": "4.1 Sample Dataset",
    "text": "4.1 Sample Dataset\n&gt;Rosalind_7142\nPFTADSMDTSNMAQCRVEDLWWCWIPVHKNPHSFLKTWSPAAGHRGWQFDHNFFVYMMGQ\nFYMTKYNHGYAPARRKRFMCQTFFILTFMHFCFRRAHSMVEWCPLTTVSQFDCTPCAIFE\nWGFMMEFPCFRKQMHHQSYPPQNGLMNFNMTISWYQMKRQHICHMWAEVGILPVPMPFNM\nSYQIWEKGMSMGCENNQKDNEVMIMCWTSDIKKDGPEIWWMYNLPHYLTATRIGLRLALY\n&gt;Rosalind_4494\nVPHRVNREGFPVLDNTFHEQEHWWKEMHVYLDALCHCPEYLDGEKVYFNLYKQQISCERY\nPIDHPSQEIGFGGKQHFTRTEFHTFKADWTWFWCEPTMQAQEIKIFDEQGTSKLRYWADF\nQRMCEVPSGGCVGFEDSQYYENQWQREEYQCGRIKSFNKQYEHDLWWCWIPVHKKPHSFL\nKTWSPAAGHRGWQFDHNFFSTKCSCIMSNCCQPPQQCGQYLTSVCWCCPEYEYVTKREEM\n&gt;Rosalind_3636\nETCYVSQLAYCRGPLLMNDGGYGPLLMNDGGYTISWYQAEEAFPLRWIFMMFWIDGHSCF\nNKESPMLVTQHALRGNFWDMDTCFMPNTLNQLPVRIVEFAKELIKKEFCMNWICAPDPMA\nGNSQFIHCKNCFHNCFRQVGMDLWWCWIPVHKNPHSFLKTWSPAAGHRGWQFDHNFFQMM\nGHQDWGTQTFSCMHWVGWMGWVDCNYDARAHPEFYTIREYADITWYSDTSSNFRGRIGQN"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-3",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-3",
    "title": "Rosalind Armory 문제풀이",
    "section": "4.2 Sample Output",
    "text": "4.2 Sample Output\nDLWWCWIPVHK[NK]PHSFLKTWSPAAGHRGWQFDHNFF"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-3",
    "href": "posts/qmd/Rosalind_armory.html#solution-3",
    "title": "Rosalind Armory 문제풀이",
    "section": "4.3 Solution",
    "text": "4.3 Solution\ninstall MM"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-4",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-4",
    "title": "Rosalind Armory 문제풀이",
    "section": "5.1 Sample Dataset",
    "text": "5.1 Sample Dataset\nJX205496.1 JX469991.1"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-4",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-4",
    "title": "Rosalind Armory 문제풀이",
    "section": "5.2 Sample Output",
    "text": "5.2 Sample Output\n257"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-4",
    "href": "posts/qmd/Rosalind_armory.html#solution-4",
    "title": "Rosalind Armory 문제풀이",
    "section": "5.3 Solution",
    "text": "5.3 Solution\nfrom Bio import Entrez, SeqIO\nfrom Bio import Align\nfrom Bio.Seq import Seq\nfrom typing import List, Optional\n\ndef fetch_sequences(genbank_ids: List[str]) -&gt; List[Seq]:\n    \"\"\"\n    Fetch sequences from GenBank given a list of IDs.\n    \n    Args:\n    genbank_ids (List[str]): List of GenBank IDs.\n    \n    Returns:\n    List[Seq]: List of Seq objects representing the fetched sequences.\n    \"\"\"\n    Entrez.email = \"byterube@gmail.com\"  # Replace with your email\n    try:\n        with Entrez.efetch(db=\"nucleotide\", id=genbank_ids, rettype=\"fasta\", retmode=\"text\") as handle:\n            return [record.seq for record in SeqIO.parse(handle, \"fasta\")]\n    except Exception as e:\n        print(f\"Error fetching sequences: {e}\")\n        return []\n\ndef align_sequences(seq1: Seq, seq2: Seq) -&gt; Optional[float]:\n    \"\"\"\n    Perform global alignment of two sequences using Bio.Align.PairwiseAligner.\n    \n    Args:\n    seq1 (Seq): First sequence.\n    seq2 (Seq): Second sequence.\n    \n    Returns:\n    Optional[float]: Alignment score, or None if alignment fails.\n    \"\"\"\n    try:\n        aligner = Align.PairwiseAligner()\n        aligner.mode = 'global'\n        aligner.match_score = 5\n        aligner.mismatch_score = -4\n        aligner.open_gap_score = -10\n        aligner.extend_gap_score = -1\n        \n        alignments = aligner.align(seq1, seq2)\n        return alignments.score\n    except Exception as e:\n        print(f\"Error during alignment: {e}\")\n        return None\n\n# Sample input data\nsample_input = \"\"\"\nJX462666.1 NM_001251956.1\n\"\"\"\ngenbank_ids = sample_input.strip().split()\n\n# Fetch sequences\nsequences = fetch_sequences(genbank_ids)\n\n# Perform alignment\nalignment_score = align_sequences(sequences[0], sequences[1])\n\nif alignment_score is not None:\n    print(f\"{alignment_score}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-5",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-5",
    "title": "Rosalind Armory 문제풀이",
    "section": "6.1 Sample Dataset",
    "text": "6.1 Sample Dataset\n@SEQ_ID\nGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n+\n!*((((***+))%%%++)(%%%%)***-+*****))**55CCF&gt;&gt;&gt;&gt;&gt;&gt;CCCCCCC65"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-5",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-5",
    "title": "Rosalind Armory 문제풀이",
    "section": "6.2 Sample Output",
    "text": "6.2 Sample Output\n&gt;SEQ_ID\nGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-5",
    "href": "posts/qmd/Rosalind_armory.html#solution-5",
    "title": "Rosalind Armory 문제풀이",
    "section": "6.3 Solution",
    "text": "6.3 Solution\nfrom Bio import SeqIO\nfrom io import StringIO\n\ndef convert_fastq_to_fasta(fastq_string):\n    \"\"\"\n    Convert a FASTQ string to a FASTA string.\n\n    Args:\n    fastq_string (str): Input FASTQ formatted string.\n\n    Returns:\n    str: FASTA formatted string.\n    \"\"\"\n    # Create file-like objects for input and output\n    fastq_handle = StringIO(fastq_string)\n    fasta_handle = StringIO()\n\n    # Perform the conversion\n    SeqIO.convert(fastq_handle, 'fastq', fasta_handle, 'fasta')\n\n    # Get the FASTA string and reset the StringIO\n    fasta_handle.seek(0)\n    fasta_string = fasta_handle.read()\n\n    return fasta_string\n\n# Sample FASTQ input\nfastq = \"\"\"\n@SEQ_ID\nGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n+\n!*((((***+))%%%++)(%%%%)***-+*****))**55CCF&gt;&gt;&gt;&gt;&gt;&gt;CCCCCCC65\n\"\"\".strip()\n\n# Convert FASTQ to FASTA\nfasta = convert_fastq_to_fasta(fastq)\n\n# Print the resulting FASTA\nprint(fasta)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-6",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-6",
    "title": "Rosalind Armory 문제풀이",
    "section": "7.1 Sample Dataset",
    "text": "7.1 Sample Dataset\n28\n@Rosalind_0041\nGGCCGGTCTATTTACGTTCTCACCCGACGTGACGTACGGTCC\n+\n6.3536354;&lt;211/0?::6/-2051)-*\"40/.,+%)\n@Rosalind_0041\nTCGTATGCGTAGCACTTGGTACAGGAAGTGAACATCCAGGAT\n+\nAH@FGGGJ&lt;GB&lt;&lt;9:GD=D@GG9=?A@DC=;:?&gt;839/4856\n@Rosalind_0041\nATTCGGTAATTGGCGTGAATCTGTTCTGACTGATAGAGACAA\n+\n@DJEJEA?JHJ@8?F?IA3=;8@C95=;=?;&gt;D/:;74792."
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-6",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-6",
    "title": "Rosalind Armory 문제풀이",
    "section": "7.2 Sample Output",
    "text": "7.2 Sample Output\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-6",
    "href": "posts/qmd/Rosalind_armory.html#solution-6",
    "title": "Rosalind Armory 문제풀이",
    "section": "7.3 Solution",
    "text": "7.3 Solution\nfrom Bio import SeqIO\nfrom io import StringIO\n\ndef phre(data):\n    count = 0\n    # Convert the string input to a file-like object\n    with StringIO(data) as f:\n        threshold = int(f.readline().strip())\n        # Parse the FASTQ data from the string\n        for record in SeqIO.parse(f, \"fastq\"):\n            quality = record.letter_annotations[\"phred_quality\"]\n            average_quality = sum(quality) / len(quality)\n            if average_quality &lt; threshold:\n                count += 1\n    return count\n\n# Sample input data\nsample_input = \"\"\"\n28\n@Rosalind_0041\nGGCCGGTCTATTTACGTTCTCACCCGACGTGACGTACGGTCC\n+\n6.3536354;&lt;211/0?::6/-2051)-*\"40/.,+%)\n@Rosalind_0041\nTCGTATGCGTAGCACTTGGTACAGGAAGTGAACATCCAGGAT\n+\nAH@FGGGJ&lt;GB&lt;&lt;9:GD=D@GG9=?A@DC=;:?&gt;839/4856\n@Rosalind_0041\nATTCGGTAATTGGCGTGAATCTGTTCTGACTGATAGAGACAA\n+\n@DJEJEA?JHJ@8?F?IA3=;8@C95=;=?;&gt;D/:;74792.\n\"\"\".strip()\n\nresult = phre(sample_input)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-7",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-7",
    "title": "Rosalind Armory 문제풀이",
    "section": "8.1 Sample Dataset",
    "text": "8.1 Sample Dataset\nATGGCCATGGCGCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA\nMAMAPRTEINSTRING"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-7",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-7",
    "title": "Rosalind Armory 문제풀이",
    "section": "8.2 Sample Output",
    "text": "8.2 Sample Output\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-7",
    "href": "posts/qmd/Rosalind_armory.html#solution-7",
    "title": "Rosalind Armory 문제풀이",
    "section": "8.3 Solution",
    "text": "8.3 Solution\nfrom Bio.Seq import translate\n\ndef find_genetic_code(dna, protein):\n    # List of genetic code table IDs to check\n    table_ids = [1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15,]\n    \n    for table in table_ids:\n        try:\n            # Translate DNA using the current table\n            translated = translate(dna, table=table, to_stop=True)\n            \n            # Check if the translated protein matches the given protein\n            if translated == protein:\n                return table\n        except:\n            # If there's an error with a particular table, skip it\n            continue\n    \n    # If no matching table is found\n    return None\n\n# Read input\nsample_input = \"\"\"\nATGGCCATGGCGCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA\nMAMAPRTEINSTRING\n\"\"\".strip().split(\"\\n\")\n\ndna = sample_input[0]\nprotein = sample_input[1]\n\n# Find the genetic code\nresult = find_genetic_code(dna, protein)\n\n# Print the result\nif result:\n    print(result)\nelse:\n    print(\"No matching genetic code found.\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-8",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-8",
    "title": "Rosalind Armory 문제풀이",
    "section": "9.1 Sample Dataset",
    "text": "9.1 Sample Dataset\n20 90\n@Rosalind_0049_1\nGCAGAGACCAGTAGATGTGTTTGCGGACGGTCGGGCTCCATGTGACACAG\n+\nFD@@;C&lt;AI?4BA:=&gt;C&lt;G=:AE=&gt;&lt;A??&gt;764A8B797@A:58:527+,\n@Rosalind_0049_2\nAATGGGGGGGGGAGACAAAATACGGCTAAGGCAGGGGTCCTTGATGTCAT\n+\n1&lt;&lt;65:793967&lt;4:92568-34:.&gt;1;2752)24')*15;1,*3+*!\n@Rosalind_0049_3\nACCCCATACGGCGAGCGTCAGCATCTGATATCCTCTTTCAATCCTAGCTA\n+\nB:EI&gt;JDB5=&gt;DA?E6B@@CA?C;=;@@C:6D:3=@49;@87;::;;?8+"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-8",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-8",
    "title": "Rosalind Armory 문제풀이",
    "section": "9.2 Sample Output",
    "text": "9.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-8",
    "href": "posts/qmd/Rosalind_armory.html#solution-8",
    "title": "Rosalind Armory 문제풀이",
    "section": "9.3 Solution",
    "text": "9.3 Solution\nfrom Bio import SeqIO\nfrom Bio.SeqRecord import SeqRecord\nfrom Bio.Seq import Seq\n\ndef quality_filtration(data):\n    # Read the threshold and percentage from the first line\n    t, p = map(int, data[0].strip().split())\n    \n    count = 0\n    # Process the FASTQ data\n    for i in range(1, len(data), 4):\n        sequence = data[i+1].strip()\n        quality_string = data[i+3].strip()\n        \n        # Convert quality string to Phred scores\n        phred_quality = [ord(char) - 33 for char in quality_string]\n        \n        # Perform quality check\n        passes = sum(ph &gt;= t for ph in phred_quality)\n        if (passes / len(phred_quality)) * 100 &gt;= p:\n            count += 1\n\n    return count\n\n# Sample input\nsample_input = \"\"\"\n20 90\n@Rosalind_0049_1\nGCAGAGACCAGTAGATGTGTTTGCGGACGGTCGGGCTCCATGTGACACAG\n+\nFD@@;C&lt;AI?4BA:=&gt;C&lt;G=:AE=&gt;&lt;A??&gt;764A8B797@A:58:527+,\n@Rosalind_0049_2\nAATGGGGGGGGGAGACAAAATACGGCTAAGGCAGGGGTCCTTGATGTCAT\n+\n1&lt;&lt;65:793967&lt;4:92568-34:.&gt;1;2752)24')*15;1,*3+*!\n@Rosalind_0049_3\nACCCCATACGGCGAGCGTCAGCATCTGATATCCTCTTTCAATCCTAGCTA\n+\nB:EI&gt;JDB5=&gt;DA?E6B@@CA?C;=;@@C:6D:3=@49;@87;::;;?8+\n\"\"\".strip().split(\"\\n\")\n\n# Call the function with the sample input\ncount = quality_filtration(sample_input)\nprint(count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-9",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-9",
    "title": "Rosalind Armory 문제풀이",
    "section": "10.1 Sample Dataset",
    "text": "10.1 Sample Dataset\n&gt;Rosalind_64\nATAT\n&gt;Rosalind_48\nGCATA"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-9",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-9",
    "title": "Rosalind Armory 문제풀이",
    "section": "10.2 Sample Output",
    "text": "10.2 Sample Output\n1"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-9",
    "href": "posts/qmd/Rosalind_armory.html#solution-9",
    "title": "Rosalind Armory 문제풀이",
    "section": "10.3 Solution",
    "text": "10.3 Solution\nfrom Bio import SeqIO\nfrom Bio.Seq import Seq\nfrom io import StringIO\n\ndef is_palindrome(seq):\n    \"\"\"Check if a sequence is equal to its reverse complement.\"\"\"\n    my_seq = Seq(seq)\n    reverse_seq = my_seq.reverse_complement()\n    return my_seq == reverse_seq\n\ndef count_palindromic_sequences(seqs):\n    \"\"\"Count the number of palindromic sequences in the list.\"\"\"\n    return sum(is_palindrome(seq) for seq in seqs)\n\ndef parse_fasta_input(fasta_input):\n    \"\"\"Parse FASTA formatted input and return a list of sequences.\"\"\"\n    fasta_io = StringIO(fasta_input)\n    return [str(record.seq) for record in SeqIO.parse(fasta_io, \"fasta\")]\n\n# Sample input\nsample_input = \"\"\"\n&gt;Rosalind_64\nATAT\n&gt;Rosalind_48\nGCATA\n\"\"\"\n\n# Parse the sequences\nsequences = parse_fasta_input(sample_input)\n\n# Count palindromic sequences\npalindrome_count = count_palindromic_sequences(sequences)\n\n# Print the result\nprint(palindrome_count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-10",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-10",
    "title": "Rosalind Armory 문제풀이",
    "section": "11.1 Sample Dataset",
    "text": "11.1 Sample Dataset\n26\n@Rosalind_0029\nGCCCCAGGGAACCCTCCGACCGAGGATCGT\n+\n&gt;?F?@6&lt;C&lt;HF?&lt;85486B;85:8488/2/\n@Rosalind_0029\nTGTGATGGCTCTCTGAATGGTTCAGGCAGT\n+\n@J@H@&gt;B9:B;&lt;D==:&lt;;:,&lt;::?463-,,\n@Rosalind_0029\nCACTCTTACTCCCTAGCCGAACTCCTTTTT\n+\n=88;99637@5,4664-65)/?4-2+)$)$\n@Rosalind_0029\nGATTATGATATCAGTTGGCTCCGAGAGCGT\n+\n&lt;@BGE@8C9=B9:B&lt;&gt;&gt;&gt;7?B&gt;7:02+33."
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-10",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-10",
    "title": "Rosalind Armory 문제풀이",
    "section": "11.2 Sample Output",
    "text": "11.2 Sample Output\n17"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-10",
    "href": "posts/qmd/Rosalind_armory.html#solution-10",
    "title": "Rosalind Armory 문제풀이",
    "section": "11.3 Solution",
    "text": "11.3 Solution\nfrom Bio import SeqIO\nfrom io import StringIO\n\ndef parse_threshold_and_fastq(data):\n    \"\"\"Parse the threshold and FASTQ data from the input string.\"\"\"\n    lines = data.strip().split('\\n')\n    threshold = int(lines[0])\n    fastq_data = '\\n'.join(lines[1:])\n    return threshold, fastq_data\n\ndef extract_quality_scores(fastq_data):\n    \"\"\"Extract quality scores from FASTQ data.\"\"\"\n    fastq_io = StringIO(fastq_data)\n    return [record.letter_annotations[\"phred_quality\"] \n            for record in SeqIO.parse(fastq_io, \"fastq\")]\n\ndef count_below_threshold(qualities, threshold):\n    \"\"\"Count positions where the average quality score is below the threshold.\"\"\"\n    num_sequences = len(qualities)\n    num_positions = len(qualities[0])\n    count = 0\n    \n    for i in range(num_positions):\n        average_quality = sum(q[i] for q in qualities) / num_sequences\n        if average_quality &lt; threshold:\n            count += 1\n    \n    return count\n\ndef bphr(data):\n    \"\"\"Calculate the number of positions with average quality below the threshold.\"\"\"\n    threshold, fastq_data = parse_threshold_and_fastq(data)\n    qualities = extract_quality_scores(fastq_data)\n    return count_below_threshold(qualities, threshold)\n\n# Sample input\nsample_input = \"\"\"\n26\n@Rosalind_0029\nGCCCCAGGGAACCCTCCGACCGAGGATCGT\n+\n&gt;?F?@6&lt;C&lt;HF?&lt;85486B;85:8488/2/\n@Rosalind_0029\nTGTGATGGCTCTCTGAATGGTTCAGGCAGT\n+\n@J@H@&gt;B9:B;&lt;D==:&lt;;:,&lt;::?463-,,\n@Rosalind_0029\nCACTCTTACTCCCTAGCCGAACTCCTTTTT\n+\n=88;99637@5,4664-65)/?4-2+)$)$\n@Rosalind_0029\nGATTATGATATCAGTTGGCTCCGAGAGCGT\n+\n&lt;@BGE@8C9=B9:B&lt;&gt;&gt;&gt;7?B&gt;7:02+33.\n\"\"\"\n\ncount = bphr(sample_input)\nprint(count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-11",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-11",
    "title": "Rosalind Armory 문제풀이",
    "section": "12.1 Sample Dataset",
    "text": "12.1 Sample Dataset\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-11",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-11",
    "title": "Rosalind Armory 문제풀이",
    "section": "12.2 Sample Output",
    "text": "12.2 Sample Output\nMLLGSFRLIPKETLIQVAGSSPCNLS"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-11",
    "href": "posts/qmd/Rosalind_armory.html#solution-11",
    "title": "Rosalind Armory 문제풀이",
    "section": "12.3 Solution",
    "text": "12.3 Solution\nfrom Bio.Seq import Seq\n\ndef gene_ORFs(dna_sequence):\n    \"\"\"Finds and prints the longest open reading frame (ORF) from a DNA sequence.\"\"\"\n    def translate_sequence(seq):\n        \"\"\"Translate a sequence in all three reading frames and split by stop codons.\"\"\"\n        return [str(seq[i:].translate(to_stop=False)).split(\"*\") for i in range(3)]\n\n    # Create a Seq object from the DNA sequence\n    seq = Seq(dna_sequence)\n    seq_reverse = seq.reverse_complement()\n\n    # Translate the sequence and its reverse complement in all reading frames\n    proteins = []\n    proteins.extend(translate_sequence(seq))\n    proteins.extend(translate_sequence(seq_reverse))\n\n    # Flatten the list of lists\n    proteins = [protein for sublist in proteins for protein in sublist]\n\n    # Find ORFs starting with 'M' and sort by length\n    orfs = sorted([protein[protein.find(\"M\"):] for protein in proteins if \"M\" in protein], key=len, reverse=True)\n    return orfs\n\n# Sample input\nsample_input = \"\"\"\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG\n\"\"\"\n\n# Strip any leading/trailing whitespace\ndna = sample_input.strip()\n\n# Find and print the longest ORF\norfs = gene_ORFs(dna)\nprint(orfs[0])"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-12",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-12",
    "title": "Rosalind Armory 문제풀이",
    "section": "13.1 Sample Dataset",
    "text": "13.1 Sample Dataset\n20\n@Rosalind_0049\nGCAGAGACCAGTAGATGTGTTTGCGGACGGTCGGGCTCCATGTGACACAG\n+\nFD@@;C&lt;AI?4BA:=&gt;C&lt;G=:AE=&gt;&lt;A??&gt;764A8B797@A:58:527+,\n@Rosalind_0049\nAATGGGGGGGGGAGACAAAATACGGCTAAGGCAGGGGTCCTTGATGTCAT\n+\n1&lt;&lt;65:793967&lt;4:92568-34:.&gt;1;2752)24')*15;1,*3+*!\n@Rosalind_0049\nACCCCATACGGCGAGCGTCAGCATCTGATATCCTCTTTCAATCCTAGCTA\n+\nB:EI&gt;JDB5=&gt;DA?E6B@@CA?C;=;@@C:6D:3=@49;@87;::;;?8+"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-12",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-12",
    "title": "Rosalind Armory 문제풀이",
    "section": "13.2 Sample Output",
    "text": "13.2 Sample Output\n@Rosalind_0049\nGCAGAGACCAGTAGATGTGTTTGCGGACGGTCGGGCTCCATGTGACAC\n+\nFD@@;C&lt;AI?4BA:=&gt;C&lt;G=:AE=&gt;&lt;A??&gt;764A8B797@A:58:527\n@Rosalind_0049\nATGGGGGGGGGAGACAAAATACGGCTAAGGCAGGGGTCCT\n+\n&lt;&lt;65:793967&lt;4:92568-34:.&gt;1;2752)24')*15;\n@Rosalind_0049\nACCCCATACGGCGAGCGTCAGCATCTGATATCCTCTTTCAATCCTAGCT\n+\nB:EI&gt;JDB5=&gt;DA?E6B@@CA?C;=;@@C:6D:3=@49;@87;::;;?8"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-12",
    "href": "posts/qmd/Rosalind_armory.html#solution-12",
    "title": "Rosalind Armory 문제풀이",
    "section": "13.3 Solution",
    "text": "13.3 Solution\ndef convert_to_phred(quality_string):\n    \"\"\"Convert a quality string to Phred scores.\"\"\"\n    return [ord(char) - 33 for char in quality_string]\n\ndef find_quality_bounds(phred_quality, threshold):\n    \"\"\"Find the start and end indices where quality is &gt;= threshold.\"\"\"\n    start = 0\n    while start &lt; len(phred_quality) and phred_quality[start] &lt; threshold:\n        start += 1\n    \n    end = len(phred_quality)\n    while end &gt; start and phred_quality[end-1] &lt; threshold:\n        end -= 1\n    \n    return start, end\n\ndef format_fastq_record(identifier, sequence, quality_string, start, end):\n    \"\"\"Format a FASTQ record with the given bounds.\"\"\"\n    return f\"@{identifier}\\n{sequence[start:end]}\\n+\\n{quality_string[start:end]}\"\n\ndef Base_Filtration_Quality(data):\n    \"\"\"Process FASTQ data and filter based on quality threshold.\"\"\"\n    threshold = int(data[0])\n    filtered_records = []\n\n    for i in range(1, len(data), 4):\n        identifier = data[i].strip()\n        sequence = data[i+1].strip()\n        quality_string = data[i+3].strip()\n        \n        phred_quality = convert_to_phred(quality_string)\n        start, end = find_quality_bounds(phred_quality, threshold)\n        \n        if start &lt; end:\n            filtered_record = format_fastq_record(identifier, sequence, quality_string, start, end)\n            filtered_records.append(filtered_record)\n    \n    return filtered_records\n\n# Sample input\nsample_input = \"\"\"\n20\n@Rosalind_0049\nGCAGAGACCAGTAGATGTGTTTGCGGACGGTCGGGCTCCATGTGACACAG\n+\nFD@@;C&lt;AI?4BA:=&gt;C&lt;G=:AE=&gt;&lt;A??&gt;764A8B797@A:58:527+,\n@Rosalind_0050\nAATGGGGGGGGGAGACAAAATACGGCTAAGGCAGGGGTCCTTGATGTCAT\n+\n1&lt;&lt;65:793967&lt;4:92568-34:.&gt;1;2752)24')*15;1,*3+*!\n@Rosalind_0051\nACCCCATACGGCGAGCGTCAGCATCTGATATCCTCTTTCAATCCTAGCTA\n+\nB:EI&gt;JDB5=&gt;DA?E6B@@CA?C;=;@@C:6D:3=@49;@87;::;;?8+\n\"\"\".strip().split(\"\\n\")\n\n# Process the input and print the results\nfiltered_records = Base_Filtration_Quality(sample_input)\nfor record in filtered_records:\n    print(record)"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-13",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-13",
    "title": "Rosalind Armory 문제풀이",
    "section": "14.1 Sample Dataset",
    "text": "14.1 Sample Dataset\n&gt;Rosalind_12\nGACTCCTTTGTTTGCCTTAAATAGATACATATTTACTCTTGACTCTTTTGTTGGCCTTAAATAGATACATATTTGTGCGACTCCACGAGTGATTCGTA\n&gt;Rosalind_37\nATGGACTCCTTTGTTTGCCTTAAATAGATACATATTCAACAAGTGTGCACTTAGCCTTGCCGACTCCTTTGTTTGCCTTAAATAGATACATATTTG"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-13",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-13",
    "title": "Rosalind Armory 문제풀이",
    "section": "14.2 Sample Output",
    "text": "14.2 Sample Output\n2 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-13",
    "href": "posts/qmd/Rosalind_armory.html#solution-13",
    "title": "Rosalind Armory 문제풀이",
    "section": "14.3 Solution",
    "text": "14.3 Solution\nfrom Bio import SeqIO\nfrom io import StringIO\n\ndef hamming_distance(s1, s2):\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\ndef count_inexact_repeats(pattern, seq, max_mismatches=3):\n    count = 0\n    pattern_length = len(pattern)\n    seq_length = len(seq)\n    \n    for i in range(seq_length - pattern_length + 1):\n        if hamming_distance(seq[i:i+pattern_length], pattern) &lt;= max_mismatches:\n            count += 1\n    \n    return count\n\n# Your sample input\nsample_input = \"\"\"\n&gt;Rosalind_12\nGACTCCTTTGTTTGCCTTAAATAGATACATATTTACTCTTGACTCTTTTGTTGGCCTTAAATAGATACATATTTGTGCGACTCCACGAGTGATTCGTA\n&gt;Rosalind_37\nATGGACTCCTTTGTTTGCCTTAAATAGATACATATTCAACAAGTGTGCACTTAGCCTTGCCGACTCCTTTGTTTGCCTTAAATAGATACATATTTG\n\"\"\"\n\n# Parse the FASTA data\nfasta_io = StringIO(sample_input.strip())\nsequences = list(SeqIO.parse(fasta_io, \"fasta\"))\n\n# Extract the sequences as strings\ns = str(sequences[0].seq)\nt = str(sequences[1].seq)\n\n# Find the shared inexact repeat\n# We'll use a simple approach: try all substrings of length 32-40 from s as potential repeats\nbest_repeat = \"\"\nbest_count = 0\n\nfor length in range(32, 41):\n    for i in range(len(s) - length + 1):\n        potential_repeat = s[i:i+length]\n        count_s = count_inexact_repeats(potential_repeat, s)\n        count_t = count_inexact_repeats(potential_repeat, t)\n        total_count = count_s + count_t\n        \n        if total_count &gt; best_count:\n            best_count = total_count\n            best_repeat = potential_repeat\n\n# Count the occurrences of the best repeat in both sequences\ncount_s = count_inexact_repeats(best_repeat, s)\ncount_t = count_inexact_repeats(best_repeat, t)\n\nprint(f\"{count_s} {count_t}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-dataset-14",
    "href": "posts/qmd/Rosalind_armory.html#sample-dataset-14",
    "title": "Rosalind Armory 문제풀이",
    "section": "15.1 Sample Dataset",
    "text": "15.1 Sample Dataset\n&gt;Rosalind_18\nGACATGTTTGTTTGCCTTAAACTCGTGGCGGCCTAGCCGTAAGTTAAG\n&gt;Rosalind_23\nACTCATGTTTGTTTGCCTTAAACTCTTGGCGGCTTAGCCGTAACTTAAG\n&gt;Rosalind_51\nTCCTATGTTTGTTTGCCTCAAACTCTTGGCGGCCTAGCCGTAAGGTAAG\n&gt;Rosalind_7\nCACGTCTGTTCGCCTAAAACTTTGATTGCCGGCCTACGCTAGTTAGTTA\n&gt;Rosalind_28\nGGGGTCATGGCTGTTTGCCTTAAACCCTTGGCGGCCTAGCCGTAATGTTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#sample-output-14",
    "href": "posts/qmd/Rosalind_armory.html#sample-output-14",
    "title": "Rosalind Armory 문제풀이",
    "section": "15.2 Sample Output",
    "text": "15.2 Sample Output\nRosalind_7"
  },
  {
    "objectID": "posts/qmd/Rosalind_armory.html#solution-14",
    "href": "posts/qmd/Rosalind_armory.html#solution-14",
    "title": "Rosalind Armory 문제풀이",
    "section": "15.3 Solution",
    "text": "15.3 Solution\nfrom Bio import SeqIO\nfrom io import StringIO\n\ndef simple_msa(sequences):\n    # Find the length of the longest sequence\n    max_length = max(len(seq) for seq in sequences)\n    \n    # Pad shorter sequences with gaps\n    aligned_sequences = [seq.ljust(max_length, '-') for seq in sequences]\n    \n    return aligned_sequences\n\ndef calculate_differences(seq1, seq2):\n    return sum(a != b for a, b in zip(seq1, seq2))\n\ndef find_most_different_sequence(fasta_string):\n    # Parse the FASTA string\n    fasta_io = StringIO(fasta_string)\n    sequences = list(SeqIO.parse(fasta_io, \"fasta\"))\n    \n    # Perform a simple multiple sequence alignment\n    aligned_seqs = simple_msa([str(seq.seq) for seq in sequences])\n    \n    n_seqs = len(aligned_seqs)\n    avg_distances = []\n\n    for i in range(n_seqs):\n        total_distance = sum(calculate_differences(aligned_seqs[i], aligned_seqs[j]) \n                             for j in range(n_seqs) if i != j)\n        avg_distances.append(total_distance / (n_seqs - 1))\n\n    most_different_index = avg_distances.index(max(avg_distances))\n    return sequences[most_different_index].id\n\n# Your sample dataset\nsample_data = \"\"\"\n&gt;Rosalind_18\nGACATGTTTGTTTGCCTTAAACTCGTGGCGGCCTAGCCGTAAGTTAAG\n&gt;Rosalind_23\nACTCATGTTTGTTTGCCTTAAACTCTTGGCGGCTTAGCCGTAACTTAAG\n&gt;Rosalind_51\nTCCTATGTTTGTTTGCCTCAAACTCTTGGCGGCCTAGCCGTAAGGTAAG\n&gt;Rosalind_7\nCACGTCTGTTCGCCTAAAACTTTGATTGCCGGCCTACGCTAGTTAGTTA\n&gt;Rosalind_28\nGGGGTCATGGCTGTTTGCCTTAAACCCTTGGCGGCCTAGCCGTAATGTTT\n\"\"\"\n\nresult = find_most_different_sequence(sample_data)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/setup_flox.html",
    "href": "posts/qmd/setup_flox.html",
    "title": "Flox 시작하기",
    "section": "",
    "text": "Flox는 Nix를 기반으로 개발 환경을 만들고 관리하는 도구입니다. Nix는 강력한 도구지만, 진입 장벽이 높아 사용하기 어렵다는 평가를 받기도 합니다. Flox는 이러한 Nix의 복잡성을 해결하여, 누구나 쉽게 개발 환경을 구성하고 공유할 수 있도록 돕습니다. Flox를 사용하면 프로젝트별로 필요한 패키지를 격리하여 관리할 수 있어 개발 편의성이 크게 향상됩니다. 이 글에서는 Flox를 처음 사용하는 개발자를 위한 기본 사용법을 안내합니다."
  },
  {
    "objectID": "posts/qmd/setup_flox.html#설치",
    "href": "posts/qmd/setup_flox.html#설치",
    "title": "Flox 시작하기",
    "section": "1.1 설치",
    "text": "1.1 설치\nFlox 공식 웹사이트에서 OS별 설치 방법을 안내합니다. Homebrew를 사용한다면 아래 명령어를 실행하세요.\nbrew install flox"
  },
  {
    "objectID": "posts/qmd/setup_flox.html#삭제",
    "href": "posts/qmd/setup_flox.html#삭제",
    "title": "Flox 시작하기",
    "section": "1.2 삭제",
    "text": "1.2 삭제\n시스템에서 Flox를 완전히 제거하려면 다음 절차를 따르세요. 진행하기 전에 중요한 Nix 관련 파일과 패키지를 백업해두는 것을 권장합니다. Flox 제거 후에는 시스템을 재부팅하는 것이 좋습니다.\nbrew uninstall flox\n사용자 환경 설정을 포함한 모든 Flox 관련 데이터를 완전히 삭제하려면 다음 명령어를 사용하세요.\nbrew uninstall --force --zap flox"
  },
  {
    "objectID": "posts/qmd/setup_flox.html#기초-사용법",
    "href": "posts/qmd/setup_flox.html#기초-사용법",
    "title": "Flox 시작하기",
    "section": "2.1 기초 사용법",
    "text": "2.1 기초 사용법\nFlox를 사용하면 새 프로젝트나 기존 프로젝트에 독립된 개발 환경을 설정할 수 있습니다. Flox 환경은 새로운 셸이나 현재 셸에서 활성화할 수 있습니다. Flox 환경의 패키지는 시스템에 설치된 패키지보다 우선적으로 적용되며, 기존 시스템 환경은 전혀 변경되지 않습니다. Flox 환경을 벗어나면 원래의 셸 상태로 돌아갑니다.1\n\n2.1.1 가상환경 만들기\nflox init 명령을 사용하여 example-python-project라는 이름의 프로젝트 환경을 설정해 보겠습니다.\nmkdir example-python-project && cd example-python-project\nflox init\n환경이 생성되면 flox init을 실행한 위치에 .flox 디렉터리와 관련 파일들이 만들어진 것을 확인할 수 있습니다. 이 디렉터리에는 환경에 대한 선언적 구성 정보가 저장되며, 버전 관리에 포함하여 팀원들과 공유할 수 있습니다.\nflox init\n✨ Created environment example-python-project (aarch64-darwin)\n\nNext:\n  $ flox search &lt;package&gt;    &lt;- Search for a package\n  $ flox install &lt;package&gt;   &lt;- Install a package into an environment\n  $ flox activate            &lt;- Enter the environment\n\nflox init으로 만든 가상환경 목록은 flox envs 명령어로 확인할 수 있습니다.\n\n\n\n2.1.2 가상환경 삭제\nflox delete 명령어로 가상 환경과 관련된 모든 데이터를 삭제합니다. 기본적으로 현재 디렉터리의 환경만 삭제하지만, -d 플래그를 사용하면 다른 디렉터리의 환경도 삭제할 수 있습니다. 환경을 삭제하기 전에는 확인 메시지가 표시됩니다.\n\n\n2.1.3 가상환경 활성화\nflox activate 명령으로 환경을 활성화하면 설치한 패키지를 사용할 수 있습니다. 환경이 활성화되면 터미널 프롬프트가 변경된 것을 볼 수 있습니다.\nflox activate\n✅ You are now using the environment 'example-python-project'.\nTo stop using this environment, type 'exit'\nflox [example-python-project] ➜  example-python-project\n\n\n2.1.4 패키지 검색, 표시 및 설치\nFlox는 8만 개 이상의 오픈 소스 패키지를 제공하며, 이 패키지들을 가상 환경에 설치할 수 있습니다. flox search, flox show, flox install 명령어로 패키지를 검색하고 설치하세요. example-project가 파이썬 프로젝트라고 가정하고 flox search로 python을 검색해 보겠습니다.\nflox search python\nflox search python\n\npython     High-level dynamically-typed programming language\ngpython    Python interpreter written in Go\npython2    High-level dynamically-typed programming language\npython3    High-level dynamically-typed programming language\npython27   High-level dynamically-typed programming language\npython36   A high-level dynamically-typed programming language\npython37   A high-level dynamically-typed programming language\npython38   A high-level dynamically-typed programming language\npython39   High-level dynamically-typed programming language\npython-qt  PythonQt is a dynamic Python binding for the Qt framework. It offers an easy way to embed the Python scripting language into your C++ Qt applications\n\nShowing 10 of 21672 results. Use `flox search python --all` to see the full list.\n\nUse 'flox show &lt;package&gt;' to see available versions\n특정 패키지의 상세 정보(사용 가능한 버전 등)를 보려면 flox show를 사용하세요.\n\n여기서는 python3으로 버전을 지정하겠습니다.\n\nflox show python3\nflox show python3\npython3 - High-level dynamically-typed programming language\n    python3@3.13.6\n    python3@3.13.5\n    python3@3.13.4\n    ...\n    python3@3.9.9\n    python3@3.9.6\n    python3@3.9.5\n    python3@3.8.9\n원하는 패키지를 찾았다면 flox install로 설치할 수 있습니다.\nflox install python3@3.9.9\n✅ 'python3' installed to environment 'example-python-project'\nwhich python 명령어로 설치된 파이썬의 위치를 확인할 수 있습니다.\nwhich python\n~/example-python-project/.flox/run/aarch64-darwin.example-python-project.dev/bin/python\n위 결과를 통해 시스템과 격리된 공간에 파이썬이 설치되었음을 알 수 있습니다.\n\n\n2.1.5 가상환경에 설치된 패키지 확인 및 제거\n설치된 패키지 목록은 flox list 명령어로 확인합니다.\nflox list\npython3: python3 (3.9.9)\n패키지를 제거할 때는 flox uninstall 명령어를 사용합니다.\nflox uninstall python3\n🗑️  'python3' uninstalled from environment 'example-python-project'\n\n\n2.1.6 가상환경 가비지 컬렉션\n가상환경을 여러 개 만들다 보면 불필요한 파일들이 쌓여 저장 공간을 차지할 수 있습니다. flox gc 명령어를 실행하면 Flox가 관리하는 데이터와 Nix 저장소의 불필요한 파일을 정리하여 공간을 확보할 수 있습니다.\n\n\n2.1.7 고급 사용법\n지금까지 알아본 방법 외에 더 세밀한 설정이 필요하다면, flox edit 명령어를 통해 toml 파일을 직접 편집할 수 있습니다. 자세한 내용은 공식 문서를 참고하시기 바랍니다.\n\n\n2.1.8 가상환경 나가기\n활성화된 환경을 종료하려면 exit 명령을 입력하거나 단축키 CTRL + D를 사용하세요."
  },
  {
    "objectID": "posts/qmd/setup_flox.html#가상환경-공유하기",
    "href": "posts/qmd/setup_flox.html#가상환경-공유하기",
    "title": "Flox 시작하기",
    "section": "2.2 가상환경 공유하기",
    "text": "2.2 가상환경 공유하기\nFlox의 가장 큰 장점 중 하나는 다른 사용자와 가상 환경을 매우 쉽게 공유할 수 있다는 점입니다. 공유 방법은 다음 세 가지가 있습니다.\n\n.flox 폴더를 통한 공유: git과 같은 버전 관리 시스템에 등록해 공유합니다.\nFloxHub으로 환경 공유: Flox에서 제공하는 명령어를 통해 공유합니다.\n컨테이너: Flox 환경을 컨테이너 이미지로 만들어 공유합니다.\n\n\n2.2.1 폴더를 통한 공유\nflox init을 실행한 디렉터리에 생성된 .flox 폴더를 공유하면, 다른 사용자는 git clone으로 프로젝트를 복제한 뒤 flox activate 명령만 실행하면 동일한 환경을 구성할 수 있습니다.\n\n환경을 생성한 사용자와 다른 CPU 아키텍처 또는 OS를 사용하는 사용자와 환경을 공유하는 경우, 시스템별 패키지를 사용할 수 없는 문제가 발생할 수 있습니다. 이 문제는 매니페스트 파일을 약간 수정하여 해결할 수 있습니다.\n\n다음은 git을 사용하여 프로젝트를 공유하는 예시입니다. 첫 번째 사용자가 환경을 생성하고 git에 추가합니다.\ngit add .flox\ngit commit -m \"sharing flox environment\"\ngit push\n다른 개발자는 프로젝트를 내려받은 후 flox activate만 실행하면 동일한 버전의 패키지가 자동으로 설치되어 즉시 개발을 시작할 수 있습니다.\n\n\n2.2.2 FloxHub로 공유\nflox push 명령을 사용하면 FloxHub를 통해 환경을 쉽게 공유할 수 있습니다.\nflox push\n✅  example-project successfully pushed to FloxHub\n\n    Use 'flox pull youruser/example-project' to get this environment in any other location.\n다른 사용자는 flox activate -r username/environment 명령어를 사용하여 원격 저장소에 있는 환경을 활성화할 수 있습니다.\n\n\n2.2.3 컨테이너로 공유\nFlox는 현재 환경을 Docker 등에서 사용할 수 있는 OCI 컨테이너 이미지로 만들 수 있습니다. flox containerize를 실행하면 컨테이너 이미지가 생성되며, 이 명령은 이미지를 Docker에 자동으로 로드합니다.\nflox containerize --runtime docker\n...\nCreating layer 1 from paths: [...]\n...\nLoaded image: example-project:latest\n✨ Container written to Docker runtime"
  },
  {
    "objectID": "posts/qmd/setup_flox.html#footnotes",
    "href": "posts/qmd/setup_flox.html#footnotes",
    "title": "Flox 시작하기",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n공식문서↩︎"
  },
  {
    "objectID": "posts/qmd/learn_STAT4Life.html",
    "href": "posts/qmd/learn_STAT4Life.html",
    "title": "일상에 필요한 통계학 개념",
    "section": "",
    "text": "이 글의 목적은 통계의 “철학”을 우리 삶에서 실제로 적용하는 방법을 소개하고 통계가 작동하는 방식을 더 명확하게 설명 하는 것입니다. 글을 읽고 나면 생각보다 실생활에 통계가 많이 사용된 다는 것을 알게 될 것입니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT4Life.html#편향되지-않은-추정",
    "href": "posts/qmd/learn_STAT4Life.html#편향되지-않은-추정",
    "title": "일상에 필요한 통계학 개념",
    "section": "1.1 편향되지 않은 추정",
    "text": "1.1 편향되지 않은 추정\n편향의 정의는 단순히 원래 목표로부터의 벗어남을 의미 합니다. 연구된 매개변수의 기대값(즉, 무한한 수의 학생을 인터뷰할 수 있다면 얻어야 할 값)과 실제(또는 진정한) 매개변수 간의 차이가 0이면 추정량은 편향되지 않은 것으로 간주될 수 있습니다. 하지만 우리의 추정량이 편향되었는지 아닌지를 아는 것은 쉽지 않습니다.\n예를 들어 수업에 출석한 학생에게만 평균 공부 시간을 질문하는 것은 수업에 출석하지 않은 학생은 우리의 질문에 답하지 않을 것이라는 것을 의미합니다. 그리고 수업에 가지 않는 학생들은 시험 공부를 덜 할 가능성이 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT4Life.html#낮은-분산을-가진-추정",
    "href": "posts/qmd/learn_STAT4Life.html#낮은-분산을-가진-추정",
    "title": "일상에 필요한 통계학 개념",
    "section": "1.2 낮은 분산을 가진 추정",
    "text": "1.2 낮은 분산을 가진 추정\n분산은 측정 값의 퍼짐의 정도를 나타냅니다. 다시 말해 표본의 사람들이 평균에서 얼마나 벗어나는 경향이 있는지 알려줍니다. 반대로 분산이 0이라는 것은 모든 사람이 동일한 값을 갖는 것입니다.\n이것은 중요합니다. 왜냐하면 편향되지 않은 추정량이 낮은 분산을 갖는다면 일반화할 수 있다고 확신할 수 있다는 것을 의미하기 때문입니다. 예를 들어 학생이 시험 전에 평균 4시간 동안 공부한다고 추정하고 이 추정이 편향되지 않고 낮은 분산을 갖는다는 것을 증명한다면 진정한 추정량은 4시간 근처일 가능성이 높습니다."
  },
  {
    "objectID": "posts/qmd/learn_STAT4Life.html#추론inferences-예측하기",
    "href": "posts/qmd/learn_STAT4Life.html#추론inferences-예측하기",
    "title": "일상에 필요한 통계학 개념",
    "section": "1.3 추론(Inferences): 예측하기",
    "text": "1.3 추론(Inferences): 예측하기\n모든 추정의 목적은 추론을 하는 것입니다. 앞서 말했듯이 당신은 세상의 모든 정보를 가지고 있지 않고 적은 수의 데이터를 기반으로 일반화할 수 있는지 여부를 알고 싶습니다. 이때 통계학은 일반적으로 p-value을 계산하는 방법을 적용합니다.\n예를 들어 약물이 LDL 콜레스테롤을 낮추는 데 효과적인지 알고 싶다고 가정합니다. 그렇다면 높은 LDL을 가진 사람들에게 그 약물을 투여하고 일주일 후에 높은 LDL을 가지고 있지만 약물을 복용하지 않은 사람들과의 차이를 비교합니다. 약물이 효과가 없다고 가정하면 우리가 얻은 결과(예: 약물을 복용한 사람들은 LDL이 10포인트 감소했고 위약을 복용한 사람들은 4포인트만 감소했습니다)를 얻을 확률을 계산할 수 있습니다.\n만약 이 확률이 매우 낮다면 우리의 초기 가설이 사실이 아닐 수 있다고 추론할 수 있습니다. 즉, 약물이 LDL 콜레스테롤을 낮추는 데 효과적일 수 있다는 것입니다.\n여기서 확률이 낮다는 것은 일반적으로 5%로 사용합니다. \\(10 - 4 = 6\\)의 차이가 발생할 확률이 5% 미만이라면 우리는 결과가 약물이 효과가 없다는 가설(귀무가설)을 받아들일 수 없고 반대로 약물이 효과적이라고 말합니다.\np-value이 5% 미만이라는 것은 실제로는 효과가 없더라도 효과가 있다고 결론(False positive) 내릴 5%의 위험을 가져간다는 것과 같습니다. 거짓 양성과 거짓 음성은 서로 반대로 움직이기 때문에 중간 절충점으로 5%를 사용하는 것입니다. 임상 분야에서는 아픈 사람에게 아무 이상이 없다고 말할 확률(False negative)을 최소화하는 것을 선호하기에 p-value 5%이 적절한지에 대한 큰 이견은 없습니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html",
    "href": "posts/qmd/Rosalind_stronghold.html",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "",
    "text": "생물정보학의 다양한 주제인 질량 분석, 서열 정렬, 동적 프로그래밍, 게놈 어셈블리, 계통 발생, 확률, 문자열 알고리즘 등의 기초가 되는 알고리즘에 대해 알아봅니다.\nRosalind 는 프로젝트 오일러, 구글 코드 잼에서 영감을 얻었습니다. 이 프로젝트의 이름은 DNA 이중나선을 발견하는 데 기여한 로잘린드 프랭클린 에서 따왔습니다. Rosalind 는 프로그래밍 실력을 키우고자 하는 생물학자와 분자생물학의 계산 문제를 접해본 적이 없는 프로그래머들에게 도움이 될 것입니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "1.1 Sample Dataset",
    "text": "1.1 Sample Dataset\nAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "1.2 Sample Output",
    "text": "1.2 Sample Output\n20 12 17 21"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution",
    "href": "posts/qmd/Rosalind_stronghold.html#solution",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "1.3 Solution",
    "text": "1.3 Solution\n주어진 DNA 문자열 ‘s’ 에서 각 뉴클레오티드 (‘A’, ‘C’, ‘G’, ‘T’) 의 발생 횟수를 세는 문제를 해결하려면 다음 단계를 따르세요.\n\n카운터를 초기화합니다: ‘A’, ‘C’, ‘G’, ‘T’ 에 대한 카운터를 설정합니다.\n문자열을 반복합니다: 문자열의 각 문자를 순회하며 해당 카운터를 증가시킵니다.\n결과를 출력합니다: ‘A’, ‘C’, ‘G’, ‘T’ 의 개수를 공백으로 구분하여 인쇄합니다.\n\ndef count_nucleotides(dna_string):\n    count_A = 0\n    count_C = 0\n    count_G = 0\n    count_T = 0\n    \n    for nucleotide in dna_string:\n        if nucleotide == 'A':\n            count_A += 1\n        elif nucleotide == 'C':\n            count_C += 1\n        elif nucleotide == 'G':\n            count_G += 1\n        elif nucleotide == 'T':\n            count_T += 1\n    \n    return count_A, count_C, count_G, count_T\n\n# Sample Dataset\ns = \"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\"\n\nresult = count_nucleotides(s)\nprint(\" \".join(map(str, result)))\n# Output should be \"20 12 17 21\""
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#설명",
    "href": "posts/qmd/Rosalind_stronghold.html#설명",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "1.4 설명",
    "text": "1.4 설명\n\n초기화: ‘A’, ‘C’, ‘G’, ‘T’ 의 카운터가 0 으로 초기화됩니다.\n각 문자를 반복합니다: 루프는 DNA 문자열의 각 문자를 검사하고 발견된 문자에 따라 해당 카운터를 증가시킵니다.\n결과를 반환하고 인쇄합니다: 이 함수는 카운트를 반환한 다음 필요한 형식으로 출력합니다.\n\n이 접근 방식은 각 뉴클레오타이드가 문자열을 한 번 통과할 때 효율적으로 카운트되도록 보장하며, 시간 복잡도는 \\(O(n)\\) 입니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-1",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "2.1 Sample Dataset",
    "text": "2.1 Sample Dataset\nGATGGAACTTGACTACGTAAATT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-1",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "2.2 Sample Output",
    "text": "2.2 Sample Output\nGAUGGAACUUGACUACGUAAAUU"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-1",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "2.3 Solution",
    "text": "2.3 Solution\nTo transcribe a DNA string to an RNA string, we need to replace every occurrence of the nucleotide ‘T’ in the DNA string with ‘U’ to form the RNA string. This is because RNA uses uracil (U) instead of thymine (T).\ndef transcribe_dna_to_rna(dna_string):\n    # Replace all occurrences of 'T' with 'U'\n    rna_string = dna_string.replace('T', 'U')\n    return rna_string\n\n# Sample Dataset\ndna_string = \"GATGGAACTTGACTACGTAAATT\"\nprint(transcribe_dna_to_rna(dna_string))  # Output should be \"GAUGGAACUUGACUACGUAAAUU\""
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "2.4 Explanation",
    "text": "2.4 Explanation\n\nFunction Definition: transcribe_dna_to_rna(dna_string) takes a DNA string as input.\nString Replacement: dna_string.replace('T', 'U') creates a new string where all Ts are replaced with Us.\nReturn Statement: The resulting RNA string is returned."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-2",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "3.1 Sample Dataset",
    "text": "3.1 Sample Dataset\nAAAACCCGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-2",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "3.2 Sample Output",
    "text": "3.2 Sample Output\nACCGGGTTTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#soultion",
    "href": "posts/qmd/Rosalind_stronghold.html#soultion",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "3.3 soultion",
    "text": "3.3 soultion\nTo find the reverse complement of a DNA string, follow these steps:\n\nReverse the string: First, reverse the input DNA string.\nComplement the string: Replace each nucleotide with its complement: ‘A’ with ‘T’, ‘T’ with ‘A’, ‘C’ with ‘G’, and ‘G’ with ‘C’.\n\ndef reverse_complement(dna_string):\n    # Dictionary to map each nucleotide to its complement\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    \n    # Reverse the DNA string\n    reversed_dna = dna_string[::-1]\n    \n    # Replace each nucleotide with its complement\n    reverse_complement_dna = ''.join(complement[base] for base in reversed_dna)\n    \n    return reverse_complement_dna\n\n# Sample Dataset\ndna_string = \"AAAACCCGGT\"\nprint(reverse_complement(dna_string))  \n# Output should be \"ACCGGGTTTT\""
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-1",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "3.4 Explanation",
    "text": "3.4 Explanation\n\nComplement Mapping:\n\nA dictionary complement is used to map each nucleotide to its complementary nucleotide.\n\nReversing the String:\n\nThe slicing operation dna_string[::-1] reverses the string.\n\nGenerating the Complement:\n\nA list comprehension is used to replace each nucleotide in the reversed string with its complement.\n''.join() combines the list of complemented nucleotides into a single string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-3",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "4.1 Sample Dataset",
    "text": "4.1 Sample Dataset\n5 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-3",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "4.2 Sample Output",
    "text": "4.2 Sample Output\n19"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-2",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "4.3 Solution",
    "text": "4.3 Solution\nTo solve the problem of computing the total number of rabbit pairs after a given number of months \\(n\\) when each pair of reproduction-age rabbits produces \\(k\\) rabbit pairs each month, we can modify the classic Fibonacci sequence. Instead of each rabbit pair producing just one new pair, they produce \\(k\\) new pairs.\nLet’s break down the steps to create the solution:\n\nDefine the recurrence relation: The problem can be modeled with a recurrence relation. Let \\(F(n)\\) represent the number of rabbit pairs after \\(n\\) months. The recurrence relation can be expressed as: \\[ F(n) = F(n-1) + k \\times F(n-2) \\] Here, \\(F(n-1)\\) represents the number of rabbit pairs from the previous month, and \\(k\\) times \\(F(n-2)\\) represents the new rabbit pairs produced by the pairs from two months ago.\nInitial conditions:\n\n\\(F(1) = 1\\) (initially, there is one pair of rabbits)\n\\(F(2) = 1\\) (in the second month, there is still only one pair, as they have not yet reproduced)\n\nIterative computation: Using a loop, compute the number of rabbit pairs for each month up to \\(n\\) based on the recurrence relation.\n\nHere is the Python function to implement this approach:\ndef total_rabbit_pairs(n, k):\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the first two months\n    F1 = 1\n    F2 = 1\n    \n    # Compute the number of rabbit pairs for each subsequent month\n    for month in range(3, n + 1):\n        F_current = F2 + k * F1\n        F1 = F2\n        F2 = F_current\n    \n    return F2\n\n# Sample Dataset\nn = 5\nk = 3\nprint(total_rabbit_pairs(n, k))  # Output should be 19"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "4.4 Explanation of the Code",
    "text": "4.4 Explanation of the Code\n\nBase Cases:\n\nIf \\(n\\) is 1 or 2, the function returns 1 because the first two terms are both 1.\n\nInitialization:\n\nVariables F1 and F2 are initialized to 1, representing the number of rabbit pairs in the first and second months, respectively.\n\nLoop Through Months:\n\nFor each month from 3 to \\(n\\) , the number of rabbit pairs is calculated using the recurrence relation. F_current is calculated as the sum of the number of rabbit pairs from the previous month (F2) and the number of new rabbit pairs produced by the pairs from two months ago (k * F1).\n\nUpdate Variables:\n\nAfter computing F_current, update F1 and F2 to the values of the last two computed terms to prepare for the next iteration.\n\nReturn the Result:\n\nFinally, return F2, which holds the number of rabbit pairs after \\(n\\) months."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-4",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "5.1 Sample Dataset",
    "text": "5.1 Sample Dataset\n&gt;Rosalind_6404\nCCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC\nTCCCACTAATAATTCTGAGG\n&gt;Rosalind_5959\nCCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT\nATATCCATTTGTCAGCAGACACGC\n&gt;Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-4",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "5.2 Sample Output",
    "text": "5.2 Sample Output\nRosalind_0808\n60.919540"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-3",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "5.3 Solution",
    "text": "5.3 Solution\nTo solve this problem, we need to compute the GC-content of multiple DNA strings provided in FASTA format and identify the string with the highest GC-content."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "5.4 Steps to Solve the Problem",
    "text": "5.4 Steps to Solve the Problem\n\nParse the FASTA formatted input: Extract the DNA strings and their corresponding IDs.\nCompute GC-content: For each DNA string, calculate the percentage of nucleotides that are ‘C’ or ‘G’.\nDetermine the highest GC-content: Identify the DNA string with the highest GC-content and return its ID along with the computed GC-content.\n\nHere’s the Python code to achieve this:\ndef parse_fasta(fasta_strings):\n    sequences = {}\n    label = None\n    \n    for line in fasta_strings.splitlines():\n        if line.startswith('&gt;'):\n            label = line[1:].strip()\n            sequences[label] = \"\"\n        else:\n            sequences[label] += line.strip()\n    \n    return sequences\n\ndef gc_content(dna_string):\n    gc_count = dna_string.count('G') + dna_string.count('C')\n    return (gc_count / len(dna_string)) * 100\n\ndef highest_gc_content(fasta_strings):\n    sequences = parse_fasta(fasta_strings)\n    max_gc_id = None\n    max_gc_content = 0\n    \n    for label, dna_string in sequences.items():\n        gc = gc_content(dna_string)\n        if gc &gt; max_gc_content:\n            max_gc_content = gc\n            max_gc_id = label\n            \n    return max_gc_id, max_gc_content\n\n# Sample Dataset\nfasta_strings = \"\"\"&gt;Rosalind_6404\nCCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC\nTCCCACTAATAATTCTGAGG\n&gt;Rosalind_5959\nCCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT\nATATCCATTTGTCAGCAGACACGC\n&gt;Rosalind_0808\nCCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC\nTGGGAACCTGCGGGCAGTAGGTGGAAT\"\"\"\n\n# Compute and print the result\nresult_id, result_gc_content = highest_gc_content(fasta_strings)\nprint(result_id)\nprint(f\"{result_gc_content:f}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-2",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "5.5 Explanation",
    "text": "5.5 Explanation\n\nParsing FASTA Format:\n\nThe parse_fasta function reads the FASTA formatted string and extracts the sequences.\nIt uses a dictionary to store the DNA sequences with their labels as keys.\n\nComputing GC-content:\n\nThe gc_content function calculates the GC-content by counting ‘G’ and ‘C’ nucleotides and dividing by the total length of the DNA string.\n\nFinding the Highest GC-content:\n\nThe highest_gc_content function iterates through the parsed sequences, calculates the GC-content for each, and keeps track of the highest value and its corresponding label."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-5",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "6.1 Sample Dataset",
    "text": "6.1 Sample Dataset\nGAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-5",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "6.2 Sample Output",
    "text": "6.2 Sample Output\n7"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-4",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "6.3 Solution",
    "text": "6.3 Solution\nThe Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols differ. Given two DNA strings, we can compute the Hamming distance by comparing each position in the strings and counting the differences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-1",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "6.4 Steps to Solve the Problem",
    "text": "6.4 Steps to Solve the Problem\n\nEnsure Strings are of Equal Length: The problem guarantees that the strings are of equal length, so we don’t need to check for this.\nCompare Corresponding Symbols: Traverse both strings and compare corresponding characters.\nCount Differences: Increment a counter whenever the characters at the same position are different.\n\ndef hamming_distance(s, t):\n    # Initialize the counter for differences\n    count = 0\n    \n    # Traverse both strings and compare characters\n    for char1, char2 in zip(s, t):\n        if char1 != char2:\n            count += 1\n    \n    return count\n\n# Sample Dataset\ns = \"GAGCCTACTAACGGGAT\"\nt = \"CATCGTAATGACGGCCT\"\nprint(hamming_distance(s, t))  # Output should be 7"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-3",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "6.5 Explanation",
    "text": "6.5 Explanation\n\nInitialize Counter:\n\ncount is initialized to zero. This will keep track of the number of differing positions.\n\nTraverse Strings:\n\nzip(s, t) pairs up characters from both strings at each position.\nFor each pair of characters (char1, char2), compare them.\n\nCount Differences:\n\nIf char1 is not equal to char2, increment the count."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-6",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "7.1 Sample Dataset",
    "text": "7.1 Sample Dataset\n2 2 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-6",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "7.2 Sample Output",
    "text": "7.2 Sample Output\n0.78333"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-5",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "7.3 Solution",
    "text": "7.3 Solution\nTo solve this problem, we need to calculate the probability that two randomly selected organisms from a population will produce an offspring with at least one dominant allele. The population is divided into three groups: - \\(k\\): Homozygous dominant organisms (AA) - \\(m\\): Heterozygous organisms (Aa) - \\(n\\): Homozygous recessive organisms (aa)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-2",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "7.4 Steps to Solve the Problem",
    "text": "7.4 Steps to Solve the Problem\n\nCalculate Total Population Size:\n\nTotal number of organisms: \\((T = k + m + n)\\)\n\nCalculate the Probability of Each Possible Pairing:\n\nThere are several pairings to consider:\n\n\\(AA \\times AA\\)\n\\(AA \\times Aa\\)\n\\(AA \\times aa\\)\n\\(Aa \\times Aa\\)\n\\(Aa \\times aa\\)\n\\(aa \\times aa\\)\n\n\nCalculate the Probability of Producing a Dominant Phenotype from Each Pairing:\n\n\\(AA \\times AA\\): 100% dominant phenotype.\n\\(AA \\times Aa\\): 100% dominant phenotype.\n\\(AA \\times aa\\): 100% dominant phenotype.\n\\(Aa \\times Aa\\): 75% dominant phenotype (since the combinations are AA, Aa, Aa, aa).\n\\(Aa \\times aa\\): 50% dominant phenotype (since the combinations are Aa, Aa, aa, aa).\n\\(aa \\times aa\\): 0% dominant phenotype.\n\nCalculate the Probability of Selecting Each Pairing:\n\nThe probability of selecting two organisms is determined by the number of ways to choose them from the total population.\n\nCombine Probabilities to Get the Overall Probability of Dominant Phenotype:\n\nSum the probabilities of all pairings that produce a dominant phenotype, weighted by their probability of selection.\n\n\nHere is the Python code that implements the above steps:\ndef probability_dominant_phenotype(k, m, n):\n    # Total population\n    total = k + m + n\n    \n    # Total number of possible pairings\n    total_pairings = total * (total - 1)\n    \n    # Probabilities of each pairing type\n    prob_AA_AA = k * (k - 1) / total_pairings\n    prob_AA_Aa = 2 * k * m / total_pairings\n    prob_AA_aa = 2 * k * n / total_pairings\n    prob_Aa_Aa = m * (m - 1) / total_pairings\n    prob_Aa_aa = 2 * m * n / total_pairings\n    prob_aa_aa = n * (n - 1) / total_pairings\n    \n    # Probabilities of dominant phenotype from each pairing\n    prob_dom_AA_AA = 1.0  # 100%\n    prob_dom_AA_Aa = 1.0  # 100%\n    prob_dom_AA_aa = 1.0  # 100%\n    prob_dom_Aa_Aa = 0.75 # 75%\n    prob_dom_Aa_aa = 0.5  # 50%\n    prob_dom_aa_aa = 0.0  # 0%\n    \n    # Total probability of dominant phenotype\n    prob_dom = (prob_AA_AA * prob_dom_AA_AA +\n                prob_AA_Aa * prob_dom_AA_Aa +\n                prob_AA_aa * prob_dom_AA_aa +\n                prob_Aa_Aa * prob_dom_Aa_Aa +\n                prob_Aa_aa * prob_dom_Aa_aa +\n                prob_aa_aa * prob_dom_aa_aa)\n    \n    return prob_dom\n\n# Sample Dataset\nk, m, n = 2, 2, 2\n\n# Calculate and print the result\nresult = probability_dominant_phenotype(k, m, n)\nprint(f\"{result:f}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-4",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "7.5 Explanation",
    "text": "7.5 Explanation\n\nTotal Population:\n\nWe calculate the total number of organisms, \\(total = k + m + n\\).\n\nPairing Probabilities:\n\nEach pairing probability is calculated based on the number of ways to select pairs from the total population.\n\nDominant Phenotype Probabilities:\n\nEach pairing type has a different probability of producing a dominant phenotype based on Mendelian inheritance.\n\nOverall Probability:\n\nThe overall probability is a weighted sum of the probabilities of each pairing type producing a dominant phenotype.\n\n\nThis code computes the required probability efficiently and accurately, matching the example output provided in the problem description."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-7",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "8.1 Sample Dataset",
    "text": "8.1 Sample Dataset\nAUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-7",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "8.2 Sample Output",
    "text": "8.2 Sample Output\nMAMAPRTEINSTRING"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-6",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "8.3 Solution",
    "text": "8.3 Solution\nTo convert an RNA string into a protein string, you need to translate the RNA codons into their corresponding amino acids based on the RNA codon table. Each RNA codon (a sequence of three nucleotides) corresponds to a specific amino acid or a stop signal, which terminates translation.\nHere’s the step-by-step approach to solving the problem:\n\nCreate an RNA Codon Table: The RNA codon table maps each of the 64 possible codons to their corresponding amino acid or stop signal. For example, the codon “AUG” codes for Methionine (M), and “UGA” is a stop codon.\nRead the RNA String: The RNA string will be read in chunks of three nucleotides (codons).\nTranslate Each Codon: Using the codon table, translate each codon into the corresponding amino acid. If a stop codon is encountered, terminate the translation.\nConstruct the Protein String: Concatenate the translated amino acids to form the final protein string.\n\nHere is the Python implementation of this approach:\ndef translate_rna_to_protein(rna_sequence):\n    codon_table = {\n        \"UUU\": \"F\", \"UUC\": \"F\", \"UUA\": \"L\", \"UUG\": \"L\",\n        \"UCU\": \"S\", \"UCC\": \"S\", \"UCA\": \"S\", \"UCG\": \"S\",\n        \"UAU\": \"Y\", \"UAC\": \"Y\", \"UAA\": \"Stop\", \"UAG\": \"Stop\",\n        \"UGU\": \"C\", \"UGC\": \"C\", \"UGA\": \"Stop\", \"UGG\": \"W\",\n        \"CUU\": \"L\", \"CUC\": \"L\", \"CUA\": \"L\", \"CUG\": \"L\",\n        \"CCU\": \"P\", \"CCC\": \"P\", \"CCA\": \"P\", \"CCG\": \"P\",\n        \"CAU\": \"H\", \"CAC\": \"H\", \"CAA\": \"Q\", \"CAG\": \"Q\",\n        \"CGU\": \"R\", \"CGC\": \"R\", \"CGA\": \"R\", \"CGG\": \"R\",\n        \"AUU\": \"I\", \"AUC\": \"I\", \"AUA\": \"I\", \"AUG\": \"M\",\n        \"ACU\": \"T\", \"ACC\": \"T\", \"ACA\": \"T\", \"ACG\": \"T\",\n        \"AAU\": \"N\", \"AAC\": \"N\", \"AAA\": \"K\", \"AAG\": \"K\",\n        \"AGU\": \"S\", \"AGC\": \"S\", \"AGA\": \"R\", \"AGG\": \"R\",\n        \"GUU\": \"V\", \"GUC\": \"V\", \"GUA\": \"V\", \"GUG\": \"V\",\n        \"GCU\": \"A\", \"GCC\": \"A\", \"GCA\": \"A\", \"GCG\": \"A\",\n        \"GAU\": \"D\", \"GAC\": \"D\", \"GAA\": \"E\", \"GAG\": \"E\",\n        \"GGU\": \"G\", \"GGC\": \"G\", \"GGA\": \"G\", \"GGG\": \"G\"\n    }\n\n    protein_string = []\n    \n    # Proces the RNA sequence in chunks of three nucleotides (codons)\n    for i in range(0, len(rna_sequence), 3):\n        codon = rna_sequence[i:i+3]\n        if codon in codon_table:\n            amino_acid = codon_table[codon]\n            if amino_acid == \"Stop\":\n                break\n            protein_string.append(amino_acid)\n    \n    return ''.join(protein_string)\n\n# Sample Dataset\nrna_sequence = \"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"\nprint(translate_rna_to_protein(rna_sequence))\n# Output should be \"MAMAPRTEINSTRING\""
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-5",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "8.4 Explanation",
    "text": "8.4 Explanation\n\nCodon Table: The dictionary codon_table maps RNA codons to their corresponding amino acids or stop signals.\nProcessing the RNA Sequence:\n\nThe loop iterates over the RNA sequence in steps of three nucleotides.\nFor each codon, the corresponding amino acid is retrieved from the codon_table.\nIf the amino acid is “Stop”, the loop terminates, indicating the end of the protein sequence.\nOtherwise, the amino acid is appended to the protein_string list.\n\nConstructing the Protein String:\n\nThe list of amino acids is joined into a single string and returned as the final protein string.\n\n\nThis method ensures that the RNA sequence is translated efficiently and correctly into the corresponding protein string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-8",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.1 Sample Dataset",
    "text": "9.1 Sample Dataset\nGATATATGCATATACTT\nATAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-8",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.2 Sample Output",
    "text": "9.2 Sample Output\n2 4 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-7",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.3 Solution",
    "text": "9.3 Solution\nTo solve the problem of finding all locations of a substring t in a string s, we need to identify each position in s where t starts. This can be achieved using simple string matching techniques."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-3",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.4 Steps to Solve the Problem",
    "text": "9.4 Steps to Solve the Problem\n\nRead the Input Strings:\n\nWe have two DNA strings, s and t.\n\nIterate Through the Main String s:\n\nCheck for occurrences of the substring t starting at each position in s.\n\nCollect All Starting Positions:\n\nWhenever t is found in s, record the starting position. Note that the positions should be 1-based as per the problem statement.\n\nOutput the Results:\n\nPrint all recorded positions separated by spaces."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.5 Implementation",
    "text": "9.5 Implementation\nHere is the Python code that implements the above logic:\ndef find_motif_locations(s, t):\n    positions = []\n    len_s = len(s)\n    len_t = len(t)\n    \n    # Iterate through the main string `s`\n    for i in range(len_s - len_t + 1):\n        # Check if the substring `t` matches the segment in `s` starting at position `i`\n        if s[i:i+len_t] == t:\n            # If it matches, record the 1-based position\n            positions.append(i + 1)\n    \n    return positions\n\n# Sample Dataset\ns = \"GATATATGCATATACTT\"\nt = \"ATAT\"\n\n# Find and print the locations\nlocations = find_motif_locations(s, t)\nprint(\" \".join(map(str, locations)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-6",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "9.6 Explanation",
    "text": "9.6 Explanation\n\nIterate Through the Main String s:\n\nWe use a for loop to go through each possible starting position for t in s. The loop runs from 0 to len(s) - len(t) to ensure we don’t go out of bounds.\n\nCheck for Substring Match:\n\nFor each position i, we check if the substring s[i:i+len(t)] matches t.\n\nRecord the Position:\n\nIf a match is found, we append the 1-based position (i.e., i + 1) to our list of positions.\n\nOutput the Results:\n\nWe convert the list of positions to a space-separated string and print it.\n\n\nThis approach ensures that all occurrences of t in s are found and correctly reported. The solution efficiently handles the constraints of the problem, making it suitable for DNA strings up to 1 kbp in length."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-9",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-9",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "10.1 Sample Dataset",
    "text": "10.1 Sample Dataset\n&gt;Rosalind_1\nATCCAGCT\n&gt;Rosalind_2\nGGGCAACT\n&gt;Rosalind_3\nATGGATCT\n&gt;Rosalind_4\nAAGCAACC\n&gt;Rosalind_5\nTTGGAACT\n&gt;Rosalind_6\nATGCCATT\n&gt;Rosalind_7\nATGGCACT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-9",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-9",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "10.2 Sample Output",
    "text": "10.2 Sample Output\nATGCAACT\nA: 5 1 0 0 5 5 0 0\nC: 0 0 1 4 2 0 6 1\nG: 1 1 6 3 0 1 0 0\nT: 1 5 0 0 0 1 1 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-8",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "10.3 Solution",
    "text": "10.3 Solution\nTo solve the problem of finding the consensus string and profile matrix from a collection of DNA strings, we need to follow these steps:\n\nParse the FASTA format input to extract the DNA strings.\nInitialize the profile matrix to keep track of the frequency of each nucleotide (A, C, G, T) at each position in the strings.\nPopulate the profile matrix by iterating through each DNA string and counting the occurrences of each nucleotide at each position.\nConstruct the consensus string by selecting the most frequent nucleotide at each position based on the profile matrix.\nOutput the consensus string and the profile matrix.\n\nHere’s the Python code to solve the problem:\ndef parse_fasta(fasta_string):\n    sequences = {}\n    current_label = \"\"\n    \n    lines = fasta_string.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\"&gt;\"):\n            current_label = line[1:]\n            sequences[current_label] = \"\"\n        else:\n            sequences[current_label] += line\n            \n    return list(sequences.values())\n\ndef calculate_profile_matrix(dna_strings):\n    n = len(dna_strings[0])\n    profile_matrix = {\n        'A': [0] * n,\n        'C': [0] * n,\n        'G': [0] * n,\n        'T': [0] * n\n    }\n    \n    for dna in dna_strings:\n        for i, nucleotide in enumerate(dna):\n            profile_matrix[nucleotide][i] += 1\n    \n    return profile_matrix\n\ndef calculate_consensus_string(profile_matrix, length):\n    consensus = []\n    for i in range(length):\n        max_count = 0\n        max_nucleotide = ''\n        for nucleotide in \"ACGT\":\n            if profile_matrix[nucleotide][i] &gt; max_count:\n                max_count = profile_matrix[nucleotide][i]\n                max_nucleotide = nucleotide\n        consensus.append(max_nucleotide)\n    return ''.join(consensus)\n\ndef consensus_and_profile(fasta_string):\n    dna_strings = parse_fasta(fasta_string)\n    profile_matrix = calculate_profile_matrix(dna_strings)\n    consensus_string = calculate_consensus_string(profile_matrix, len(dna_strings[0]))\n    \n    return consensus_string, profile_matrix\n\n# Sample Dataset as a single string\nfasta_string = \"\"\"\n&gt;Rosalind_1\nATCCAGCT\n&gt;Rosalind_2\nGGGCAACT\n&gt;Rosalind_3\nATGGATCT\n&gt;Rosalind_4\nAAGCAACC\n&gt;Rosalind_5\nTTGGAACT\n&gt;Rosalind_6\nATGCCATT\n&gt;Rosalind_7\nATGGCACT\n\"\"\"\n\n# Compute the result\nconsensus_string, profile_matrix = consensus_and_profile(fasta_string)\n\n# Print the result\nprint(consensus_string)\nfor nucleotide in \"ACGT\":\n    print(f\"{nucleotide}: {' '.join(map(str, profile_matrix[nucleotide]))}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-7",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "10.4 Explanation",
    "text": "10.4 Explanation\n\nParsing FASTA Input:\n\nThe parse_fasta function now processes a single string input and splits it into lines. It reads through each line, detecting labels (lines starting with ‘&gt;’) and corresponding DNA sequences, which are stored in a dictionary and then converted into a list of sequences.\n\nProfile Matrix Calculation:\n\nThe calculate_profile_matrix function initializes a dictionary with keys ‘A’, ‘C’, ‘G’, and ‘T’ and lists as values to store nucleotide counts at each position.\n\nConsensus String Calculation:\n\nThe calculate_consensus_string function builds the consensus string by selecting the nucleotide with the highest count at each position.\n\nMain Function:\n\nThe consensus_and_profile function orchestrates the entire process, returning the consensus string and the profile matrix."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-10",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-10",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "10.5 Sample Output",
    "text": "10.5 Sample Output\nRunning the provided dataset through the code will produce the following output:\nATGCAACT\nA: 5 1 0 0 5 5 0 0\nC: 0 0 1 4 2 0 6 1\nG: 1 1 6 3 0 1 0 0\nT: 1 5 0 0 0 1 1 6\nThis output shows the consensus string and the profile matrix with counts of each nucleotide at each position, formatted as required by the problem statement."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-10",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-10",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "11.1 Sample Dataset",
    "text": "11.1 Sample Dataset\n6 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-11",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-11",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "11.2 Sample Output",
    "text": "11.2 Sample Output\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-9",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-9",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "11.3 Solution",
    "text": "11.3 Solution\nTo solve the problem of computing the number of rabbit pairs after a given number of months with a lifespan constraint, we need to adjust the classic Fibonacci sequence to consider the mortality of rabbits. Here’s how we can approach this using dynamic programming:\n\nInitialize the state:\n\nWe keep track of the number of rabbits of different ages using an array.\nrabbits[i] will represent the number of rabbit pairs of age i.\n\nSimulate each month:\n\nIn each month, rabbits of age 0 produce new rabbits.\nAll rabbits get older by one month.\nRabbits older than m months die.\n\nUpdate the state:\n\nShift all elements in the rabbits array to the right.\nUpdate the number of new-born rabbits based on the rabbits of age 1 to m-1.\n\n\ndef mortal_fibonacci_rabbits(n, m):\n    rabbits = [0] * m\n    rabbits[0] = 1  # Initial pair of rabbits\n    \n    for month in range(1, n):\n        new_born = sum(rabbits[1:])  # All rabbits that are not in their first month\n        # Shift all rabbits to the next month\n        for i in range(m-1, 0, -1):\n            rabbits[i] = rabbits[i-1]\n        rabbits[0] = new_born  # Update the new-born rabbits\n    \n    return sum(rabbits)\n\n# Test the function with the sample dataset\nprint(mortal_fibonacci_rabbits(6, 3))  # Output should be 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-8",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "11.4 Explanation",
    "text": "11.4 Explanation\n\nInitialization:\n\nWe start with rabbits = [1, 0, 0], which represents 1 pair of newborn rabbits and no other rabbits of other ages.\n\nMonthly updates:\n\nFor each month, compute the number of new-born rabbits.\nShift the ages of rabbits, which involves moving each count in the rabbits array to the next index.\nRabbits older than m-1 months (last index) die off automatically as they are not carried forward.\n\nResult:\n\nThe total number of rabbits is the sum of all entries in the rabbits array after the loop ends.\n\n\nThis approach ensures that we accurately track the age of each rabbit pair and account for their mortality, providing the correct number of rabbit pairs after n months."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-11",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-11",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.1 Sample Dataset",
    "text": "12.1 Sample Dataset\nMA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-12",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-12",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.2 Sample Output",
    "text": "12.2 Sample Output\n12"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-10",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-10",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.3 Solution",
    "text": "12.3 Solution\nTo solve the problem of finding the total number of different RNA strings from which a given protein string could have been translated, we need to consider the redundancy in the genetic code. Each amino acid can be encoded by one or more codons, and this redundancy will influence the number of possible RNA sequences that can result in the same protein."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-4",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.4 Steps to Solve the Problem",
    "text": "12.4 Steps to Solve the Problem\n\nUnderstand the Genetic Code:\n\nCreate a mapping of each amino acid to the number of possible codons that encode it.\nDon’t forget to include the stop codons, which signal the end of translation.\n\nCalculate Possible RNA Strings for Each Amino Acid:\n\nFor each amino acid in the given protein string, multiply the number of possible codons for that amino acid.\nInclude a factor for the stop codon at the end.\n\nUse Modular Arithmetic:\n\nSince the resulting number can be very large, use modulo \\(1,000,000\\) to avoid overflow and ensure the result fits within standard integer sizes."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#genetic-code-table",
    "href": "posts/qmd/Rosalind_stronghold.html#genetic-code-table",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.5 Genetic Code Table",
    "text": "12.5 Genetic Code Table\nHere is the mapping of amino acids to their respective number of codons: - ‘A’: 4, ‘C’: 2, ‘D’: 2, ‘E’: 2, ‘F’: 2, ‘G’: 4, ‘H’: 2, ‘I’: 3, ‘K’: 2, ‘L’: 6, - ‘M’: 1, ‘N’: 2, ‘P’: 4, ‘Q’: 2, ‘R’: 6, ‘S’: 6, ‘T’: 4, ‘V’: 4, ‘W’: 1, ‘Y’: 2, - Stop codon: 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-1",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.6 Implementation",
    "text": "12.6 Implementation\nBelow is the Python code that implements the solution:\ndef infer_mrna_from_protein(protein):\n    # Codon counts for each amino acid and stop codon\n    codon_count = {\n        'A': 4, 'C': 2, 'D': 2, 'E': 2, 'F': 2, 'G': 4,\n        'H': 2, 'I': 3, 'K': 2, 'L': 6, 'M': 1, 'N': 2,\n        'P': 4, 'Q': 2, 'R': 6, 'S': 6, 'T': 4, 'V': 4,\n        'W': 1, 'Y': 2, 'Stop': 3\n    }\n    \n    # Initialize the number of possible RNA strings\n    possible_rna_strings = 1\n    \n    # Calculate the product of possible codons for each amino acid\n    for aa in protein:\n        possible_rna_strings *= codon_count[aa]\n        possible_rna_strings %= 1000000  # Take modulo 1,000,000 to keep the number manageable\n    \n    # Multiply by the number of stop codons\n    possible_rna_strings *= codon_count['Stop']\n    possible_rna_strings %= 1000000  # Take modulo 1,000,000 again\n    \n    return possible_rna_strings\n\n# Sample Dataset\nprotein_string = \"MA\"\n\n# Compute the result\nresult = infer_mrna_from_protein(protein_string)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-9",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-9",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "12.7 Explanation",
    "text": "12.7 Explanation\n\nCodon Count Mapping:\n\nThe codon_count dictionary stores the number of codons that can encode each amino acid, along with the number of stop codons.\n\nProduct Calculation:\n\nWe initialize possible_rna_strings to 1.\nFor each amino acid in the protein string, multiply possible_rna_strings by the number of codons that can encode that amino acid.\nUse modulo 1,000,000 after each multiplication to keep the number within manageable limits.\n\nStop Codon Factor:\n\nFinally, multiply by the number of stop codons and take modulo 1,000,000 again.\n\n\nThis approach ensures that we efficiently compute the total number of possible RNA sequences modulo 1,000,000."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-12",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-12",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.1 Sample Dataset",
    "text": "13.1 Sample Dataset\n&gt;Rosalind_0498\nAAATAAA\n&gt;Rosalind_2391\nAAATTTT\n&gt;Rosalind_2323\nTTTTCCC\n&gt;Rosalind_0442\nAAATCCC\n&gt;Rosalind_5013\nGGGTGGG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-13",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-13",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.2 Sample Output",
    "text": "13.2 Sample Output\nRosalind_0498 Rosalind_2391\nRosalind_0498 Rosalind_0442\nRosalind_2391 Rosalind_2323"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-11",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-11",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.3 Solution",
    "text": "13.3 Solution\nTo solve the problem of constructing an overlap graph from a collection of DNA strings, we need to follow these steps:\n\nParse the input data: Read the DNA strings in FASTA format.\nConstruct the graph: Identify edges between nodes based on the overlap condition.\nOutput the adjacency list: List all directed edges that satisfy the overlap condition."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-implement-the-solution",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-implement-the-solution",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.4 Steps to Implement the Solution",
    "text": "13.4 Steps to Implement the Solution\n\nRead the Input Data:\n\nUse a parser to read the input DNA strings in FASTA format.\nStore the strings in a dictionary with their labels as keys.\n\nCheck for Overlaps:\n\nFor each pair of strings, check if the suffix of length k of one string matches the prefix of length k of the other string.\nIf they match and the strings are different, record the directed edge from the first string to the second.\n\nOutput the Results:\n\nPrint each directed edge in the format “label1 label2”."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#example-implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#example-implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.5 Example Implementation",
    "text": "13.5 Example Implementation\nBelow is the Python code that performs these steps:\ndef parse_fasta(data):\n    sequences = {}\n    label = None\n    for line in data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            label = line[1:]\n            sequences[label] = \"\"\n        else:\n            sequences[label] += line\n    return sequences\n\ndef overlap_graph(sequences, k):\n    adjacency_list = []\n    for s1 in sequences:\n        for s2 in sequences:\n            if s1 != s2:\n                if sequences[s1][-k:] == sequences[s2][:k]:\n                    adjacency_list.append((s1, s2))\n    return adjacency_list\n\ndef print_adjacency_list(adjacency_list):\n    for edge in adjacency_list:\n        print(f\"{edge[0]} {edge[1]}\")\n\n# Sample dataset\ndata = \"\"\"\n&gt;Rosalind_0498\nAAATAAA\n&gt;Rosalind_2391\nAAATTTT\n&gt;Rosalind_2323\nTTTTCCC\n&gt;Rosalind_0442\nAAATCCC\n&gt;Rosalind_5013\nGGGTGGG\n\"\"\"\n\nsequences = parse_fasta(data)\nadjacency_list = overlap_graph(sequences, 3)\nprint_adjacency_list(adjacency_list)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-1",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "13.6 Explanation of the Code",
    "text": "13.6 Explanation of the Code\n\nparse_fasta function:\n\nReads the FASTA formatted input.\nStores sequences in a dictionary where keys are the labels and values are the sequences.\n\noverlap_graph function:\n\nTakes the sequences dictionary and the overlap length k.\nChecks each pair of sequences to see if the suffix of length k of the first sequence matches the prefix of length k of the second sequence.\nRecords the directed edge if the condition is met.\n\nprint_adjacency_list function:\n\nPrints each edge in the required format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-13",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-13",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.1 Sample Dataset",
    "text": "14.1 Sample Dataset\n1 0 0 1 0 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-14",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-14",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.2 Sample Output",
    "text": "14.2 Sample Output\n3.5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-12",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-12",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.3 Solution",
    "text": "14.3 Solution\nTo solve this problem, we need to calculate the expected number of offspring displaying the dominant phenotype given six nonnegative integers representing the number of couples with specific genotype pairings. Each couple has exactly two offspring."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#genotype-pairings-and-dominance",
    "href": "posts/qmd/Rosalind_stronghold.html#genotype-pairings-and-dominance",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.4 Genotype Pairings and Dominance",
    "text": "14.4 Genotype Pairings and Dominance\nThe six genotype pairings are: 1. AA-AA: 100% dominant phenotype 2. AA-Aa: 100% dominant phenotype 3. AA-aa: 100% dominant phenotype 4. Aa-Aa: 75% dominant phenotype 5. Aa-aa: 50% dominant phenotype 6. aa-aa: 0% dominant phenotype\nWe can represent the probability of offspring having the dominant phenotype for each genotype pairing as follows: 1. AA-AA: \\(1.0\\) 2. AA-Aa: \\(1.0\\) 3. AA-aa: \\(1.0\\) 4. Aa-Aa: \\(0.75\\) 5. Aa-aa: \\(0.5\\) 6. aa-aa: \\(0.0\\)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#expected-number-of-dominant-offspring",
    "href": "posts/qmd/Rosalind_stronghold.html#expected-number-of-dominant-offspring",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.5 Expected Number of Dominant Offspring",
    "text": "14.5 Expected Number of Dominant Offspring\nFor each couple, since they produce exactly two offspring, we can multiply the number of couples by 2 and then by the probability of having a dominant phenotype to get the expected number of dominant offspring per genotype pairing."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-2",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.6 Implementation",
    "text": "14.6 Implementation\nHere’s the Python code to compute the expected number of dominant offspring:\ndef expected_dominant_offspring(couples):\n    # Probabilities of offspring having dominant phenotype for each genotype pairing\n    probabilities = [1.0, 1.0, 1.0, 0.75, 0.5, 0.0]\n    \n    # Calculate the expected number of dominant offspring\n    expected_value = 0\n    for i in range(6):\n        expected_value += couples[i] * probabilities[i] * 2\n    \n    return expected_value\n\n# Sample dataset\nsample_input = \"1 0 0 1 0 1\"\ninput_ = [int(x) for x in \"1 0 0 1 0 1\".split()]\nprint(expected_dominant_offspring(input_))  # Output: 3.5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-10",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-10",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "14.7 Explanation",
    "text": "14.7 Explanation\n\nInput: We take a list of six integers representing the number of each genotype pairing.\nProbabilities: We define the probabilities for each pairing’s offspring to display the dominant phenotype.\nCalculation: We iterate through each pairing, multiply the number of couples by the corresponding probability and by 2 (since each couple has 2 offspring), and sum these values to get the total expected number of dominant offspring.\nOutput: The result is the expected number of dominant phenotype offspring.\n\nThis code will compute the expected number of offspring displaying the dominant phenotype for any valid input as specified by the problem statement."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-14",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-14",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.1 Sample Dataset",
    "text": "15.1 Sample Dataset\n&gt;Rosalind_1\nGATTACA\n&gt;Rosalind_2\nTAGACCA\n&gt;Rosalind_3\nATACA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-15",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-15",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.2 Sample Output",
    "text": "15.2 Sample Output\nAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-13",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-13",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.3 Solution",
    "text": "15.3 Solution\nTo find the longest common substring (LCS) among a collection of DNA strings given in FASTA format, we can use the following approach:\n\nRead and Parse Input: Parse the input FASTA format to get a list of DNA strings.\nIdentify Potential Substrings: Generate all possible substrings of the shortest DNA string since the longest common substring can’t be longer than the shortest string.\nCheck Commonality: Check each substring from longest to shortest to see if it appears in all DNA strings.\nReturn the LCS: Return the first longest common substring found."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-steps",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-steps",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.4 Detailed Steps",
    "text": "15.4 Detailed Steps\n\nParse the Input:\n\nRead the input strings and remove the FASTA headers.\nCollect the DNA strings into a list.\n\nGenerate All Substrings:\n\nGenerate all substrings of the shortest string in the list. Start with the longest substrings and move to shorter ones.\n\nCheck Substrings:\n\nFor each substring generated, check if it exists in all other DNA strings.\nReturn the first substring that is found in all strings since we are generating substrings from longest to shortest."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-3",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.5 Implementation",
    "text": "15.5 Implementation\nHere’s a Python function that implements the above plan:\ndef parse_fasta(data):\n    sequences = []\n    seq = \"\"\n    for line in data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if seq:\n                sequences.append(seq)\n                seq = \"\"\n        else:\n            seq += line.strip()\n    if seq:\n        sequences.append(seq)\n    return sequences\n\ndef find_longest_common_substring(dna_strings):\n    # Find the shortest string in the list\n    shortest_str = min(dna_strings, key=len)\n    len_shortest = len(shortest_str)\n    \n    # Function to check if a substring is common in all strings\n    def is_common(sub):\n        return all(sub in dna for dna in dna_strings)\n    \n    # Iterate over all substrings of the shortest string\n    for length in range(len_shortest, 0, -1):\n        for start in range(len_shortest - length + 1):\n            candidate = shortest_str[start:start + length]\n            if is_common(candidate):\n                return candidate\n    return \"\"\n\n# Sample dataset\ndata = \"\"\"&gt;Rosalind_1\nGATTACA\n&gt;Rosalind_2\nTAGACCA\n&gt;Rosalind_3\nATACA\"\"\"\n\n# Parse the FASTA format data\ndna_strings = parse_fasta(data)\n\n# Find and print the longest common substring\nlcs = find_longest_common_substring(dna_strings)\nprint(lcs)  # Output: AC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-11",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-11",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "15.6 Explanation",
    "text": "15.6 Explanation\n\nParsing the Input:\n\nThe parse_fasta function reads the FASTA data, splits it into individual sequences, and returns a list of DNA strings.\n\nFinding the Longest Common Substring:\n\nThe find_longest_common_substring function first identifies the shortest string among the DNA strings.\nIt then iterates over all possible substrings of the shortest string, starting from the longest possible substrings.\nFor each candidate substring, it checks if this substring is present in all other DNA strings using the is_common function.\nThe first substring found that is common to all DNA strings is returned as the result.\n\n\nThis approach ensures that we find the longest common substring efficiently by leveraging the properties of substrings and the fact that the longest common substring cannot be longer than the shortest string in the list."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-15",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-15",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "16.1 Sample Dataset",
    "text": "16.1 Sample Dataset\n2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-16",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-16",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "16.2 Sample Output",
    "text": "16.2 Sample Output\n0.684"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-16",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-16",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "17.1 Sample Dataset",
    "text": "17.1 Sample Dataset\nA2Z669\nB5ZC00\nP07204_TRBM_HUMAN\nP20840_SAG1_YEAST"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-17",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-17",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "17.2 Sample Output",
    "text": "17.2 Sample Output\nB5ZC00\n85 118 142 306 395\nP07204_TRBM_HUMAN\n47 115 116 382 409\nP20840_SAG1_YEAST\n79 109 135 248 306 348 364 402 485 501 614"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-14",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-14",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "17.3 Solution",
    "text": "17.3 Solution\nTo solve the problem of identifying N-glycosylation motifs in protein sequences from the UniProt database, we need to follow these steps:\n\nFetch Protein Sequences: Retrieve the protein sequences in FASTA format from UniProt using the given acces IDs.\nIdentify Motif Locations: Search for the motif N{P}[ST]{P} in each protein sequence and record the positions where it occurs.\nOutput Results: For each protein containing the motif, output its ID followed by the positions where the motif is found.\n\nHere is a complete Python script to perform these tasks:\nimport requests\nimport re\n\ndef fetch_fasta(uniprot_id):\n    url = f\"http://www.uniprot.org/uniprot/{uniprot_id}.fasta\"\n    response = requests.get(url)\n    response.raise_for_status()  # Ensure we notice bad responses\n    fasta_data = response.text\n    return ''.join(fasta_data.split('\\n')[1:])  # Remove the first line and join the rest\n\ndef find_motif_locations(sequence, motif_regex):\n    matches = re.finditer(motif_regex, sequence)\n    return [match.start() + 1 for match in matches]  # Convert to 1-based index\n    \ndef fetch_input(data):\n    ids = []\n    for line in data.strip().split('\\n'):\n        ids.append(line)\n    return ids\n   \ndata = \"\"\"\nA2Z669\nB5ZC00\nP07204_TRBM_HUMAN\nP20840_SAG1_YEAST\n\"\"\"\n\nids = fetch_input(data)\nmotif_regex = re.compile(r'N[^P][ST][^P]')\nresults = {}\n\nfor uniprot_id in ids:\n    sequence = fetch_fasta(uniprot_id)\n    locations = find_motif_locations(sequence, motif_regex)\n    if locations:\n        results[uniprot_id] = locations\n\nfor uniprot_id, locations in results.items():\n    print(uniprot_id)\n    print(' '.join(map(str, locations)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-12",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-12",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "17.4 Explanation",
    "text": "17.4 Explanation\n\nfetch_fasta(uniprot_id):\n\nTakes a UniProt ID and fetches the corresponding protein sequence in FASTA format.\nStrips out the header line and joins the remaining lines to form the complete sequence.\n\nfind_motif_locations(sequence, motif_regex):\n\nUses the regex N[^P][ST][^P] to find all positions of the motif in the sequence.\nReturns a list of start positions in 1-based index format.\n\nmain():\n\nDefines the list of UniProt IDs.\nCompiles the regex for the motif.\nFetches each protein sequence, finds motif locations, and stores the results.\nOutputs the protein IDs followed by the locations of the motif.\n\n\nThis script fetches protein sequences from UniProt, searches for the N-glycosylation motif, and prints the locations where the motif occurs for each protein that contains it."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-17",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-17",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "18.1 Sample Dataset",
    "text": "18.1 Sample Dataset\n&gt;Rosalind_99\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-18",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-18",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "18.2 Sample Output",
    "text": "18.2 Sample Output\nMLLGSFRLIPKETLIQVAGSSPCNLS\nM\nMGMTPRLGLESLLE\nMTPRLGLESLLE"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-15",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-15",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "18.3 Solution",
    "text": "18.3 Solution\nTo find all distinct candidate protein strings from open reading frames (ORFs) in the given DNA sequence, the following approach is used:\n\nParse the Input DNA Sequence: Read the input in FASTA format and obtain the DNA sequence.\nGenerate Reading Frames: Generate six reading frames: three from the original DNA strand and three from its reverse complement.\nIdentify ORFs: For each reading frame, identify sequences that start with a start codon (ATG) and end with a stop codon (TAA, TAG, TGA).\nTranslate to Proteins: Translate the identified ORFs to protein sequences.\nCollect and Print Distinct Proteins: Collect all distinct protein sequences.\n\nHere’s the complete implementation in Python:\nCODON_TABLE = {\n    'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',\n    'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',\n    'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',\n    'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',\n    'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',\n    'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',\n    'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',\n    'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',\n    'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',\n    'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',\n    'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',\n    'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',\n    'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',\n    'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',\n    'TAC':'Y', 'TAT':'Y', 'TAA':'*', 'TAG':'*',\n    'TGC':'C', 'TGT':'C', 'TGA':'*', 'TGG':'W',\n}\n\ndef translate_dna_to_protein(dna_seq):\n    protein = []\n    has_stop_codon = False\n    for i in range(0, len(dna_seq) - 2, 3):\n        codon = dna_seq[i:i + 3]\n        amino_acid = CODON_TABLE.get(codon, '')\n        if amino_acid == '*':\n            has_stop_codon = True\n            break\n        protein.append(amino_acid)\n    return ''.join(protein), has_stop_codon\n\ndef find_orfs(dna_seq):\n    orfs = set()\n    \n    # Generate 3 reading frames for the DNA sequence\n    for frame in range(3):\n        for i in range(frame, len(dna_seq) - 2, 3):\n            if dna_seq[i:i + 3] == 'ATG':\n                protein, has_stop_codon = translate_dna_to_protein(dna_seq[i:])\n                if protein and has_stop_codon:\n                    orfs.add(protein)\n    \n    return orfs\n\ndef reverse_complement(dna_seq):\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return ''.join(complement[base] for base in reversed(dna_seq))\n\ndef main():\n    fasta_input = \"\"\"&gt;Rosalind_99\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG\"\"\"\n\n    dna_seq = ''.join(line.strip() for line in fasta_input.split('\\n') if not line.startswith('&gt;'))\n    \n    # Get reverse complement of the DNA sequence\n    reverse_complement_seq = reverse_complement(dna_seq)\n\n    # Find ORFs in the original and reverse complement sequences\n    original_orfs = find_orfs(dna_seq)\n    reverse_orfs = find_orfs(reverse_complement_seq)\n\n    # Combine results and remove duplicates\n    all_orfs = original_orfs.union(reverse_orfs)\n\n    # Print all distinct protein sequences\n    for protein in all_orfs:\n        print(protein)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanations",
    "href": "posts/qmd/Rosalind_stronghold.html#explanations",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "18.4 Explanations",
    "text": "18.4 Explanations\n\ntranslate_dna_to_protein: Now returns a tuple containing the translated protein and a boolean indicating if a stop codon was found.\nfind_orfs: Checks for the presence of a stop codon in the translated protein before adding it to the set of ORFs."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-18",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-18",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "19.1 Sample Dataset",
    "text": "19.1 Sample Dataset\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-19",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-19",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "19.2 Sample Output",
    "text": "19.2 Sample Output\n6\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-16",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-16",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "19.3 Solution",
    "text": "19.3 Solution\nTo solve the problem of enumerating all permutations of a given integer \\(n\\), we can use Python’s itertools.permutations to generate all possible permutations. Here’s a simple code that accomplishes this:\nfrom itertools import permutations\n\ndef enumerate_gene_orders(n):\n    # Generate permutations\n    perm = permutations(range(1, n + 1))\n    \n    # Convert permutations to a list\n    perm_list = list(perm)\n    \n    # Print the number of permutations\n    print(len(perm_list))\n    \n    # Print each permutation\n    for p in perm_list:\n        print(' '.join(map(str, p)))\n\n# Example usage\nn = 3\nenumerate_gene_orders(n)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-13",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-13",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "19.4 Explanation",
    "text": "19.4 Explanation\n\nImporting permutations: We import the permutations function from Python’s itertools module, which is perfect for generating permutations of a sequence.\nGenerating permutations: Using permutations(range(1, n + 1)), we generate all permutations of the list [1, 2, ..., n].\nConverting to a list: We convert the permutations object to a list to easily count and iterate over the permutations.\nPrinting the count: We print the total number of permutations.\nPrinting each permutation: We iterate through each permutation and print it in the required format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-19",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-19",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "20.1 Sample Dataset",
    "text": "20.1 Sample Dataset\nSKADYEK"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-20",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-20",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "20.2 Sample Output",
    "text": "20.2 Sample Output\n821.392"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-17",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-17",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "20.3 Solution",
    "text": "20.3 Solution\n\n먼저, 각 아미노산의 질량을 딕셔너리로 정의합니다.\n주어진 단백질 문자열의 각 아미노산의 질량을 더해서 총 질량을 계산합니다.\n\n# 아미노산 질량 테이블\nmass_table = {\n    'A': 71.03711, 'C': 103.00919, 'D': 115.02694, 'E': 129.04259,\n    'F': 147.06841, 'G': 57.02146, 'H': 137.05891, 'I': 113.08406,\n    'K': 128.09496, 'L': 113.08406, 'M': 131.04049, 'N': 114.04293,\n    'P': 97.05276, 'Q': 128.05858, 'R': 156.10111, 'S': 87.03203,\n    'T': 101.04768, 'V': 99.06841, 'W': 186.07931, 'Y': 163.06333\n}\n\ndef calculate_protein_mass(protein):\n    total_mas = 0.0\n    for amino_acid in protein:\n        if amino_acid in mass_table:\n            total_mas += mass_table[amino_acid]\n        else:\n            print(f\"Unknown amino acid: {amino_acid}\")\n    return total_mass\n\n# 샘플 데이터셋\nsequence = \"SKADYEK\"\n\n# 총 질량 계산\ntotal_mas = calculate_protein_mass(sequence)\nprint(f\"{total_mass:.3f}\")\n이 코드는 단백질 문자열 SKADYEK 의 총 질량을 계산하여 821.392 라는 결과를 출력합니다. mass_table 에 정의된 각 아미노산의 질량을 이용하여 문자열을 순회하면서 질량을 더해 총 질량을 계산합니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-20",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-20",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "21.1 Sample Dataset",
    "text": "21.1 Sample Dataset\n&gt;Rosalind_24\nTCAATGCATGCGGGTCTATATGCAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-21",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-21",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "21.2 Sample Output",
    "text": "21.2 Sample Output\n4 6\n5 4\n6 6\n7 4\n17 4\n18 4\n20 6\n21 4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-18",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-18",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "21.3 Solution",
    "text": "21.3 Solution\n주어진 DNA 문자열에서 역방향 팔린드롬을 찾는 코드를 작성하겠습니다. 역방향 팔린드롬은 해당 문자열이 그 역상 보완 문자열과 동일한 문자열을 말합니다. 역방향 팔린드롬의 위치와 길이를 반환하도록 하겠습니다.\ndef reverse_complement(dna):\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return ''.join(complement[base] for base in reversed(dna))\n\ndef find_reverse_palindromes(dna):\n    results = []\n    length = len(dna)\n    \n    for i in range(length):\n        for j in range(4, 13):  # 길이가 4에서 12까지인 모든 경우를 확인\n            if i + j &gt; length:\n                break\n            substring = dna[i:i+j]\n            if substring == reverse_complement(substring):\n                results.append((i+1, j))\n    \n    return results\n\n# 샘플 데이터셋\nsample_fasta = \"\"\"&gt;Rosalind_24\nTCAATGCATGCGGGTCTATATGCAT\"\"\"\n\n# FASTA 포맷에서 DNA 문자열 추출\ndna_string = ''.join(sample_fasta.split('\\n')[1:])\n\n# 역방향 팔린드롬 찾기\npalindromes = find_reverse_palindromes(dna_string)\n\n# 결과 출력\nfor pos, length in palindromes:\n    print(pos, length)\n위 코드는 다음과 같이 작동합니다:\n\nreverse_complement 함수는 DNA 문자열의 역상 보완 문자열을 생성합니다.\nfind_reverse_palindromes 함수는 DNA 문자열을 순회하면서 길이가 4 에서 12 사이인 모든 부분 문자열에 대해 역방향 팔린드롬인지 확인합니다.\n샘플 데이터를 입력으로 사용하여 역방향 팔린드롬의 위치와 길이를 출력합니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-21",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-21",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "22.1 Sample Dataset",
    "text": "22.1 Sample Dataset\n&gt;Rosalind_10\nATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG\n&gt;Rosalind_12\nATCGGTCGAA\n&gt;Rosalind_15\nATCGGTCGAGCGTGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-22",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-22",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "22.2 Sample Output",
    "text": "22.2 Sample Output\nMVYIADKQHVASREAYGHMFKVCA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-19",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-19",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "22.3 Solution",
    "text": "22.3 Solution\n먼저, 주어진 데이터를 파싱하고 인트론을 제거한 후 RNA 로 전사하고, 이를 단백질로 번역합니다.\n# DNA 문자열에서 RNA로 전사\ndef transcribe(dna):\n    return dna.replace('T', 'U')\n\n# RNA를 단백질로 번역하기 위한 코돈 테이블\ncodon_table = {\n    'AUG': 'M', 'UGU': 'C', 'UGC': 'C', 'UGA': '', 'UAA': '', 'UAG': '',\n    'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L', 'UAU': 'Y', 'UAC': 'Y',\n    'UGG': 'W', 'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L', 'CCU': 'P',\n    'CCC': 'P', 'CCA': 'P', 'CCG': 'P', 'CAU': 'H', 'CAC': 'H', 'CAA': 'Q',\n    'CAG': 'Q', 'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'AUU': 'I',\n    'AUC': 'I', 'AUA': 'I', 'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'AGU': 'S', 'AGC': 'S',\n    'AGA': 'R', 'AGG': 'R', 'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n    'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A', 'GAU': 'D', 'GAC': 'D',\n    'GAA': 'E', 'GAG': 'E', 'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S'\n}\n\n# RNA 문자열을 단백질로 번역\ndef translate(rna):\n    protein = []\n    for i in range(0, len(rna) - 2, 3):\n        codon = rna[i:i+3]\n        if codon in codon_table:\n            if codon_table[codon] == '':\n                break\n            protein.append(codon_table[codon])\n    return ''.join(protein)\n\n# FASTA 형식의 데이터를 파싱하여 DNA 문자열과 인트론을 추출\ndef parse_fasta(fasta_data):\n    sequences = []\n    label = None\n    for line in fasta_data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            label = line[1:]\n            sequences.append([])\n        else:\n            sequences[-1].append(line)\n    return [''.join(seq) for seq in sequences]\n\n# 샘플 데이터셋\nsample_data = \"\"\"&gt;Rosalind_10\nATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG\n&gt;Rosalind_12\nATCGGTCGAA\n&gt;Rosalind_15\nATCGGTCGAGCGTGT\"\"\"\n\n# FASTA 데이터를 파싱하여 주어진 DNA와 인트론 추출\nsequences = parse_fasta(sample_data)\nmain_dna = sequences[0]\nintrons = sequences[1:]\n\n# 인트론을 제거하여 엑손 결합\nfor intron in introns:\n    main_dna = main_dna.replace(intron, '')\n\n# 엑손을 RNA로 전사\nrna = transcribe(main_dna)\n\n# RNA를 단백질로 번역\nprotein = translate(rna)\n\n# 결과 출력\nprint(protein)\n이 코드는 다음과 같이 동작합니다:\n\nparse_fasta 함수는 FASTA 형식의 데이터를 파싱하여 DNA 문자열과 인트론을 추출합니다.\nmain_dna 에서 모든 인트론을 제거하여 엑손을 결합합니다.\ntranscribe 함수는 DNA 를 RNA 로 전사합니다.\ntranslate 함수는 RNA 를 단백질로 번역합니다.\n최종 결과를 출력합니다.\n\n샘플 데이터를 사용하여 실행하면, 결과는 MVYIADKQHVASREAYGHMFKVCA 가 됩니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-22",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-22",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "23.1 Sample Dataset",
    "text": "23.1 Sample Dataset\nA C G T\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-23",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-23",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "23.2 Sample Output",
    "text": "23.2 Sample Output\nAA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-20",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-20",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "23.3 Solution",
    "text": "23.3 Solution\n주어진 알파벳과 길이 \\(n\\) 에 대해 가능한 모든 \\(n\\) 길이의 문자열을 사전순으로 나열하는 파이썬 코드를 작성하겠습니다. 이를 위해 itertools 모듈의 product 함수를 사용할 수 있습니다.\n다음은 이를 구현한 파이썬 코드입니다:\nimport itertools\n\ndef enumerate_kmers(alphabet, n):\n    return [''.join(p) for p in itertools.product(alphabet, repeat=n)]\n\n# 샘플 데이터셋\nalphabet = \"A C G T\".split()\nn = 2\n\n# k-mer를 나열하고 사전순으로 정렬\nkmers = enumerate_kmers(alphabet, n)\nfor kmer in kmers:\n    print(kmer)\n이 코드는 다음과 같은 절차로 동작합니다:\n\nitertools.product 를 사용하여 주어진 알파벳의 모든 가능한 길이 \\(n\\) 의 조합을 생성합니다.\n각 조합을 문자열로 변환하여 리스트에 저장합니다.\n결과 리스트를 출력합니다.\n\n샘플 데이터를 사용하여 실행하면, 결과는 다음과 같습니다:\nAA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT\n이 코드는 주어진 알파벳과 길이 n 에 대해 가능한 모든 문자열을 사전순으로 올바르게 나열합니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-23",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-23",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "24.1 Sample Dataset",
    "text": "24.1 Sample Dataset\n5\n5 1 4 2 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-24",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-24",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "24.2 Sample Output",
    "text": "24.2 Sample Output\n1 2 3\n5 4 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-21",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-21",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "24.3 Solution",
    "text": "24.3 Solution\n주어진 시퀀스에서 ” 가장 긴 증가하는 부분 수열 ” 과 ” 가장 긴 감소하는 부분 수열 ” 을 찾아서 출력하는 기능을 합니다.\ndef input_processor(seq_str):\n    \"\"\"\n    입력 문자열을 처리하여 정수 리스트로 변환하는 함수\n    \"\"\"\n    return list(map(int, seq_str.split()))\n\ndef longest_subsequence(long_type, seq):\n    \"\"\"\n    가장 긴 증가 또는 감소하는 부분 수열을 찾는 함수\n\n    Args:\n    - long_type (str): 부분 수열의 종류 (\"inc\" 또는 \"dec\")\n    - seq (list of int): 입력 시퀀스\n\n    Returns:\n    - prev_idxes (list of int): 이전 인덱스를 기록한 리스트\n    - seq (list of int): 변환된 입력 시퀀스\n    \"\"\"\n    # 입력 시퀀스를 내림차순으로 변경할지 여부에 따라 결정\n    seq = list(reversed(seq)) if long_type != \"inc\" else seq\n    \n    # 부분 수열의 길이를 저장할 리스트 초기화\n    L = [1] * len(seq)\n    # 이전 인덱스를 저장할 리스트 초기화\n    prev_idxes = []\n    \n    # 각 위치마다 최장 부분 수열의 길이 계산\n    for i in range(len(L)):\n        subproblems = [L[k] for k in range(i) if seq[k] &lt; seq[i]]\n        L[i] = 1 + max(subproblems, default=0)\n        \n        if len(subproblems) == 0:\n            prev_idxes.append(-1)\n        else:\n            # 최장 부분 수열의 마지막 인덱스 계산\n            last_idx = len(L[:i]) - L[:i][::-1].index(max(subproblems)) - 1\n            prev_idxes.append(last_idx)\n    \n    return prev_idxes, seq\n\ndef decode_prev_idx(data_package):\n    \"\"\"\n    이전 인덱스를 기반으로 최장 부분 수열을 복원하는 함수\n\n    Args:\n    - data_package (tuple): (prev_idxes, seq), 이전 인덱스 리스트와 시퀀스\n\n    Returns:\n    - vals (list of list): 복원된 최장 부분 수열들의 리스트\n    \"\"\"\n    prev_idxes, seq = data_package\n    vals = []\n    \n    # 각 최장 부분 수열을 복원\n    for cur_idx in range(len(prev_idxes) - 1, -1, -1):\n        val = []\n        while cur_idx != -1:\n            cur_val = seq[cur_idx]\n            val.append(cur_val)\n            prev_idx = prev_idxes[cur_idx]\n            cur_idx = prev_idx\n        vals.append(val)\n    \n    return vals\n\ndef print_result(long_type, seq):\n    \"\"\"\n    결과를 출력하는 함수\n\n    Args:\n    - long_type (str): 부분 수열의 종류 (\"inc\" 또는 \"dec\")\n    - seq (list of int): 출력할 시퀀스\n    \"\"\"\n    if long_type == \"inc\":\n        print(*seq[::-1])\n    else:\n        print(*seq)\n\n# 입력 데이터\ndata = \"5 1 4 2 3\"\n\n# \"inc\"와 \"dec\" 각각에 대해 최장 부분 수열을 찾고 출력\nfor long_type in [\"inc\", \"dec\"]:\n    seq = input_processor(data)\n    prev_idxes, seq = longest_subsequence(long_type, seq)\n    vals = decode_prev_idx((prev_idxes, seq))\n    longest_subseq = max(vals, key=len)\n    print_result(long_type, longest_subseq)\n\nlongest_subsequence(long_type, seq):\n\nlong_type 이 “inc” 인 경우에는 시퀀스를 그대로 사용하고, “dec” 인 경우에는 시퀀스를 뒤집어서 사용합니다.\nL 리스트를 초기화하고 각 위치에서 최장 증가 부분 수열의 길이를 계산합니다.\nprev_idxes 리스트에는 각 위치에서의 이전 인덱스를 기록하여 후에 부분 수열을 복원하는 데 사용됩니다.\n\ndecode_prev_idx(data_package):\n\nlongest_subsequence 함수에서 반환된 (prev_idxes, seq) 를 받아서 이전 인덱스를 기반으로 최장 부분 수열을 복원합니다.\n각 부분 수열을 vals 리스트에 저장하고 반환합니다.\n\nprint_result(long_type, seq):\n\nlong_type 이 “inc” 인 경우에는 시퀀스를 역순으로 출력하고, “dec” 인 경우에는 그대로 출력합니다.\n\nMain Loop:\n\n입력 데이터인 “5 1 4 2 3” 에 대해 “inc” 와 “dec” 각각에 대해 최장 부분 수열을 찾고 출력합니다.\n예를 들어, “inc” 인 경우 [1, 2, 3] 이 출력되며, “dec” 인 경우 [5, 4, 2] 가 출력됩니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-24",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-24",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "25.1 Sample Dataset",
    "text": "25.1 Sample Dataset\n&gt;Rosalind_56\nATTAGACCTG\n&gt;Rosalind_57\nCCTGCCGGAA\n&gt;Rosalind_58\nAGACCTGCCG\n&gt;Rosalind_59\nGCCGGAATAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-25",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-25",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "25.2 Sample Output",
    "text": "25.2 Sample Output\nATTAGACCTGCCGGAATAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-22",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-22",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "25.3 Solution",
    "text": "25.3 Solution\n아래는 주어진 FASTA 형식 텍스트를 입력으로 받아 최단 슈퍼스트링을 계산하는 파이썬 코드입니다.\ndef parse_fasta(fasta_text):\n    sequences = {}\n    current_header = None\n    current_sequence = []\n    \n    lines = fasta_text.splitlines()\n    for line in lines:\n        line = line.strip()\n        if line.startswith('&gt;'):\n            if current_header:\n                sequences[current_header] = ''.join(current_sequence)\n                current_sequence = []\n            current_header = line[1:]\n        else:\n            current_sequence.append(line)\n    \n    # 마지막 시퀀스 처리\n    if current_header:\n        sequences[current_header] = ''.join(current_sequence)\n    \n    return sequences\n\ndef overlap(s1, s2):\n    max_len = min(len(s1), len(s2))\n    for i in range(max_len, 0, -1):\n        if s1[-i:] == s2[:i]:\n            return i\n    return 0\n\ndef shortest_superstring(dna_sequences):\n    strings = list(dna_sequences.values())\n    n = len(strings)\n    \n    while n &gt; 1:\n        max_overlap = -1\n        best_i, best_j = -1, -1\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    overlap_len = overlap(strings[i], strings[j])\n                    if overlap_len &gt; max_overlap:\n                        max_overlap = overlap_len\n                        best_i, best_j = i, j\n        \n        if max_overlap &gt; 0:\n            strings[best_i] += strings[best_j][max_overlap:]\n            strings.pop(best_j)\n            n -= 1\n        else:\n            break\n    \n    return strings[0]\n\n# 예시로 주어진 FASTA 형식 텍스트\nfasta_text = '''&gt;Rosalind_56\nATTAGACCTG\n&gt;Rosalind_57\nCCTGCCGGAA\n&gt;Rosalind_58\nAGACCTGCCG\n&gt;Rosalind_59\nGCCGGAATAC'''\n\n# FASTA 형식 텍스트를 파싱하여 DNA 시퀀스 딕셔너리를 얻음\ndna_sequences = parse_fasta(fasta_text)\n\n# 최단 슈퍼스트링 계산\nresult = shortest_superstring(dna_sequences)\nprint(\"Shortest superstring:\", result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#코드-설명",
    "href": "posts/qmd/Rosalind_stronghold.html#코드-설명",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "25.4 코드 설명",
    "text": "25.4 코드 설명\n\nparse_fasta 함수: 입력으로 받은 FASTA 형식 텍스트를 파싱하여 시퀀스 헤더를 키로, 시퀀스를 값으로 갖는 딕셔너리를 반환합니다.\noverlap 함수: 두 문자열 사이의 최대 겹치는 길이를 계산합니다.\nshortest_superstring 함수: DNA 시퀀스들을 최단 슈퍼스트링으로 합치는 과정을 반복하여 수행합니다. 각 반복에서 가장 많이 겹치는 두 시퀀스를 찾아 이어붙이고, 필요 없는 시퀀스는 제거합니다.\n예시 입력 (fasta_text): 문제에서 제공된 예시 FASTA 형식의 텍스트입니다. 이를 통해 각 DNA 시퀀스를 추출하여 최단 슈퍼스트링을 계산합니다.\n결과 출력: 계산된 최단 슈퍼스트링을 출력합니다.\n\n이 코드를 실행하면 주어진 FASTA 형식 텍스트에서 DNA 시퀀스들을 추출하고, 이를 이용하여 최단 슈퍼스트링을 계산하여 출력합니다."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-25",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-25",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.1 Sample Dataset",
    "text": "26.1 Sample Dataset\n&gt;Rosalind_23\nAGCUAGUCAU"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-26",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-26",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.2 Sample Output",
    "text": "26.2 Sample Output\n12"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-23",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-23",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.3 Solution",
    "text": "26.3 Solution\nTo solve the problem of calculating the total number of perfect matchings in the bonding graph of an RNA string s, we can break down the solution into clear steps:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-5",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.4 Steps to Solve the Problem",
    "text": "26.4 Steps to Solve the Problem\n\nParse the Input: Extract the RNA string from the input, ignoring the header line (if any).\nCount Nucleotide Pairs: Count the occurrences of each nucleotide (A, U, C, G) in the RNA string s.\nCalculate Perfect Matchings:\n\nThe number of perfect matchings in the bonding graph of s is determined by pairing each A with a U and each C with a G.\nCompute the factorial of half the count of each nucleotide pair (A with U and C with G). This gives the number of ways to form perfect matchings for each pair.\n\nOutput the Result: Print the computed number of perfect matchings."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#python-implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#python-implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.5 Python Implementation",
    "text": "26.5 Python Implementation\nHere’s the Python code that implements the above approach:\nimport math\n\ndef count_nucleotides(s):\n    count_A = s.count('A')\n    count_U = s.count('U')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    return count_A, count_U, count_C, count_G\n\ndef calculate_perfect_matchings(s):\n    count_A, count_U, count_C, count_G = count_nucleotides(s)\n    \n    # Check if counts of A == U and C == G\n    if count_A != count_U or count_C != count_G:\n        return 0\n    \n    # Calculate number of perfect matchings\n    perfect_matchings = math.factorial(count_A) * math.factorial(count_C)\n    \n    return perfect_matchings\n\n# Example usage with sample dataset\nrna_string = \"AGCUAGUCAU\"\n\nresult = calculate_perfect_matchings(rna_string)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-2",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "26.6 Explanation of the Code",
    "text": "26.6 Explanation of the Code\n\ncount_nucleotides: This function counts the occurrences of A, U, C, and G in the RNA string s.\ncalculate_perfect_matchings:\n\nIt first calls count_nucleotides to get the counts of each nucleotide.\nChecks if the counts of A equal U and C equal G. If not, it returns 0 since perfect matchings are not possible.\nCalculates the number of perfect matchings using factorials of half the counts of A and C (since each A pairs with a U and each C pairs with a G).\n\nExample Usage:\n\nIt demonstrates how to use the calculate_perfect_matchings function with the RNA string \"AGCUAGUCAU\", which is given in the sample dataset.\nThe result is printed, which in this case would be 12, indicating the total number of perfect matchings in the bonding graph of \"AGCUAGUCAU\".\n\n\nThis code efficiently calculates the required number of perfect matchings based on the properties of RNA and the bonding rules specified. Adjustments can be made to handle different inputs as needed, ensuring accurate computation of perfect matchings."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-26",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-26",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "27.1 Sample Dataset",
    "text": "27.1 Sample Dataset\n21 7"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-27",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-27",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "27.2 Sample Output",
    "text": "27.2 Sample Output\n51200"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-24",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-24",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "27.3 Solution",
    "text": "27.3 Solution\nTo solve the problem of calculating the number of partial permutations \\(P(n, k)\\), where \\(P(n, k) = \\frac{n!}{(n-k)!}\\), we need to consider the constraints provided and handle computations under a modulo operation.\nHere’s a step-by-step approach to implement the solution:\n\nRead Input: Extract integers \\(n\\) and \\(k\\) from the input.\nCompute Factorials: Calculate \\(n!\\) and \\((n-k)!\\) using factorial computations. Since \\(n\\) can be up to 100, Python’s built-in math.factorial function is suitable for this task.\nCompute Partial Permutations: Compute \\(P(n, k)\\) using the formula \\(P(n, k) = \\frac{n!}{(n-k)!}\\).\nApply Modulo Operation: Since the result needs to be modulo \\(1,000,000\\), compute the result using % 1,000,000 to prevent overflow and adhere to the problem’s requirement.\nOutput the Result: Print the computed result.\n\nHere’s the Python code that implements the above plan:\nimport math\n\ndef partial_permutations(n, k):\n    # Calculate n!\n    n_fact = math.factorial(n)\n    \n    # Calculate (n-k)!\n    nk_fact = math.factorial(n - k)\n    \n    # Calculate P(n, k) = n! / (n-k)!\n    P_n_k = n_fact // nk_fact\n    \n    # Return P(n, k) % 1,000,000\n    return P_n_k % 1000000\n\n# Example usage with sample dataset\nn, k = 21, 7\nresult = partial_permutations(n, k)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-14",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-14",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "27.4 Explanation",
    "text": "27.4 Explanation\n\nmath.factorial: This function from the math module efficiently computes factorials, which is crucial given the constraints \\(n \\leq 100\\).\npartial_permutations function:\n\nComputes \\(n!\\) and \\((n-k)!\\).\nComputes \\(P(n, k)\\) using integer division // to ensure the result is an integer.\nApplies the modulo operation % 1,000,000 to handle large numbers and ensure the result fits within the specified range.\n\nExample Usage:\n\nThe code snippet demonstrates how to compute \\(P(21, 7)\\) using the partial_permutations function and prints the result.\n\n\nThis approach efficiently computes the required number of partial permutations while adhering to the constraints and output requirements specified in the problem statement."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#hint",
    "href": "posts/qmd/Rosalind_stronghold.html#hint",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "28.1 Hint",
    "text": "28.1 Hint\nOne property of the logarithm function is that for any positive numbers \\(x\\) and \\(y\\), \\(\\log_{10}(x⋅y)= \\log_{10}(x)+ \\log_{10}(y)\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-27",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-27",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "28.2 Sample Dataset",
    "text": "28.2 Sample Dataset\nACGATACAA\n0.129 0.287 0.423 0.476 0.641 0.742 0.783"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-28",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-28",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "28.3 Sample Output",
    "text": "28.3 Sample Output\n-5.737 -5.217 -5.263 -5.360 -5.958 -6.628 -7.009"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-25",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-25",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "28.4 Solution",
    "text": "28.4 Solution\nimport math\n\ndef calculate_log_probabilities(s, gc_contents):\n    \"\"\"\n    Calculate the logarithm of the probabilities of the DNA string s\n    matching random strings generated with different GC-contents.\n\n    Parameters:\n    s (str): DNA string\n    gc_contents (list of float): List of GC-content values\n\n    Returns:\n    list of float: List of log probabilities for each GC-content\n    \"\"\"\n    log_probs = [calculate_log_prob_for_gc_content(s, gc_content) for gc_content in gc_contents]\n    return log_probs\n\ndef calculate_log_prob_for_gc_content(s, gc_content):\n    \"\"\"\n    Calculate the logarithm of the probability of the DNA string s\n    given a specific GC-content.\n\n    Parameters:\n    s (str): DNA string\n    gc_content (float): GC-content value\n\n    Returns:\n    float: Logarithm of the probability\n    \"\"\"\n    p_gc = gc_content / 2\n    p_at = (1 - gc_content) / 2\n    log_prob = sum(math.log10(p_gc if nucleotide in 'GC' else p_at) for nucleotide in s)\n    return log_prob\n\ndef parse_input(input_string):\n    \"\"\"\n    Parse the input string to extract the DNA string and GC-content values.\n\n    Parameters:\n    input_string (str): Input string containing the DNA string and GC-content values\n\n    Returns:\n    tuple: DNA string and list of GC-content values\n    \"\"\"\n    lines = input_string.strip().split('\\n')\n    s = lines[0]\n    gc_contents = list(map(float, lines[1].split()))\n    return s, gc_contents\n\ndef format_output(log_probs):\n    \"\"\"\n    Format the output to match the required format.\n\n    Parameters:\n    log_probs (list of float): List of log probabilities\n\n    Returns:\n    str: Formatted output string\n    \"\"\"\n    return ' '.join(f'{x:f}' for x in log_probs)\n\n# Example usage:\ninput_string = \"\"\"ACGATACAA\n0.129 0.287 0.423 0.476 0.641 0.742 0.783\"\"\"\n\ns, gc_contents = parse_input(input_string)\nlog_probs = calculate_log_probabilities(s, gc_contents)\noutput = format_output(log_probs)\nprint(output)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-3",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "28.5 Explanation of the Code",
    "text": "28.5 Explanation of the Code\n\nFunction calculate_log_probabilities:\n\nThis is the main function that calculates the log probabilities for each GC-content in the input list.\nIt uses a list comprehension to call calculate_log_prob_for_gc_content for each GC-content value.\n\nFunction calculate_log_prob_for_gc_content:\n\nThis function calculates the log probability for a specific GC-content value.\nIt computes the probabilities of G/C and A/T based on the GC-content.\nIt sums the logarithms of the probabilities of each nucleotide in the DNA string s.\n\nFunction parse_input:\n\nThis function parses the input string to extract the DNA string and the list of GC-content values.\nIt splits the input string into lines and processes them accordingly.\n\nFunction format_output:\n\nThis function formats the list of log probabilities to the required output format.\nIt uses a list comprehension to format each log probability to three decimal places."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-28",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-28",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "29.1 Sample Dataset",
    "text": "29.1 Sample Dataset\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-29",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-29",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "29.2 Sample Output",
    "text": "29.2 Sample Output\n8\n-1 -2\n-1 2\n1 -2\n1 2\n-2 -1\n-2 1\n2 -1\n2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-26",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-26",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "29.3 solution",
    "text": "29.3 solution\nTo generate the correct total number of signed permutations and their combinations, we need to combine each permutation of the numbers with all possible sign variations correctly. Here’s the revised approach:\n\nGenerate Permutations: First, generate all possible permutations of the integers from 1 to \\(n\\).\nGenerate Signed Permutations: For each permutation, generate all possible signed versions of that permutation. Each integer in the permutation can be either positive or negative.\nCombine and Output: Combine all the signed permutations and output the total count followed by all the signed permutations.\n\nHere’s the corrected implementation:\nfrom itertools import permutations, product\n\ndef signed_permutations(n):\n    # Generate all permutations of length n\n    perms = list(permutations(range(1, n + 1)))\n    \n    # Generate all possible signed permutations\n    signed_perms = []\n    for perm in perms:\n        for signs in product([-1, 1], repeat=n):\n            signed_perm = [a * sign for a, sign in zip(perm, signs)]\n            signed_perms.append(signed_perm)\n    \n    return signed_perms\n\n# Read the input\nn = 2  # Example input, you can change this value\n\n# Get all signed permutations\nresult = signed_permutations(n)\n\n# Output the total number of signed permutations\nprint(len(result))\n\n# Output each signed permutation\nfor perm in result:\n    print(' '.join(map(str, perm)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-15",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-15",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "29.4 Explanation",
    "text": "29.4 Explanation\n\nGenerating Permutations:\n\nUse itertools.permutations to generate all permutations of the integers from 1 to \\(n\\).\n\nGenerating Signed Permutations:\n\nFor each permutation, we use itertools.product to generate all possible sign combinations (each element can be either -1 or 1).\nFor each sign combination, multiply each element of the permutation with the respective sign to create a signed permutation.\n\nCombining and Output:\n\nWe store all the signed permutations in a list.\nFirst, print the total number of signed permutations.\nThen, print each signed permutation.\n\n\nThis should correctly generate all signed permutations and output them in the desired format. The total number of signed permutations for a given \\(n\\) is \\(n! \\times 2^n\\), ensuring all combinations of signs and orderings are included."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-29",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-29",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "30.1 Sample Dataset",
    "text": "30.1 Sample Dataset\n&gt;Rosalind_14\nACGTACGTGACG\n&gt;Rosalind_18\nGTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-30",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-30",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "30.2 Sample Output",
    "text": "30.2 Sample Output\n3 4 5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-27",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-27",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "30.3 Solution",
    "text": "30.3 Solution\nThank you for the clarification. Let’s refine the approach to ensure it correctly finds the indices of the subsequence.\nHere’s the corrected version of the code without any hardcoding:\ndef parse_fasta(fasta_str):\n    sequences = []\n    current_seq = []\n    for line in fasta_str.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_seq:\n                sequences.append(''.join(current_seq))\n                current_seq = []\n        else:\n            current_seq.append(line)\n    if current_seq:\n        sequences.append(''.join(current_seq))\n    return sequences\n\ndef find_spliced_motif(s, t):\n    indices = []\n    t_index = 0\n    \n    for s_index in range(len(s)):\n        if t_index &lt; len(t) and s[s_index] == t[t_index]:\n            indices.append(s_index + 1)\n            t_index += 1\n            if t_index == len(t):\n                break\n    \n    return indices\n\n# Sample input\nfasta_input = \"\"\"&gt;Rosalind_14\nACGTACGTGACG\n&gt;Rosalind_18\nGTA\"\"\"\n\nsequences = parse_fasta(fasta_input)\ns = sequences[0]\nt = sequences[1]\n\nresult = find_spliced_motif(s, t)\nprint(' '.join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-16",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-16",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "30.4 Explanation",
    "text": "30.4 Explanation\n\nparse_fasta Function:\n\nThis function parses the input FASTA string into sequences. It collects lines of sequences until it encounters a new sequence identifier (a line starting with &gt;). This function does not hardcode sequence identifiers and can handle any number of sequences.\n\nfind_spliced_motif Function:\n\nThis function searches for the subsequence t within the sequence s and returns the 1-based indices of s where the characters of t appear in order.\nIt uses a single loop over s to find matches for the characters in t.\nIt stops searching as soon as it finds all characters of t within s.\n\n\nThe sample dataset should now correctly produce the output 3 8 10."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-30",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-30",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "31.1 Sample Dataset",
    "text": "31.1 Sample Dataset\n&gt;Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n&gt;Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-31",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-31",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "31.2 Sample Output",
    "text": "31.2 Sample Output\n1.21428571429"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-28",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-28",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "31.3 Solution",
    "text": "31.3 Solution\nTo solve the problem of calculating the transition/transversion ratio, we need to perform the following steps:\n\nParse the input data to extract the two DNA sequences.\nDefine transition and transversion mutations:\n\nTransitions are interchanges of two purines (A &lt;-&gt; G) or two pyrimidines (C &lt;-&gt; T).\nTransversions are interchanges between a purine and a pyrimidine (A &lt;-&gt; C, A &lt;-&gt; T, G &lt;-&gt; C, G &lt;-&gt; T).\n\nCount the number of transitions and transversions between the two sequences.\nCalculate the ratio of transitions to transversions."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#step-by-step-implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#step-by-step-implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "31.4 Step-by-step Implementation",
    "text": "31.4 Step-by-step Implementation\n\nParsing the Input:\n\nRead the input in FASTA format.\nExtract the sequences associated with each identifier.\n\nCounting Mutations:\n\nCompare each base of the two sequences.\nIncrement the transition count if a transition mutation is found.\nIncrement the transversion count if a transversion mutation is found.\n\nCalculating the Ratio:\n\nCompute the ratio of the number of transitions to the number of transversions.\n\n\nHere’s the Python implementation of the solution:\ndef parse_fasta(fasta_str):\n    sequences = []\n    current_seq = []\n    for line in fasta_str.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_seq:\n                sequences.append(''.join(current_seq))\n                current_seq = []\n        else:\n            current_seq.append(line)\n    if current_seq:\n        sequences.append(''.join(current_seq))\n    return sequences\n\ndef count_transitions_transversions(s1, s2):\n    transitions = 0\n    transversions = 0\n    \n    transitions_set = {('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')}\n    \n    for base1, base2 in zip(s1, s2):\n        if base1 != base2:\n            if (base1, base2) in transitions_set:\n                transitions += 1\n            else:\n                transversions += 1\n                \n    return transitions, transversions\n\ndef transition_transversion_ratio(s1, s2):\n    transitions, transversions = count_transitions_transversions(s1, s2)\n    if transversions == 0:\n        return float('inf')  # or some other large number or special case\n    return transitions / transversions\n\n# Sample input\nfasta_input = \"\"\"&gt;Rosalind_0209\nGCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA\nAGTACGGGCATCAACCCAGTT\n&gt;Rosalind_2200\nTTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC\nGGTACGAGTGTTCCTTTGGGT\"\"\"\n\nsequences = parse_fasta(fasta_input)\ns1 = sequences[0]\ns2 = sequences[1]\n\nresult = transition_transversion_ratio(s1, s2)\nprint(f\"{result:.11f})"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-17",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-17",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "31.5 Explanation",
    "text": "31.5 Explanation\n\nparse_fasta Function:\n\nThis function parses the FASTA formatted input to extract sequences. It handles multiple sequences and collects lines until a new identifier is found.\n\ncount_transitions_transversions Function:\n\nThis function takes two DNA sequences and counts the transitions and transversions by comparing each nucleotide in the two sequences.\nIt uses a set of tuples to check if a given mutation is a transition.\n\ntransition_transversion_ratio Function:\n\nThis function calculates the ratio of transitions to transversions. If there are no transversions, it handles this by returning infinity or some other large number."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-31",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-31",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "32.1 Sample Dataset",
    "text": "32.1 Sample Dataset\n10\n1 2\n2 8\n4 10\n5 9\n6 10\n7 9"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-32",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-32",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "32.2 Sample Output",
    "text": "32.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-29",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-29",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "32.3 Solution",
    "text": "32.3 Solution\nTo solve the problem of determining the minimum number of edges needed to make a given graph a tree, we can follow these steps:\n\nUnderstand the Input and Output:\n\nThe input consists of an integer n, which is the number of nodes, followed by a list of edges given as pairs of integers.\nThe output should be the minimum number of edges required to make the graph a tree.\n\nConcepts:\n\nA tree is a connected graph with no cycles.\nFor a graph with n nodes to be a tree, it must have exactly n-1 edges.\nIf the graph has fewer than n-1 edges, it must be connected. If it is not connected, it will have multiple connected components.\n\nAlgorithm:\n\nUse a graph traversal algorithm (e.g., Depth-First Search (DFS) or Breadth-First Search (BFS)) to find all the connected components of the graph.\nCount the number of connected components, c.\nThe minimum number of edges needed to connect all components to form a single connected component (tree) is c-1.\n\n\nHere is the implementation in Python:\ndef find_connected_components(n, edges):\n    from collections import defaultdict, deque\n\n    def bfs(start):\n        queue = deque([start])\n        visited.add(start)\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n    num_components = 0\n\n    for node in range(1, n + 1):\n        if node not in visited:\n            bfs(node)\n            num_components += 1\n\n    return num_components\n\ndef min_edges_to_tree(n, edges):\n    num_components = find_connected_components(n, edges)\n    return num_components - 1\n\ndef parse_input(input_text):\n    lines = input_text.strip().split('\\n')\n    n = int(lines[0])\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n    return n, edges\n\n# Sample input\ninput_text = \"\"\"\n10\n1 2\n2 8\n4 10\n5 9\n6 10\n7 9\n\"\"\"\n\nn, edges = parse_input(input_text)\nresult = min_edges_to_tree(n, edges)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-18",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-18",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "32.4 Explanation",
    "text": "32.4 Explanation\n\nfind_connected_components Function:\n\nThis function remains the same, using BFS to find the number of connected components in the graph.\n\nmin_edges_to_tree Function:\n\nThis function remains the same, calculating the minimum number of edges required to connect all components into a single tree.\n\nparse_input Function:\n\nThis function takes the input as a string, splits it into lines, and processes the first line to get the number of nodes n.\nThe remaining lines are processed to extract the edges as tuples of integers.\n\nSample Input and Running the Code:\n\nThe sample input is provided as a multi-line string.\nThe parse_input function parses this string to extract n and the list of edges.\nThe min_edges_to_tree function calculates the result and prints it.\n\n\nThe expected output for the provided sample input is 3, which is the minimum number of edges required to make the graph a tree."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-32",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-32",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "33.1 Sample Dataset",
    "text": "33.1 Sample Dataset\n&gt;Rosalind_57\nAUAU"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-33",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-33",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "33.2 Sample Output",
    "text": "33.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-30",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-30",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "33.3 Solution",
    "text": "33.3 Solution\ndef solve(rna):\n    \"\"\"\n    Given an RNA string consisting of {A, U, C, G},\n    calculates the number of non-overlapping perfect matchings.\n\n    Parameters:\n    rna (str): The RNA string.\n\n    Returns:\n    int: The number of non-overlapping perfect matchings modulo 1,000,000.\n    \"\"\"\n    return count_non_crossing_matchings(rna) % 1000000\n\ndef count_non_crossing_matchings(rna):\n    \"\"\"\n    Helper function that recursively calculates the number of non-crossing perfect matchings\n    of base pairs in the RNA string.\n\n    Parameters:\n    rna (str): The RNA string.\n    \n    Returns:\n    int: The number of non-crossing perfect matchings modulo 1,000,000.\n    \"\"\"\n    # Define complementary nucleotides\n    mapping = {\n        \"A\": \"U\",\n        \"U\": \"A\",\n        \"G\": \"C\",\n        \"C\": \"G\"\n    }\n    \n    n = len(rna)\n    \n    # If the length of the RNA string is odd, return 0\n    if n % 2 != 0:\n        return 0\n    \n    # Memoization dictionary\n    dp = {}\n    \n    def helper(lo, hi):\n        \"\"\"\n        Recursive helper function that computes the number of non-crossing perfect matchings\n        between indices lo and hi in the RNA string.\n\n        Parameters:\n        lo (int): Start index of the substring.\n        hi (int): End index of the substring.\n\n        Returns:\n        int: Number of non-crossing perfect matchings between indices lo and hi.\n        \"\"\"\n        # Base cases\n        if lo &gt;= hi:\n            return 1\n        if (lo, hi) in dp:\n            return dp[(lo, hi)]\n        \n        curr = rna[lo]\n        target = mapping[curr]\n        acc = 0\n        \n        # Iterate through the possible pairs\n        for i in range(lo + 1, hi + 1, 2):\n            if rna[i] == target:\n                left = helper(lo + 1, i - 1)\n                right = helper(i + 1, hi)\n                acc += (left * right) % 1000000\n        \n        dp[(lo, hi)] = acc % 1000000\n        return dp[(lo, hi)]\n    \n    # Call the helper function starting from index 0 to n-1\n    return helper(0, n - 1)\n\n# Parsing the input\ndef parse_fasta(fasta_str):\n    sequences = {}\n    current_label = None\n    \n    for line in fasta_str.strip().split(\"\\n\"):\n        if line.startswith(\"&gt;\"):\n            current_label = line[1:].strip()\n            sequences[current_label] = \"\"\n        else:\n            sequences[current_label] += line.strip()\n    \n    return sequences\n\n# Sample Input in FASTA format\nfasta_input = \"\"\"\n&gt;Rosalind_9378\nAUAU\n\"\"\"\n\n# Parse the input to get the RNA string\nsequences = parse_fasta(fasta_input)\nrna_string = list(sequences.values())[0]\n\n# Output the result\nprint(solve(rna_string))  # Output should be 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-19",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-19",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "33.4 Explanation",
    "text": "33.4 Explanation\n\nsolve(rna) function:\n\nThis function is the entry point that computes and returns the number of non-overlapping perfect matchings of the RNA string modulo 1,000,000.\nIt calls count_non_crossing_matchings(rna) and returns its result modulo 1,000,000.\n\ncount_non_crossing_matchings(rna) function:\n\nThis is the core function that recursively computes the number of non-crossing perfect matchings.\nIt uses a helper function helper(lo, hi) which performs the recursive computation.\nThe function checks for edge cases such as odd length of RNA string and uses memoization (dp dictionary) to store already computed results to avoid redundant computations.\nIt iterates through possible pairs of nucleotides and calculates the number of matchings recursively using the defined base cases and recurrence relations.\n\nparse_fasta(fasta_str) function:\n\nThis function parses the given FASTA formatted input string and extracts the RNA sequence from it.\nIt returns a dictionary where the key is the label (e.g., Rosalind_9378) and the value is the RNA sequence.\n\nUsage:\n\nThe sample input in FASTA format is parsed to obtain the RNA sequence.\nThe solve function is called with the RNA sequence as input, and the result is printed out.\n\n\nThis approach efficiently computes the desired number of non-crossing perfect matchings using recursion with memoization, ensuring that the computation remains feasible even for longer RNA sequences up to 300 base pairs."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-33",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-33",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "34.1 Sample Dataset",
    "text": "34.1 Sample Dataset\n&gt;Rosalind_52\nTCATC\n&gt;Rosalind_44\nTTCAT\n&gt;Rosalind_68\nTCATC\n&gt;Rosalind_28\nTGAAA\n&gt;Rosalind_95\nGAGGA\n&gt;Rosalind_66\nTTTCA\n&gt;Rosalind_33\nATCAA\n&gt;Rosalind_21\nTTGAT\n&gt;Rosalind_18\nTTTCC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-34",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-34",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "34.2 Sample Output",
    "text": "34.2 Sample Output\nTTCAT-&gt;TTGAT\nGAGGA-&gt;GATGA\nTTTCC-&gt;TTTCA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-31",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-31",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "34.3 Solution",
    "text": "34.3 Solution\n\nParse the FASTA format input to extract reads.\nIdentify correct reads:\n\nReads that appear at least twice or appear once but their reverse complement also appears at least once.\n\nIdentify incorrect reads:\n\nReads that appear exactly once and do not have their reverse complement in the list of correct reads.\n\nCorrect the errors:\n\nFor each incorrect read, find the correct read that has a Hamming distance of 1 with the incorrect read or its reverse complement.\n\nOutput the corrections."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#step-by-step-implementation-1",
    "href": "posts/qmd/Rosalind_stronghold.html#step-by-step-implementation-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "34.4 Step-by-step Implementation",
    "text": "34.4 Step-by-step Implementation\nHere’s the revised Python code to achieve the above steps:\ndef parse_fasta(fasta_str):\n    \"\"\"\n    Parses a FASTA formatted string.\n    \"\"\"\n    sequences = {}\n    current_label = None\n    for line in fasta_str.strip().split(\"\\n\"):\n        if line.startswith(\"&gt;\"):\n            current_label = line[1:].strip()\n            sequences[current_label] = \"\"\n        else:\n            sequences[current_label] += line.strip()\n    return sequences\n\ndef reverse_complement(dna):\n    \"\"\"\n    Returns the reverse complement of a DNA string.\n    \"\"\"\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return \"\".join(complement[base] for base in reversed(dna))\n\ndef hamming_distance(s1, s2):\n    \"\"\"\n    Calculates the Hamming distance between two strings.\n    \"\"\"\n    return sum(1 for a, b in zip(s1, s2) if a != b)\n\ndef find_correct_reads(reads):\n    \"\"\"\n    Identifies the correct reads in the dataset.\n    \"\"\"\n    from collections import defaultdict\n    \n    read_counts = defaultdict(int)\n    for read in reads:\n        read_counts[read] += 1\n        read_counts[reverse_complement(read)] += 1\n    \n    correct_reads = {read for read, count in read_counts.items() if count &gt; 1}\n    return correct_reads\n\ndef find_corrections(reads, correct_reads):\n    \"\"\"\n    Identifies corrections needed for the erroneous reads.\n    \"\"\"\n    corrections = []\n    for read in reads:\n        if read not in correct_reads:\n            for correct_read in correct_reads:\n                if hamming_distance(read, correct_read) == 1:\n                    corrections.append(f\"{read}-&gt;{correct_read}\")\n                    break\n                elif hamming_distance(read, reverse_complement(correct_read)) == 1:\n                    corrections.append(f\"{read}-&gt;{reverse_complement(correct_read)}\")\n                    break\n    return corrections\n\n# Sample Input in FASTA format\nfasta_input = \"\"\"\n&gt;Rosalind_52\nTCATC\n&gt;Rosalind_44\nTTCAT\n&gt;Rosalind_68\nTCATC\n&gt;Rosalind_28\nTGAAA\n&gt;Rosalind_95\nGAGGA\n&gt;Rosalind_66\nTTTCA\n&gt;Rosalind_33\nATCAA\n&gt;Rosalind_21\nTTGAT\n&gt;Rosalind_18\nTTTCC\n\"\"\"\n\n# Parsing the input\nsequences = parse_fasta(fasta_input)\nreads = list(sequences.values())\n\n# Find correct reads\ncorrect_reads = find_correct_reads(reads)\n\n# Find necessary corrections\ncorrections = find_corrections(reads, correct_reads)\n\n# Output the corrections\nfor correction in corrections:\n    print(correction)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-20",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-20",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "34.5 Explanation",
    "text": "34.5 Explanation\n\nparse_fasta(fasta_str): Parses the input FASTA formatted string to extract the reads.\nreverse_complement(dna): Returns the reverse complement of a given DNA string.\nhamming_distance(s1, s2): Computes the Hamming distance between two strings.\nfind_correct_reads(reads): Identifies reads that are correct (appear at least twice considering both original and reverse complement).\nfind_corrections(reads, correct_reads): Identifies the necessary corrections for erroneous reads by checking each read against the set of correct reads and their reverse complements."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-34",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-34",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "35.1 Sample Dataset",
    "text": "35.1 Sample Dataset\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-35",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-35",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "35.2 Sample Output",
    "text": "35.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-32",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-32",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "35.3 Solution",
    "text": "35.3 Solution\nTo solve the problem of finding the number of internal nodes in an unrooted binary tree given \\(n\\) leaves, let’s delve into some tree properties and the characteristics of unrooted binary trees."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-concepts-and-approach",
    "href": "posts/qmd/Rosalind_stronghold.html#key-concepts-and-approach",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "35.4 Key Concepts and Approach",
    "text": "35.4 Key Concepts and Approach\n\nTree Properties:\n\nAn unrooted binary tree is a tree where every internal node has exactly three connections (degree 3), and each leaf node has one connection (degree 1).\n\nLeaves and Internal Nodes Relationship:\n\nIn any tree, if we let \\(L\\) be the number of leaves and \\(I\\) be the number of internal nodes, for an unrooted binary tree, there is a specific relationship:\nFor every new leaf added to maintain the tree as binary, you essentially add a new internal node to accommodate the structure.\n\nMathematical Relationship:\n\nIt is known that for an unrooted binary tree with \\(n\\) leaves, the number of internal nodes \\(I\\) is given by: [ I = n - 2 ]\nThis is derived from the fact that the total number of nodes in an unrooted binary tree with \\(n\\) leaves is \\(2n - 2\\). Out of these, \\(n\\) are leaves, and the remaining \\(n - 2\\) are internal nodes."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-4",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "35.5 Implementation",
    "text": "35.5 Implementation\nGiven this understanding, the implementation to find the number of internal nodes in an unrooted binary tree with \\(n\\) leaves is straightforward. Here’s the Python code to accomplish this:\ndef count_internal_nodes(n):\n    return n - 2\n\n# Sample Input\nn = 4\nprint(count_internal_nodes(n))  # Output should be 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-35",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-35",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.1 Sample Dataset",
    "text": "36.1 Sample Dataset\n&gt;Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-36",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-36",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.2 Sample Output",
    "text": "36.2 Sample Output\n4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-33",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-33",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.3 Solution",
    "text": "36.3 Solution\nTo solve the problem of finding the 4-mer composition of a given DNA string, we need to follow these steps:\n\nParse the input FASTA format to extract the DNA sequence.\nGenerate all possible 4-mers from the given DNA alphabet.\nCount the occurrences of each 4-mer in the DNA sequence.\nOutput the counts in lexicographical order of the 4-mers."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-explanation",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-explanation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.4 Detailed Explanation",
    "text": "36.4 Detailed Explanation\n\nParsing the FASTA format: The input DNA sequence is provided in FASTA format. We need to extract the actual DNA string from this format.\nGenerating all possible 4-mers: A 4-mer is a sequence of 4 nucleotides. Since the DNA alphabet consists of {A, C, G, T}, there are $4^4 = 256) possible 4-mers. We can generate these 4-mers lexicographically (sorted order).\nCounting occurrences of each 4-mer: We will slide a window of length 4 acros the DNA sequence and count how many times each 4-mer appears.\nOutput the results: We output the counts of each 4-mer in the lexicographical order."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#python-implementation-1",
    "href": "posts/qmd/Rosalind_stronghold.html#python-implementation-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.5 Python Implementation",
    "text": "36.5 Python Implementation\nHere is the complete Python code that implements the above steps:\nfrom itertools import product\n\ndef parse_fasta(fasta_str):\n    sequences = {}\n    current_label = None\n    \n    for line in fasta_str.strip().split(\"\\n\"):\n        if line.startswith(\"&gt;\"):\n            current_label = line[1:].strip()\n            sequences[current_label] = \"\"\n        else:\n            sequences[current_label] += line.strip()\n    \n    return sequences\n\ndef generate_kmers(k, alphabet='ACGT'):\n    return [''.join(p) for p in product(alphabet, repeat=k)]\n\ndef count_kmers(dna, k):\n    kmer_counts = {}\n    for i in range(len(dna) - k + 1):\n        kmer = dna[i:i+k]\n        if kmer in kmer_counts:\n            kmer_counts[kmer] += 1\n        else:\n            kmer_counts[kmer] = 1\n    return kmer_counts\n\ndef kmer_composition(dna, k=4):\n    kmers = generate_kmers(k)\n    kmer_counts = count_kmers(dna, k)\n    \n    return [kmer_counts.get(kmer, 0) for kmer in kmers]\n\n# Sample Input in FASTA format\nfasta_input = \"\"\"\n&gt;Rosalind_6431\nCTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG\nCCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT\nTTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA\nAATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG\nGGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA\nCTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA\nCCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG\n\"\"\"\n\n# Parsing the input\nsequences = parse_fasta(fasta_input)\n\n# There should be only one sequence in the given input\ndna_string = list(sequences.values())[0]\n\n# Getting the 4-mer composition\ncomposition = kmer_composition(dna_string, k=4)\n\n# Printing the result\nprint(\" \".join(map(str, composition)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-4",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "36.6 Explanation of the Code",
    "text": "36.6 Explanation of the Code\n\nparse_fasta(fasta_str): This function parses the input FASTA format string and returns a dictionary of sequences.\ngenerate_kmers(k, alphabet=‘ACGT’): This function generates all possible k-mers of length k using the given alphabet.\ncount_kmers(dna, k): This function counts the occurrences of each k-mer in the DNA sequence.\nkmer_composition(dna, k=4): This function calculates the k-mer composition by using the previous two functions. It returns a list of counts of each k-mer in lexicographical order.\nThe main block: Parses the input, extracts the DNA sequence, computes the 4-mer composition, and prints the results."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-36",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-36",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.1 Sample Dataset",
    "text": "37.1 Sample Dataset\n&gt;Rosalind_87\nCAGCATGGTATCACAGCAGAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-37",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-37",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.2 Sample Output",
    "text": "37.2 Sample Output\n0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-34",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-34",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.3 Solution",
    "text": "37.3 Solution\nTo solve the problem of computing the failure array of a given DNA string in FASTA format, we need to follow these steps:\n\nParse the input FASTA format to extract the DNA sequence.\nCompute the failure array using the Knuth-Morris-Prat (KMP) algorithm.\nOutput the failure array."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-1",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.4 Detailed Explanation",
    "text": "37.4 Detailed Explanation\n\nParsing the FASTA format: We need to extract the actual DNA string from the provided FASTA format.\nComputing the Failure Array: The failure array is computed using the KMP preprocessing algorithm. The failure array P at position k represents the length of the longest prefix of the substring s[1:k] that is also a suffix of this substring."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#python-implementation-2",
    "href": "posts/qmd/Rosalind_stronghold.html#python-implementation-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.5 Python Implementation",
    "text": "37.5 Python Implementation\nHere is the complete Python code that implements the above steps:\ndef parse_fasta(fasta_str):\n    \"\"\"\n    Parses a FASTA format string and returns the DNA sequence.\n    \"\"\"\n    sequences = []\n    for line in fasta_str.strip().split(\"\\n\"):\n        if not line.startswith(\"&gt;\"):\n            sequences.append(line.strip())\n    return \"\".join(sequences)\n\ndef compute_failure_array(s):\n    \"\"\"\n    Computes the failure array for a given string s using the KMP algorithm.\n    \"\"\"\n    n = len(s)\n    P = [0] * n\n    k = 0\n    \n    for i in range(1, n):\n        while k &gt; 0 and s[k] != s[i]:\n            k = P[k - 1]\n        \n        if s[k] == s[i]:\n            k += 1\n        \n        P[i] = k\n    \n    return P\n\n# Sample Input in FASTA format\nfasta_input = \"\"\"\n&gt;Rosalind_87\nCAGCATGGTATCACAGCAGAG\n\"\"\"\n\n# Parsing the input\ndna_string = parse_fasta(fasta_input)\n\n# Computing the failure array\nfailure_array = compute_failure_array(dna_string)\n\n# Printing the result\nprint(\" \".join(map(str, failure_array)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-5",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "37.6 Explanation of the Code",
    "text": "37.6 Explanation of the Code\n\nparse_fasta(fasta_str): This function parses the input FASTA format string and returns the concatenated DNA sequence.\ncompute_failure_array(s): This function computes the failure array for the string s using the KMP algorithm.\n\nInitialize an array P of length n with zeros.\nIterate through the string s from the second character to the end.\nFor each character, update the value of k to the length of the longest prefix which is also a suffix for the substring s[1:i+1].\nStore the value of k in P[i].\n\nThe main block:\n\nParse the input FASTA format string to extract the DNA sequence.\nCompute the failure array for the DNA sequence.\nPrint the failure array as a space-separated string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-37",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-37",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.1 Sample Dataset",
    "text": "38.1 Sample Dataset\n&gt;Rosalind_23\nAACCTTGG\n&gt;Rosalind_64\nACACTGTGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-38",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-38",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.2 Sample Output",
    "text": "38.2 Sample Output\nAACTGG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-35",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-35",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.3 Solution",
    "text": "38.3 Solution\nTo solve the problem of finding the longest common subsequence (LCS) between two DNA strings provided in FASTA format, you can use dynamic programming. Here’s a step-by-step explanation and implementation:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-6",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.4 Steps to Solve the Problem",
    "text": "38.4 Steps to Solve the Problem\n\nParse the FASTA Input: Extract the DNA sequences from the FASTA format input.\nCompute the Longest Common Subsequence: Use a dynamic programming approach to find the LCS. The idea is to use a 2D table where dp[i][j] represents the length of the longest common subsequence of the substrings s[0:i] and t[0:j].\nReconstruct the LCS: Once the table is filled, backtrack to reconstruct the longest common subsequence from the table."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-2",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.5 Detailed Explanation",
    "text": "38.5 Detailed Explanation\n\nDynamic Programming Table Initialization:\n\nCreate a 2D list dp where dp[i][j] contains the length of the LCS of substrings s[0:i] and t[0:j].\nInitialize the first row and first column of the table to 0 because an LCS with an empty string is 0.\n\nFilling the DP Table:\n\nIterate through each character of s and t. If the characters match, update dp[i][j] based on dp[i-1][j-1] + 1.\nIf they do not match, set dp[i][j] to the maximum of dp[i-1][j] and dp[i][j-1].\n\nBacktracking to Find LCS:\n\nStart from dp[len(s)][len(t)] and trace back to build the LCS string by comparing characters and using the DP table to decide whether to include a character or move in a specific direction."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#python-implementation-3",
    "href": "posts/qmd/Rosalind_stronghold.html#python-implementation-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.6 Python Implementation",
    "text": "38.6 Python Implementation\nHere’s the Python code to achieve the above steps:\ndef parse_fasta(fasta_str):\n    \"\"\"\n    Parses a FASTA format string and returns the DNA sequences.\n    \"\"\"\n    sequences = []\n    current_sequence = []\n    for line in fasta_str.strip().split(\"\\n\"):\n        if line.startswith(\"&gt;\"):\n            if current_sequence:\n                sequences.append(\"\".join(current_sequence))\n                current_sequence = []\n        else:\n            current_sequence.append(line.strip())\n    if current_sequence:\n        sequences.append(\"\".join(current_sequence))\n    return sequences\n\ndef longest_common_subsequence(s, t):\n    \"\"\"\n    Finds the longest common subsequence between strings s and t.\n    \"\"\"\n    m, n = len(s), len(t)\n    # Create a 2D table to store lengths of longest common subsequences.\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # Backtrack to find the LCS\n    lcs = []\n    i, j = m, n\n    while i &gt; 0 and j &gt; 0:\n        if s[i - 1] == t[j - 1]:\n            lcs.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] &gt; dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))\n\n# Sample Input in FASTA format\nfasta_input = \"\"\"\n&gt;Rosalind_23\nAACCTTGG\n&gt;Rosalind_64\nACACTGTGA\n\"\"\"\n\n# Parsing the input\nsequences = parse_fasta(fasta_input)\ns = sequences[0]\nt = sequences[1]\n\n# Finding the longest common subsequence\nlcs = longest_common_subsequence(s, t)\n\n# Printing the result\nprint(lcs)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-6",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "38.7 Explanation of the Code",
    "text": "38.7 Explanation of the Code\n\nparse_fasta(fasta_str): This function parses the FASTA format string and returns a list of DNA sequences.\nlongest_common_subsequence(s, t): This function calculates the longest common subsequence using a dynamic programming table and then backtracks to reconstruct the LCS.\nMain Execution:\n\nParse the input FASTA string to get the DNA sequences.\nCompute the LCS using the longest_common_subsequence function.\nPrint the result.\n\n\nThis code will correctly find and output the longest common subsequence of the given DNA sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-38",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-38",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.1 Sample Dataset",
    "text": "39.1 Sample Dataset\nD N A\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-39",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-39",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.2 Sample Output",
    "text": "39.2 Sample Output\nD\nDD\nDDD\nDDN\nDDA\nDN\nDND\nDNN\nDNA\nDA\nDAD\nDAN\nDAA\nN\nND\nNDD\nNDN\nNDA\nNN\nNND\nNNN\nNNA\nNA\nNAD\nNAN\nNAA\nA\nAD\nADD\nADN\nADA\nAN\nAND\nANN\nANA\nAA\nAAD\nAAN\nAAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-36",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-36",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.3 Solution",
    "text": "39.3 Solution\nTo solve the problem of generating all strings of length up to \\(n\\) formed from an ordered alphabet \\(A\\), and then ordering them lexicographically based on the given alphabet order, we can use a recursive approach or itertools to generate the permutations. Here is a detailed step-by-step explanation and implementation:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-7",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.4 Steps to Solve the Problem",
    "text": "39.4 Steps to Solve the Problem\n\nInput Parsing:\n\nParse the given ordered alphabet \\(A\\) and the integer \\(n\\).\n\nGenerate All Possible Strings:\n\nUse recursion or itertools to generate all strings of length from 1 to \\(n\\) using the symbols in \\(A\\).\n\nSorting:\n\nSort the generated strings based on the custom order provided by \\(A\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-3",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-3",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.5 Detailed Explanation",
    "text": "39.5 Detailed Explanation\n\nGenerating Combinations:\n\nFor each length \\(k\\) from 1 to \\(n\\), generate all possible strings of that length using the symbols in \\(A\\).\n\nCustom Sorting:\n\nUse the order of symbols in \\(A\\) to sort the generated strings lexicographically."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#python-implementation-4",
    "href": "posts/qmd/Rosalind_stronghold.html#python-implementation-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.6 Python Implementation",
    "text": "39.6 Python Implementation\nHere is the Python code to achieve the above steps:\nimport itertools\n\ndef parse_input(input_str):\n    lines = input_str.strip().split(\"\\n\")\n    alphabet = lines[0].split()\n    n = int(lines[1])\n    return alphabet, n\n\ndef generate_strings(alphabet, n):\n    all_strings = []\n    for length in range(1, n + 1):\n        for combo in itertools.product(alphabet, repeat=length):\n            all_strings.append(\"\".join(combo))\n    return all_strings\n\ndef custom_sort(strings, alphabet):\n    order_map = {char: idx for idx, char in enumerate(alphabet)}\n    return sorted(strings, key=lambda word: [order_map[char] for char in word])\n\n# Sample Input\ninput_data = \"\"\"\nD N A\n3\n\"\"\"\n\n# Parse input\nalphabet, n = parse_input(input_data)\n\n# Generate all strings of length up to n\nall_strings = generate_strings(alphabet, n)\n\n# Sort the strings based on the custom lexicographical order\nsorted_strings = custom_sort(all_strings, alphabet)\n\n# Print the result\nfor s in sorted_strings:\n    print(s)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-7",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "39.7 Explanation of the Code",
    "text": "39.7 Explanation of the Code\n\nparse_input(input_str): This function parses the input string to extract the alphabet and the integer \\(n\\).\ngenerate_strings(alphabet, n): This function generates all possible strings of lengths from 1 to \\(n\\) using itertools.product.\ncustom_sort(strings, alphabet): This function sorts the generated strings based on the custom order defined by the alphabet. It uses a mapping of characters to their indices in the given order for sorting.\nMain Execution:\n\nParse the input data.\nGenerate all possible strings.\nSort the strings using the custom lexicographical order.\nPrint each string in the sorted list."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-39",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-39",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "40.1 Sample Dataset",
    "text": "40.1 Sample Dataset\n&gt;Rosalind_92\nAUGCUUC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-40",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-40",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "40.2 Sample Output",
    "text": "40.2 Sample Output\n6"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-37",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-37",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "40.3 Solution",
    "text": "40.3 Solution\n\nCounting Nucleotides: Count occurrences of each nucleotide.\nCalculating Pairings:\n\nThe number of possible AU pairs is determined by the minimum of A and U.\nSimilarly, the number of possible GC pairs is determined by the minimum of G and C.\n\nUsing Factorials: Calculate how many ways to pair these nucleotides.\n\nLet’s correct the implementation:\nfrom math import factorial\n\ndef count_nucleotides(sequence):\n    \"\"\"\n    Count the occurrences of each nucleotide in the RNA sequence.\n    \n    Args:\n    sequence (str): The RNA sequence as a string.\n    \n    Returns:\n    dict: A dictionary with counts for 'A', 'U', 'G', and 'C'.\n    \"\"\"\n    counts = {'A': 0, 'U': 0, 'G': 0, 'C': 0}\n    for nucleotide in sequence:\n        if nucleotide in counts:\n            counts[nucleotide] += 1\n    return counts\n\ndef max_matching_pairs(a, b):\n    \"\"\"\n    Calculate the number of ways to pair 'a' items with 'b' items.\n    \n    Args:\n    a (int): Number of items of type A.\n    b (int): Number of items of type B.\n    \n    Returns:\n    int: The number of maximum matching pairs.\n    \"\"\"\n    return factorial(a) // (factorial(b) * factorial(a - b))\n\ndef maximum_matchings(sequence):\n    \"\"\"\n    Calculate the number of maximum matchings in an RNA sequence.\n    \n    Args:\n    sequence (str): The RNA sequence.\n    \n    Returns:\n    int: The number of maximum matchings.\n    \"\"\"\n    # Count nucleotides\n    counts = count_nucleotides(sequence)\n    \n    # Get counts for each nucleotide\n    A = counts['A']\n    U = counts['U']\n    G = counts['G']\n    C = counts['C']\n    \n    # Calculate the number of possible AU and GC pairings\n    min_au_pairs = min(A, U)\n    min_gc_pairs = min(G, C)\n    \n    # Compute number of ways to form these pairs\n    au_pairings = max_matching_pairs(A, min_au_pairs) * max_matching_pairs(U, min_au_pairs)\n    gc_pairings = max_matching_pairs(G, min_gc_pairs) * max_matching_pairs(C, min_gc_pairs)\n    \n    # Total number of maximum matchings\n    total_matchings = au_pairings * gc_pairings\n    return total_matchings\n\n# Example RNA sequence\nrna_sequence = \"AUGCUUC\"\n\n# Compute and print the number of maximum matchings\nprint(maximum_matchings(rna_sequence))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-changes",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-changes",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "40.4 Explanation of Changes",
    "text": "40.4 Explanation of Changes\n\ncount_nucleotides(sequence): Counts the number of each nucleotide.\nmax_matching_pairs(a, b): Calculates the number of ways to form b pairs from a items using factorials. This function helps in calculating possible pairings for nucleotides.\nmaximum_matchings(sequence): Computes the number of ways to match A with U and G with C, and then multiplies these to get the total number of matchings.\n\n\n\n\n\n\n\nNote\n\n\n\nRosalind 의 서버는 python2.7 로 구현되어 있어 python3 에서 실행한 결과는 옳지 않다고 판단합니다. 따라서 상대적으로 정확도가 떨어지는 python2.7 로 실행하세요."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-40",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-40",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "41.1 Sample Dataset",
    "text": "41.1 Sample Dataset\n&gt;Rosalind_9499\nTTTCCATTTA\n&gt;Rosalind_0942\nGATTCATTTC\n&gt;Rosalind_6568\nTTTCCATTTT\n&gt;Rosalind_1833\nGTTCCATTTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-41",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-41",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "41.2 Sample Output",
    "text": "41.2 Sample Output\n0.00000 0.40000 0.10000 0.10000\n0.40000 0.00000 0.40000 0.30000\n0.10000 0.40000 0.00000 0.20000\n0.10000 0.30000 0.20000 0.00000"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-38",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-38",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "41.3 Solution",
    "text": "41.3 Solution\nTo create a distance matrix based on the p-distance for a given set of DNA strings, we will follow these steps:\n\nRead the Input: Parse the FASTA formatted input to extract DNA strings.\nCalculate p-distance: Compute the p-distance between each pair of DNA strings. The p-distance is defined as the proportion of differing symbols between two strings of equal length.\nConstruct the Distance Matrix: Populate the distance matrix with the computed p-distances."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "41.4 Detailed Implementation",
    "text": "41.4 Detailed Implementation\n\nReading the Input: We’ll parse the input to extract the DNA sequences.\nComputing p-distance: For each pair of sequences, we’ll count the differing positions and divide by the total length of the sequences.\nOutput the Distance Matrix: Format the matrix with each entry having a precision up to five decimal places.\n\nHere’s the Python code to achieve this:\ndef read_fasta(fasta_string):\n    \"\"\"\n    Parses a FASTA formatted string and returns a list of sequences.\n    \"\"\"\n    sequences = []\n    current_sequence = []\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_sequence:\n                sequences.append(''.join(current_sequence))\n                current_sequence = []\n        else:\n            current_sequence.append(line.strip())\n    if current_sequence:\n        sequences.append(''.join(current_sequence))\n    return sequences\n\ndef p_distance(s1, s2):\n    \"\"\"\n    Computes the p-distance between two DNA sequences of equal length.\n    \"\"\"\n    assert len(s1) == len(s2), \"Sequences must be of equal length.\"\n    differences = sum(1 for a, b in zip(s1, s2) if a != b)\n    return differences / len(s1)\n\ndef distance_matrix(sequences):\n    \"\"\"\n    Computes the distance matrix for a list of sequences based on p-distance.\n    \"\"\"\n    n = len(sequences)\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                matrix[i][j] = p_distance(sequences[i], sequences[j])\n    return matrix\n\ndef format_matrix(matrix):\n    \"\"\"\n    Formats the matrix for output with each entry having five decimal places.\n    \"\"\"\n    return '\\n'.join(' '.join(f\"{cell:f}\" for cell in row) for row in matrix)\n\n# Sample dataset\nfasta_string = \"\"\"&gt;Rosalind_9499\nTTTCCATTTA\n&gt;Rosalind_0942\nGATTCATTTC\n&gt;Rosalind_6568\nTTTCCATTTT\n&gt;Rosalind_1833\nGTTCCATTTA\"\"\"\n\n# Reading sequences from the sample dataset\nsequences = read_fasta(fasta_string)\n\n# Calculating the distance matrix\ndist_matrix = distance_matrix(sequences)\n\n# Formatting and printing the distance matrix\nformatted_matrix = format_matrix(dist_matrix)\nprint(formatted_matrix)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-21",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-21",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "41.5 Explanation",
    "text": "41.5 Explanation\n\nReading FASTA Data: The read_fasta function processes the input FASTA data and extracts the sequences.\nCalculating p-distance: The p_distance function computes the proportion of differing symbols between two sequences.\nConstructing Distance Matrix: The distance_matrix function creates a matrix where each entry $(i, j)) contains the p-distance between sequences $i) and $j).\nFormatting the Output: The format_matrix function ensures that each entry in the matrix is printed with five decimal places for precision."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-41",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-41",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "42.1 Sample Dataset",
    "text": "42.1 Sample Dataset\n1 2 3 4 5 6 7 8 9 10\n3 1 5 2 7 4 9 6 10 8\n\n3 10 8 2 5 4 7 1 6 9\n5 2 3 1 7 4 10 8 6 9\n\n8 6 7 9 4 1 3 10 2 5\n8 2 7 6 9 1 5 3 10 4\n\n3 9 10 4 1 8 6 7 5 2\n2 9 8 5 1 7 3 4 6 10\n\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-42",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-42",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "42.2 Sample Output",
    "text": "42.2 Sample Output\n9 4 5 7 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-39",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-39",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "42.3 Solution",
    "text": "42.3 Solution\nimport collections\n\ndef get_all_permutations(s):\n    for i in range(len(s)):\n        for j in range(i + 2, len(s) + 1):\n            yield s[:i] + s[i:j][::-1] + s[j:]\n\ndef get_reversal_distance(p1, p2):\n    if p1 == p2:\n        return 0\n    \n    target = tuple(p2)\n    fromfirst = {tuple(p1): 0}\n    q = collections.deque([p1])\n    \n    while q:\n        s = q.popleft()\n        c = fromfirst[s]\n        \n        for j in get_all_permutations(s):\n            if j == target:\n                return c + 1\n            \n            if j not in fromfirst:\n                fromfirst[j] = c + 1\n                \n                if c != 4:\n                    q.append(j)\n                    \n    fromsecond = {tuple(p2): 0}\n    target = tuple(p1)\n    q = collections.deque([p2])\n    answer = 100000\n    \n    while q:\n        s = q.popleft()\n        c = fromsecond[s]\n        \n        if c == 4:\n            break\n        \n        for j in get_all_permutations(s):\n            if j == target:\n                return c + 1\n            \n            if j not in fromsecond:\n                fromsecond[j] = c + 1\n                \n                if c != 3:\n                    q.append(j)\n                    \n            if j in fromfirst:\n                answer = min(answer, fromfirst[j] + fromsecond[j])\n                \n    return answer\n\n\ninput_data = \"\"\"\n1 2 3 4 5 6 7 8 9 10\n3 1 5 2 7 4 9 6 10 8\n\n3 10 8 2 5 4 7 1 6 9\n5 2 3 1 7 4 10 8 6 9\n\n8 6 7 9 4 1 3 10 2 5\n8 2 7 6 9 1 5 3 10 4\n\n3 9 10 4 1 8 6 7 5 2\n2 9 8 5 1 7 3 4 6 10\n\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n\"\"\"\n\n# Proces input data\ndataset = list(map(str.strip, input_data.strip().split('\\n')))\ndistances = []\n\nfor i in range(0, len(dataset), 3):\n    s = tuple(map(int, dataset[i].split()))\n    t = tuple(map(int, dataset[i + 1].split()))\n    distances.append(get_reversal_distance(t, s))\n\nprint(' '.join(map(str, distances)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-changes-and-additions",
    "href": "posts/qmd/Rosalind_stronghold.html#key-changes-and-additions",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "42.4 Key Changes and Additions",
    "text": "42.4 Key Changes and Additions\n\nConversion to Python 3:\n\nChanged xrange to range.\nChanged print statement to print() function.\n\nInput Handling:\n\nReplaced file reading with a direct input_data string for simplicity and demonstration purposes.\nProcessed the input_data string to split it into individual lines and then handled them similarly to how they would be read from a file."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-42",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-42",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "43.1 Sample Dataset",
    "text": "43.1 Sample Dataset\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-43",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-43",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "43.2 Sample Output",
    "text": "43.2 Sample Output\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-40",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-40",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "43.3 Solution",
    "text": "43.3 Solution\nTo solve the problem of counting the total number of subsets of the set \\({1, 2, \\ldots, n}\\) modulo 1,000,000, we need to understand a few key points:\n\nSubsets of a Set:\n\nFor any set of size \\(n\\), the number of possible subsets is \\(2^n\\). This includes the empty set and the set itself.\n\nModulo Operation:\n\nSince \\(n\\) can be as large as 1000, \\(2^n\\) can be a very large number. To manage this, we will compute the result modulo 1,000,000."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solution",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solution",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "43.4 Steps to Solution",
    "text": "43.4 Steps to Solution\n\nCalculate \\(2^n \\mod 1,000,000\\):\n\nWe will use modular exponentiation to compute this efficiently. Direct computation of \\(2^n\\) for large \\(n\\) is impractical due to the size of the number.\n\nModular Exponentiation:\n\nThis technique allows us to compute \\((base^{exp}) \\mod mod\\) efficiently using an iterative or recursive approach that reduces the number of multiplications required.\n\n\nHere’s the Python code to solve the problem:\ndef modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp &gt; 0:\n        if (exp % 2) == 1:  # If exp is odd, multiply base with result\n            result = (result * base) % mod\n        exp = exp &gt;&gt; 1  # exp = exp // 2\n        base = (base * base) % mod  # Change base to base^2\n    return result\n\ndef count_subsets(n):\n    mod = 1000000\n    return modular_exponentiation(2, n, mod)\n\n# Sample input\nn = 3\nprint(count_subsets(n))  # Output should be 8"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-8",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "43.5 Explanation of the Code",
    "text": "43.5 Explanation of the Code\n\nFunction modular_exponentiation:\n\nInputs: base (2), exp (n), and mod (1,000,000).\nProcess: This function uses an efficient loop to compute the exponentiation modulo mod. By squaring the base and halving the exponent iteratively, it ensures that we keep the numbers manageable and perform fewer multiplications.\n\nFunction count_subsets:\n\nThis function simply calls modular_exponentiation with base 2, exp n, and mod 1,000,000.\n\nMain Execution:\n\nThe sample input n = 3 is used to demonstrate the function, which should output 8 as expected.\nThe script can also read from standard input for actual use cases."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-43",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-43",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "44.1 Sample Dataset",
    "text": "44.1 Sample Dataset\n90000 0.6\nATAGCCGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-44",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-44",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "44.2 Sample Output",
    "text": "44.2 Sample Output\n0.689"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-41",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-41",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "44.3 Solution",
    "text": "44.3 Solution\nTo solve the problem of calculating the probability that at least one out of \\(N\\)random DNA strings matches a given DNA string \\(s\\), we can follow these steps:\n\nCalculate the Probability of Matching a Single String:\n\nThe probability of a specific base in \\(s\\)matching a random base depends on the GC-content \\(x\\).\nFor GC-content \\(x\\), the probabilities are:\n\nProbability of ‘G’ or ‘C’: \\(\\frac{x}{2}\\)\nProbability of ‘A’ or ‘T’: \\(\\frac{1 - x}{2}\\)\n\n\nCompute the Probability of the Entire String Matching:\n\nThe probability that a random DNA string of the same length as \\(s\\)matches \\(s\\)exactly is the product of the probabilities for each individual base.\n\nCalculate the Complementary Probability:\n\nCompute the probability that a single random DNA string does NOT match \\(s\\).\nUsing this, compute the probability that all \\(N\\)random strings do NOT match \\(s\\).\n\nCompute the Final Probability:\n\nThe probability that at least one out of \\(N\\)random DNA strings matches \\(s\\)is the complement of the probability that none of them matches \\(s\\).\n\n\nLet’s go through the implementation of this step-by-step:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-5",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-5",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "44.4 Implementation",
    "text": "44.4 Implementation\ndef calculate_probability(N, x, s):\n    # Step 1: Calculate the probability of matching a single base\n    prob_match = 1.0\n    for base in s:\n        if base in 'GC':\n            prob_match *= x / 2\n        else:  # base in 'AT'\n            prob_match *= (1 - x) / 2\n    \n    # Step 2: Compute the probability of the entire string matching\n    # This is already computed as prob_match\n    \n    # Step 3: Calculate the complementary probability\n    prob_not_match = 1 - prob_match\n    \n    # Step 4: Compute the final probability\n    prob_all_not_match = prob_not_match ** N\n    prob_at_least_one_match = 1 - prob_all_not_match\n    \n    return prob_at_least_one_match\n\n# Sample input\nN = 90000\nx = 0.6\ns = \"ATAGCCGA\"\n\n# Calculate and print the probability\nresult = calculate_probability(N, x, s)\nprint(f\"{result:f}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-9",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-9",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "44.5 Explanation of the Code",
    "text": "44.5 Explanation of the Code\n\nProbability Calculation for Each Base:\n\nFor each base in the string \\(s\\), the probability of it being either ‘G’ or ‘C’ is \\(\\frac{x}{2}\\) and for ‘A’ or ‘T’ is \\(\\frac{1 - x}{2}\\).\n\nComputing Probability for the Entire String:\n\nMultiply the probabilities of each base matching to get the probability of the entire string matching a random string of the same length.\n\nComplementary Probability:\n\nCompute the probability that a single random DNA string does NOT match \\(s\\).\nRaise this probability to the power \\(N\\) to get the probability that none of the \\(N\\) strings match \\(s\\).\n\nFinal Probability:\n\nSubtract the complementary probability from 1 to get the probability that at least one out of \\(N\\) random strings matches \\(s\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-44",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-44",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "45.1 Sample Dataset",
    "text": "45.1 Sample Dataset\n6 3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-45",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-45",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "45.2 Sample Output",
    "text": "45.2 Sample Output\n42"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-42",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-42",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "45.3 Solution",
    "text": "45.3 Solution\nHere’s the refactored code that performs the required calculation using Python’s built-in math module while maintaining readability and simplicity.\nimport math\n\ndef sum_of_combinations(n, m, MOD):\n    total = 0\n    for k in range(m, n + 1):\n        # Calculate C(n, k) using math.factorial\n        comb = math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n        total = (total + comb) % MOD\n    return total\n\n# Sample input\nsample_input = \"6 3\"\nn, m = map(int, sample_input.strip().split())\n\n# Define the modulo\nMOD = 1000000\n\n# Calculate the sum of combinations\nresult = sum_of_combinations(n, m, MOD)\n\n# Print the results\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-22",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-22",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "45.4 Explanation",
    "text": "45.4 Explanation\n\nFunction Definition:\nMain Logic:\n\nIterate through all \\(k\\)from \\(m\\)to \\(n\\).\nCalculate \\(C(n, k)\\) using the factorial function.\nSum the results, taking modulo \\(1000000\\)at each step to handle large numbers efficiently.\n\nSample Input Handling:\n\nParse the sample input to get the values of \\(n\\)and \\(m\\).\nDefine the modulo value \\(MOD = 1000000\\).\nCalculate the result using the sum_of_combinations function and print the results."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-45",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-45",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "46.1 Sample Dataset",
    "text": "46.1 Sample Dataset\n&gt;Rosalind_39\nPLEASANTLY\n&gt;Rosalind_11\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-46",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-46",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "46.2 Sample Output",
    "text": "46.2 Sample Output\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-46",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-46",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.1 Sample Dataset",
    "text": "47.1 Sample Dataset\n10\nAG\n0.25 0.5 0.75"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-47",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-47",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.2 Sample Output",
    "text": "47.2 Sample Output\n0.422 0.563 0.422"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-43",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-43",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.3 Solution",
    "text": "47.3 Solution\nTo solve this problem, we need to compute the expected number of times a given DNA string \\(s\\)will appear as a substring in a random DNA string \\(t\\)of length \\(n\\). The DNA string \\(t\\)is generated with varying GC-content values given in an array \\(A\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#approach",
    "href": "posts/qmd/Rosalind_stronghold.html#approach",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.4 Approach",
    "text": "47.4 Approach\n\nCalculate Probabilities:\n\nThe probability of each nucleotide (A, T, C, G) depends on the GC-content.\nFor a given GC-content \\(gc\\):\n\nProbability of G or C: \\(\\frac{gc}{2}\\)\nProbability of A or T: \\(\\frac{1 - gc}{2}\\)\n\n\nCompute the Probability of \\(s\\)as a Substring:\n\nFor each GC-content value \\(A[i]\\), compute the probability that \\(s\\)appears at any specific position in \\(t\\).\nSum the probabilities for all possible starting positions of \\(s\\)in \\(t\\)(from 0 to \\(n - \\text{len}(s)\\)).\n\nExpected Value:\n\nMultiply the single-position probability by the number of possible starting positions to get the expected number of times \\(s\\)appears in \\(t\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-steps-and-code",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-steps-and-code",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.5 Detailed Steps and Code",
    "text": "47.5 Detailed Steps and Code\n\nReading Input:\n\nRead \\(n\\), the DNA string \\(s\\), and the array \\(A\\).\n\nProbability Calculation:\n\nFor each GC-content value in \\(A\\), compute the probability of \\(s\\).\n\nOutput:\n\nPrint the expected values for each GC-content in \\(A\\).\n\n\nHere’s the Python code to achieve this:\ndef expected_restriction_sites(n, s, A):\n    len_s = len(s)\n    B = []\n    \n    for gc_content in A:\n        p_gc = gc_content / 2\n        p_at = (1 - gc_content) / 2\n        \n        prob_s = 1.0\n        for nucleotide in s:\n            if nucleotide in 'GC':\n                prob_s *= p_gc\n            else:\n                prob_s *= p_at\n        \n        expected_count = prob_s * (n - len_s + 1)\n        B.append(expected_count)\n    \n    return B\n\n# Sample input\ntext = \"\"\"\n10\nAG\n0.25 0.5 0.75\"\"\"\n\nn = int(text.strip().split(\"\\n\")[0])\ns = text.strip().split(\"\\n\")[1]\nA = [float(x) for x in text.strip().split(\"\\n\")[2].split()]\n\nresult = expected_restriction_sites(n, s, A)\nprint(\" \".join(f\"{x:f}\" for x in result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-23",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-23",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "47.6 Explanation",
    "text": "47.6 Explanation\n\nReading Input:\n\nn is the length of the random DNA string.\ns is the DNA substring we are looking for.\nA is an array of GC-content values.\n\nProbability Calculation:\n\nFor each GC-content \\(gc\\), compute the probability prob_s that the substring \\(s\\) will match exactly at a given position.\nUse the formula: \\[\n\\text{prob\\_s} = \\prod_{i=1}^{\\text{len}(s)} \\text{probability of } s[i]\n\\]\n\nExpected Value:\n\nMultiply prob_s by the number of possible starting positions in the string \\(t\\)(which is \\(n - \\text{len}(s) + 1\\)).\n\nOutput:\n\nPrint the expected counts, formatted to three decimal places."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-47",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-47",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "48.1 Sample Dataset",
    "text": "48.1 Sample Dataset\n&gt;Rosalind_57\nAUAU"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-48",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-48",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "48.2 Sample Output",
    "text": "48.2 Sample Output\n7"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-44",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-44",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "48.3 Solution",
    "text": "48.3 Solution\nWe want to count the number of ways to form noncrossing matchings of basepair edges in an RNA string. RNA strings can form base pairs between A and U or C and G.\n\nInitialization:\n\nInput: An RNA string rna of length n.\nDP Table: We create a 2D list dp of size (n+1) x (n+1) initialized to zero. dp[i][j] will store the number of noncrossing matchings in the substring from index i to j-1 of the RNA string.\nBase Case:\n\ndp[i][i] = 1 because a single nucleotide can only be matched with itself.\ndp[i][i+1] = 1 because a pair of adjacent nucleotides can either be unmatched or form one valid base pair.\n\n\nFilling the DP Table:\n\nWe iterate over all possible substring lengths starting from 2 up to n.\nFor each substring of length length starting at index i and ending at index j-1:\n\nWe start by assuming the first nucleotide rna[i] is not paired, so the count of valid matchings is initially dp[i+1][j].\nThen we check all possible positions k where rna[i] can form a valid base pair (i.e., rna[i] with rna[k]). If they form a valid base pair:\n\nWe add the number of ways to match the left part (dp[i+1][k]) and the right part (dp[k+1][j]).\n\nSum the results and take modulo $10^6) to avoid large numbers.\n\n\nResult:\n\nThe result for the entire RNA string is stored in dp[0][n]."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#code-explanation",
    "href": "posts/qmd/Rosalind_stronghold.html#code-explanation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "48.4 Code Explanation",
    "text": "48.4 Code Explanation\nHere’s the code again with comments to explain each part:\ndef count_noncrossing_matchings(rna):\n    n = len(rna)  # Length of the RNA string\n    MOD = 1000000  # Modulo value to avoid large numbers\n\n    # Initialize a dp table with all zeros\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: Single nucleotides and empty string\n    for i in range(n + 1):\n        dp[i][i] = 1  # A single nucleotide matches with itself\n        if i &lt; n:\n            dp[i][i + 1] = 1  # Two adjacent nucleotides can be unmatched or paired\n\n    # Fill the dp table for all substring lengths\n    for length in range(2, n + 1):  # Length of the substring\n        for i in range(n - length + 1):\n            j = i + length\n            dp[i][j] = dp[i + 1][j]  # Case when the first nucleotide is unpaired\n            for k in range(i + 1, j):\n                # Check if rna[i] and rna[k] can form a valid base pair\n                if (rna[i] == 'A' and rna[k] == 'U') or (rna[i] == 'U' and rna[k] == 'A') or \\\n                   (rna[i] == 'C' and rna[k] == 'G') or (rna[i] == 'G' and rna[k] == 'C'):\n                    dp[i][j] += dp[i + 1][k] * dp[k + 1][j]\n                    dp[i][j] %= MOD  # Take modulo to avoid large numbers\n\n    # The result for the entire string\n    return dp[0][n]\n\n# Sample input\nrna_string = \"AUAU\"\nresult = count_noncrossing_matchings(rna_string)\nprint(result)  # Output: 7"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-points",
    "href": "posts/qmd/Rosalind_stronghold.html#key-points",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "48.5 Key Points",
    "text": "48.5 Key Points\n\nBase Cases: Handle single and adjacent nucleotides.\nDynamic Programming: Use a table to store results of subproblems to build up the solution for the entire string.\nModulo Operation: Keep results manageable by taking modulo $10^6).\n\nThis approach efficiently calculates the number of noncrossing matchings for the given RNA string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-48",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-48",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "49.1 Sample Dataset",
    "text": "49.1 Sample Dataset\n(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-49",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-49",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "49.2 Sample Output",
    "text": "49.2 Sample Output\n1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-45",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-45",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "49.3 Solution",
    "text": "49.3 Solution\ndef dis_tree(T, x, y):\n    # Find the indices of x and y in the Newick string T\n    x_index = T.find(x)\n    y_index = T.find(y)\n    \n    # Extract the relevant substring between the indices of x and y\n    sub_tree = [i for i in T[min(x_index, y_index):max(x_index, y_index)] if i in [')', '(', ',']]\n    \n    # Convert the list of characters to a string\n    bracket = ''.join(sub_tree)\n    \n    # Remove empty pairs of parentheses\n    while '(,)' in bracket:\n        bracket = bracket.replace('(,)', '')\n    \n    # Determine the number of steps based on the type of brackets remaining\n    if bracket.count('(') == len(bracket) or bracket.count(')') == len(bracket):\n        return len(bracket)\n    elif bracket.count(',') == len(bracket):\n        return 2\n    else:\n        return bracket.count(')') + bracket.count('(') + 2\n\ndef process_input(input_data):\n    # Parse the input data into a list of tree and node pairs\n    tree_data = [line.strip().replace(\";\", \"\") for line in input_data.strip().split(\"\\n\") if line.strip()]\n    results = []\n    \n    # Iterate through the parsed data to proces each tree and node pair\n    for i in range(0, len(tree_data), 2):\n        T = tree_data[i]\n        x, y = tree_data[i+1].split(' ')\n        results.append(dis_tree(T, x, y))\n    \n    return results\n\n# Sample input\ninput_data = \"\"\"\n(cat)dog;\ndog cat\n\n(dog,cat);\ndog cat\n\"\"\"\n\n# Proces the input and print the results\noutput_data = process_input(input_data)\nprint(\" \".join(map(str, output_data)))  # Output should be: 1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-24",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-24",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "49.4 Explanation",
    "text": "49.4 Explanation\n\nThe dis_tree function computes the distance between nodes x and y in the given Newick string T.\nThe process_input function processes the input string, extracts the tree and node pairs, and computes the distances using the dis_tree function.\nFinally, the results are printed in the required format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-49",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-49",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "50.1 Sample Dataset",
    "text": "50.1 Sample Dataset\nATCTGAT\nTGCATA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-50",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-50",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "50.2 Sample Output",
    "text": "50.2 Sample Output\nATGCATGAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-46",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-46",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "50.3 Solution",
    "text": "50.3 Solution\nTo solve the problem of finding the shortest common supersequence (SCS) of two DNA strings $ s$ and $ t$, we can use a dynamic programming approach. The idea is similar to finding the longest common subsequence (LCS), but with a few modifications to ensure that we construct the SCS."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-8",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve-the-problem-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "50.4 Steps to Solve the Problem",
    "text": "50.4 Steps to Solve the Problem\n\nDefine the Dynamic Programming Table:\n\nLet \\(dp[i][j]\\) represent the length of the SCS of the substrings \\(s[0:i]\\) and \\(t[0:j]\\).\n\nInitialize the Table:\n\nFor \\(dp[i][0]\\), the SCS is simply the prefix of \\(s\\) of length \\(i\\), so \\(dp[i][0] = i\\).\nFor \\(dp[0][j]\\), the SCS is simply the prefix of \\(t\\) of length \\(j\\), so \\(dp[0][j] = j\\).\n\nFill the DP Table:\n\nIf \\(s[i-1] == t[j-1]\\), then \\(dp[i][j] = dp[i-1][j-1] + 1\\) because the characters match and they contribute once to the SCS.\nOtherwise, \\(dp[i][j] = \\min(dp[i-1][j], dp[i][j-1]) + 1\\), meaning we take the shorter SCS by either adding the current character of \\(s\\) or \\(t\\).\n\nConstruct the SCS:\n\nUse the DP table to backtrack and construct the SCS by starting from \\(dp[len(s)][len(t)]\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#code-implementation",
    "href": "posts/qmd/Rosalind_stronghold.html#code-implementation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "50.5 Code Implementation",
    "text": "50.5 Code Implementation\nHere’s the code to solve the problem:\ndef shortest_common_supersequence(s, t):\n    m, n = len(s), len(t)\n    \n    # Initialize the DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the base cases\n    for i in range(1, m + 1):\n        dp[i][0] = i\n    for j in range(1, n + 1):\n        dp[0][j] = j\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n    \n    # Backtrack to find the SCS\n    i, j = m, n\n    scs = []\n    \n    while i &gt; 0 and j &gt; 0:\n        if s[i - 1] == t[j - 1]:\n            scs.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] &lt; dp[i][j - 1]:\n            scs.append(s[i - 1])\n            i -= 1\n        else:\n            scs.append(t[j - 1])\n            j -= 1\n    \n    while i &gt; 0:\n        scs.append(s[i - 1])\n        i -= 1\n    while j &gt; 0:\n        scs.append(t[j - 1])\n        j -= 1\n    \n    return ''.join(reversed(scs))\n\n# Sample input\ns = \"ATCTGAT\"\nt = \"TGCATA\"\n\n# Calculate and print the shortest common supersequence\nprint(shortest_common_supersequence(s, t))  # Output should be a valid SCS like \"ATGCATGAT\""
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-50",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-50",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "51.1 Sample Dataset",
    "text": "51.1 Sample Dataset\n10\n{1, 2, 3, 4, 5}\n{2, 8, 5, 10}"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-51",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-51",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "51.2 Sample Output",
    "text": "51.2 Sample Output\n{1, 2, 3, 4, 5, 8, 10}\n{2, 5}\n{1, 3, 4}\n{8, 10}\n{8, 9, 10, 6, 7}\n{1, 3, 4, 6, 7, 9}"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-47",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-47",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "51.3 Solution",
    "text": "51.3 Solution\nTo solve this problem involving set operations, we need to perform union, intersection, set difference, and complement operations on two given sets \\(A\\) and \\(B\\), with respect to a universal set \\(U\\) which contains all integers from 1 to \\(n\\). Here’s how we can approach this step-by-step:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps",
    "href": "posts/qmd/Rosalind_stronghold.html#steps",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "51.4 Steps",
    "text": "51.4 Steps\n\nRead Input:\n\nThe first line contains the integer \\(n\\), the size of the universal set.\nThe second line contains set \\(A\\).\nThe third line contains set \\(B\\).\n\nParse Sets:\n\nExtract the elements of sets \\(A\\) and \\(B\\) from the input strings.\n\nDefine Universal Set \\(U\\):\n\nThis is simply the set of all integers from 1 to \\(n\\).\n\nPerform Set Operations:\n\nUnion \\(A \\cup B\\): Elements in either \\(A\\) or \\(B\\).\nIntersection \\(A \\cap B\\): Elements common to both \\(A\\) and \\(B\\).\nDifference \\(A - B\\): Elements in \\(A\\) but not in \\(B\\).\nDifference \\(B - A\\): Elements in \\(B\\) but not in \\(A\\).\nComplement \\(A^c\\): Elements in \\(U\\) but not in \\(A\\).\nComplement \\(B^c\\): Elements in \\(U\\) but not in \\(B\\).\n\n\nHere’s the Python code to implement the above logic:\ndef set_operations(n, A, B):\n    U = set(range(1, n+1))\n    A = set(A)\n    B = set(B)\n\n    union = A | B\n    intersection = A & B\n    difference_A_B = A - B\n    difference_B_A = B - A\n    complement_A = U - A\n    complement_B = U - B\n\n    return union, intersection, difference_A_B, difference_B_A, complement_A, complement_B\n\n# Sample input\nn = 10\nA = {1, 2, 3, 4, 5}\nB = {2, 8, 5, 10}\n\n# Get the results\nresults = set_operations(n, A, B)\n\n# Print the results\nfor result in results:\n    print(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-25",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-25",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "51.5 Explanation",
    "text": "51.5 Explanation\n\nUnion (\\(A \\cup B\\)): Combines all unique elements from both sets.\nIntersection (\\(A \\cap B\\)): Selects only the elements that are present in both sets.\nDifference (\\(A - B\\)): Selects elements that are in \\(A\\) but not in \\(B\\).\nDifference (\\(B - A\\)): Selects elements that are in \\(B\\) but not in \\(A\\).\nComplement (\\(A^c\\)): Selects elements that are in the universal set \\(U\\) but not in \\(A\\).\nComplement (\\(B^c\\)): Selects elements that are in the universal set \\(U\\) but not in \\(B\\)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-51",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-51",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.1 Sample Dataset",
    "text": "52.1 Sample Dataset\n1 2 3 4 5 6 7 8 9 10\n1 8 9 3 2 7 6 5 4 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-52",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-52",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.2 Sample Output",
    "text": "52.2 Sample Output\n2\n4 9\n2 5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-48",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-48",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.3 Solution",
    "text": "52.3 Solution\nTo solve the problem of sorting by reversals, we need to find the minimum number of reversals needed to transform one permutation \\(\\pi\\) into another permutation \\(\\gamma\\), as well as the specific reversals that accomplish this transformation."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-concepts",
    "href": "posts/qmd/Rosalind_stronghold.html#key-concepts",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.4 Key Concepts",
    "text": "52.4 Key Concepts\n\nReversal: A reversal is an operation that takes a segment of the permutation and reverses the order of the elements within that segment.\nReversal Distance: The reversal distance between two permutations is the minimum number of reversals needed to transform one permutation into another."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#approach-1",
    "href": "posts/qmd/Rosalind_stronghold.html#approach-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.5 Approach",
    "text": "52.5 Approach\n\nGraph Representation:\n\nRepresent the permutations as nodes in a graph, where each node is a permutation and edges represent a single reversal operation transforming one permutation into another.\n\nBreadth-First Search (BFS):\n\nUse BFS to find the shortest path from the starting permutation \\(\\pi\\) to the target permutation \\(\\gamma\\). Each level of BFS corresponds to one reversal.\nTrack the reversals used to transform \\(\\pi\\) to \\(\\gamma\\).\n\nImplementing BFS:\n\nUse a queue to manage the permutations to explore.\nUse a set to keep track of visited permutations to avoid redundant work.\nFor each permutation, generate all possible permutations resulting from a single reversal and enqueue them if they haven’t been visited.\n\nReconstruct Path:\n\nOnce the target permutation \\(\\gamma\\) is reached, backtrack to reconstruct the sequence of reversals."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#example-solution-in-python",
    "href": "posts/qmd/Rosalind_stronghold.html#example-solution-in-python",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.6 Example Solution in Python",
    "text": "52.6 Example Solution in Python\nHere’s the implementation of the approach:\nfrom collections import deque\n\ndef reverse_sublist(lst, start, end):\n    lst[start:end+1] = lst[start:end+1][::-1]\n\ndef bfs(start, target):\n    queue = deque([(start, [])])\n    visited = set()\n    visited.add(tuple(start))\n\n    while queue:\n        current, path = queue.popleft()\n\n        if current == target:\n            return len(path), path\n\n        for i in range(len(current)):\n            for j in range(i+1, len(current)):\n                new_perm = current[:]\n                reverse_sublist(new_perm, i, j)\n                new_tuple = tuple(new_perm)\n\n                if new_tuple not in visited:\n                    visited.add(new_tuple)\n                    queue.append((new_perm, path + [(i+1, j+1)]))\n                    \n    return -1, []\n\ndef sorting_by_reversals(pi, gamma):\n    distance, reversals = bfs(pi, gamma)\n    return distance, reversals\n    \ndef parse_input(input_string):\n    lines = input_string.strip().split(\"\\n\")\n    pi = [int(x) for x in lines[0].split()]\n    gamma = [int(x) for x in lines[1].split()]\n    return pi, gamma\n    \n# Sample input\nsample_input = \"\"\"\n6 5 4 7 2 3 9 8 10 1\n4 6 2 9 7 1 3 8 5 10\n\"\"\"\n\npi, gamma = parse_input(sample_input)\n# Get the results\ndistance, reversals = sorting_by_reversals(pi, gamma)\n\n# Print the results\nprint(distance)\nfor r in reversals:\n    print(r[0], r[1])"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-26",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-26",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "52.7 Explanation",
    "text": "52.7 Explanation\n\nreverse_sublist: A helper function to reverse a sublist within a list.\nbfs: The BFS function to explore all possible permutations resulting from single reversals, tracking the path taken.\nsorting_by_reversals: Main function to find the reversal distance and the specific reversals."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-52",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-52",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "53.1 Sample Dataset",
    "text": "53.1 Sample Dataset\n3524.8542\n3710.9335\n3841.974\n3970.0326\n4057.0646"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-53",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-53",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "53.2 Sample Output",
    "text": "53.2 Sample Output\nWMQS"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-49",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-49",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "53.3 Solution",
    "text": "53.3 Solution\nTo solve this problem, we need to infer a protein string from its prefix spectrum. The prefix spectrum is a list of cumulative masses of prefixes of the protein. Given a list of masses, our goal is to determine which amino acids correspond to the differences between successive masses in this list.\nHere’s a step-by-step approach to solve the problem:\n\nParse the input list of masses.\nCompute the differences between successive masses. These differences should correspond to the masses of amino acids.\nMatch the computed differences to the known monoisotopic masses of amino acids.\nConstruct the protein string from the matched amino acids.\n\nWe’ll use the monoisotopic mas table for amino acids, which provides the exact masses of each amino acid.\nHere’s the Python code to implement this:\n# Monoisotopic mas table for amino acids\nmonoisotopic_mass_table = {\n    'A': 71.03711, 'C': 103.00919, 'D': 115.02694, 'E': 129.04259, 'F': 147.06841,\n    'G': 57.02146, 'H': 137.05891, 'I': 113.08406, 'K': 128.09496, 'L': 113.08406,\n    'M': 131.04049, 'N': 114.04293, 'P': 97.05276, 'Q': 128.05858, 'R': 156.10111,\n    'S': 87.03203, 'T': 101.04768, 'V': 99.06841, 'W': 186.07931, 'Y': 163.06333\n}\n\ndef parse_input(input_string):\n    return list(map(float, input_string.strip().split()))\n\ndef find_amino_acid(delta_mass):\n    for amino_acid, mas in monoisotopic_mass_table.items():\n        if abs(mas - delta_mass) &lt; 0.01:  # Allowing a small tolerance\n            return amino_acid\n    return None\n\ndef infer_protein_from_spectrum(spectrum):\n    protein = \"\"\n    for i in range(1, len(spectrum)):\n        delta_mas = spectrum[i] - spectrum[i-1]\n        amino_acid = find_amino_acid(delta_mass)\n        if amino_acid:\n            protein += amino_acid\n        else:\n            raise ValueError(f\"No matching amino acid found for mas difference {delta_mass}\")\n    return protein\n\ndef main():\n    # Sample input\n    sample_input = \"\"\"\n    3524.8542\n    3710.9335\n    3841.974\n    3970.0326\n    4057.0646\n    \"\"\"\n\n    spectrum = parse_input(sample_input)\n    protein = infer_protein_from_spectrum(spectrum)\n    print(protein)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-27",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-27",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "53.4 Explanation",
    "text": "53.4 Explanation\n\nparse_input: This function parses the input string into a list of floats representing the masses.\nfind_amino_acid: This function takes a mas difference and finds the corresponding amino acid by comparing it against the monoisotopic mas table, allowing for a small tolerance due to floating-point precision issues.\ninfer_protein_from_spectrum: This function computes the differences between successive masses in the spectrum and uses find_amino_acid to map these differences to amino acids, constructing the protein string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-53",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-53",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "54.1 Sample Dataset",
    "text": "54.1 Sample Dataset\nATAGA\nATC\nGAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-54",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-54",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "54.2 Sample Output",
    "text": "54.2 Sample Output\n1 2 A\n2 3 T\n3 4 A\n4 5 G\n5 6 A\n3 7 C\n1 8 G\n8 9 A\n9 10 T"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-50",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-50",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "54.3 Solution",
    "text": "54.3 Solution\nTo construct a trie from a given collection of DNA strings, we need to follow these steps:\n\nInitialization: Start with a root node.\nInsertion: For each string in the collection, insert it into the trie by creating new nodes and edges as necessary.\nOutput: Generate the adjacency list representation of the trie.\n\nHere is the Python code to accomplish this task:\ndef build_trie(patterns):\n    trie = {1: {}}\n    next_node = 2\n    for pattern in patterns:\n        current_node = 1\n        for char in pattern:\n            if char in trie[current_node]:\n                current_node = trie[current_node][char]\n            else:\n                trie[current_node][char] = next_node\n                trie[next_node] = {}\n                current_node = next_node\n                next_node += 1\n    return trie\n\ndef trie_to_adjacency_list(trie):\n    adjacency_list = []\n    for parent in trie:\n        for char, child in trie[parent].items():\n            adjacency_list.append((parent, child, char))\n    return adjacency_list\n\ndef main():\n    # Sample input\n    input_data = \"\"\"\n    ATAGA\n    ATC\n    GAT\n    \"\"\"\n    patterns = input_data.strip().split()\n    \n    # Build the trie\n    trie = build_trie(patterns)\n    \n    # Convert trie to adjacency list\n    adjacency_list = trie_to_adjacency_list(trie)\n    \n    # Print the adjacency list\n    for parent, child, char in adjacency_list:\n        print(f\"{parent} {child} {char}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-28",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-28",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "54.4 Explanation",
    "text": "54.4 Explanation\n\nFunction build_trie:\n\nInitializes the trie with a root node labeled 1.\nFor each pattern, it iterates through its characters, and either moves to an existing node if the character is already in the current node’s dictionary or creates a new node if the character is not present.\nIt maintains a counter next_node to assign new labels to nodes.\n\nFunction trie_to_adjacency_list:\n\nConverts the trie structure into an adjacency list format, which is a list of tuples where each tuple represents an edge from a parent node to a child node labeled by a character.\n\nFunction main:\n\nHandles input and output operations.\nReads the input strings, constructs the trie, converts it to an adjacency list, and then prints the adjacency list."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-54",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-54",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "55.1 Sample Dataset",
    "text": "55.1 Sample Dataset\n186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-55",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-55",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "55.2 Sample Output",
    "text": "55.2 Sample Output\n3\n85.03163"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-51",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-51",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "55.3 Solution",
    "text": "55.3 Solution\nTo solve the problem of comparing spectra using the spectral convolution, we need to follow these steps:\n\nParse the input: Read the two multisets \\(S1\\) and \\(S2\\).\nCompute the spectral convolution: For each pair of elements \\((s1, s2)\\) where \\(s1 \\in S1\\) and \\(s2 \\in S2\\), compute the difference \\(s1 - s2\\).\nCount the occurrences of each difference: Track how many times each difference appears.\nFind the most frequent difference: Identify the difference that appears most frequently and its multiplicity.\n\nHere’s the Python code to implement the above steps:\nfrom collections import Counter\n\ndef parse_input(input_data):\n    lines = input_data.strip().split(\"\\n\")\n    S1 = list(map(float, lines[0].split()))\n    S2 = list(map(float, lines[1].split()))\n    return S1, S2\n\ndef spectral_convolution(S1, S2):\n    convolution = []\n    for s1 in S1:\n        for s2 in S2:\n            convolution.append(round(s1 - s2, 5))\n    return convolution\n\ndef find_max_multiplicity(convolution):\n    count = Counter(convolution)\n    max_value, max_count = max(count.items(), key=lambda x: x[1])\n    return max_count, abs(max_value)\n\ndef main(input_data):\n    S1, S2 = parse_input(input_data)\n    convolution = spectral_convolution(S1, S2)\n    max_count, max_value = find_max_multiplicity(convolution)\n    return max_count, max_value\n\n# Sample input\nsample_input = \"\"\"\n186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544\n101.04768 158.06914 202.09536 318.09979 419.14747 463.17369\n\"\"\"\n\n# Proces the input and get the result\nresult = main(sample_input)\nprint(result[0])\nprint(f\"{result[1]:f}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-29",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-29",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "55.4 Explanation",
    "text": "55.4 Explanation\n\nParsing Input:\n\nThe parse_input function reads the input data, splits it into lines, and then converts each line into a list of floats representing \\(S1\\) and \\(S2\\).\n\nComputing Spectral Convolution:\n\nThe spectral_convolution function takes all pairs \\((s1, s2)\\) from \\(S1\\) and \\(S2\\), computes the difference \\(s1 - s2\\), and stores these differences in a list. The round function ensures precision to 5 decimal places, as floating-point arithmetic can introduce small errors.\n\nCounting Occurrences:\n\nThe find_max_multiplicity function uses Python’s Counter from the collections module to count how often each difference appears in the convolution list. It then finds the difference with the maximum count (multiplicity) and its corresponding value.\n\nMain Function:\n\nThe main function orchestrates the proces by calling the helper functions and printing the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-55",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-55",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "56.1 Sample Dataset",
    "text": "56.1 Sample Dataset\n(dog,((elephant,mouse),robot),cat);"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-56",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-56",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "56.2 Sample Output",
    "text": "56.2 Sample Output\n00110\n00111"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-52",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-52",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "56.3 Solution",
    "text": "56.3 Solution\nThe code parses a Newick string representing a phylogenetic tree and converts it into a character table, where each row of the table represents a partition of taxa.\nfrom collections import defaultdict\n\n# Node clas to represent a node in the tree\nclas Node:\n    def __init__(self, name=\"\"):\n        self.name = name         # Name of the taxon or internal node\n        self.children = []       # List to store child nodes\n\n# Function to parse a Newick string into a tree structure\ndef parse_newick(newick):\n    def parse_node():\n        nonlocal i\n        node = Node()\n        if newick[i] == '(':\n            i += 1\n            while newick[i] != ')':\n                node.children.append(parse_node())\n                if newick[i] == ',':\n                    i += 1\n            i += 1\n        # Extract node name\n        if newick[i] not in ',)':\n            name_start = i\n            while newick[i] not in ',)':\n                i += 1\n            node.name = newick[name_start:i]\n        return node\n\n    i = 0\n    return parse_node()\n\n# Recursive function to find all splits (partitions) of the taxa\ndef find_splits(node, taxa, splits):\n    # If it's a leaf node, return the set containing the taxon name\n    if not node.children:\n        return {node.name}\n    \n    # Recursively find splits in left and right children\n    left = find_splits(node.children[0], taxa, splits)\n    right = find_splits(node.children[1], taxa, splits)\n    \n    # Combine left and right splits\n    split = left | right\n    \n    # Check if this split is non-trivial and add it to the splits list\n    if 1 &lt; len(split) &lt; len(taxa) - 1:\n        splits.append(split)\n    \n    return split\n\n# Function to create a character table from the splits\ndef create_character_table(tree, taxa):\n    splits = []\n    find_splits(tree, set(taxa), splits)\n    \n    table = []\n    # Convert each split into a binary row\n    for split in splits:\n        row = ['1' if taxon in split else '0' for taxon in taxa]\n        table.append(''.join(row))\n    \n    return table\n\n# Sample Newick string\nsample_input = \"\"\"\n(dog,((elephant,mouse),robot),cat);\n\"\"\"\n\n# Strip leading/trailing whitespace and parse the Newick string\nnewick = sample_input.strip()\ntree = parse_newick(newick)\n\ntaxa = []\n\n# Function to collect all taxa names from the tree\ndef collect_taxa(node):\n    if node.name:\n        taxa.append(node.name)\n    for child in node.children:\n        collect_taxa(child)\n\n# Collect and sort taxa names\ncollect_taxa(tree)\ntaxa.sort()\n\n# Create the character table based on the collected taxa\ncharacter_table = create_character_table(tree, taxa)\n\n# Print each row of the character table\nfor row in character_table:\n    print(row)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explain",
    "href": "posts/qmd/Rosalind_stronghold.html#explain",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "56.4 Explain",
    "text": "56.4 Explain\n\nNode Class:\n\nPurpose: Represents a node in the tree.\nAttributes:\n\nname: Name of the taxon or internal node.\nchildren: List of child nodes.\n\n\nparse_newick Function:\n\nPurpose: Parses a Newick string into a tree structure.\nInner Function parse_node:\n\nHandles parentheses: It processes nested parentheses to build the tree structure.\nExtracts names: It extracts the name of each node by looking for characters until it hits a delimiter (comma or closing parenthesis).\n\n\nfind_splits Function:\n\nPurpose: Finds and collects all non-trivial splits of the taxa.\nParameters:\n\nnode: Current node in the tree.\ntaxa: Set of all taxa names.\nsplits: List to collect all non-trivial splits.\n\nLogic:\n\nRecursively computes splits for left and right subtrees.\nCombines splits and checks if they are non-trivial.\nAdds valid splits to the splits list.\n\n\ncreate_character_table Function:\n\nPurpose: Converts splits into a character table.\nParameters:\n\ntree: Root node of the tree.\ntaxa: List of sorted taxa names.\n\nLogic:\n\nUses find_splits to get the splits.\nConverts each split into a binary representation.\nConstructs and returns the character table as a list of strings.\n\n\nMain Execution:\n\nInput Handling: Reads and strips the Newick string, then parses it into a tree.\nTaxa Collection: Collects and sorts all taxa names from the tree.\nCharacter Table Creation: Generates and prints the character table based on the tree structure and taxa."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-56",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-56",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "57.1 Sample Dataset",
    "text": "57.1 Sample Dataset\nTGAT\nCATG\nTCAT\nATGC\nCATC\nCATC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-57",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-57",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "57.2 Sample Output",
    "text": "57.2 Sample Output\n(ATC, TCA)\n(ATG, TGA)\n(ATG, TGC)\n(CAT, ATC)\n(CAT, ATG)\n(GAT, ATG)\n(GCA, CAT)\n(TCA, CAT)\n(TGA, GAT)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-53",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-53",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "57.3 Solution",
    "text": "57.3 Solution\nWe’ll compute the reverse complements and the updated set separately and then proceed with constructing the De Bruijn graph.\nfrom collections import defaultdict\n\ndef reverse_complement(dna):\n    \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return ''.join(complement[base] for base in reversed(dna))\n\ndef construct_de_bruijn_graph(kmers):\n    \"\"\"Constructs the De Bruijn graph and returns the adjacency list.\"\"\"\n    # Create a new set to include reverse complements\n    kmers_with_rc = set(kmers)\n    for kmer in kmers:\n        rc_kmer = reverse_complement(kmer)\n        kmers_with_rc.add(rc_kmer)\n    \n    adjacency_list = defaultdict(set)\n    k = len(next(iter(kmers))) - 1  # Length of the k-mer\n    \n    for kmer in kmers_with_rc:\n        for i in range(len(kmer) - k):\n            prefix = kmer[i:i+k]\n            suffix = kmer[i+1:i+k+1]\n            adjacency_list[prefix].add(suffix)\n    \n    return adjacency_list\n\ndef format_adjacency_list(adj_list):\n    \"\"\"Formats the adjacency list into the required output format.\"\"\"\n    result = []\n    for start_node, end_nodes in adj_list.items():\n        for end_node in end_nodes:\n            result.append(f\"({start_node}, {end_node})\")\n    return sorted(result)\n\ndef main(input_data):\n    \"\"\"Main function to proces the input data and generate the De Bruijn graph.\"\"\"\n    lines = input_data.strip().split('\\n')\n    kplus1_mers = set(lines)\n    \n    # Determine k from the length of the (k+1)-mers\n    k = len(next(iter(kplus1_mers))) - 1\n    \n    # Construct the De Bruijn graph\n    adj_list = construct_de_bruijn_graph(kplus1_mers)\n    \n    # Format and print the adjacency list\n    formatted_output = format_adjacency_list(adj_list)\n    for line in formatted_output:\n        print(line)\n\n# Sample input\nsample_input = \"\"\"\nTGAT\nCATG\nTCAT\nATGC\nCATC\nCATC\n\"\"\"\n\n# Run the main function with the sample input\nmain(sample_input)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#changes-made",
    "href": "posts/qmd/Rosalind_stronghold.html#changes-made",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "57.4 Changes Made",
    "text": "57.4 Changes Made\n\nAvoided Modifying Set During Iteration:\n\nInstead of modifying kmers while iterating over it, we create a new set kmers_with_rc that initially contains all the original kmers and then add reverse complements to it.\n\nFixed the Extraction of Prefix and Suffix:\n\nAdjusted the slicing in the De Bruijn graph construction to ensure we correctly extract the prefix and suffix (k)-mers from each (k+1)-mer.\n\nEnsured Proper Handling of Adjacency List:\n\nCorrectly formatted the adjacency list to meet the output requirements."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-57",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-57",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "58.1 Sample Dataset",
    "text": "58.1 Sample Dataset\n&gt;Rosalind_43\nPRETTY\n&gt;Rosalind_97\nPRTTEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-58",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-58",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "58.2 Sample Output",
    "text": "58.2 Sample Output\n4\nPRETTY--\nPR-TTEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-54",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-54",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "58.3 Solution",
    "text": "58.3 Solution\ndef parse_fasta(fasta_str):\n    \"\"\"\n    Parse a FASTA format string into a list of sequences.\n    \"\"\"\n    sequences = []\n    current_sequence = []\n    for line in fasta_str.strip().split(\"\\n\"):\n        if line.startswith(\"&gt;\"):\n            if current_sequence:\n                sequences.append(\"\".join(current_sequence))\n                current_sequence = []\n        else:\n            current_sequence.append(line.strip())\n    if current_sequence:\n        sequences.append(\"\".join(current_sequence))\n    return sequences\n\ndef edit_distance_alignment(s, t):\n    \"\"\"\n    Compute the edit distance and optimal alignment of two strings.\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize the dp table for base cases\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n\n    # Traceback to construct the aligned strings\n    s_aligned, t_aligned = \"\", \"\"\n    i, j = m, n\n    while i &gt; 0 and j &gt; 0:\n        if s[i-1] == t[j-1]:\n            s_aligned = s[i-1] + s_aligned\n            t_aligned = t[j-1] + t_aligned\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i-1][j] + 1:\n            s_aligned = s[i-1] + s_aligned\n            t_aligned = \"-\" + t_aligned\n            i -= 1\n        elif dp[i][j] == dp[i][j-1] + 1:\n            s_aligned = \"-\" + s_aligned\n            t_aligned = t[j-1] + t_aligned\n            j -= 1\n        else:\n            s_aligned = s[i-1] + s_aligned\n            t_aligned = t[j-1] + t_aligned\n            i -= 1\n            j -= 1\n\n    # Handle any remaining characters\n    while i &gt; 0:\n        s_aligned = s[i-1] + s_aligned\n        t_aligned = \"-\" + t_aligned\n        i -= 1\n    while j &gt; 0:\n        s_aligned = \"-\" + s_aligned\n        t_aligned = t[j-1] + t_aligned\n        j -= 1\n\n    return dp[m][n], s_aligned, t_aligned\n\n# Sample input\nsample_input = \"\"\"\n&gt;Rosalind_43\nPRETTY\n&gt;Rosalind_97\nPRTTEIN\n\"\"\"\n\n# Proces the input\nsequences = parse_fasta(sample_input)\ns, t = sequences[0], sequences[1]\n\n# Compute edit distance and alignment\nedit_distance, s_aligned, t_aligned = edit_distance_alignment(s, t)\n\n# Print the results\nprint(edit_distance)\nprint(s_aligned)\nprint(t_aligned)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-10",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-10",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "58.4 Explanation of the Code",
    "text": "58.4 Explanation of the Code\n\nparse_fasta(fasta_str): Convert a FASTA format string into a list of sequences.\n\nSplit the input string into lines.\nCollect sequence lines into current_sequence until a new header line is encountered.\nAppend the complete sequence to sequences when a new header is found.\nReturn the list of sequences.\n\nedit_distance_alignment(s, t): Compute the edit distance and provide an optimal alignment of two sequences.\n\nInitialize DP Table: Set up a 2D table dp where dp[i][j] holds the minimum edit distance between the first i characters of s and the first j characters of t.\nFill DP Table: Use dynamic programming to calculate the edit distance considering substitutions, insertions, and deletions.\nTraceback: Build the aligned sequences by following the dp table from the bottom-right to the top-left, handling matches, insertions, and deletions.\nHandle Remaining Characters: If there are remaining characters in either string after the traceback, append them with gaps."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-58",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-58",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "59.1 Sample Dataset",
    "text": "59.1 Sample Dataset\n1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-59",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-59",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "59.2 Sample Output",
    "text": "59.2 Sample Output\nKEKEP"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-55",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-55",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "59.3 Solution",
    "text": "59.3 Solution\nimport random\nfrom typing import List, Tuple, Dict, Union\n\n# Amino acid mas mapping\namino_acid_masses: Dict[float, List[str]] = {\n    57.02146: [\"G\"], 71.03711: [\"A\"], 87.03203: [\"S\"], 97.05276: [\"P\"], 99.06841: [\"V\"],\n    101.04768: [\"T\"], 103.00919: [\"C\"], 113.08406: [\"I\", \"L\"], 114.04293: [\"N\"], 115.02694: [\"D\"],\n    128.05858: [\"Q\"], 128.09496: [\"K\"], 129.04259: [\"E\"], 131.04049: [\"M\"], 137.05891: [\"H\"],\n    147.06841: [\"F\"], 156.10111: [\"R\"], 163.06333: [\"Y\"], 186.07931: [\"W\"],\n}\n\ndef infer_peptide(n: int, parent_mass: float, ion_masses: List[float], peptides: List[str]) -&gt; List[str]:\n    \"\"\"\n    Infers peptide sequences based on given ion masses and the target peptide length.\n\n    :param n: Length of the peptide to be inferred.\n    :param parent_mass: Mas of the parent peptide.\n    :param ion_masses: List of ion masses representing b-ions and y-ions.\n    :param peptides: List of current peptide candidates.\n    :return: List of inferred peptide sequences.\n    \"\"\"\n    if len(peptides[0]) == n:\n        return peptides\n\n    possible_ions = []  # List to store possible amino acids between ion pairs\n\n    # Find possible amino acids between ion pairs\n    for i in range(len(ion_masses) - 1):\n        for j in range(i + 1, len(ion_masses)):\n            delta_mas = round(ion_masses[j] - ion_masses[i], 5)\n            amino_acids = amino_acid_masses.get(delta_mass, [])\n            if amino_acids:\n                possible_ions.append((i, j, amino_acids))\n    \n    if possible_ions:\n        # Update ion masses and peptide candidates\n        new_ion_masses = ion_masses[possible_ions[0][1]:]\n        new_amino_acids = possible_ions[0][2]\n        new_peptides = [peptide + aa for peptide in peptides for aa in new_amino_acids]\n        \n        # Recursively infer peptide sequences\n        return infer_peptide(n, parent_mass, new_ion_masses, new_peptides)\n\n    return peptides\n\n# Sample input\nsample_input = \"\"\"\n1988.21104821\n610.391039105\n738.485999105\n766.492149105\n863.544909105\n867.528589105\n992.587499105\n995.623549105\n1120.6824591\n1124.6661391\n1221.7188991\n1249.7250491\n1377.8200091\n\"\"\"\n\n# Parse input data\ninput_lines = [float(line) for line in sample_input.strip().split(\"\\n\")]\nparent_mass, ion_masses = input_lines[0], input_lines[1:]\n\n# Determine the length of the peptide\npeptide_length = (len(ion_masses) - 2) // 2\n\n# Infer peptide sequences\npossible_peptides = infer_peptide(peptide_length, parent_mass, ion_masses, [\"\"])\n\n# Print a random peptide sequence\nprint(random.choice(possible_peptides))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-59",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-59",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "60.1 Sample Dataset",
    "text": "60.1 Sample Dataset\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-60",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-60",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "60.2 Sample Output",
    "text": "60.2 Sample Output\n0.000 -0.005 -0.024 -0.082 -0.206 -0.424 -0.765 -1.262 -1.969 -3.010"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-56",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-56",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "60.3 Solution",
    "text": "60.3 Solution\nimport math\n\ndef calculate_shared_chromosome_probabilities(sample_input: str):\n    \"\"\"\n    Calculate the common logarithm of the probability that two diploid siblings\n    share at least k of their 2n chromosomes, given n.\n    \n    Args:\n    - sample_input (str): The input string representing the value of n.\n    \n    Returns:\n    - List of float: Logarithm base 10 of the cumulative probabilities.\n    \"\"\"\n    # Parse the sample input to an integer\n    n = int(sample_input.strip())\n\n    # Probability of sharing each chromosome (independent coin flip)\n    p = 0.5\n\n    # Initialize the cumulative probability and the result array\n    Pr = 0\n    A = []\n\n    # Loop from 2*n down to 1 (inclusive) to calculate cumulative probabilities\n    for k in range(2 * n, 0, -1):\n        # Calculate the binomial coefficient: C(2n, k)\n        binom_coeff = math.factorial(2 * n) / (math.factorial(k) * math.factorial(2 * n - k))\n\n        # Calculate the probability of exactly k shared chromosomes\n        Pr += binom_coeff * math.pow(p, k) * math.pow(1 - p, 2 * n - k)\n\n        # Append the common logarithm (base 10) of the cumulative probability to the result array\n        A.append(math.log10(Pr))\n\n    # Return the result array in reverse order\n    return [round(value, 3) for value in A[::-1]]\n\n# Example usage\nsample_input = \"5\"\nresult = calculate_shared_chromosome_probabilities(sample_input)\nprint(\" \".join(f\"{value:3f}\" for value in result))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-function",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-function",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "60.4 Explanation of the Function",
    "text": "60.4 Explanation of the Function\n\nFunction Definition:\n\nThe function calculate_shared_chromosome_probabilities takes a string sample_input.\n\nParse Input:\n\nsample_input is stripped of any surrounding whitespace and converted to an integer n.\n\nInitialize Variables:\n\np is set to 0.5, representing the probability of sharing each chromosome.\nPr is initialized to store the cumulative probability.\nA is an empty list to store the logarithms of cumulative probabilities.\n\nCalculate Cumulative Probabilities:\n\nLoop from 2*n down to 1 to calculate the cumulative probability for at least k shared chromosomes.\nFor each k, compute the binomial coefficient \\(C(2n, k)\\).\nCalculate the probability of exactly k shared chromosomes and add it to Pr.\nAppend the logarithm (base 10) of Pr to the list A.\n\nReturn the Result:\n\nReturn the values in A in reverse order, rounded to 3 decimal places.\n\nExample Usage:\n\nThe function is called with a sample input \"5\", and the results are printed in the specified format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-60",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-60",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "61.1 Sample Dataset",
    "text": "61.1 Sample Dataset\nGACCACGGTT\nACAG\nGT\nCCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-61",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-61",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "61.2 Sample Output",
    "text": "61.2 Sample Output\n0 0 1\n0 1 0\n1 0 0"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-57",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-57",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "61.3 Solution",
    "text": "61.3 Solution\nimport numpy as np\n\ndef is_interwoven(dna1, dna2, superstr):\n    \"\"\"\n    Recursive function to check if dna1 and dna2 can be interwoven to form superstr.\n    \"\"\"\n    if len(superstr) == 0:\n        return True\n    elif dna1 and dna2 and dna1[0] == dna2[0] == superstr[0]:\n        return is_interwoven(dna1[1:], dna2, superstr[1:]) or is_interwoven(dna1, dna2[1:], superstr[1:])\n    elif dna1 and dna1[0] == superstr[0]:\n        return is_interwoven(dna1[1:], dna2, superstr[1:])\n    elif dna2 and dna2[0] == superstr[0]:\n        return is_interwoven(dna1, dna2[1:], superstr[1:])\n    else:\n        return False\n\ndef find_disjoint_motifs(super_string, patterns):\n    \"\"\"\n    Function to find the disjoint motifs matrix for the given super_string and patterns.\n    \"\"\"\n    n = len(patterns)\n    M = np.zeros((n, n), dtype=int)\n\n    for i in range(n):\n        for j in range(i, n):\n            pattern1 = patterns[i]\n            pattern2 = patterns[j]\n            combined_length = len(pattern1) + len(pattern2)\n            combined_profile = [pattern1.count(nuc) + pattern2.count(nuc) for nuc in \"ACGT\"]\n\n            for index in range(len(super_string) - combined_length + 1):\n                superstr_segment = super_string[index:index + combined_length]\n                superstr_profile = [superstr_segment.count(nuc) for nuc in \"ACGT\"]\n\n                if combined_profile == superstr_profile:\n                    if is_interwoven(pattern1 + '$', pattern2 + '$', superstr_segment):\n                        M[i][j] = 1\n                        break\n\n            if i != j:\n                M[j][i] = M[i][j]\n\n    return M\n\n# Sample dataset\nsample_input = \"\"\"\nGACCACGGTT\nACAG\nGT\nCCG\n\"\"\"\ndata = sample_input.strip().split()\nsuper_string = data[0]\npatterns = data[1:]\n\n# Find the disjoint motifs matrix\nresult_matrix = find_disjoint_motifs(super_string, patterns)\n\n# Print the result matrix\nfor row in result_matrix:\n    print(\" \".join(map(str, row)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-30",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-30",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "61.4 Explanation",
    "text": "61.4 Explanation\n\nis_interwoven Function:\n\nPurpose: To check if dna1 and dna2 can be interwoven to form superstr.\nParameters: dna1, dna2, and superstr.\nLogic:\n\nIf superstr is empty, return True because the interweaving is complete.\nIf both dna1 and dna2 are non-empty and their first characters match the first character of superstr, recursively check both possibilities (taking from dna1 or dna2).\nIf the first character of dna1 matches the first character of superstr, recursively check the remaining parts.\nIf the first character of dna2 matches the first character of superstr, recursively check the remaining parts.\nIf none of the above conditions are met, return False.\n\n\nfind_disjoint_motifs Function:\n\nPurpose: To find the disjoint motifs matrix for the given super_string and patterns.\nParameters: super_string and patterns.\nLogic:\n\nInitialize a zero matrix M of size n x n where n is the number of patterns.\nFor each pair of patterns pattern1 and pattern2, calculate their combined length and nucleotide profile.\nIterate over all possible substrings of super_string of the same length.\nCompare the nucleotide profile of the substring with the combined profile.\nIf they match, use is_interwoven to check if they can be interwoven to form the substring.\nUpdate the matrix M accordingly.\nSince the comparison is symmetric, update both M[i][j] and M[j][i].\n\n\nMain Execution:\n\nParse the input to extract the super_string and patterns.\nCall find_disjoint_motifs to get the result matrix.\nPrint the result matrix."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-61",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-61",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.1 Sample Dataset",
    "text": "62.1 Sample Dataset\nCATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-62",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-62",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.2 Sample Output",
    "text": "62.2 Sample Output\nCATAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-58",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-58",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.3 Solution",
    "text": "62.3 Solution\nTo solve this problem, we need to find the longest substring that appears at least k times in a given string s, using its suffix tree. Here’s how we can approach the problem step-by-step:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-approach-the-problem",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-approach-the-problem",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.4 Steps to Approach the Problem",
    "text": "62.4 Steps to Approach the Problem\n\nParse the Input:\n\nRead the DNA string s with $ appended.\nRead the integer k.\nParse the edges defining the suffix tree.\n\nSuffix Tree Representation:\n\nUse the given edges to construct the suffix tree.\nEach edge contains information about the parent node, child node, start position of the substring in s, and the length of the substring.\n\nTraverse the Suffix Tree:\n\nTraverse the tree to count the occurrences of substrings.\nUse a depth-first search (DFS) to explore all paths from the root to the leaves.\n\nIdentify the Longest Substring with at least k Occurrences:\n\nTrack the longest substring that meets the condition during the traversal."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-6",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-6",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.5 Implementation",
    "text": "62.5 Implementation\nHere’s the Python code to implement the solution:\nclas SuffixTreeNode:\n    def __init__(self):\n        self.children = {}\n        self.start = -1\n        self.length = -1\n        self.parent = None\n\ndef build_suffix_tree(edges, s):\n    nodes = {}\n    for edge in edges:\n        parent, child, start, length = edge\n        if parent not in nodes:\n            nodes[parent] = SuffixTreeNode()\n        if child not in nodes:\n            nodes[child] = SuffixTreeNode()\n        nodes[child].parent = nodes[parent]\n        nodes[child].start = start - 1  # Convert to zero-based index\n        nodes[child].length = length\n        nodes[parent].children[child] = nodes[child]\n    return nodes\n\ndef dfs(node, s, k, path, results):\n    if len(node.children) == 0:\n        return 1  # Leaf node\n    \n    count = 0\n    for child in node.children.values():\n        count += dfs(child, s, k, path + s[child.start:child.start + child.length], results)\n    \n    if count &gt;= k:\n        results.append((path, len(path)))\n    \n    return count\n\ndef longest_k_fold_substring(s, k, edges):\n    nodes = build_suffix_tree(edges, s)\n    root = nodes['node1']\n    results = []\n    dfs(root, s, k, \"\", results)\n    \n    results.sort(key=lambda x: x[1], reverse=True)\n    \n    return results[0][0] if results else \"\"\n\n# Sample input\nsample_input = \"\"\"\nCATACATAC$\n2\nnode1 node2 1 1\nnode1 node7 2 1\nnode1 node14 3 3\nnode1 node17 10 1\nnode2 node3 2 4\nnode2 node6 10 1\nnode3 node4 6 5\nnode3 node5 10 1\nnode7 node8 3 3\nnode7 node11 5 1\nnode8 node9 6 5\nnode8 node10 10 1\nnode11 node12 6 5\nnode11 node13 10 1\nnode14 node15 6 5\nnode14 node16 10 1\n\"\"\"\n\ndata = sample_input.strip().split('\\n')\ns = data[0]\nk = int(data[1])\nedges = [tuple(line.split()) for line in data[2:]]\nedges = [(e[0], e[1], int(e[2]), int(e[3])) for e in edges]\n\nresult = longest_k_fold_substring(s, k, edges)\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-31",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-31",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "62.6 Explanation",
    "text": "62.6 Explanation\n\nSuffixTreeNode Class:\n\nA clas to represent each node in the suffix tree.\n\nbuild_suffix_tree Function:\n\nConstructs the suffix tree using the given edges.\n\ndfs Function:\n\nPerforms a depth-first search to count the occurrences of substrings and keep track of the valid ones.\n\nlongest_k_fold_substring Function:\n\nBuilds the suffix tree, performs DFS, and identifies the longest substring with at least k occurrences.\n\nSample Input:\n\nParses the input and invokes the longest_k_fold_substring function to find and print the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-62",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-62",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "63.1 Sample Dataset",
    "text": "63.1 Sample Dataset\n(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-63",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-63",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "63.2 Sample Output",
    "text": "63.2 Sample Output\n75 136"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-59",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-59",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "63.3 Solution",
    "text": "63.3 Solution\nclas Node:\n    def __init__(self, number, parent, name=None):\n        self.number = number\n        self.parent = parent\n        self.name = \"Node_\" + str(self.number) if name is None else name\n\n    def __repr__(self):\n        tmp = \"\"\n        if self.name != \"Node_\" + str(self.number):\n            tmp = f\"({self.name})\"\n        return f\"Node_{self.number}{tmp}\"\n\n\nclas WeightedNewick:\n    def __init__(self, data):\n        self.nodes = []\n        self.edge_weight = {}\n        self.construct_tree(data)\n        self.name_index = {node.name: node.number for node in self.nodes}\n\n    def construct_tree(self, data):\n        \"\"\"Constructs the Newick Tree from the input data.\"\"\"\n        data = data.replace(',', ' ').replace('(', '( ').replace(')', ' )').strip(';').split()\n        current_parent = Node(-1, None)\n        for item in data:\n            if item[0] == '(':\n                # New internal node\n                current_parent = Node(len(self.nodes), current_parent.number)\n                self.nodes.append(current_parent)\n            elif item[0] == ')':\n                # End of a subtree, backtrack to parent\n                if len(item) &gt; 1:\n                    self.edge_weight[(current_parent.number, current_parent.parent)] = int(item[item.find(':') + 1:])\n                    if len(item) &gt; 2:\n                        current_parent.name = item[1:item.find(':')]\n                current_parent = self.nodes[current_parent.parent]\n            else:\n                # Leaf node\n                self.edge_weight[(len(self.nodes), current_parent.number)] = int(item[item.find(':') + 1:])\n                self.nodes.append(Node(len(self.nodes), current_parent.number, item[:item.find(':')]))\n\n    def distance(self, name1, name2):\n        \"\"\"Returns the distance between nodes with names name1 and name2.\"\"\"\n        if name1 == name2:\n            return 0\n\n        # Create the branches from the two desired nodes to the root\n        idx1 = self.name_index[name1]\n        branch1 = [(idx1, self.nodes[idx1].parent)]\n        idx2 = self.name_index[name2]\n        branch2 = [(idx2, self.nodes[idx2].parent)]\n\n        # Trace the path to the root for both nodes\n        while branch1[-1][1] != -1:\n            current_idx = branch1[-1][1]\n            branch1.append((current_idx, self.nodes[current_idx].parent))\n        while branch2[-1][1] != -1:\n            current_idx = branch2[-1][1]\n            branch2.append((current_idx, self.nodes[current_idx].parent))\n\n        # Calculate the distance as the sum of edge weights in the symmetric difference of paths\n        return sum([self.edge_weight[edge] for edge in set(branch1) ^ set(branch2)])\n\n\n# Sample input\nsample_input = \"\"\"\n(dog:42,cat:33);\ncat dog\n\n((dog:4,cat:3):74,robot:98,elephant:58);\ndog elephant\n\"\"\"\ninput_lines = sample_input.strip().split('\\n')\n\n# Compute distances between pairs of nodes in each tree\ndistance_list = []\nfor i in range(0, len(input_lines) - 1, 3):\n    tree = input_lines[i]\n    nodeA, nodeB = input_lines[i + 1].split()\n    distance_list.append(str(WeightedNewick(tree).distance(nodeA, nodeB)))\n\n# Print the computed distances\nprint(\" \".join(distance_list))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-32",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-32",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "63.4 Explanation",
    "text": "63.4 Explanation\n\nNode Class:\n\nThis clas represents a node in the tree.\nEach node has a number, a parent, and an optional name.\nThe __repr__ method provides a string representation of the node.\n\nWeightedNewick Class:\n\nThis clas constructs a tree from a Newick string and provides functionality to compute distances between nodes.\n__init__: Initializes the tree, constructs it from the input data, and creates a mapping from node names to their indices.\nconstruct_tree: Parses the Newick string to build the tree structure and store edge weights.\ndistance: Computes the distance between two nodes by tracing their paths to the root and summing the edge weights in the symmetric difference of these paths.\n\nMain Execution:\n\nThe sample input is split into lines, and the trees and node pairs are extracted.\nFor each tree and node pair, a WeightedNewick object is created, and the distance between the specified nodes is computed.\nThe distances are printed in the required format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-63",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-63",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.1 Sample Dataset",
    "text": "64.1 Sample Dataset\nAUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-64",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-64",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.2 Sample Output",
    "text": "64.2 Sample Output\n284850219977421"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-60",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-60",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.3 Solution",
    "text": "64.3 Solution\nTo solve the problem of counting distinct valid matchings of basepair edges in an RNA string considering wobble base pairing (G-U pairs) and noncrossing constraints, we can use a dynamic programming approach. Below is a detailed explanation and implementation in Python:"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#approach-2",
    "href": "posts/qmd/Rosalind_stronghold.html#approach-2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.4 Approach",
    "text": "64.4 Approach\n\nDynamic Programming (DP) Setup:\n\nDefine a 2D DP table dp where dp[i][j] represents the number of valid matchings for the substring of the RNA sequence from index i to index j.\nBase case: dp[i][i-1] = 1 for all i because an empty substring has one valid matching (the empty matching).\n\nRecursive Relation:\n\nFor each pair of indices i and j such that i &lt; j, we consider the possibility of the base at position i pairing with any valid base at position k where i &lt; k &lt;= j and k &gt;= i + 4 (to respect the distance constraint).\nThe RNA bases can pair if they form a valid pair: A-U, U-A, C-G, G-C, G-U, or U-G.\nThe number of matchings for substring s[i:j+1] is calculated by splitting it into the matchings between s[i] and s[k] and recursively solving for the substrings s[i+1:k-1] and s[k+1:j].\n\nIterative Calculation:\n\nFill in the DP table iteratively, starting from smaller substrings and building up to the entire string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-7",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-7",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.5 Implementation",
    "text": "64.5 Implementation\ndef count_valid_matchings(rna):\n    n = len(rna)\n    dp = [[0] * n for _ in range(n)]\n\n    def can_pair(b1, b2):\n        return (b1 == 'A' and b2 == 'U') or (b1 == 'U' and b2 == 'A') or \\\n               (b1 == 'C' and b2 == 'G') or (b1 == 'G' and b2 == 'C') or \\\n               (b1 == 'G' and b2 == 'U') or (b1 == 'U' and b2 == 'G')\n\n    for i in range(n):\n        dp[i][i] = 1  # A single base has one valid matching (itself)\n\n    for length in range(1, n + 1):  # length is the length of the substring\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = dp[i+1][j]  # Case where s[i] is not paired\n            for k in range(i + 4, j + 1):\n                if can_pair(rna[i], rna[k]):\n                    if k == j:\n                        dp[i][j] += dp[i+1][k-1]\n                    else:\n                        dp[i][j] += dp[i+1][k-1] * dp[k+1][j]\n\n    return dp[0][n-1]\n\n# Sample Dataset\nrna = \"AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU\"\n\n# Output the result\nprint(count_valid_matchings(rna))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-33",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-33",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "64.6 Explanation",
    "text": "64.6 Explanation\n\nBase Case:\n\nEach single base (or empty substring) has one valid matching (dp[i][i] = 1).\n\nFilling DP Table:\n\nFor each possible substring length, calculate the number of valid matchings by considering all possible pairs for the first base and ensuring the substrings formed by removing the matched bases also have valid matchings.\n\nHelper Function:\n\ncan_pair checks if two bases can pair according to the given rules including wobble base pairing."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-64",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-64",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.1 Sample Dataset",
    "text": "65.1 Sample Dataset\n0.1 0.25 0.5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-65",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-65",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.2 Sample Output",
    "text": "65.2 Sample Output\n0.532 0.75 0.914"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-61",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-61",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.3 Solution",
    "text": "65.3 Solution\nTo solve the problem of determining the probability that a randomly selected individual carries at least one copy of the recessive allele for each Mendelian factor, we need to work with the Hardy-Weinberg equilibrium principles."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#steps-to-solve",
    "href": "posts/qmd/Rosalind_stronghold.html#steps-to-solve",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.4 Steps to Solve",
    "text": "65.4 Steps to Solve\n\nGiven Data:\n\nArray \\(A\\) where \\(A[k]\\) is the proportion of homozygous recessive individuals for the \\(k\\)-th factor.\nWe need to find an array \\(B\\) where \\(B[k]\\) is the probability that a randomly selected individual carries at least one copy of the recessive allele for the \\(k\\)-th factor.\n\nHardy-Weinberg Principle:\n\nIn genetic equilibrium, the proportion of homozygous recessive individuals (denoted \\(q^2\\)) is \\(A[k]\\).\nThe recessive allele frequency \\(q\\) is the square root of \\(A[k]\\), i.e., \\(q = \\sqrt{A[k]}\\).\nThe dominant allele frequency \\(p\\) is \\(1 - q\\).\n\nCarrier Probability:\n\nThe probability that an individual carries at least one recessive allele (i.e., they are either heterozygous or homozygous recessive) is given by \\(1 - p^2\\).\nSince \\(p = 1 - q\\), the carrier probability becomes \\(1 - (1 - q)^2\\).\n\nCalculation:\n\nFor each \\(k\\): \\[ q = \\sqrt{A[k]} \\] \\[ B[k] = 1 - (1 - q)^2 \\]"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#implementation-8",
    "href": "posts/qmd/Rosalind_stronghold.html#implementation-8",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.5 Implementation",
    "text": "65.5 Implementation\nHere’s how you can implement this in Python:\nimport math\n\ndef calculate_carrier_probability(A):\n    B = []\n    for q_squared in A:\n        q = math.sqrt(q_squared)\n        p = 1 - q\n        carrier_probability = 1 - p**2\n        B.append(carrier_probability)\n    return B\n\n# Sample Dataset\nsample_input = \"\"\"\n0.1 0.25 0.5\"\"\"\nA = [float(x) for x in sample_input.strip().split()]\n\n# Calculate the carrier probabilities\nB = calculate_carrier_probability(A)\n\n# Print the results formatted to three decimal places\nprint(\" \".join(f\"{prob:f}\" for prob in B))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-34",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-34",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "65.6 Explanation",
    "text": "65.6 Explanation\n\nFunction Definition:\n\ncalculate_carrier_probability takes the array \\(A\\) as input and returns the array \\(B\\).\n\nLoop Through \\(A\\):\n\nFor each element in \\(A\\):\n\nCompute \\(q\\) as the square root of the element.\nCompute \\(p\\) as \\(1 - q\\).\nCompute the carrier probability using \\(1 - p^2\\).\nAppend the result to \\(B\\).\n\n\nOutput:\n\nFormat the output to three decimal places for better readability."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-65",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-65",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "66.1 Sample Dataset",
    "text": "66.1 Sample Dataset\nATGCTACC\nCGTTTACC\nATTCGACC\nAGTCTCCC\nCGTCTATC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-66",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-66",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "66.2 Sample Output",
    "text": "66.2 Sample Output\n10110\n10100"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-62",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-62",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "66.3 Solution",
    "text": "66.3 Solution\ndef char_table_from_strings(dna_list):\n    \"\"\"\n    Builds a character table from a given list of DNA strings.\n    \n    Parameters:\n    dna_list (list of str): A list of DNA strings.\n    \n    Returns:\n    set of str: A set containing nontrivial character rows.\n    \"\"\"\n    character_table = set()\n    \n    # Iterate over each position in the DNA strings\n    for pos in range(len(dna_list[0])):\n        # Determine the reference character at the current position from the first DNA string\n        ref_char = dna_list[0][pos]\n        \n        # Create a binary array indicating the presence of the reference character at the current position\n        char_array = [int(dna[pos] == ref_char) for dna in dna_list]\n        \n        # Check if the character array is nontrivial (i.e., it has both 0s and 1s but not all 0s or all 1s)\n        if 1 &lt; sum(char_array) &lt; len(dna_list) - 1:\n            # Convert the binary array to a string and add it to the character table\n            character_table.add(''.join(map(str, char_array)))\n    \n    return character_table\n\n# Sample input\nsample_input = \"\"\"\nATGCTACC\nCGTTTACC\nATTCGACC\nAGTCTCCC\nCGTCTATC\n\"\"\"\n\n# Convert the input string to a list of DNA strings\ndna_list = sample_input.strip().split(\"\\n\")\n\n# Get the character table\ncharacter_table = char_table_from_strings(dna_list)\n\n# Print the character table\nfor row in character_table:\n    print(row)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-35",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-35",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "66.4 Explanation",
    "text": "66.4 Explanation\n\nFunction Definition: The function char_table_from_strings is defined to take a list of DNA strings and return a set of nontrivial character rows.\nInitialize Character Table: An empty set character_table is initialized to store the nontrivial character rows.\nIterate Over Positions: A loop iterates over each position in the DNA strings. The length of the first string is used to determine the number of positions.\nReference Character: For each position, the reference character ref_char is taken from the first DNA string.\nCreate Binary Array: A binary array char_array is created using a list comprehension. For each DNA string, it checks if the character at the current position matches the reference character and records 1 if it does and 0 if it doesn’t.\nCheck Nontrivial Condition: The array is considered nontrivial if it contains both 0s and 1s but is not all 0s or all 1s. This is checked using the condition 1 &lt; sum(char_array) &lt; len(dna_list) - 1.\nAdd to Character Table: If the binary array is nontrivial, it is converted to a string and added to the character_table set.\nReturn Character Table: The function returns the character_table set containing all nontrivial character rows.\nSample Input: The sample input is given as a multiline string, which is converted to a list of DNA strings by stripping and splitting by newline characters.\nGenerate and Print Character Table: The character table is generated by calling the function and printed row by row."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-66",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-66",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "67.1 Sample Dataset",
    "text": "67.1 Sample Dataset\n&gt;Rosalind_78\nPLEASANTLY\n&gt;Rosalind_33\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-67",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-67",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "67.2 Sample Output",
    "text": "67.2 Sample Output\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-63",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-63",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "67.3 Solution",
    "text": "67.3 Solution\ndef parse_fasta(fasta_string):\n    '''Parses a FASTA format string and returns the sequences in a list.'''\n    sequences = []\n    sequence = []\n\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if sequence:\n                sequences.append(''.join(sequence))\n                sequence = []\n        else:\n            sequence.append(line.strip())\n\n    if sequence:\n        sequences.append(''.join(sequence))\n    \n    return sequences\n\ndef count_optimal_alignments(s, t):\n    '''Counts the total number of optimal alignments of s and t with respect to edit alignment score.'''\n    MOD = 134217727  # Modulo value to prevent overflow\n    \n    m, n = len(s), len(t)\n    \n    # Initialize DP tables\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Table for edit distances\n    count = [[0] * (n + 1) for _ in range(m + 1)]  # Table for counting optimal alignments\n    \n    # Base cases: edit distance and count for aligning to empty string\n    for i in range(m + 1):\n        dp[i][0] = i\n        count[i][0] = 1\n    \n    for j in range(n + 1):\n        dp[0][j] = j\n        count[0][j] = 1\n    \n    # Fill the DP tables\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Calculate the cost of insert, delete, and replace operations\n            insert_cost = dp[i][j-1] + 1\n            delete_cost = dp[i-1][j] + 1\n            replace_cost = dp[i-1][j-1] + (0 if s[i-1] == t[j-1] else 1)\n            \n            # Find the minimum cost among the three operations\n            dp[i][j] = min(insert_cost, delete_cost, replace_cost)\n            \n            # Count the number of ways to achieve this minimum cost\n            if dp[i][j] == insert_cost:\n                count[i][j] += count[i][j-1]\n            if dp[i][j] == delete_cost:\n                count[i][j] += count[i-1][j]\n            if dp[i][j] == replace_cost:\n                count[i][j] += count[i-1][j-1]\n            \n            # Apply the modulo to keep the count manageable\n            count[i][j] %= MOD\n    \n    return count[m][n]\n\n# Sample dataset in FASTA format\nsample_input = \"\"\"\n&gt;Rosalind_78\nPLEASANTLY\n&gt;Rosalind_33\nMEANLY\n\"\"\"\n\n# Parse the FASTA input to get the sequences\nsequences = parse_fasta(sample_input)\ns, t = sequences[0], sequences[1]\n\n# Get the number of optimal alignments\nresult = count_optimal_alignments(s, t)\n\n# Print the result\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-36",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-36",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "67.4 Explanation",
    "text": "67.4 Explanation\n\nFASTA Parsing (parse_fasta):\n\nThis function reads a FASTA formatted string and extracts sequences.\nIt initializes an empty list sequences to store the parsed sequences and another list sequence to build each sequence.\nIt iterates over each line of the input string:\n\nIf a line starts with &gt;, it indicates a new sequence header. If sequence is not empty, it joins its elements into a single string and adds it to sequences.\nIf a line does not start with &gt;, it is part of a sequence, so it is added to sequence.\n\nAfter the loop, any remaining sequence is added to sequences.\nThe function returns the list of sequences.\n\nCounting Optimal Alignments (count_optimal_alignments):\n\nThis function calculates the number of optimal alignments between two strings s and t.\nMOD is a large prime number used to keep the counts within manageable limits.\ndp is a table where dp[i][j] stores the minimum edit distance between the first i characters of s and the first j characters of t.\ncount is a table where count[i][j] stores the number of optimal alignments that result in the minimum edit distance for the first i characters of s and the first j characters of t.\nThe base cases initialize the first row and first column of dp and count to represent alignments with an empty string.\nThe nested loops fill in the dp and count tables by considering insertion, deletion, and replacement operations.\nThe minimum cost operation is selected, and the number of ways to achieve this cost is counted.\nThe result is the number of optimal alignments for the entire strings s and t, stored in count[m][n].\n\nMain Execution:\n\nThe sample input is given in FASTA format.\nThe parse_fasta function is called to extract the sequences.\nThe count_optimal_alignments function is called with the parsed sequences to get the number of optimal alignments.\nThe result is printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-67",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-67",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "68.1 Sample Dataset",
    "text": "68.1 Sample Dataset\n5"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-68",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-68",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "68.2 Sample Output",
    "text": "68.2 Sample Output\n15"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-64",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-64",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "68.3 Solution",
    "text": "68.3 Solution\nimport functools\n\ndef count_unrooted_binary_trees(num_leaves: int) -&gt; int:\n    \"\"\"\n    Returns the number of unrooted binary trees with num_leaves leaves, \n    modulo 1,000,000.\n    \"\"\"\n    MODULO = 10**6\n\n    def double_factorial(n: int) -&gt; int:\n        result = 1\n        for i in range(n, 1, -2):\n            result = (result * i) % MODULO\n        return result\n\n    return double_factorial(2 * num_leaves - 5)\n\n# Sample input\nsample_input = \"5\"\nnum_leaves = int(sample_input.strip())\n\n# Get the number of unrooted binary trees\ntree_count = count_unrooted_binary_trees(num_leaves)\n\n# Print the result\nprint(tree_count)\n##$ Explanation\n\nDouble Factorial Calculation without Lambda:\n\nThe double_factorial function is now implemented using a simple for loop.\nThe loop iterates over the range from n down to 1, stepping by -2 (to get only odd numbers).\nIn each iteration, the current result is multiplied by i and taken modulo (10^6).\nThis avoids the use of a lambda function and functools.reduce.\n\nRest of the Code:\n\nThe rest of the code remains unchanged.\nThe count_unrooted_binary_trees function calls double_factorial with 2 * num_leaves - 5 to compute the number of unrooted binary trees.\nThe result is printed after parsing the sample input."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-68",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-68",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "69.1 Sample Dataset",
    "text": "69.1 Sample Dataset\n&gt;Rosalind_67\nPLEASANTLY\n&gt;Rosalind_17\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-69",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-69",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "69.2 Sample Output",
    "text": "69.2 Sample Output\n8"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-65",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-65",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "69.3 Solution",
    "text": "69.3 Solution\nTo solve the problem of finding the maximum alignment score between two protein strings using the BLOSUM62 scoring matrix and a linear gap penalty of 5, we need to implement the Needleman-Wunsch algorithm for global sequence alignment. This involves dynamic programming to compute the optimal alignment score.\nHere is the step-by-step explanation of the solution along with the Python code implementation:\n\nParse the FASTA input to extract the two protein sequences.\nSet up the BLOSUM62 scoring matrix.\nImplement the Needleman-Wunsch algorithm to compute the alignment score using the given scoring matrix and gap penalty.\n\ndef parse_fasta(fasta_string):\n    '''Parses a FASTA format string and returns the sequences in a list.'''\n    sequences = []\n    sequence = []\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if sequence:\n                sequences.append(''.join(sequence))\n                sequence = []\n        else:\n            sequence.append(line.strip())\n    if sequence:\n        sequences.append(''.join(sequence))\n    return sequences\n\n# BLOSUM62 matrix\nblosum62_str = \"\"\"\nA  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y\nA  4  0 -2 -1 -2  0 -2 -1 -1 -1 -1 -2 -1 -1 -1  1  0  0 -3 -2\nC  0  9 -3 -4 -2 -3 -3 -1 -3 -1 -1 -3 -3 -3 -3 -1 -1 -1 -2 -2\nD -2 -3  6  2 -3 -1 -1 -3 -1 -4 -3  1 -1  0 -2  0 -1 -3 -4 -3\nE -1 -4  2  5 -3 -2  0 -3  1 -2 -2  0 -1  2  0  0 -1 -2 -3 -2\nF -2 -2 -3 -3  6 -3 -1  0 -3  0  0 -3 -4 -3 -3 -2 -2 -1  1  3\nG  0 -3 -1 -2 -3  6 -2 -4 -2 -4 -3  0 -2 -2 -3  0 -2 -3 -2 -3\nH -2 -3 -1  0 -1 -2  8 -3 -1 -3 -2  1 -2  0  0 -1 -2 -3 -2  2\nI -1 -1 -3 -3  0 -4 -3  4 -3  2  1 -3 -3 -3 -3 -2 -1  3 -3 -1\nK -1 -3 -1  1 -3 -2 -1 -3  5 -2 -1  0 -1  1  2  0 -1 -2 -3 -2\nL -1 -1 -4 -2  0 -4 -3  2 -2  4  2 -3 -3 -2 -2 -2 -1  1 -2 -1\nM -1 -1 -3 -2  0 -3 -2  1 -1  2  5 -2 -2  0 -1 -1 -1  1 -1 -1\nN -2 -3  1  0 -3  0  1 -3  0 -3 -2  6 -2  0  0  1  0 -3 -4 -2\nP -1 -3 -1 -1 -4 -2 -2 -3 -1 -3 -2 -2  7 -1 -2 -1 -1 -3 -4 -3\nQ -1 -3  0  2 -3 -2  0 -3  1 -2  0  0 -1  5  1  0 -1 -2 -2 -1\nR -1 -3 -2  0 -3 -3  0 -3  2 -2 -1  0 -2  1  5 -1 -1 -3 -3 -2\nS  1 -1  0  0 -2  0 -1 -2  0 -2 -1  1 -1  0 -1  4  1 -2 -3 -2\nT  0 -1 -1 -1 -2 -2 -2 -1 -1 -1 -1  0 -1 -1 -1  1  5  0 -2 -2\nV  0 -1 -3 -2 -1 -3 -3  3 -2  1  1 -3 -3 -2 -3 -2  0  4 -3 -1\nW -3 -2 -4 -3  1 -2 -2 -3 -3 -2 -1 -4 -4 -2 -3 -3 -2 -3 11  2\nY -2 -2 -3 -2  3 -3  2 -1 -2 -1 -1 -2 -3 -1 -2 -2 -2 -1  2  7\n\"\"\"\n\ndef parse_blosum62(matrix_str):\n    \"\"\"Parse the BLOSUM62 matrix from a string.\"\"\"\n    lines = matrix_str.strip().split('\\n')\n    headers = lines[0].split()\n    matrix = {}\n    for line in lines[1:]:\n        values = line.split()\n        row = values[0]\n        scores = list(map(int, values[1:]))\n        for col, score in zip(headers, scores):\n            matrix[(row, col)] = score\n    return matrix\n\ndef needleman_wunsch(s, t, blosum62, gap_penalty):\n    \"\"\"Perform the Needleman-Wunsch algorithm for global alignment.\"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize dp table with gap penalties\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] + gap_penalty\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] + gap_penalty\n\n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = dp[i - 1][j - 1] + blosum62[(s[i - 1], t[j - 1])]\n            delete = dp[i - 1][j] + gap_penalty\n            insert = dp[i][j - 1] + gap_penalty\n            dp[i][j] = max(match, delete, insert)\n\n    return dp[m][n]\n\n# Sample dataset in FASTA format\nsample_input = \"\"\"\n&gt;Rosalind_67\nPLEASANTLY\n&gt;Rosalind_17\nMEANLY\n\"\"\"\n\n# Parse the FASTA input to get the sequences\nsequences = parse_fasta(sample_input)\ns, t = sequences[0], sequences[1]\n\n# Parse the BLOSUM62 matrix\nblosum62 = parse_blosum62(blosum62_str)\n\n# Set the gap penalty\ngap_penalty = -5\n\n# Get the maximum alignment score using Needleman-Wunsch algorithm\nresult = needleman_wunsch(s, t, blosum62, gap_penalty)\n\n# Print the result\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-11",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-11",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "69.4 Explanation of the Code",
    "text": "69.4 Explanation of the Code\n\nParsing FASTA Input:\n\nparse_fasta function reads the input in FASTA format and returns the sequences in a list.\n\nBLOSUM62 Scoring Matrix:\n\nparse_blosum62 function parses the BLOSUM62 matrix string and stores the scores in a dictionary for easy lookup.\n\nNeedleman-Wunsch Algorithm:\n\nneedleman_wunsch function implements the dynamic programming algorithm to compute the global alignment score.\nThe dp table is initialized with gap penalties.\nThe table is filled based on the scores for matches, insertions, and deletions.\nThe final alignment score is found in dp[m][n].\n\nExecution:\n\nThe sequences are parsed, the scoring matrix is loaded, and the alignment score is computed using the Needleman-Wunsch algorithm.\nThe result is printed as the maximum alignment score.\n\n\nThis implementation ensures the alignment score is computed efficiently even for long protein sequences, utilizing the scoring matrix and gap penalties correctly."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-69",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-69",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "70.1 Sample Dataset",
    "text": "70.1 Sample Dataset\nATTAC\nTACAG\nGATTA\nACAGA\nCAGAT\nTTACA\nAGATT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-70",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-70",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "70.2 Sample Output",
    "text": "70.2 Sample Output\nATTACAG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-66",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-66",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "70.3 Solution",
    "text": "70.3 Solution\ndef generate_coverings(current_string, edges, k):\n    \"\"\"\n    Generate all possible complete cycle coverings from the given edges.\n\n    Args:\n    - current_string: The current string being formed as part of the cycle.\n    - edges: Remaining edges in the De Bruijn graph to be used.\n    - k: Length of the k-mers.\n\n    Returns:\n    - A list of possible cycle coverings as strings.\n    \"\"\"\n    # Find the indices of edges that can be added next based on the current string.\n    next_edges_indices = [i for i, edge in enumerate(edges) if edge[0] == current_string[-k+1:]]\n\n    # If no more edges can be added:\n    if not next_edges_indices:\n        # Return the current string if all edges have been used (perfect covering).\n        return [current_string] if not edges else []\n\n    # Otherwise, recursively generate coverings with each possible next edge.\n    possible_coverings = []\n    for i in next_edges_indices:\n        next_string = current_string + edges[i][1][-1]\n        remaining_edges = edges[:i] + edges[i+1:]\n        possible_coverings.append(generate_coverings(next_string, remaining_edges, k))\n\n    return possible_coverings\n\ndef flatten(nested_list):\n    \"\"\"\n    Flattens a nested list into a single list.\n\n    Args:\n    - nested_list: A list that may contain other nested lists.\n\n    Yields:\n    - Individual elements from the nested list, flattened.\n    \"\"\"\n    for item in nested_list:\n        if isinstance(item, list):\n            yield from flatten(item)\n        else:\n            yield item\n\n# Sample input data\nsample_input = \"\"\"\nATTAC\nTACAG\nGATTA\nACAGA\nCAGAT\nTTACA\nAGATT\"\"\"\n\n# Split input into k-mers\nk_mers = sample_input.strip().split(\"\\n\")\n\n# Create edges of the De Bruijn graph from the k-mers\nk = len(k_mers[0])\ncreate_edge = lambda k_mer: [k_mer[:k-1], k_mer[1:]]\nde_bruijn_edges = [create_edge(k_mer) for k_mer in k_mers[1:]]\n\n# Generate all possible circular strings\ncircular_strings = set(flatten(generate_coverings(k_mers[0], de_bruijn_edges, k)))\n\n# Trim each circular string to the appropriate length (number of k-mers)\ncircular_strings = [cycle[:len(k_mers)] for cycle in circular_strings]\n\n# Print the resulting circular strings\nprint('\\n'.join(circular_strings))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-12",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-12",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "70.4 Explanation of the Code",
    "text": "70.4 Explanation of the Code\n\ngenerate_coverings Function:\n\nPurpose: This function recursively generates all possible cycle coverings (i.e., circular strings) by extending the current string with valid edges from the De Bruijn graph.\nHow it works:\n\nIt looks for edges that can be appended to the current string (based on the last \\(k-1\\) characters of the string).\nIf no valid edges are left, it checks if all edges have been used (indicating a perfect covering). If so, it returns the current string.\nIf there are valid edges, it recursively tries to extend the string with each possible edge and collects all possible coverings.\n\n\nflatten Function:\n\nPurpose: This helper function is used to flatten a nested list into a single-level list.\nHow it works: It recursively traverses the nested list and yields individual elements, effectively flattening the list.\n\nMain Execution:\n\nk_mers: The input strings are split into individual \\(k\\)-mers.\nde_bruijn_edges: This creates the edges of the De Bruijn graph. Each \\(k\\)-mer is split into its prefix and suffix of length \\(k-1\\).\ngenerate_coverings: This function is called with the first \\(k\\)-mer as the starting point, and it generates all possible circular strings by finding all Eulerian cycles in the graph.\ncircular_strings: The resulting strings are then trimmed to the length of the input (number of \\(k\\)-mers) to ensure that only the desired cyclic superstrings are printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-70",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-70",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "71.1 Sample Dataset",
    "text": "71.1 Sample Dataset\n4\nGSDMQS\nVWICN\nIASWMQS\nPVSMGAD\n445.17838\n115.02694\n186.07931\n314.13789\n317.1198\n215.09061"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-71",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-71",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "71.2 Sample Output",
    "text": "71.2 Sample Output\n3\nIASWMQS"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-67",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-67",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "71.3 Solution",
    "text": "71.3 Solution\nfrom decimal import Decimal\nfrom collections import defaultdict\n\ndef get_protein_weights():\n    \"\"\"Returns a dictionary mapping amino acids to their weights.\"\"\"\n    return {\n        'G': Decimal('57.02146'), 'A': Decimal('71.03711'), 'S': Decimal('87.03203'), \n        'P': Decimal('97.05276'), 'V': Decimal('99.06841'), 'T': Decimal('101.04768'), \n        'C': Decimal('103.00919'), 'I': Decimal('113.08406'), 'L': Decimal('113.08406'), \n        'N': Decimal('114.04293'), 'D': Decimal('115.02694'), 'Q': Decimal('128.05858'), \n        'K': Decimal('128.09496'), 'E': Decimal('129.04259'), 'M': Decimal('131.04049'), \n        'H': Decimal('137.05891'), 'F': Decimal('147.06841'), 'R': Decimal('156.10111'), \n        'Y': Decimal('163.06333'), 'W': Decimal('186.07931')\n    }\n\ndef calculate_weight(protein_sequence):\n    \"\"\"Calculates the total weight of a given protein sequence based on amino acid weights.\"\"\"\n    weights = get_protein_weights()\n    total_weight = Decimal('0.0')\n    for amino_acid in protein_sequence:\n        total_weight += weights[amino_acid]\n    return total_weight\n\ndef calculate_multiplicity(proteins, spectrum_weights):\n    \"\"\"\n    Calculates the maximum multiplicity of spectrum weights for each protein\n    and identifies the protein with the highest multiplicity.\n    \"\"\"\n    max_multiplicity = -1\n    best_protein = None\n    \n    for protein in proteins:\n        # Compute the spectrum weights for all prefixes and suffixes of the protein\n        spectrum = []\n        for i in range(1, len(protein) + 1):\n            spectrum.append(calculate_weight(protein[:i]))\n        for i in range(len(protein)):\n            spectrum.append(calculate_weight(protein[i:]))\n        \n        spectrum_weights_count = defaultdict(int)\n        \n        # Count the differences between the spectrum weights and given weights\n        for protein_weight in spectrum:\n            for given_weight in spectrum_weights:\n                diff = round(protein_weight - given_weight, 3)\n                spectrum_weights_count[diff] += 1\n        \n        # Determine the maximum multiplicity for the current protein\n        current_multiplicity = max(spectrum_weights_count.values(), default=0)\n        \n        if current_multiplicity &gt; max_multiplicity:\n            max_multiplicity = current_multiplicity\n            best_protein = protein\n    \n    return max_multiplicity, best_protein\n\n# Sample input (for demonstration purposes)\nsample_input = \"\"\"\n4\nGSDMQS\nVWICN\nIASWMQS\nPVSMGAD\n445.17838\n115.02694\n186.07931\n314.13789\n317.1198\n215.09061\n\"\"\"\n\n# Parse the input\nlines = sample_input.strip().split(\"\\n\")\nnumber_of_proteins = int(lines[0])\nprotein_sequences = lines[1:number_of_proteins + 1]\nspectrum_weights = sorted(map(Decimal, lines[number_of_proteins + 1:]))\n\n# Calculate the maximum multiplicity and the corresponding protein\nmax_multiplicity, best_protein = calculate_multiplicity(protein_sequences, spectrum_weights)\n\n# Print the results\nprint(max_multiplicity)\nprint(best_protein)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-13",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-13",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "71.4 Explanation of the Code",
    "text": "71.4 Explanation of the Code\n\nget_protein_weights(): Returns a dictionary mapping each amino acid to its corresponding weight using the Decimal type for precision.\ncalculate_weight(protein_sequence): Computes the total weight of a protein sequence by summing the weights of its amino acids.\ncalculate_multiplicity(proteins, spectrum_weights):\n\nIterates through each protein sequence to compute the weights of all possible prefixes and suffixes.\nUses a defaultdict to count how often the difference between each protein weight and given spectrum weight appears.\nFinds and returns the protein with the highest multiplicity of such differences.\n\nInput Parsing:\n\nReads and parses the sample input to extract the number of proteins, the list of protein sequences, and the list of spectrum weights.\n\nResults:\n\nCalls calculate_multiplicity to get the protein with the maximum multiplicity and prints the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-71",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-71",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "72.1 Sample Dataset",
    "text": "72.1 Sample Dataset\ncat dog elephant ostrich mouse rabbit robot\n01xxx00\nx11xx00\n111x00x"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-72",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-72",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "72.2 Sample Output",
    "text": "72.2 Sample Output\n{cat, dog} {mouse, rabbit}\n{dog, elephant} {rabbit, robot}\n{cat, elephant} {mouse, rabbit}\n{dog, elephant} {mouse, rabbit}"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-68",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-68",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "72.3 Solution",
    "text": "72.3 Solution\n# Sample input data\ndata = \"\"\"\ncat dog elephant ostrich mouse rabbit robot\n01xxx00\nx11xx00\n111x00x\n\"\"\"\n\n# Split the input data into lines\nlines = data.strip().split(\"\\n\")\n\n# Extract taxa (species) from the first line\ntaxa = lines[0].strip().split(' ')\n\n# Initialize a set to store unique quartets\nunique_quartets = set()\n\n# Proces each line of the partial character table\nfor line in lines[1:]:\n    # Initialize lists to hold taxa for two groups\n    group_C = []\n    group_D = []\n\n    # Classify taxa based on the partial character table\n    for i in range(len(line)):\n        if line[i] == '1':\n            group_C.append(taxa[i])\n        elif line[i] == '0':\n            group_D.append(taxa[i])\n    \n    # Ensure each group has at least two taxa to form a quartet\n    if len(group_C) &gt;= 2 and len(group_D) &gt;= 2:\n        # Generate all possible pairs for group C and group D\n        for i in range(len(group_C) - 1):\n            for j in range(i + 1, len(group_C)):\n                for k in range(len(group_D) - 1):\n                    for l in range(k + 1, len(group_D)):\n                        # Form pairs (A, B) from group_C and (C, D) from group_D\n                        pair_A = tuple(sorted([group_C[i], group_C[j]]))\n                        pair_B = tuple(sorted([group_D[k], group_D[l]]))\n                        \n                        # Add the sorted quartet to the set\n                        sorted_quartet = (pair_A, pair_B) if pair_A &lt; pair_B else (pair_B, pair_A)\n                        unique_quartets.add(sorted_quartet)\n\n# Print each unique quartet in the required format\nfor quartet in unique_quartets:\n    pair_A, pair_B = quartet\n    print('{{{}, {}}} {{{}, {}}}'.format(pair_A[0], pair_A[1], pair_B[0], pair_B[1]))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-14",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-14",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "72.4 Explanation of the Code",
    "text": "72.4 Explanation of the Code\n\nInput Data Handling:\n\ndata.strip().split(\"\\n\"): Split the input data into lines. The first line contains taxa names, and the subsequent lines contain the partial character table.\n\nExtracting Taxa:\n\ntaxa = lines[0].strip().split(' '): The first line is split into individual taxa names.\n\nInitialize Set for Quartets:\n\nunique_quartets = set(): This set will store unique quartets to avoid duplicates.\n\nProcessing Each Partial Character Table Line:\n\nFor each line after the first one, initialize group_C and group_D to store taxa based on the partial character table values (1 and 0 respectively).\nPopulate group_C and group_D based on whether the character is 1 or 0.\n\nForming Quartets:\n\nEnsure each group has at least two taxa to form pairs.\nGenerate all possible pairs from group_C and group_D.\nSort pairs and add them to the unique_quartets set, ensuring that each quartet is stored in a canonical (sorted) form to avoid duplicates.\n\nOutput Results:\n\nFor each unique quartet, format and print the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-72",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-72",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "73.1 Sample Dataset",
    "text": "73.1 Sample Dataset\n3524.8542\n3623.5245\n3710.9335\n3841.974\n3929.00603\n3970.0326\n4026.05879\n4057.0646\n4083.08025"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-73",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-73",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "73.2 Sample Output",
    "text": "73.2 Sample Output\nSPG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-69",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-69",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "73.3 Solution",
    "text": "73.3 Solution\nfrom collections import defaultdict\n\n# Monoisotopic mas table for amino acids\nmass_table = {\n    'A': 71.03711, 'C': 103.00919, 'D': 115.02694, 'E': 129.04259,\n    'F': 147.06841, 'G': 57.02146, 'H': 137.05891, 'I': 113.08406,\n    'K': 128.09496, 'L': 113.08406, 'M': 131.04049, 'N': 114.04293,\n    'P': 97.05276, 'Q': 128.05858, 'R': 156.10111, 'S': 87.03203,\n    'T': 101.04768, 'V': 99.06841, 'W': 186.07931, 'Y': 163.06333\n}\n\ndef build_spectrum_graph(L, mass_table):\n    \"\"\"\n    Create a graph where each node represents a number in L.\n    Add a directed edge from u to v if v &gt; u and the weight difference\n    matches any amino acid's mas in the mass_table.\n    \"\"\"\n    graph = defaultdict(list)\n    \n    # Iterate over each pair of nodes (u, v) where v &gt; u\n    for i, u in enumerate(L):\n        for j, v in enumerate(L):\n            if v &gt; u:\n                # Calculate the weight difference between v and u\n                weight_diff = v - u\n                \n                # Check if this weight difference matches any amino acid mass\n                for symbol, mas in mass_table.items():\n                    if abs(weight_diff - mass) &lt; 1e-5:\n                        graph[u].append((v, symbol))\n    \n    return graph\n\ndef find_longest_path(graph, start):\n    \"\"\"\n    Use depth-first search to find the longest path in the graph starting from 'start'.\n    \"\"\"\n    stack = [(start, '')]  # Stack for DFS: (current_node, path_string)\n    longest_path = ''\n    \n    # Store the longest path ending at each node\n    path_map = defaultdict(str)\n    \n    while stack:\n        node, path = stack.pop()\n        \n        # Update the longest path for the current node\n        if len(path) &gt; len(path_map[node]):\n            path_map[node] = path\n        \n        # Traverse neighbors\n        for neighbor, symbol in graph[node]:\n            stack.append((neighbor, path + symbol))\n    \n    # Return the longest path found\n    longest_path = max(path_map.values(), key=len)\n    return longest_path\n\ndef find_longest_protein_string(L, mass_table):\n    \"\"\"\n    Build the spectrum graph and find the longest protein string.\n    \"\"\"\n    # Create the spectrum graph from the list L\n    graph = build_spectrum_graph(L, mass_table)\n    \n    # Find the longest path starting from each node in L\n    longest_protein = ''\n    for node in L:\n        current_protein = find_longest_path(graph, node)\n        if len(current_protein) &gt; len(longest_protein):\n            longest_protein = current_protein\n    \n    return longest_protein\n\n# Sample input\nsample_input = \"\"\"\n3524.8542\n3623.5245\n3710.9335\n3841.974\n3929.00603\n3970.0326\n4026.05879\n4057.0646\n4083.08025\"\"\"\n\n# Parse the sample input into a list of floats\nL = [float(x) for x in sample_input.strip().split(\"\\n\")]\n\n# Find and print the longest protein string\nlongest_protein = find_longest_protein_string(L, mass_table)\nprint(longest_protein)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-37",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-37",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "73.4 Explanation",
    "text": "73.4 Explanation\n\nMonoisotopic Mas Table:\n\nmass_table maps each amino acid to its mass.\n\nGraph Construction (build_spectrum_graph):\n\nPurpose: Create a directed graph where each node is a number from \\(L\\), and edges are added if the difference between nodes corresponds to the mas of an amino acid.\nProcess:\n\nIterate through each pair of numbers in \\(L\\) where the second number is greater than the first.\nCalculate the weight difference and check if it matches any mas in the mass_table.\nAdd a directed edge between these nodes labeled with the corresponding amino acid.\n\n\nFinding the Longest Path (find_longest_path):\n\nPurpose: Determine the longest path in the graph starting from a given node using depth-first search (DFS).\nProcess:\n\nUse a stack to explore nodes.\nTrack the longest path ending at each node.\nUpdate the longest path found during traversal.\n\n\nMain Function (find_longest_protein_string):\n\nPurpose: Integrates the graph construction and longest path finding to return the longest protein string.\nProcess:\n\nBuild the spectrum graph.\nFor each node, find the longest path starting from that node.\nReturn the longest path found.\n\n\nExecution:\n\nSample Input: Represents a list of mas values.\nProcessing: Converts the sample input into a list of floats, finds the longest protein string, and prints it."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-73",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-73",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "74.1 Sample Dataset",
    "text": "74.1 Sample Dataset\nATAAATG$"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-74",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-74",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "74.2 Sample Output",
    "text": "74.2 Sample Output\nA\nA\nATG$\nTG$\nT\nAAATG$\nG$\nT\nAAATG$\nG$\nG$\n$"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-70",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-70",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "74.3 Solution",
    "text": "74.3 Solution\nfrom collections import defaultdict\n\nclas SuffixTree:\n    \"\"\"Creates a suffix tree for the provided word.\"\"\"\n    \n    def __init__(self, word):\n        \"\"\"Initializes the suffix tree.\"\"\"\n        self.nodes = [self.Node(None, 0)]  # Initialize with root node.\n        self.edges = dict()  # Dictionary to store edges.\n        self.descendants_count = dict()  # Cache for the number of descendants of nodes.\n        if isinstance(word, str):  # Check if the input is a string.\n            self._build_suffix_tree(word)\n\n    clas Node:\n        \"\"\"Represents a node in the suffix tree.\"\"\"\n        def __init__(self, parent, node_id):\n            self.parent = parent\n            self.node_id = node_id\n            self.children = []\n\n        def add_child(self, child_node):\n            self.children.append(child_node)\n\n        def remove_child(self, child_node):\n            self.children.remove(child_node)\n\n        def update_parent(self, new_parent):\n            self.parent = new_parent\n\n    def _build_suffix_tree(self, word):\n        \"\"\"Builds the suffix tree by adding each suffix of the word.\"\"\"\n        if word[-1] != '$':\n            word += '$'  # Ensure the word ends with the terminal symbol '$'.\n        self.word = word\n        self.length = len(self.word)\n\n        for i in range(self.length):\n            parent_node, edge_start, has_overlap = self._find_insertion_point(i, self.nodes[0])\n\n            if has_overlap:\n                existing_start, existing_end = self.edges[(parent_node.parent.node_id, parent_node.node_id)]\n\n                # Determine the length of the overlap.\n                overlap_length = 0\n                while self.word[edge_start:edge_start + overlap_length] == self.word[existing_start:existing_start + overlap_length]:\n                    overlap_length += 1\n\n                # Create a new internal node at the point of insertion.\n                new_internal_node = self.Node(parent_node.parent, len(self.nodes))\n                new_internal_node.add_child(parent_node)\n                self._add_edge_and_node(parent_node.parent, existing_start, existing_start + overlap_length - 1, new_internal_node)\n\n                # Update the edge and parent relationship for the original child node.\n                del self.edges[(parent_node.parent.node_id, parent_node.node_id)]\n                parent_node.parent.remove_child(parent_node)\n                parent_node.update_parent(new_internal_node)\n                self.edges[(new_internal_node.node_id, parent_node.node_id)] = [existing_start + overlap_length - 1, existing_end]\n\n                # Add the remaining suffix as a new child node.\n                self._add_edge_and_node(new_internal_node, edge_start + overlap_length - 1, self.length)\n\n            else:\n                # No overlap, simply add the entire suffix as a new edge.\n                self._add_edge_and_node(parent_node, edge_start, self.length)\n\n    def _find_insertion_point(self, start_index, parent_node):\n        \"\"\"Determines where to insert a suffix into the tree.\"\"\"\n        for child_node in parent_node.children:\n            edge_start, edge_end = self.edges[(parent_node.node_id, child_node.node_id)]\n            if self.word[start_index:start_index + edge_end - edge_start] == self.word[edge_start:edge_end]:\n                return self._find_insertion_point(start_index + edge_end - edge_start, child_node)\n            elif self.word[edge_start] == self.word[start_index]:\n                return child_node, start_index, True\n        return parent_node, start_index, False\n\n    def _add_edge_and_node(self, parent_node, edge_start, edge_end, child_node=None):\n        \"\"\"Adds a node and the corresponding edge to the suffix tree.\"\"\"\n        if child_node is None:\n            child_node = self.Node(parent_node, len(self.nodes))\n\n        self.nodes.append(child_node)\n        parent_node.add_child(child_node)\n        self.edges[(parent_node.node_id, child_node.node_id)] = [edge_start, edge_end]\n\n    def get_edge_labels(self):\n        \"\"\"Returns the substrings representing the edges of the suffix tree.\"\"\"\n        return [self.word[start:end] for start, end in self.edges.values()]\n\n    def count_total_descendants(self, node):\n        \"\"\"Calculates the total number of descendants of a given node.\"\"\"\n        if node not in self.descendants_count:\n            self.descendants_count[node] = len(node.children) + sum(self.count_total_descendants(child) for child in node.children)\n        return self.descendants_count[node]\n\n    def get_node_label(self, node):\n        \"\"\"Returns the string represented by the path from the root to a given node.\"\"\"\n        label = ''\n        while node.node_id != 0:\n            start, end = self.edges[(node.parent.node_id, node.node_id)]\n            label = self.word[start:end] + label\n            node = node.parent\n        return label.strip('$')\n\n# Example usage\nsample_input = \"ATAAATG$\"\nsuffix_tree = SuffixTree(sample_input)\nresult = '\\n'.join(suffix_tree.get_edge_labels())\nprint(result)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-15",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-15",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "74.4 Explanation of the Code",
    "text": "74.4 Explanation of the Code\n\nClas Structure:\n\nSuffixTree class: Manages the construction and representation of the suffix tree.\nNode clas (nested within SuffixTree): Represents each node in the suffix tree. Each node has a parent, a unique identifier (node_id), and a list of child nodes.\n\nInitialization:\n\nThe SuffixTree is initialized with a root node (with node_id = 0).\nThe _build_suffix_tree method ensures the input word ends with the terminal symbol $ and then processes each suffix of the word to build the tree.\n\nBuilding the Tree:\n\nFor each suffix, _find_insertion_point is called to determine where in the tree the suffix should be inserted.\nIf there’s an overlap with an existing edge, a new internal node is created, and the tree is split at the point of overlap.\nOtherwise, a new edge representing the suffix is added directly.\n\nEdge and Node Management:\n\nThe _add_edge_and_node method handles the actual insertion of edges and nodes into the tree structure.\nThe edges dictionary maps parent-child relationships to the start and end indices of the corresponding substring in the word.\n\nRetrieving Results:\n\nget_edge_labels: Returns the list of substrings corresponding to all edges in the tree.\ncount_total_descendants: Computes the number of descendants for any given node in the tree (cached to optimize repeated queries).\nget_node_label: Recovers the substring represented by a path from the root to a specific node."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-74",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-74",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "75.1 Sample Dataset",
    "text": "75.1 Sample Dataset\ncat dog elephant mouse rabbit rat\n011101\n001101\n001100"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-75",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-75",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "75.2 Sample Output",
    "text": "75.2 Sample Output\n(((cat,rabbit),dog),(elephant,mouse),rat);"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-71",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-71",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "75.3 Solution",
    "text": "75.3 Solution\nfrom Bio import Phylo\nimport sys\n\ndef find_columns_to_unify(splits):\n    \"\"\"Finds two columns in the split matrix that should be unified into a single clade.\"\"\"\n    for split in splits:\n        sum_split = sum(split)\n        if sum_split == 2:\n            # Find the pair of columns where the sum is exactly 2.\n            return tuple(i for i, value in enumerate(split) if value == 1)\n        elif sum_split == len(split) - 2:\n            # Find the pair of columns where the sum is all but 2.\n            return tuple(i for i, value in enumerate(split) if value == 0)\n    raise ValueError('No columns to unify found!', splits)\n\ndef print_clade_trees(clades):\n    \"\"\"Prints the clades as Newick formatted trees.\"\"\"\n    for clade in clades:\n        tree = Phylo.BaseTree.Tree.from_clade(clade)\n        Phylo.write(tree, sys.stdout, 'newick', plain=True)\n\ndef build_phylogenetic_tree(input_lines):\n    \"\"\"Builds a phylogenetic tree based on the input split matrix.\"\"\"\n    clades = [Phylo.BaseTree.Clade(name=name) for name in input_lines[0].split()]\n\n    splits = []\n    for line in input_lines[1:]:\n        splits.append([int(x) for x in line])\n\n    while splits:\n        col1, col2 = find_columns_to_unify(splits)\n\n        # Remove the second of the unified columns from the splits\n        for split in splits:\n            split.pop(col2)\n\n        # Remove trivial splits where all entries are 1 or all but one are 1\n        splits = [split for split in splits if 1 &lt; sum(split) &lt; len(split) - 1]\n\n        # Unify the clades corresponding to the selected columns\n        clades[col1] = Phylo.BaseTree.Clade(clades=[clades[col1], clades[col2]])\n        clades.pop(col2)\n\n    # Final clade to represent the complete phylogenetic tree\n    final_clade = Phylo.BaseTree.Clade(clades=clades)\n    print_clade_trees([final_clade])\n\n# Sample Input\nsample_input = \"\"\"\ncat dog elephant mouse rabbit rat\n011101\n001101\n001100\n\"\"\"\n\ninput_lines = sample_input.strip().split(\"\\n\")\nbuild_phylogenetic_tree(input_lines)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-16",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-16",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "75.4 Explanation of the Code",
    "text": "75.4 Explanation of the Code\n\nPurpose:\n\nThe code is designed to build a phylogenetic tree based on a set of species (or objects) and their binary split representations. The input consists of species names followed by rows of binary digits representing splits between species.\n\nFunctions:\n\nfind_columns_to_unify(splits):\n\nThis function identifies two columns in the split matrix that can be unified into a single clade.\nIt looks for a pair of columns where the sum of the values in the columns equals 2 (indicating that exactly two species share a common clade) or equals the number of species minus 2 (indicating all but two species share a clade).\n\nprint_clade_trees(clades):\n\nThis function prints the clades in Newick format, which is a common format for representing phylogenetic trees.\n\nbuild_phylogenetic_tree(input_lines):\n\nThis is the main function that constructs the phylogenetic tree.\nIt first parses the input to create a list of clades, one for each species.\nThen it iterates through the split matrix, repeatedly unifying clades based on the identified columns until only one clade (the final tree) remains.\n\n\nProcess:\n\nInput Parsing:\n\nThe input string is split into lines, with the first line containing species names and the subsequent lines containing binary splits.\n\nTree Construction:\n\nThe code processes the splits by repeatedly identifying pairs of species to unify (using the find_columns_to_unify function).\nAfter unifying species into clades, it modifies the split matrix by removing the unified columns and trivial splits.\nThis continues until only one clade remains, representing the complete phylogenetic tree.\n\n\nOutput:\n\nThe resulting phylogenetic tree is printed in Newick format, which can be visualized or further analyzed using tools that support this format."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-75",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-75",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "76.1 Sample Dataset",
    "text": "76.1 Sample Dataset\n6\n(lobster,(cat,dog),(caterpillar,(elephant,mouse)));"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-76",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-76",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "76.2 Sample Output",
    "text": "76.2 Sample Output\n15"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-72",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-72",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "76.3 Solution",
    "text": "76.3 Solution\n# Sample Input\nsample_input = \"\"\"\n6\n(lobster,(cat,dog),(caterpillar,(elephant,mouse)));\n\"\"\"\n\n# Parse input lines\ninput_lines = sample_input.strip().split(\"\\n\")\nn = int(input_lines[0])\n\n# Initialize a memoization list to store factorials\nfactorials = [1] * (n + 1)  # Initialize with 1 for factorial(0)\n\n# Calculate all factorials from 1 to n and store in the list\nfor i in range(1, n + 1):\n    factorials[i] = i * factorials[i - 1]\n\n# Calculate the number of possible quartets using the combination formula\n# C(n, 4) = n! / ((n-4)! * 4!)\nnum_quartets = (factorials[n] // (factorials[n - 4] * factorials[4])) % 1000000\n\n# Output the result\nprint(num_quartets)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-38",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-38",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "76.4 Explanation",
    "text": "76.4 Explanation\n\nInput Parsing:\n\nThe input is a string representing the number of taxa n and a Newick formatted tree. The first line is split to extract n.\n\nFactorial Calculation:\n\nWe need to calculate the number of quartets possible, which involves computing combinations. The combination formula C(n, 4) is used to calculate how many ways we can choose 4 taxa from n, and it requires calculating factorials.\nWe initialize a list factorials with n+1 elements, all set to 1. This list will store factorial values from 0! to n!.\nA loop is used to calculate each factorial iteratively and store it in the list.\n\nCombination Calculation:\n\nThe number of quartets is calculated using the formula C(n, 4) = n! / ((n-4)! * 4!).\nThe combination result is then taken modulo 1,000,000 to meet the problem’s requirement.\n\nOutput:\n\nThe final result is printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-concepts-1",
    "href": "posts/qmd/Rosalind_stronghold.html#key-concepts-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "76.5 Key Concepts",
    "text": "76.5 Key Concepts\n\nFactorials: Factorials are calculated iteratively and stored in a list to avoid recalculating the same value multiple times.\nCombinations: The formula for combinations C(n, 4) is used to find out how many quartets can be formed from n taxa.\nModulo Operation: Since the number of quartets can be large, the result is taken modulo 1,000,000."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-76",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-76",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "77.1 Sample Dataset",
    "text": "77.1 Sample Dataset\ndog cat mouse elephant"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-77",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-77",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "77.2 Sample Output",
    "text": "77.2 Sample Output\n((cat,(mouse,elephant)))dog\n((mouse,(cat,elephant)))dog\n((elephant,(cat,mouse)))dog"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-73",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-73",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "77.3 Solution",
    "text": "77.3 Solution\nfrom itertools import combinations\n\ndef generate_combinations(n, items):\n    \"\"\"\n    Generates all combinations of `n` elements from the list `items`.\n    \"\"\"\n    if n == 0:\n        return [[]]\n    if not items:\n        return []\n    \n    head, *tail = items\n    with_head = [[head] + rest for rest in generate_combinations(n-1, tail)]\n    without_head = generate_combinations(n, tail)\n    \n    return with_head + without_head\n\ndef memoized_combinations(n, k):\n    \"\"\"\n    Returns all `k`-combinations of `n` items using memoization.\n    This prevents redundant computation of the same combination.\n    \"\"\"\n    memo = memoized_combinations.cache\n    if n not in memo:\n        memo[n] = {}\n    if k not in memo[n]:\n        memo[n][k] = generate_combinations(k, list(range(n)))\n    return memo[n][k]\n\nmemoized_combinations.cache = {}\n\ndef generate_unrooted_binary_trees(species):\n    \"\"\"\n    Generates all possible unrooted binary trees in Newick format for a given list of species.\n    \"\"\"\n    if len(species) == 1:\n        return species\n    elif len(species) == 2:\n        return [f\"({species[0]},{species[1]})\"]\n    elif len(species) &gt;= 3:\n        trees = []\n        for k in range(1, (len(species) // 2) + 1):\n            seen_combinations = set()\n            for selected_indices in memoized_combinations(len(species), k):\n                selected_species = [species[i] for i in selected_indices]\n                selected_key = ':'.join(sorted(selected_species))\n                if selected_key in seen_combinations:\n                    continue\n                seen_combinations.add(selected_key)\n                remaining_species = [sp for sp in species if sp not in selected_species]\n                remaining_key = ':'.join(sorted(remaining_species))\n                if remaining_key in seen_combinations:\n                    continue\n                seen_combinations.add(remaining_key)\n                \n                for left_tree in generate_unrooted_binary_trees(remaining_species):\n                    for right_tree in generate_unrooted_binary_trees(selected_species):\n                        trees.append(f\"({right_tree},{left_tree})\")\n        return trees\n    else:\n        raise Exception(\"Unexpected number of species\")\n\ninput_data = \"dog cat mouse elephant\"\nspecies_list = input_data.split()\nroot_species = species_list.pop(0)\n\nfor tree in generate_unrooted_binary_trees(species_list):\n    print(f\"({tree}){root_species}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-17",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-the-code-17",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "77.4 Explanation of the Code",
    "text": "77.4 Explanation of the Code\n\ngenerate_combinations Function:\n\nThis function is a recursive implementation to generate all possible combinations of n elements from the given list items.\nIt works by considering each element (head) and recursively generating combinations with (with_head) and without (without_head) that element.\n\nmemoized_combinations Function:\n\nThis function leverages memoization to store previously computed combinations to avoid redundant calculations.\nIt checks if the combination of n and k has already been computed and stored in the cache (a dictionary attached to the function).\nIf not, it computes the combination using generate_combinations and stores it for future use.\n\ngenerate_unrooted_binary_trees Function:\n\nThis function generates all possible unrooted binary trees for the provided list of species in Newick format.\nIt uses a recursive approach:\n\nIf there’s only one species, it simply returns it.\nIf there are two species, it returns them in a pair.\nIf there are three or more species, it splits them into subgroups and recursively generates trees for each subgroup, ensuring that each possible tree structure is considered without duplicates."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-77",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-77",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "78.1 Sample Dataset",
    "text": "78.1 Sample Dataset\nAATCT\nTGTAA\nGATTA\nACAGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-78",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-78",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "78.2 Sample Output",
    "text": "78.2 Sample Output\nTGTAATC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-74",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-74",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "78.3 Solution",
    "text": "78.3 Solution\nfrom itertools import chain\n\ndef reverse_complement(dna):\n    \"\"\"Returns the reverse complement of a given DNA strand.\"\"\"\n    translation_table = str.maketrans('ATCG', 'TAGC')\n    return dna.translate(translation_table)[::-1]\n\ndef find_cyclic_superstring(dna_strings):\n    \"\"\"Finds the cyclic superstring from a list of DNA strings and their reverse complements.\"\"\"\n    def flatten_list_of_lists(list_of_lists):\n        \"\"\"Flattens one level of nesting in a list of lists.\"\"\"\n        return chain.from_iterable(list_of_lists)\n    \n    num_strings = len(dna_strings)\n    string_length = len(dna_strings[0])  # Assumes all strings have the same length\n    \n    for k in range(string_length - 1, 1, -1):\n        # Create adjacency list of k-mers\n        adj_list = dict(flatten_list_of_lists([\n            [(dna[i:i+k], dna[i+1:i+k+1]) for i in range(string_length - k)] \n            for dna in dna_strings\n        ]))\n        \n        # Start with an arbitrary k-mer and initialize the superstring\n        first_kmer = kmer = next(iter(adj_list))\n        superstring = ''\n        \n        while True:\n            if kmer in adj_list:\n                # Add the last character of the k-mer to the superstring\n                superstring += kmer[-1]\n                # Move to the next k-mer in the path\n                kmer = adj_list.pop(kmer)\n                # If we have returned to the start, we have completed a cycle\n                if kmer == first_kmer:\n                    return superstring\n            else:\n                # Exit if no continuation of the k-mer path is found\n                break\n\n# Read and preproces input\nsample_input = \"\"\"\nAATCT\nTGTAA\nGATTA\nACAGA\n\"\"\"\ndna_strings = sample_input.strip().split('\\n')\n# Add reverse complements of the DNA strings\ndna_strings = list(set(dna_strings + [reverse_complement(dna) for dna in dna_strings]))\n\n# Find and print the cyclic superstring\nprint(find_cyclic_superstring(dna_strings))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-39",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-39",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "78.4 Explanation",
    "text": "78.4 Explanation\n\nReverse Complement Function:\n\nreverse_complement(dna): Computes the reverse complement of a DNA sequence. It uses a translation table to map each nucleotide to its complement and then reverses the string.\n\nFinding Cyclic Superstring:\n\nfind_cyclic_superstring(dna_strings): Finds a cyclic superstring from the given list of DNA strings. It:\n\nUses flatten_list_of_lists to flatten a list of lists into a single list.\nIterates over possible lengths of k-mers from the longest (one les than the length of the DNA strings) to 2.\nConstructs a De Bruijn graph where edges are k-mers, and vertices are k-1-mers.\nTries to find a cyclic path in the graph that returns to the starting k-mer and constructs the superstring from this path.\n\n\nInput Processing:\n\nsample_input: Defines a sample input containing multiple DNA strings.\ndna_strings: Converts the input into a list of DNA strings and adds their reverse complements to handle both possible orientations.\n\nFinding and Printing the Superstring:\n\nCalls find_cyclic_superstring with the DNA strings (including their reverse complements) to find the cyclic superstring and prints the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-78",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-78",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "79.1 Sample Dataset",
    "text": "79.1 Sample Dataset\n&gt;Rosalind_79\nPLEASANTLY\n&gt;Rosalind_41\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-79",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-79",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "79.2 Sample Output",
    "text": "79.2 Sample Output\n13"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-75",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-75",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "79.3 Solution",
    "text": "79.3 Solution\nBLOSUM62 = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef parse_fasta(fasta_string):\n    \"\"\"Parse the input FASTA format string into individual sequences.\"\"\"\n    sequences = []\n    current_sequence = \"\"\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith(\"&gt;\"):\n            if current_sequence:\n                sequences.append(current_sequence)\n            current_sequence = \"\"\n        else:\n            current_sequence += line.strip()\n    sequences.append(current_sequence)  # Append the last sequence\n    return sequences\n\ndef global_alignment_with_gap_penalty(seq1, seq2):\n    \"\"\"Compute the global alignment score between two sequences with gap penalties.\"\"\"\n    seq1 = \"-\" + seq1  # Add a leading gap for alignment\n    seq2 = \"-\" + seq2  # Add a leading gap for alignment\n\n    # Initialize scoring matrices\n    lower_matrix = [[0 for _ in range(len(seq2))] for _ in range(len(seq1))]\n    middle_matrix = [[0 for _ in range(len(seq2))] for _ in range(len(seq1))]\n    upper_matrix = [[0 for _ in range(len(seq2))] for _ in range(len(seq1))]\n\n    # Set gap penalties for the first row and column\n    for col in range(1, len(seq2)):\n        lower_matrix[0][col] = -5\n        middle_matrix[0][col] = -5\n        upper_matrix[0][col] = -50\n\n    for row in range(1, len(seq1)):\n        lower_matrix[row][0] = -5\n        middle_matrix[row][0] = -5\n        upper_matrix[row][0] = -50\n\n    # Fill the scoring matrices\n    for col in range(1, len(seq2)):\n        for row in range(1, len(seq1)):\n            lower_matrix[row][col] = max(lower_matrix[row - 1][col], middle_matrix[row - 1][col] - 5)\n            upper_matrix[row][col] = max(upper_matrix[row][col - 1], middle_matrix[row][col - 1] - 5)\n\n            pair = (seq1[row], seq2[col])\n            reverse_pair = (seq2[col], seq1[row])\n            score = BLOSUM62.get(pair, BLOSUM62.get(reverse_pair, 0))\n            middle_matrix[row][col] = max(\n                lower_matrix[row][col],\n                middle_matrix[row - 1][col - 1] + score,\n                upper_matrix[row][col]\n            )\n\n    return middle_matrix[len(seq1) - 1][len(seq2) - 1]\n\n# Sample Input\nsample_input = \"\"\"&gt;Rosalind_79\nPLEASANTLY\n&gt;Rosalind_41\nMEANLY\n\"\"\"\n\n# Parse input FASTA format data\nsequences = parse_fasta(sample_input)\nsequence1, sequence2 = sequences[0], sequences[1]\n\n# Compute the global alignment score\nalignment_score = global_alignment_with_gap_penalty(sequence1, sequence2)\nprint(alignment_score)\nThe code computes the global alignment score between two sequences using a scoring matrix (BLOSUM62) and gap penalties. This involves parsing FASTA formatted sequence data, initializing scoring matrices for dynamic programming, and then filling these matrices to calculate the alignment score."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#parse_fastafasta_string",
    "href": "posts/qmd/Rosalind_stronghold.html#parse_fastafasta_string",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "79.4 1. parse_fasta(fasta_string)",
    "text": "79.4 1. parse_fasta(fasta_string)\nPurpose: Parses a FASTA format string into individual sequences.\nHow it works: - Input: A FASTA format string where sequences are prefixed with a &gt; character. - Output: A list of sequences.\nSteps: 1. Initialize an empty list sequences to store parsed sequences. 2. Initialize an empty string current_sequence to build sequences as you read the input. 3. Split the input string into lines and iterate through them: - If a line starts with &gt;, it indicates the start of a new sequence. Append the current sequence to sequences if it’s not empty, then reset current_sequence. - Otherwise, append the line (after stripping whitespace) to current_sequence. 4. Append the last sequence after exiting the loop. 5. Return the list of sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#global_alignment_with_gap_penaltyseq1-seq2",
    "href": "posts/qmd/Rosalind_stronghold.html#global_alignment_with_gap_penaltyseq1-seq2",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "79.5 2. global_alignment_with_gap_penalty(seq1, seq2)",
    "text": "79.5 2. global_alignment_with_gap_penalty(seq1, seq2)\nPurpose: Computes the global alignment score between two sequences using a dynamic programming approach with gap penalties.\nHow it works: - Input: Two sequences, seq1 and seq2. - Output: The alignment score for the sequences.\nSteps: 1. Initialize Sequences: - Prepend a gap (-) to both sequences to handle gaps at the start of alignments.\n\nInitialize Matrices:\n\nlower_matrix, middle_matrix, upper_matrix are 2D lists used to store scores during alignment:\n\nlower_matrix tracks scores when aligning with gaps in seq2.\nupper_matrix tracks scores when aligning with gaps in seq1.\nmiddle_matrix stores the scores for the current alignment considering both sequences.\n\n\nSet Initial Gap Penalties:\n\nFor the first row (aligning gaps in seq1 with the second sequence), initialize with gap penalties of -5 for lower_matrix and middle_matrix, and a larger penalty -50 for upper_matrix.\nFor the first column (aligning gaps in seq2 with the first sequence), use similar penalties.\n\nFill Matrices:\n\nUse nested loops to fill the matrices:\n\nLower Matrix: Computes scores for gaps in seq2.\nUpper Matrix: Computes scores for gaps in seq1.\nMiddle Matrix: Computes scores for aligning characters in seq1 and seq2.\n\nRetrieve the score from BLOSUM62 for the pair of characters.\nUse the maximum of the scores from lower_matrix, middle_matrix, and upper_matrix to fill in middle_matrix.\n\n\n\nRetrieve Final Score:\n\nThe final alignment score is in middle_matrix[len(seq1) - 1][len(seq2) - 1], which represents the best alignment score for the entire length of both sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-79",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-79",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "80.1 Sample Dataset",
    "text": "80.1 Sample Dataset\n((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-80",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-80",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "80.2 Sample Output",
    "text": "80.2 Sample Output\n0.156 0.5 0.344"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-76",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-76",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "80.3 Solution",
    "text": "80.3 Solution\n# Probabilities from an individual's ancestors (based on Mendelian inheritance)\nprob_dict = {\n    (\"AA\", \"AA\"): (1.0, 0.0, 0.0),\n    (\"AA\", \"Aa\"): (0.5, 0.5, 0.0),\n    (\"AA\", \"aa\"): (0.0, 1.0, 0.0),\n    (\"Aa\", \"AA\"): (0.5, 0.5, 0.0),\n    (\"Aa\", \"Aa\"): (0.25, 0.5, 0.25),\n    (\"Aa\", \"aa\"): (0.0, 0.5, 0.5),\n    (\"aa\", \"AA\"): (0.0, 1.0, 0.0),\n    (\"aa\", \"Aa\"): (0.0, 0.5, 0.5),\n    (\"aa\", \"aa\"): (0.0, 0.0, 1.0)\n}\n\ndef calculate_child_probabilities(parent1, parent2):\n    \"\"\"\n    Given the genotype probabilities of two parents, calculate the probabilities for the child.\n    \n    :param parent1: Dictionary containing the probabilities for the first parent (keys: 'AA', 'Aa', 'aa')\n    :param parent2: Dictionary containing the probabilities for the second parent (keys: 'AA', 'Aa', 'aa')\n    :return: Dictionary containing the probabilities for the child (keys: 'AA', 'Aa', 'aa')\n    \"\"\"\n    child_prob = {\"AA\": 0.0, \"Aa\": 0.0, \"aa\": 0.0}\n    \n    # Combine the genotype probabilities from both parents using the Mendelian inheritance rules\n    for p1_genotype, p1_prob in parent1.items():\n        for p2_genotype, p2_prob in parent2.items():\n            # Look up the probability distribution for the child based on the parent genotypes\n            child_distribution = prob_dict[(p1_genotype, p2_genotype)]\n            child_prob[\"AA\"] += p1_prob * p2_prob * child_distribution[0]\n            child_prob[\"Aa\"] += p1_prob * p2_prob * child_distribution[1]\n            child_prob[\"aa\"] += p1_prob * p2_prob * child_distribution[2]\n    \n    return child_prob\n\n# Known genotype probabilities for the leaves (ancestral individuals)\nAA = {\"AA\": 1.0, \"Aa\": 0.0, \"aa\": 0.0}\nAa = {\"AA\": 0.0, \"Aa\": 1.0, \"aa\": 0.0}\naa = {\"AA\": 0.0, \"Aa\": 0.0, \"aa\": 1.0}\n\n# Pedigree input in Newick format\npedigree = \"((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);\"\n\n# Modify the Newick string to turn it into a Python expression using the `calculate_child_probabilities` function\npedigree_expression = pedigree.replace(\";\", \"\").replace(\"(\", \"calculate_child_probabilities(\")\n\n# Evaluate the expression to calculate the probabilities for the root individual\nroot_probabilities = eval(pedigree_expression)\n\n# Print the final probabilities for the root individual\nprint(f\"{root_probabilities['AA']:f} {root_probabilities['Aa']:f} {root_probabilities['aa']:f}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-40",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-40",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "80.4 Explanation",
    "text": "80.4 Explanation\n\nprob_dict:\n\nThis dictionary contains the Mendelian inheritance probabilities for a child given the genotypes of both parents. Each tuple of parent genotypes maps to a tuple of probabilities representing the likelihood of the child being AA, Aa, or aa.\n\ncalculate_child_probabilities:\n\nThis function calculates the probabilities for a child’s genotype based on the genotype probabilities of their two parents.\nIt iterates over all combinations of the parents’ genotypes, looks up the probabilities from prob_dict, and accumulates the resulting probabilities for the child.\n\nLeaf Node Probabilities:\n\nThe genotype probabilities for the leaf nodes (the known ancestors) are defined:\n\nAA: 100% chance of being AA\nAa: 100% chance of being Aa\naa: 100% chance of being aa\n\n\nPedigree Parsing:\n\nThe input pedigree is provided in Newick format. This format is transformed into a Python expression that can be evaluated using eval. The key part of this transformation is replacing the ( characters with calls to the calculate_child_probabilities function. This allows the pedigree to be evaluated as a nested set of function calls, starting from the leaves and working up to the root.\n\nResult:\n\nThe program evaluates the pedigree, calculating the probabilities of the root individual being AA, Aa, or aa. These probabilities are then printed to three decimal places."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-80",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-80",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "81.1 Sample Dataset",
    "text": "81.1 Sample Dataset\nATTTGGATT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-81",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-81",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "81.2 Sample Output",
    "text": "81.2 Sample Output\n0.875"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-77",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-77",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "81.3 Solution",
    "text": "81.3 Solution\nimport sys\nfrom math import log\n\nclas SuffixTree:\n    '''Creates a suffix tree for the provided word.'''\n\n    def __init__(self, input_word):\n        '''Initializes the suffix tree.'''\n        self.nodes = [self.Node(None, 0)]\n        self.edges = dict()\n        self.descendants_count = dict()\n        if isinstance(input_word, str):\n            self.build_suffix_tree(input_word)\n\n    clas Node(object):\n        '''Suffix tree node class.'''\n        def __init__(self, parent_node, node_number):\n            self.parent = parent_node\n            self.number = node_number\n            self.children = []\n\n        def add_child(self, child_node):\n            self.children.append(child_node)\n\n        def remove_child(self, child_node):\n            self.children.remove(child_node)\n\n        def update_parent(self, new_parent):\n            self.parent = new_parent\n\n    def build_suffix_tree(self, input_word):\n        '''Build the suffix tree from the input word.'''\n        if input_word[-1] != '$':\n            input_word += '$'\n        self.word = input_word\n        self.length = len(self.word)\n\n        for i in range(self.length):\n            parent_node, edge_start, overlap_exists = self.find_insert_position(i, self.nodes[0])\n\n            if overlap_exists:\n                old_edge_start, old_edge_end = self.edges[(parent_node.parent.number, parent_node.number)]\n\n                # Determine the length of the edge to be inserted\n                insertion_length = 0\n                while input_word[edge_start:edge_start + insertion_length] == input_word[old_edge_start:old_edge_start + insertion_length]:\n                    insertion_length += 1\n\n                # Create a new node for the insertion\n                new_node = self.Node(parent_node.parent, len(self.nodes))\n                new_node.add_child(parent_node)\n                self.add_edge(parent_node.parent, old_edge_start, old_edge_start + insertion_length - 1, new_node)\n\n                # Update the parent node since a new node is inserted above it\n                del self.edges[(parent_node.parent.number, parent_node.number)]\n                parent_node.parent.remove_child(parent_node)\n                parent_node.update_parent(new_node)\n                self.edges[(parent_node.parent.number, parent_node.number)] = [old_edge_start + insertion_length - 1, old_edge_end]\n\n                # Add new child node\n                self.add_edge(new_node, edge_start + insertion_length - 1, self.length)\n\n            else:\n                # No insertion necessary, just append the new node\n                self.add_edge(parent_node, edge_start, self.length)\n\n    def find_insert_position(self, start_index, parent_node):\n        '''Finds the appropriate position to insert a suffix into the suffix tree.'''\n        for child_node in parent_node.children:\n            edge_start, edge_end = self.edges[(parent_node.number, child_node.number)]\n            if self.word[start_index:start_index + edge_end - edge_start] == self.word[edge_start:edge_end]:\n                return self.find_insert_position(start_index + edge_end - edge_start, child_node)\n\n            elif self.word[edge_start] == self.word[start_index]:\n                return child_node, start_index, True\n\n        return parent_node, start_index, False\n\n    def add_edge(self, parent_node, edge_start, edge_end, child_node=None):\n        '''Adds a node and the associated edge to the suffix tree.'''\n        if child_node is None:\n            child_node = self.Node(parent_node, len(self.nodes))\n\n        self.nodes.append(child_node)\n        parent_node.add_child(child_node)\n        self.edges[(parent_node.number, child_node.number)] = [edge_start, edge_end]\n\n    def get_edge_strings(self):\n        '''Returns the string representations of the edges.'''\n        return [self.word[i:j] for i, j in self.edges.values()]\n\n    def calculate_descendants(self, base_node):\n        '''Calculates the total number of descendants of a given node.'''\n        if base_node not in self.descendants_count:\n            self.descendants_count[base_node] = len(base_node.children) + sum([self.calculate_descendants(c) for c in base_node.children])\n\n        return self.descendants_count[base_node]\n\n    def get_node_word(self, end_node):\n        '''Returns the prefix of the suffix tree word up to a given node.'''\n        accumulated_word = ''\n        while end_node.number != 0:\n            edge_indices = self.edges[(end_node.parent.number, end_node.number)]\n            accumulated_word = self.word[edge_indices[0]:edge_indices[1]] + accumulated_word\n            end_node = end_node.parent\n\n        return accumulated_word.strip('$')\n\n\n# Sample input\ndna_sequence = \"ATTTGGATT\"\nsequence_length = len(dna_sequence)\n\n# After removing the termination symbol $, if necessary, each edge corresponds to len(edge) substrings\nedge_lengths = [edge if edge[1] != sequence_length + 1 else [edge[0], sequence_length] for edge in SuffixTree(dna_sequence).edges.values()]\nobserved_substrings = float(sum([edge[1] - edge[0] for edge in edge_lengths]))\n\n# The number of possible substrings of length k is min(4^k, n-k-1)\nmax_possible_substrings = float(sum([sequence_length - k + 1 if k &gt; log(sequence_length + 1) / log(4) else 4 ** k for k in range(1, sequence_length + 1)]))\n\nprint(observed_substrings / max_possible_substrings)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-41",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-41",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "81.4 Explanation",
    "text": "81.4 Explanation\n\n81.4.1 1. SuffixTree Class\n\n__init__(self, input_word): Initializes the suffix tree with the given word. It sets up initial structures and calls build_suffix_tree to construct the tree.\nNode Class: Represents nodes in the suffix tree.\n\n__init__(self, parent_node, node_number): Initializes a node with a parent and a unique number.\nadd_child(self, child_node): Adds a child node.\nremove_child(self, child_node): Removes a child node.\nupdate_parent(self, new_parent): Updates the parent of the node.\n\nbuild_suffix_tree(self, input_word): Constructs the suffix tree for the given word. Adds a terminator character $ if not already present.\nfind_insert_position(self, start_index, parent_node): Determines where to insert a suffix starting at start_index under parent_node. Handles edge splitting and suffix insertion.\nadd_edge(self, parent_node, edge_start, edge_end, child_node=None): Adds an edge between parent_node and child_node with start and end indices.\nget_edge_strings(self): Returns the substrings represented by each edge in the suffix tree.\ncalculate_descendants(self, base_node): Computes the total number of descendants of base_node, caching results for efficiency.\nget_node_word(self, end_node): Constructs the string from the root to end_node.\n\n\n\n81.4.2 2. Calculations\n\nobserved_substrings: Computes the total length of all distinct substrings from the suffix tree.\nmax_possible_substrings: Calculates the maximum number of distinct substrings possible for a string of length n with an alphabet of size 4.\nprint(observed_substrings / max_possible_substrings): Outputs the linguistic complexity as the ratio of observed distinct substrings to the maximum possible distinct substrings."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-81",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-81",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "82.1 Sample Dataset",
    "text": "82.1 Sample Dataset\n&gt;Rosalind_80\nMEANLYPRTEINSTRING\n&gt;Rosalind_21\nPLEASANTLYEINSTEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-82",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-82",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "82.2 Sample Output",
    "text": "82.2 Sample Output\n23\nLYPRTEINSTRIN\nLYEINSTEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-78",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-78",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "82.3 Solution",
    "text": "82.3 Solution\nimport numpy as np\n\nclas PAM250:\n    \"\"\"The PAM250 scoring matrix class.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the scoring matrix.\"\"\"\n        # Manually define the PAM250 scoring matrix.\n        self.scoring_matrix = {\n            ('A', 'A'): 2, ('A', 'C'): -2, ('A', 'D'): 0, ('A', 'E'): 0, ('A', 'F'): -3, ('A', 'G'): 1, ('A', 'H'): -1,\n            ('A', 'I'): -1, ('A', 'K'): -1, ('A', 'L'): -2, ('A', 'M'): -1, ('A', 'N'): 0, ('A', 'P'): 1, ('A', 'Q'): 0,\n            ('A', 'R'): -2, ('A', 'S'): 1, ('A', 'T'): 1, ('A', 'V'): 0, ('A', 'W'): -6, ('A', 'Y'): -3,\n            ('C', 'A'): -2, ('C', 'C'): 12, ('C', 'D'): -5, ('C', 'E'): -5, ('C', 'F'): -4, ('C', 'G'): -3, ('C', 'H'): -3,\n            ('C', 'I'): -2, ('C', 'K'): -5, ('C', 'L'): -6, ('C', 'M'): -5, ('C', 'N'): -4, ('C', 'P'): -3, ('C', 'Q'): -5,\n            ('C', 'R'): -4, ('C', 'S'): 0, ('C', 'T'): -2, ('C', 'V'): -2, ('C', 'W'): -8, ('C', 'Y'): 0,\n            ('D', 'A'): 0, ('D', 'C'): -5, ('D', 'D'): 4, ('D', 'E'): 3, ('D', 'F'): -6, ('D', 'G'): 1, ('D', 'H'): 1,\n            ('D', 'I'): -2, ('D', 'K'): 0, ('D', 'L'): -4, ('D', 'M'): -3, ('D', 'N'): 2, ('D', 'P'): -1, ('D', 'Q'): 2,\n            ('D', 'R'): -1, ('D', 'S'): 0, ('D', 'T'): 0, ('D', 'V'): -2, ('D', 'W'): -7, ('D', 'Y'): -4,\n            ('E', 'A'): 0, ('E', 'C'): -5, ('E', 'D'): 3, ('E', 'E'): 4, ('E', 'F'): -5, ('E', 'G'): 0, ('E', 'H'): 1,\n            ('E', 'I'): -2, ('E', 'K'): 0, ('E', 'L'): -3, ('E', 'M'): -2, ('E', 'N'): 1, ('E', 'P'): -1, ('E', 'Q'): 2,\n            ('E', 'R'): -1, ('E', 'S'): 0, ('E', 'T'): 0, ('E', 'V'): -2, ('E', 'W'): -7, ('E', 'Y'): -4,\n            ('F', 'A'): -3, ('F', 'C'): -4, ('F', 'D'): -6, ('F', 'E'): -5, ('F', 'F'): 9, ('F', 'G'): -5, ('F', 'H'): -2,\n            ('F', 'I'): 1, ('F', 'K'): -5, ('F', 'L'): 2, ('F', 'M'): 0, ('F', 'N'): -3, ('F', 'P'): -5, ('F', 'Q'): -5,\n            ('F', 'R'): -4, ('F', 'S'): -3, ('F', 'T'): -3, ('F', 'V'): -1, ('F', 'W'): 0, ('F', 'Y'): 7,\n            ('G', 'A'): 1, ('G', 'C'): -3, ('G', 'D'): 1, ('G', 'E'): 0, ('G', 'F'): -5, ('G', 'G'): 5, ('G', 'H'): -2,\n            ('G', 'I'): -3, ('G', 'K'): -2, ('G', 'L'): -4, ('G', 'M'): -3, ('G', 'N'): 0, ('G', 'P'): 0, ('G', 'Q'): -1,\n            ('G', 'R'): -3, ('G', 'S'): 1, ('G', 'T'): 0, ('G', 'V'): -1, ('G', 'W'): -7, ('G', 'Y'): -5,\n            ('H', 'A'): -1, ('H', 'C'): -3, ('H', 'D'): 1, ('H', 'E'): 1, ('H', 'F'): -2, ('H', 'G'): -2, ('H', 'H'): 6,\n            ('H', 'I'): -2, ('H', 'K'): 0, ('H', 'L'): -2, ('H', 'M'): -2, ('H', 'N'): 2, ('H', 'P'): 0, ('H', 'Q'): 3,\n            ('H', 'R'): 2, ('H', 'S'): -1, ('H', 'T'): -1, ('H', 'V'): -2, ('H', 'W'): -3, ('H', 'Y'): 0,\n            ('I', 'A'): -1, ('I', 'C'): -2, ('I', 'D'): -2, ('I', 'E'): -2, ('I', 'F'): 1, ('I', 'G'): -3, ('I', 'H'): -2,\n            ('I', 'I'): 5, ('I', 'K'): -2, ('I', 'L'): 2, ('I', 'M'): 2, ('I', 'N'): -2, ('I', 'P'): -2, ('I', 'Q'): -2,\n            ('I', 'R'): -2, ('I', 'S'): -1, ('I', 'T'): 0, ('I', 'V'): 4, ('I', 'W'): -5, ('I', 'Y'): -1,\n            ('K', 'A'): -1, ('K', 'C'): -5, ('K', 'D'): 0, ('K', 'E'): 0, ('K', 'F'): -5, ('K', 'G'): -2, ('K', 'H'): 0,\n            ('K', 'I'): -2, ('K', 'K'): 5, ('K', 'L'): -3, ('K', 'M'): 0, ('K', 'N'): 1, ('K', 'P'): -1, ('K', 'Q'): 1,\n            ('K', 'R'): 3, ('K', 'S'): 0, ('K', 'T'): 0, ('K', 'V'): -2, ('K', 'W'): -3, ('K', 'Y'): -4,\n            ('L', 'A'): -2, ('L', 'C'): -6, ('L', 'D'): -4, ('L', 'E'): -3, ('L', 'F'): 2, ('L', 'G'): -4, ('L', 'H'): -2,\n            ('L', 'I'): 2, ('L', 'K'): -3, ('L', 'L'): 6, ('L', 'M'): 4, ('L', 'N'): -3, ('L', 'P'): -3, ('L', 'Q'): -2,\n            ('L', 'R'): -3, ('L', 'S'): -3, ('L', 'T'): -2, ('L', 'V'): 2, ('L', 'W'): -2, ('L', 'Y'): -1,\n            ('M', 'A'): -1, ('M', 'C'): -5, ('M', 'D'): -3, ('M', 'E'): -2, ('M', 'F'): 0, ('M', 'G'): -3, ('M', 'H'): -2,\n            ('M', 'I'): 2, ('M', 'K'): 0, ('M', 'L'): 4, ('M', 'M'): 6, ('M', 'N'): -2, ('M', 'P'): -2, ('M', 'Q'): -1,\n            ('M', 'R'): 0, ('M', 'S'): -2, ('M', 'T'): -1, ('M', 'V'): 2, ('M', 'W'): -4, ('M', 'Y'): -2,\n            ('N', 'A'): 0, ('N', 'C'): -4, ('N', 'D'): 2, ('N', 'E'): 1, ('N', 'F'): -3, ('N', 'G'): 0, ('N', 'H'): 2,\n            ('N', 'I'): -2, ('N', 'K'): 1, ('N', 'L'): -3, ('N', 'M'): -2, ('N', 'N'): 2, ('N', 'P'): 0, ('N', 'Q'): 1,\n            ('N', 'R'): 0, ('N', 'S'): 1, ('N', 'T'): 0, ('N', 'V'): -2, ('N', 'W'): -4, ('N', 'Y'): -2,\n            ('P', 'A'): 1, ('P', 'C'): -3, ('P', 'D'): -1, ('P', 'E'): -1, ('P', 'F'): -5, ('P', 'G'): 0, ('P', 'H'): 0,\n            ('P', 'I'): -2, ('P', 'K'): -1, ('P', 'L'): -3, ('P', 'M'): -2, ('P', 'N'): 0, ('P', 'P'): 6, ('P', 'Q'): 0,\n            ('P', 'R'): 0, ('P', 'S'): 1, ('P', 'T'): 0, ('P', 'V'): -1, ('P', 'W'): -6, ('P', 'Y'): -5,\n            ('Q', 'A'): 0, ('Q', 'C'): -5, ('Q', 'D'): 2, ('Q', 'E'): 2, ('Q', 'F'): -5, ('Q', 'G'): -1, ('Q', 'H'): 3,\n            ('Q', 'I'): -2, ('Q', 'K'): 1, ('Q', 'L'): -2, ('Q', 'M'): -1, ('Q', 'N'): 1, ('Q', 'P'): 0, ('Q', 'Q'): 4,\n            ('Q', 'R'): 1, ('Q', 'S'): -1, ('Q', 'T'): -1, ('Q', 'V'): -2, ('Q', 'W'): -5, ('Q', 'Y'): -4,\n            ('R', 'A'): -2, ('R', 'C'): -4, ('R', 'D'): -1, ('R', 'E'): -1, ('R', 'F'): -4, ('R', 'G'): -3, ('R', 'H'): 2,\n            ('R', 'I'): -2, ('R', 'K'): 3, ('R', 'L'): -3, ('R', 'M'): 0, ('R', 'N'): 0, ('R', 'P'): 0, ('R', 'Q'): 1,\n            ('R', 'R'): 6, ('R', 'S'): 0, ('R', 'T'): -1, ('R', 'V'): -2, ('R', 'W'): 2, ('R', 'Y'): -4,\n            ('S', 'A'): 1, ('S', 'C'): 0, ('S', 'D'): 0, ('S', 'E'): 0, ('S', 'F'): -3, ('S', 'G'): 1, ('S', 'H'): -1,\n            ('S', 'I'): -1, ('S', 'K'): 0, ('S', 'L'): -3, ('S', 'M'): -2, ('S', 'N'): 1, ('S', 'P'): 1, ('S', 'Q'): -1,\n            ('S', 'R'): 0, ('S', 'S'): 2, ('S', 'T'): 1, ('S', 'V'): -1, ('S', 'W'): -2, ('S', 'Y'): -3,\n            ('T', 'A'): 1, ('T', 'C'): -2, ('T', 'D'): 0, ('T', 'E'): 0, ('T', 'F'): -3, ('T', 'G'): 0, ('T', 'H'): -1,\n            ('T', 'I'): 0, ('T', 'K'): 0, ('T', 'L'): -2, ('T', 'M'): -1, ('T', 'N'): 0, ('T', 'P'): 0, ('T', 'Q'): -1,\n            ('T', 'R'): -1, ('T', 'S'): 1, ('T', 'T'): 3, ('T', 'V'): 0, ('T', 'W'): -5, ('T', 'Y'): -3,\n            ('V', 'A'): 0, ('V', 'C'): -2, ('V', 'D'): -2, ('V', 'E'): -2, ('V', 'F'): -1, ('V', 'G'): -1, ('V', 'H'): -2,\n            ('V', 'I'): 4, ('V', 'K'): -2, ('V', 'L'): 2, ('V', 'M'): 2, ('V', 'N'): -2, ('V', 'P'): -1, ('V', 'Q'): -2,\n            ('V', 'R'): -2, ('V', 'S'): -1, ('V', 'T'): 0, ('V', 'V'): 4, ('V', 'W'): -6, ('V', 'Y'): -2,\n            ('W', 'A'): -6, ('W', 'C'): -8, ('W', 'D'): -7, ('W', 'E'): -7, ('W', 'F'): 0, ('W', 'G'): -7, ('W', 'H'): -3,\n            ('W', 'I'): -5, ('W', 'K'): -3, ('W', 'L'): -2, ('W', 'M'): -4, ('W', 'N'): -4, ('W', 'P'): -6, ('W', 'Q'): -5,\n            ('W', 'R'): 2, ('W', 'S'): -2, ('W', 'T'): -5, ('W', 'V'): -6, ('W', 'W'): 17, ('W', 'Y'): 0,\n            ('Y', 'A'): -3, ('Y', 'C'): 0, ('Y', 'D'): -4, ('Y', 'E'): -4, ('Y', 'F'): 7, ('Y', 'G'): -5, ('Y', 'H'): 0,\n            ('Y', 'I'): -1, ('Y', 'K'): -4, ('Y', 'L'): -1, ('Y', 'M'): -2, ('Y', 'N'): -2, ('Y', 'P'): -5, ('Y', 'Q'): -4,\n            ('Y', 'R'): -4, ('Y', 'S'): -3, ('Y', 'T'): -3, ('Y', 'V'): -2, ('Y', 'W'): 0, ('Y', 'Y'): 10\n        }\n\n    def __getitem__(self, pair):\n        \"\"\"Return the score for a given pair of amino acids.\"\"\"\n        return self.scoring_matrix[pair]\n\ndef local_alignment(v, w, scoring_matrix, sigma):\n    \"\"\"Returns the score and local alignment with the given scoring matrix and indel penalty sigma for strings v, w.\"\"\"\n    \n    # Initialize the matrices S (score) and backtrack.\n    S = np.zeros((len(v) + 1, len(w) + 1), dtype=int)\n    backtrack = np.zeros((len(v) + 1, len(w) + 1), dtype=int)\n\n    # Fill in the score matrix S and the backtrack matrix.\n    for i in range(1, len(v) + 1):\n        for j in range(1, len(w) + 1):\n            match_score = scoring_matrix[v[i - 1], w[j - 1]]\n            scores = [\n                S[i - 1][j] - sigma,          # Insertion\n                S[i][j - 1] - sigma,          # Deletion\n                S[i - 1][j - 1] + match_score, # Match/Mismatch\n                0                             # Local alignment can start anywhere, so 0 is a valid score.\n            ]\n            S[i][j] = max(scores)             # Maximum score for cell (i, j)\n            backtrack[i][j] = scores.index(S[i][j])  # Record which move was taken.\n\n    # Find the position of the highest scoring cell in the matrix.\n    max_pos = np.unravel_index(np.argmax(S), S.shape)\n    max_score = str(S[max_pos])\n\n    # Start backtracking from the position of the highest score.\n    i, j = max_pos\n    v_aligned, w_aligned = [], []\n\n    # Reconstruct the alignment.\n    while S[i][j] != 0:\n        if backtrack[i][j] == 0:  # Insertion\n            i -= 1\n            v_aligned.append(v[i])\n            w_aligned.append('-')\n        elif backtrack[i][j] == 1:  # Deletion\n            j -= 1\n            v_aligned.append('-')\n            w_aligned.append(w[j])\n        else:  # Match or mismatch\n            i -= 1\n            j -= 1\n            v_aligned.append(v[i])\n            w_aligned.append(w[j])\n\n    # Reverse the aligned sequences since they were constructed backwards.\n    v_aligned = ''.join(v_aligned[::-1])\n    w_aligned = ''.join(w_aligned[::-1])\n\n    return max_score, v_aligned, w_aligned\n\n# Sample Input\nsample_input = \"\"\"&gt;Rosalind_80\nMEANLYPRTEINSTRING\n&gt;Rosalind_21\nPLEASANTLYEINSTEIN\n\"\"\"\n\n# Parse input FASTA format data\ndef parse_fasta(data):\n    sequences = []\n    parts = data.strip().split('&gt;')\n    for part in parts:\n        if part:\n            lines = part.split('\\n')\n            sequence = ''.join(lines[1:])\n            sequences.append(sequence)\n    return sequences\n\nsequences = parse_fasta(sample_input)\nseq1, seq2 = sequences[0], sequences[1]\n\n# Get the local alignment with sigma = 5.\nalignment = local_alignment(seq1, seq2, PAM250(), 5)\n\n# Print the alignment.\nprint('\\n'.join(alignment))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-42",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-42",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "82.4 Explanation",
    "text": "82.4 Explanation\n\nPAM250 Class:\n\nThe PAM250 clas is defined to encapsulate the scoring matrix. The matrix is stored in a dictionary where the keys are tuples of amino acid pairs, and the values are their corresponding scores.\nThe __getitem__ method allows easy acces to the matrix using tuple indexing, e.g., scoring_matrix['A', 'A'].\n\nlocal_alignment Function:\n\nThe local_alignment function computes the local alignment using dynamic programming.\nS is the score matrix that keeps track of the best scores for subsequences of v and w.\nbacktrack keeps track of the choices made to achieve the score in each cell (insertion, deletion, match/mismatch, or starting a new local alignment).\nThe function iterates over the strings v and w, filling the matrices according to the local alignment rules.\nThe backtracking step reconstructs the aligned sequences from the highest scoring position until a score of zero is encountered, indicating the start of the local alignment.\n\nBacktracking and Alignment:\n\nThe backtracking loop constructs the aligned sequences by following the recorded moves in the backtrack matrix.\nThe sequences are built in reverse and then reversed at the end to give the correct alignment.\n\nparse_fasta:\n\nThe parse_fasta function reads the input FASTA format data and extracts the sequences. It returns a list of sequences to be used in the alignment.\n\nExecution:\n\nThe code parses the sample input, computes the local alignment, and prints the aligned sequences and the alignment score."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-82",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-82",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "83.1 Sample Dataset",
    "text": "83.1 Sample Dataset\n&gt;Rosalind_92\nAACGTA\n&gt;Rosalind_47\nACACCTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-83",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-83",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "83.2 Sample Output",
    "text": "83.2 Sample Output\n3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-79",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-79",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "83.3 Solution",
    "text": "83.3 Solution\ndef maximum_gap_symbols(v, w):\n    \"\"\"\n    Returns the maximum number of gap symbols in an optimal alignment of v and w.\n    The maximum number of gaps is derived from the lengths of the input strings and the longest common subsequence (LCS) between them.\n    \"\"\"\n    # Initialize a matrix to store the lengths of the longest common subsequence\n    len_v, len_w = len(v), len(w)\n    lcs_matrix = [[0] * (len_w + 1) for _ in range(len_v + 1)]\n\n    # Fill the matrix based on LCS dynamic programming\n    for i in range(1, len_v + 1):\n        for j in range(1, len_w + 1):\n            if v[i - 1] == w[j - 1]:\n                lcs_matrix[i][j] = lcs_matrix[i - 1][j - 1] + 1\n            else:\n                lcs_matrix[i][j] = max(lcs_matrix[i][j - 1], lcs_matrix[i - 1][j])\n\n    # Calculate the maximum number of gap symbols\n    lcs_length = lcs_matrix[len_v][len_w]\n    max_gaps = len_v + len_w - 2 * lcs_length\n\n    return max_gaps\n\ndef parse_fasta(data):\n    \"\"\"\n    Parses input FASTA format data and returns a list of sequences.\n    \"\"\"\n    sequences = []\n    entries = data.strip().split('&gt;')\n    \n    for entry in entries:\n        if entry:\n            lines = entry.splitlines()\n            sequence = ''.join(lines[1:])\n            sequences.append(sequence)\n    \n    return sequences\n\n# Sample input in FASTA format\nsample_input = \"\"\"\n&gt;Rosalind_92\nAACGTA\n&gt;Rosalind_47\nACACCTA\n\"\"\"\n\n# Parse the sequences from the sample input\nsequences = parse_fasta(sample_input)\nv, w = sequences[0], sequences[1]\n\n# Get the maximum number of gap symbols\nmax_gaps = maximum_gap_symbols(v, w)\n\n# Print the result\nprint(max_gaps)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-43",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-43",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "83.4 Explanation",
    "text": "83.4 Explanation\nmaximum_gap_symbols(v, w) function calculates the maximum number of gap symbols that can appear in any optimal alignment of two DNA strings v and w. It does so by using the Longest Common Subsequence (LCS) method.\n\nInitialization:\nlen_v, len_w = len(v), len(w)\nlcs_matrix = [[0] * (len_w + 1) for _ in range(len_v + 1)]\nHere, the lengths of the input strings v and w are stored in len_v and len_w. Then, a 2D matrix lcs_matrix is initialized with all elements set to 0. The matrix has dimensions (len_v + 1) x (len_w + 1).\nFilling the LCS Matrix:\nfor i in range(1, len_v + 1):\n    for j in range(1, len_w + 1):\n        if v[i - 1] == w[j - 1]:\n            lcs_matrix[i][j] = lcs_matrix[i - 1][j - 1] + 1\n        else:\n            lcs_matrix[i][j] = max(lcs_matrix[i][j - 1], lcs_matrix[i - 1][j])\nThis loop fills the lcs_matrix based on the LCS dynamic programming approach:\n\nIf the characters v[i-1] and w[j-1] are equal, the value at lcs_matrix[i][j] is updated to lcs_matrix[i-1][j-1] + 1.\nOtherwise, it takes the maximum of the values to the left (lcs_matrix[i][j-1]) and above (lcs_matrix[i-1][j]).\n\nCalculating Maximum Number of Gaps:\nlcs_length = lcs_matrix[len_v][len_w]\nmax_gaps = len_v + len_w - 2 * lcs_length\nAfter filling the matrix, the length of the LCS is stored in lcs_length. The maximum number of gaps is then calculated using the formula len(v) + len(w) - 2 * lcs_length."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-83",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-83",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "84.1 Sample Dataset",
    "text": "84.1 Sample Dataset\nTAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-84",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-84",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "84.2 Sample Output",
    "text": "84.2 Sample Output\nATGGGTCCAGAGTTTTGTAATTT\nTAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-80",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-80",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "84.3 Solution",
    "text": "84.3 Solution\nimport functools\n\nclas SuffixTree(object):\n    '''Creates a suffix tree for the provided word.'''\n\n    def __init__(self, word):\n        '''Initializes the suffix tree.'''\n        self.nodes = [self.Node(None, 0)]\n        self.edges = dict()\n        self.descendants_dict = dict()\n        if type(word) == str:\n            self.add_word(word)\n\n    clas Node(object):\n        '''Suffix tree node class.'''\n        def __init__(self, parent, number):\n            self.parent = parent\n            self.number = number\n            self.children = []\n\n        def add_child(self, child):\n            self.children.append(child)\n\n        def remove_child(self, child):\n            self.children.remove(child)\n\n        def update_parent(self, parent):\n            self.parent = parent\n\n    def add_word(self, word):\n        '''Add a word to the suffix tree.'''\n        # Check to make sure word ends in '$'.\n        if word[-1] != '$':\n            word += '$'\n        self.word = word\n        self.n = len(self.word)\n\n        for i in range(self.n):\n            parent_node, edge_start, overlap = self.insert_position(i, self.nodes[0])\n\n            if overlap:\n                p_edge_start, p_edge_end = self.edges[(parent_node.parent.number, parent_node.number)]\n\n                # Get the edge to insert\n                insert_len = 0\n                while word[edge_start:edge_start + insert_len] == word[p_edge_start:p_edge_start + insert_len]:\n                    insert_len += 1\n\n                # Create a new node for insertion\n                new_node = self.Node(parent_node.parent, len(self.nodes))\n                new_node.add_child(parent_node)\n                self.add_node(parent_node.parent, p_edge_start, p_edge_start + insert_len - 1, new_node)\n\n                # Update the parent node since a new node is inserted above it\n                del self.edges[(parent_node.parent.number, parent_node.number)]\n                parent_node.parent.remove_child(parent_node)\n                parent_node.update_parent(new_node)\n                self.edges[(parent_node.parent.number, parent_node.number)] = [p_edge_start + insert_len - 1, p_edge_end]\n\n                # Add new child node\n                self.add_node(new_node, edge_start + insert_len - 1, self.n)\n\n            else:\n                # No insertion necessary, just append the new node.\n                self.add_node(parent_node, edge_start, self.n)\n\n    def insert_position(self, start_index, parent_node):\n        '''Determine the location and method to insert a suffix into the suffix tree.'''\n        for child_node in parent_node.children:\n            edge_start, edge_end = self.edges[(parent_node.number, child_node.number)]\n            if self.word[start_index:start_index + edge_end - edge_start] == self.word[edge_start:edge_end]:\n                return self.insert_position(start_index + edge_end - edge_start, child_node)\n\n            elif self.word[edge_start] == self.word[start_index]:\n                return child_node, start_index,  True\n\n        return parent_node, start_index, False\n\n    def add_node(self, parent_node, edge_start, edge_end, child_node=None):\n        '''Adds a node and the associated edge to the suffix tree.'''\n\n        # Create child node, if necessary\n        if child_node is None:\n            child_node = self.Node(parent_node, len(self.nodes))\n\n        # Add node to node list\n        self.nodes.append(child_node)\n\n        # Add child to parent\n        parent_node.add_child(child_node)\n\n        # Add edge to edge dict\n        self.edges[(parent_node.number, child_node.number)] = [\n            edge_start, edge_end]\n\n    def print_edges(self):\n        '''Returns the string representations of the edges.'''\n        return [self.word[i:j] for i, j in self.edges.values()]\n\n    def total_descendants(self, base_node):\n        '''Returns the total number of descendants of a given node.'''\n        if base_node not in self.descendants_dict:\n            self.descendants_dict[base_node] = len(base_node.children) + sum([self.total_descendants(c) for c in base_node.children])\n\n        return self.descendants_dict[base_node]\n\n    def node_word(self, end_node):\n        '''Returns the prefix of the suffix tree word up to a given node.'''\n        current_word = ''\n        while end_node.number != 0:\n            temp_indices = self.edges[(end_node.parent.number, end_node.number)]\n            current_word = self.word[temp_indices[0]:temp_indices[1]] + current_word\n            end_node = end_node.parent\n\n        return current_word.strip('$')\n\nclas Trie(object):\n    '''Constructs a trie.'''\n\n    def __init__(self, word=None):\n        self.nodes = [[self.Node('', 1)]]\n        self.edges = []\n        if word is not None:\n            self.add_word(word)\n\n    clas Node(object):\n        '''Trie node class.'''\n        def __init__(self, prefix, number):\n            self.prefix = prefix\n            self.number = number\n            self.depth = len(prefix)\n\n    clas Edge(object):\n        '''Trie edge class.'''\n        def __init__(self, letter, par_node, chi_node):\n            self.letter = letter\n            self.parent_node = par_node\n            self.child_node = chi_node\n\n        def get_info(self):\n            '''Return the edge information compactly.'''\n            return ' '.join(map(str, [self.parent_node, self.child_node, self.letter]))\n\n    def add_word(self, word):\n        '''Adds a word to the trie.'''\n        if type(word) == list:\n            for w in word:\n                self.add_word(w)\n        else:\n            parent = self.find_parent(word)\n            for i in range(len(parent.prefix), len(word)):\n                new_node = self.Node(word[:i + 1], self.node_count() + 1)\n                self.edges.append(self.Edge(word[i], parent.number, self.node_count() + 1))\n                self.insert_node(new_node)\n                parent = new_node\n\n    def insert_node(self, node):\n        '''Determine the location to insert the current node.'''\n        if node.depth &gt; self.depth():\n            self.nodes.append([node])\n        else:\n            self.nodes[node.depth].append(node)\n\n    def depth(self):\n        '''Returns the depth of the trie.'''\n        return len(self.nodes) - 1\n\n    def node_count(self):\n        '''Returns the total number of nodes.'''\n        count = 0\n        for trie_depth in self.nodes:\n            count += len(trie_depth)\n        return count\n\n    def find_parent(self, word):\n        '''Return the parent node of the word to be inserted.'''\n        for i in range(min(len(word), self.depth()), 0, -1):\n            for node in self.nodes[i]:\n                if word[:i] == node.prefix:\n                    return node\n\n        return self.nodes[0][0]\n\n# Read the input data.\nsample_input = \"\"\"\nTAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT\n\"\"\"\n\ndna = sample_input.strip()\n\n# Create the Suffix Tree.\nsuff = SuffixTree(dna)\n\n# Store all multiple repeats of length at least 20 in a dictionary keyed on number of appearances.\nrepeat_dict = {}\nfor node in suff.nodes[1:]:\n    if suff.total_descendants(node) &gt;= 2 and len(suff.node_word(node)) &gt;= 20:\n        if suff.total_descendants(node) not in repeat_dict:\n            repeat_dict[suff.total_descendants(node)] = [suff.node_word(node)]\n        else:\n            repeat_dict[suff.total_descendants(node)].append(suff.node_word(node))\n\n# Filter out non-maximal repeats.\nrepeats = []\nfor values in repeat_dict.values():\n    if len(values) == 1:\n        repeats += values\n    else:\n        repeats += filter(lambda v: all(v not in word for word in values if word != v), values)\n\n# Print and save the answer.\nprint('\\n'.join(repeats))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-breakdown-of-the-code",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-breakdown-of-the-code",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "84.4 Detailed Breakdown of the Code",
    "text": "84.4 Detailed Breakdown of the Code\n\nsuff = SuffixTree(dna):\n\nConstructs a suffix tree for the DNA sequence.\n\nBuilding repeat_dict:\n\nCollects all repeats that appear at least twice and are at least 20 characters long.\nUses the total_descendants method to count occurrences.\n\nFiltering Non-Maximal Repeats:\n\nEnsures that each repeat is maximal by checking if it is not a substring of any other repeat in the same list.\n\nPrinting Results:\n\nPrints the filtered list of maximal repeats."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-84",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-84",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "85.1 Sample Dataset",
    "text": "85.1 Sample Dataset\n&gt;Rosalind_7\nATATCCG\n&gt;Rosalind_35\nTCCG\n&gt;Rosalind_23\nATGTACTG\n&gt;Rosalind_44\nATGTCTG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-85",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-85",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "85.2 Sample Output",
    "text": "85.2 Sample Output\n-18\nATAT-CCG\n-T---CCG\nATGTACTG\nATGT-CTG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-81",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-81",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "85.3 Solution",
    "text": "85.3 Solution\nimport numpy as np\n\ndef score(chars, match=0, mismatch=-1):\n    \"\"\"\n    Calculate the alignment score for a list of characters.\n    :param chars: List of characters.\n    :param match: Score for matching characters.\n    :param mismatch: Score for mismatching characters.\n    :return: Total alignment score.\n    \"\"\"\n    return sum(match if chars[i] == chars[j] else mismatch for i in range(len(chars)) for j in range(i + 1, len(chars)))\n\n\ndef generate_indices(dimensions):\n    \"\"\"\n    Generate all possible indices for the given dimensions.\n    :param dimensions: List of dimensions for each sequence.\n    :return: Generator yielding tuples of indices.\n    \"\"\"\n    total_combinations = np.prod(dimensions)\n    indices = [0] * len(dimensions)\n    for _ in range(total_combinations):\n        yield tuple(indices)\n        for j in reversed(range(len(dimensions))):\n            indices[j] += 1\n            if indices[j] &lt; dimensions[j]:\n                break\n            indices[j] = 0\n\n\ndef generate_moves(num_sequences, options=[0, -1]):\n    \"\"\"\n    Generate all valid move combinations.\n    :param num_sequences: Number of sequences.\n    :param options: Possible move options (0 for match, -1 for gap).\n    :return: List of valid move combinations.\n    \"\"\"\n    def recursive_moves(m):\n        if m == 1:\n            return [[o] for o in options]\n        return [[o] + rest for o in options for rest in recursive_moves(m - 1)]\n\n    return [move for move in recursive_moves(num_sequences) if any(x != 0 for x in move)]\n\n\ndef add_tuples(u, v):\n    \"\"\"\n    Add two tuples element-wise.\n    :param u: First tuple.\n    :param v: Second tuple.\n    :return: Element-wise sum of the tuples.\n    \"\"\"\n    return tuple(a + b for a, b in zip(u, v))\n\n\ndef build_scoring_matrix(Strings, score_function=score):\n    \"\"\"\n    Build the scoring matrix for the alignment.\n    :param Strings: List of sequences to align.\n    :param score_function: Function to calculate alignment score.\n    :return: Scoring matrix, path dictionary, and move list.\n    \"\"\"\n    def calculate_scores(index):\n        def get_score(move):\n            previous = add_tuples(index, move)\n            if any(p &lt; 0 for p in previous):\n                return None\n            scorable = [Strings[j][previous[j]] if move[j] &lt; 0 else '-' for j in range(len(move))]\n            return scoring_matrix[previous] + score_function(scorable)\n\n        raw_scores = [(get_score(move), move) for move in available_moves]\n        return [(score, move) for score, move in raw_scores if score is not None]\n\n    dimensions = [len(S) + 1 for S in Strings]\n    scoring_matrix = np.zeros(dimensions, dtype=int)\n    path = {}\n    available_moves = generate_moves(len(Strings))\n\n    for index_set in generate_indices(dimensions):\n        scores_moves = calculate_scores(index_set)\n        if scores_moves:\n            scores, moves = zip(*scores_moves)\n            best_index = np.argmax(scores)\n            scoring_matrix[index_set] = scores[best_index]\n            path[index_set] = moves[best_index]\n\n    return scoring_matrix, path, available_moves\n\n\ndef backtrack_alignment(scoring_matrix, path, Strings):\n    \"\"\"\n    Perform backtracking to retrieve the optimal alignment.\n    :param scoring_matrix: Scoring matrix.\n    :param path: Path dictionary for moves.\n    :param Strings: List of sequences to align.\n    :return: Alignment score and aligned sequences.\n    \"\"\"\n    def reverse_string(s):\n        return ''.join(reversed(s))\n\n    position = tuple(len(S) for S in Strings)\n    alignment_score = scoring_matrix[position]\n    alignments = [[] for _ in Strings]\n\n    while any(p != 0 for p in position):\n        move = path[position]\n        for i, m in enumerate(move):\n            if m == 0:\n                alignments[i].append('-')\n            else:\n                alignments[i].append(Strings[i][position[i] - 1])\n        position = add_tuples(position, move)\n\n    return alignment_score, [reverse_string(s) for s in alignments]\n\n\ndef FindHighestScoringMultipleSequenceAlignment(Strings, score_function=score):\n    \"\"\"\n    Find the highest scoring multiple sequence alignment.\n    :param Strings: List of sequences to align.\n    :param score_function: Function to calculate alignment score.\n    :return: Alignment score and aligned sequences.\n    \"\"\"\n    scoring_matrix, path, _ = build_scoring_matrix(Strings, score_function)\n    return backtrack_alignment(scoring_matrix, path, Strings)\n\n\ndef parse_fasta(data):\n    \"\"\"\n    Parse FASTA format data into a list of sequences.\n    :param data: FASTA format input data.\n    :return: List of sequences.\n    \"\"\"\n    sequences = []\n    entries = data.strip().split('&gt;')\n    for entry in entries:\n        if entry:\n            lines = entry.splitlines()\n            sequence = ''.join(lines[1:])\n            sequences.append(sequence)\n    return sequences\n\n\n# Sample input in FASTA format\nsample_input = \"\"\"\n&gt;Rosalind_7\nATATCCG\n&gt;Rosalind_35\nTCCG\n&gt;Rosalind_23\nATGTACTG\n&gt;Rosalind_44\nATGTCTG\n\"\"\"\n\n# Parse the sequences from the sample input\nwords = parse_fasta(sample_input)\n\n# Get the alignment.\nscore, alignment = FindHighestScoringMultipleSequenceAlignment(words)\n\n# Print the alignment score and sequences.\nprint(score)\nfor line in alignment:\n    print(line)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explain-the-code",
    "href": "posts/qmd/Rosalind_stronghold.html#explain-the-code",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "85.4 Explain the code",
    "text": "85.4 Explain the code\n\nscore(chars, match, mismatch):\n\nThis function computes the alignment score based on matches and mismatches.\n\ngenerate_indices(dimensions):\n\nGenerates all possible index tuples for alignment, given the sequence lengths.\n\ngenerate_moves(num_sequences, options):\n\nGenerates valid move combinations for alignment, ensuring at least one non-gap move.\n\nadd_tuples(u, v):\n\nElement-wise addition of two tuples.\n\nbuild_scoring_matrix(Strings, score_function):\n\nConstructs the scoring matrix and paths for backtracking.\n\nbacktrack_alignment(scoring_matrix, path, Strings):\n\nReconstructs the alignment based on the scoring matrix and path.\n\nparse_fasta(data):\n\nParses FASTA format data into a list of sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-85",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-85",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "86.1 Sample Dataset",
    "text": "86.1 Sample Dataset\n2 2 3 3 4 5 6 7 8 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-86",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-86",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "86.2 Sample Output",
    "text": "86.2 Sample Output\n0 2 4 7 10"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-82",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-82",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "86.3 Solution",
    "text": "86.3 Solution\nfrom math import sqrt\n\ndef reconstruct_set(input_data):\n    \"\"\"\n    Reconstruct the original set from the given differences.\n    \n    :param input_data: A string containing space-separated integers representing the differences\n    :return: A list of integers representing the reconstructed set\n    \"\"\"\n    # Convert input string to list of integers\n    differences = list(map(int, input_data.strip().split()))\n\n    # Calculate the number of elements in the original set\n    # using the quadratic formula: n(n-1)/2 = len(differences)\n    set_size = int(0.5 + 0.5 * sqrt(8.0 * len(differences) + 1))\n\n    # Initialize the result set with 0\n    result_set = [0]\n\n    # Add the largest difference to the result set\n    largest_difference = max(differences)\n    result_set.append(largest_difference)\n    differences.remove(largest_difference)\n\n    # Create a set of unique differences\n    unique_differences = set(differences)\n\n    for candidate in unique_differences:\n        # Check if the candidate fits with all existing elements in the result set\n        if sum([(abs(candidate - element) in differences) for element in result_set]) == len(result_set):\n            for element in result_set:\n                # Remove the differences we've already accounted for\n                differences.remove(abs(candidate - element))\n            # Add the new element to the result set\n            result_set.append(candidate)\n            if len(result_set) == set_size:\n                break\n\n    return sorted(result_set)\n\n# Example usage\ninput_data = \"\"\"\n2 2 3 3 4 5 6 7 8 10\n\"\"\"\n\nresult = reconstruct_set(input_data)\nprint(' '.join(map(str, result)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#step-by-step-explanation",
    "href": "posts/qmd/Rosalind_stronghold.html#step-by-step-explanation",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "86.4 Step-by-Step Explanation",
    "text": "86.4 Step-by-Step Explanation\n\nConvert Input to a List:\n\nThe input string is converted into a list of integers. These integers represent the differences between every pair of elements in the original set.\n\nDetermine the Number of Elements:\n\nThe code calculates how many numbers were in the original set using a mathematical formula related to the number of differences.\n\nStart with the Smallest Element:\n\nThe code assumes the smallest number in the set is 0 and starts the result_set with [0].\n\nAdd the Largest Difference:\n\nThe largest number in the original set is found by taking the largest difference from the list. This number is added to the result_set.\n\nReconstruct the Remaining Numbers:\n\nThe code checks each remaining difference to see if it can be used to find other numbers in the set. It does this by ensuring that each candidate number fits with all previously found numbers (i.e., the differences match).\n\nBuild the Set:\n\nAs valid numbers are found, they are added to the result_set, and the corresponding differences are removed from the list.\n\nReturn the Sorted Set:\n\nThe result_set is sorted and returned, which is the reconstructed original set."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-86",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-86",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.1 Sample Dataset",
    "text": "87.1 Sample Dataset\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-87",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-87",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.2 Sample Output",
    "text": "87.2 Sample Output\n15"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-83",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-83",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.3 Solution",
    "text": "87.3 Solution\ndef count_unrooted_binary_trees(n):\n    '''Returns the number of unrooted binary trees with n leaves.'''\n    # The total number is just the double factorial (2n - 5)!!\n    result = 1\n    for i in range(2 * n - 5, 1, -2):\n        result = (result * i) % 10**6\n    return result\n\ndef count_rooted_binary_trees(n):\n    '''Returns the number of rooted binary trees with n leaves.'''\n    # Can transform an unrooted binary tree into a rooted binary tree by inserting\n    # a node into any of its 2*n - 3 edges.\n    return (count_unrooted_binary_trees(n) * (2 * n - 3)) % 10**6\n\n# Read the input data.\ninput_data = \"\"\"\n4\n\"\"\"\n\nn = int(input_data.strip())\n\n# Get the number of unrooted binary trees.\ncount = count_rooted_binary_trees(n)\n\n# Print the answer.\nprint(count)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#count_unrooted_binary_treesn",
    "href": "posts/qmd/Rosalind_stronghold.html#count_unrooted_binary_treesn",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.4 count_unrooted_binary_trees(n)",
    "text": "87.4 count_unrooted_binary_trees(n)\n\nPurpose: This function calculates the number of possible unrooted binary trees with n leaves.\nLogic:\n\nThe number of unrooted binary trees with n leaves is given by the double factorial of (2n - 5), which is denoted as (2n - 5)!!.\nThe double factorial of a number is the product of all integers down to 1 that have the same parity (odd/even) as the starting number.\nFor example, if n = 4, (2n - 5) = 3, and the double factorial would be 3!! = 3.\nThe loop multiplies all odd numbers from 2n - 5 down to 3.\nThe result is taken modulo 10^6 to keep the number manageable and avoid overflow."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#count_rooted_binary_treesn",
    "href": "posts/qmd/Rosalind_stronghold.html#count_rooted_binary_treesn",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.5 count_rooted_binary_trees(n)",
    "text": "87.5 count_rooted_binary_trees(n)\n\nPurpose: This function calculates the number of possible rooted binary trees with n leaves.\nLogic:\n\nA rooted binary tree can be derived from an unrooted binary tree by adding a root to any of the 2n - 3 edges of the unrooted tree.\nTherefore, the number of rooted binary trees is the number of unrooted binary trees multiplied by (2n - 3).\nAgain, the result is taken modulo 10^6."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#how-it-works",
    "href": "posts/qmd/Rosalind_stronghold.html#how-it-works",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "87.6 How It Works",
    "text": "87.6 How It Works\n\nInput: The code reads the input value n from the string input_data. For example, if n = 4, the code calculates the number of binary trees for n = 4.\nExecution Flow:\n\ncount_rooted_binary_trees(n) is called with n = 4.\nInside this function, count_unrooted_binary_trees(n) is called.\nThe count_unrooted_binary_trees(n) function computes the product (2n - 5)!! modulo 10^6:\n\nFor n = 4, (2n - 5) = 3.\nThe loop runs from 3 to 1 (odd numbers only), resulting in 3!! = 3.\n\nThe result (3 in this case) is multiplied by (2 * n - 3) = 5, giving 3 * 5 = 15.\nThe final result is 15 % 10^6 = 15, which is returned and printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-87",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-87",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "88.1 Sample Dataset",
    "text": "88.1 Sample Dataset\n0.1 0.5 0.8"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-88",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-88",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "88.2 Sample Output",
    "text": "88.2 Sample Output\n0.18 0.5 0.32"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-84",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-84",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "88.3 Solution",
    "text": "88.3 Solution\n# Read the input data.\ninput_data = \"\"\"\n0.1 0.5 0.8\n\"\"\"\n\n# Convert input data to a list of floats.\nnumbers = [float(x) for x in input_data.strip().split()]\n\n# Calculate the desired values.\nresults = [2 * (x - x**2) for x in numbers]\n\n# Format the results to two decimal places and print.\nformatted_results = ' '.join(f\"{result:f}\" for result in results)\nprint(formatted_results)\n\nunformatted_results = ' '.join(f\"{result}\" for result in results)\nprint(unformatted_results) # only unformatted_results accepted to answer\nCalculate Results: - For each number in numbers, the code calculates a new value using the formula 2 * (x - x**2). This formula computes the difference between a number and its square, doubles it, and stores it in the results list. - The calculations for each number would be: - For 0.1: 2 * (0.1 - 0.1**2) = 0.18 - For 0.5: 2 * (0.5 - 0.5**2) = 0.50 - For 0.8: 2 * (0.8 - 0.8**2) = 0.32 - The resulting list is: [0.18, 0.50, 0.32]."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-88",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-88",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "89.1 Sample Dataset",
    "text": "89.1 Sample Dataset\ndog rat elephant mouse cat rabbit\n(rat,(dog,cat),(rabbit,(elephant,mouse)));\n(rat,(cat,dog),(elephant,(mouse,rabbit)));"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-89",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-89",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "89.2 Sample Output",
    "text": "89.2 Sample Output\n2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-85",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-85",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "89.3 Solution",
    "text": "89.3 Solution\nimport random\n\ndef get_fingerprints_list(taxa_dict, tree):\n    result = []\n    last_char = ''\n    taxon = ''\n    taxa_stack = []\n    \n    for char in tree:\n        if char in ('(', ',', ')'):\n            if last_char in ('(', ','):\n                if taxon:\n                    taxa_stack.append(taxa_dict[taxon])\n                    taxon = ''\n            elif last_char == ')':\n                t1 = taxa_stack.pop()\n                t2 = taxa_stack.pop()\n                result.append(t1 ^ t2)\n                taxa_stack.append(t1 ^ t2)\n            last_char = char\n        else:\n            if char != ' ':\n                taxon += char\n    \n    return result\n\ndef find_split_distance(taxa, tree1, tree2):\n    random.seed()  # Initialize random number generator\n    \n    taxa_dict = {taxon: random.randint(0, 2**12) for taxon in taxa}  # Adjusted bit range for randomness\n\n    fingerprints1 = sorted(get_fingerprints_list(taxa_dict, tree1))\n    fingerprints2 = sorted(get_fingerprints_list(taxa_dict, tree2))\n\n    shared_count = 0\n    i, j = len(fingerprints1) - 1, len(fingerprints2) - 1\n\n    while i &gt;= 0 and j &gt;= 0:\n        if fingerprints1[i] == fingerprints2[j]:\n            shared_count += 1\n            i -= 1\n            j -= 1\n        elif fingerprints1[i] &gt; fingerprints2[j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return 2 * (len(taxa) - 3) - 2 * shared_count\n\n# Input data\nsample_input = \"\"\"\ndog rat elephant mouse cat rabbit\n(rat,(dog,cat),(rabbit,(elephant,mouse)));\n(rat,(cat,dog),(elephant,(mouse,rabbit)));\n\"\"\"\ninput_lines = sample_input.strip().split(\"\\n\")\ntaxa = input_lines[0].split()\ntree1 = input_lines[1]\ntree2 = input_lines[2]\n\n# Compute the maximum split distance over 500 iterations\nmax_distance = max(find_split_distance(taxa, tree1, tree2) for _ in range(500))\n\nprint(max_distance)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-44",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-44",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "89.4 Explanation",
    "text": "89.4 Explanation\n\nFunction get_fingerprints_list(taxa_dict, tree):\n\nPurpose: Converts a tree in Newick format into a list of fingerprints based on a dictionary of taxon identifiers.\nHow It Works:\n\nIterates through characters in the tree string.\nHandles tree structure symbols (, ,, ) and taxon names.\nUses a stack (taxa_stack) to keep track of taxon fingerprints.\nWhen encountering ), it combines the fingerprints of the last two taxa in the stack using the XOR operation (^), which is a common way to handle such trees.\n\n\nFunction find_split_distance(taxa, tree1, tree2):\n\nPurpose: Computes the split distance between two trees.\nHow It Works:\n\nGenerates a random dictionary mapping taxa to unique integer fingerprints.\nCalculates fingerprints for both trees and sorts them.\nFinds the number of shared fingerprints between the two trees.\nComputes the split distance using the formula 2 * (n - 3) - 2 * shared_count, where n is the number of taxa.\n\n\nMain Execution:\n\nInput Handling: Reads and parses input data.\nComputation: Runs the find_split_distance function 500 times with random initialization to determine the maximum split distance.\nOutput: Prints the maximum split distance found."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-89",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-89",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "90.1 Sample Dataset",
    "text": "90.1 Sample Dataset\n4 6 2 1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-90",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-90",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "90.2 Sample Output",
    "text": "90.2 Sample Output\n0.772"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-86",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-86",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "90.3 Solution",
    "text": "90.3 Solution\nfrom scipy.special import comb\n\ndef calculate_initial_probabilities(N, m):\n    \"\"\"\n    Calculate the probabilities of having a given number of recessive alleles in the first generation.\n    \"\"\"\n    p_rec = 1 - m / (2.0 * N)\n    return [comb(2 * N, i) * p_rec ** i * (1 - p_rec) ** (2 * N - i) for i in range(1, 2 * N + 1)]\n\ndef update_probabilities(previous_p, N):\n    \"\"\"\n    Update the probabilities of recessive alleles for the next generation.\n    \"\"\"\n    new_p = []\n    for j in range(1, 2 * N + 1):\n        temp = [comb(2 * N, j) * (x / (2 * N)) ** j * (1 - x / (2 * N)) ** (2 * N - j) for x in range(1, 2 * N + 1)]\n        new_p.append(sum(temp[i] * previous_p[i] for i in range(len(temp))))\n    return new_p\n\ndef calculate_final_probability(N, m, g, k):\n    \"\"\"\n    Calculate the probability of observing at least k recessive alleles after g generations.\n    \"\"\"\n    previous_p = calculate_initial_probabilities(N, m)\n    \n    for _ in range(2, g + 1):\n        previous_p = update_probabilities(previous_p, N)\n    \n    return sum(previous_p[k - 1:])\n\n# Sample input\nsample_input = \"\"\"\n4 6 2 1\n\"\"\"\ninput_lines = sample_input.strip().split(\"\\n\")\nN, m, g, k = [int(x) for x in input_lines[0].split()]\n\n# Calculate and print the final probability\nfinal_prob = calculate_final_probability(N, m, g, k)\nprint(final_prob)"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-45",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-45",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "90.4 Explanation",
    "text": "90.4 Explanation\n\nFunction calculate_initial_probabilities(N, m):\n\nPurpose: Computes the probabilities of having different numbers of recessive alleles in the first generation.\nHow It Works: Uses the comb function to calculate binomial probabilities based on the initial proportion of recessive alleles.\n\nFunction update_probabilities(previous_p, N):\n\nPurpose: Updates the probabilities for subsequent generations.\nHow It Works: For each possible number of recessive alleles, calculates the new probabilities based on the previous generation’s probabilities and the binomial distribution.\n\nFunction calculate_final_probability(N, m, g, k):\n\nPurpose: Computes the final probability of observing at least k recessive alleles after g generations.\nHow It Works: Iterates through generations, updating probabilities each time. After g generations, it sums up the probabilities for having at least k recessive alleles.\n\nMain Execution:\n\nInput Handling: Reads and parses input data.\nComputation: Uses the functions to calculate the final probability.\nOutput: Prints the result."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-90",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-90",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "91.1 Sample Dataset",
    "text": "91.1 Sample Dataset\n(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;\n&gt;ostrich\nAC\n&gt;cat\nCA\n&gt;duck\nT-\n&gt;fly\nGC\n&gt;elephant\n-T\n&gt;pikachu\nAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-91",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-91",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "91.2 Sample Output",
    "text": "91.2 Sample Output\n8\n&gt;rat\nAC\n&gt;mouse\nTC\n&gt;dog\nAC\n&gt;hamster\nAT\n&gt;robot\nAC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-87",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-87",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "91.3 Solution",
    "text": "91.3 Solution\nfrom math import inf\nimport re\nfrom collections import defaultdict\n\ndef parse_newick(newick, directed=True):\n    newick = re.sub(\",,\", \",.,\", newick)\n    newick = re.sub(r\"\\(,\", \"(.,\", newick)\n    newick = re.sub(r\",\\)\", \",.)\", newick)\n    newick = re.sub(r\"\\(\\)\", \"(.)\", newick)\n    newick = re.sub(r\"^\\((.+)\\);\", r\"\\1\", newick)\n    m = re.finditer(r\"(\\(|[A-z_.]+|,|\\))\", newick)\n    tokens = [x.group() for x in m]\n\n    count = 0\n    node_stack = [\"0\"]\n    g = defaultdict(list)\n    i = len(tokens) - 1\n    while i &gt;= 0:\n        if tokens[i] == \"(\":\n            node_stack = node_stack[:-1]\n        elif tokens[i] == \")\":\n            if i + 1 &lt; len(tokens) and tokens[i + 1] not in \",)\":\n                node = tokens[i + 1]\n            else:\n                count += 1\n                node = str(count)\n            g[node_stack[-1]].append({\"n\": node, \"w\": 1})\n            if not directed:\n                g[node].append({\"n\": node_stack[-1], \"w\": 1})\n            node_stack += [node]\n        elif tokens[i] != \",\" and (i == 0 or tokens[i - 1] != \")\"):\n            if tokens[i] == \".\":\n                count += 1\n                tokens[i] = str(count)\n            g[node_stack[-1]].append({\"n\": tokens[i], \"w\": 1})\n            if not directed:\n                g[tokens[i]].append({\"n\": node_stack[-1], \"w\": 1})\n        i -= 1\n    return g\n\nclas Rec:\n    \"\"\"A simple FASTA record\"\"\"\n\n    def __init__(self, id, seq):\n        self.id = id\n        self.seq = seq\n\n    def __len__(self):\n        return len(self.seq)\n\ndef read_fasta(input_string):\n    lines = input_string.strip().split('\\n')\n    header, sequence = \"\", []\n    for line in lines:\n        if line.startswith(\"&gt;\"):\n            if sequence:\n                yield Rec(header, \"\".join(sequence))\n            header, sequence = line[1:], []\n        elif line.strip():  # 빈 줄 무시\n            sequence.append(line.strip())\n    if sequence:\n        yield Rec(header, \"\".join(sequence))\n\ndef nodes(graph):\n    s = list(graph.keys())\n    e = [y for v in graph.values() for y in v]\n    return set(s) | set(e)\n\n\n# return all leaves of a simple graph\ndef leaves(graph):\n    return nodes(graph) - set(graph.keys())\n\n\ndef extract_position(graph, seqs, pos):\n    chars = {}\n    for n in nodes(graph) - leaves(graph):\n        chars[n] = \"\"\n    for leaf in leaves(graph):\n        chars[leaf] = seqs[leaf][pos]\n    return chars\n\n\ndef traceback(skp, node, ind):\n    bases = [\"A\", \"C\", \"T\", \"G\", \"-\"]\n    chars = {}\n    chars[node] = bases[ind]\n    for k, v in skp[node][ind].items():\n        if k in skp:\n            chars = chars | traceback(skp, k, v)\n    return chars\n\n\ndef small_parsimony(graph, chars):\n    bases = [\"A\", \"C\", \"T\", \"G\", \"-\"]\n    sk = {}  # minimum parsimony score of the subtree over possible labels\n    skp = {}  # pointer to selected base for each child over possible labels\n    to_proces = nodes(graph)\n\n    # # initialise leaves\n    for leaf in leaves(graph):\n        sk[leaf] = [0 if chars[leaf] == c else inf for c in bases]\n        to_process.remove(leaf)\n\n    # iterate over available nodes till all are processed\n    while to_process:\n        for n in list(to_process):\n            if all(v in sk for v in graph[n]):\n                sk[n], skp[n] = [], []\n                for k in bases:\n                    tot = 0\n                    ptr = {}\n                    for d, sk_child in [(d, sk[d]) for d in graph[n]]:\n                        score = []\n                        for i, c in enumerate(bases):\n                            score += [sk_child[i] + (0 if c == k else 1)]\n                        tot += min(score)\n                        ptr[d] = score.index(min(score))\n                    skp[n] += [ptr]\n                    sk[n] += [tot]\n                to_process.remove(n)\n\n    # Recover sequence\n    node = \"0\"\n    score = min(sk[node])\n    return score, traceback(skp, node, sk[node].index(score))\n\ndef alph(tree, seqs, i):\n    # initialise sequences\n    for n in nodes(tree) - leaves(tree):\n        seqs[n] = \"\"\n\n    n = len(seqs[list(leaves(tree))[0]])\n    total_score = 0\n    for pos in range(n):\n        chars = extract_position(tree, seqs, pos)\n        score, tbchars = small_parsimony(tree, chars)\n        total_score += score\n        for k, v in tbchars.items():\n            seqs[k] += v\n\n    return total_score, seqs\n\ndef simplify_tree(graph):\n    return {k: [x[\"n\"] for x in v] for k, v in graph.items()}\n\n\nsample_input = \"\"\"\n(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;\n&gt;ostrich\nAC\n&gt;cat\nCA\n&gt;duck\nT-\n&gt;fly\nGC\n&gt;elephant\n-T\n&gt;pikachu\nAA\n\"\"\"\n\ntree = parse_newick(sample_input.strip().split('\\n')[0])\ntree = simplify_tree(tree)\n\nseqs = read_fasta('\\n'.join(sample_input.strip().split('\\n')[1:]))\nseqs = {x.id: x.seq for x in seqs}\ntotal_score, seqs = alph(tree, seqs, 1)\nprint(total_score)\nfor node in tree.keys():\n    if node != \"0\":\n        print(f\"&gt;{node}\")\n        print(seqs[node])"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#working-principle",
    "href": "posts/qmd/Rosalind_stronghold.html#working-principle",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "91.4 Working Principle",
    "text": "91.4 Working Principle\n\nThe code implements the Small Parsimony algorithm for phylogenetic tree reconstruction.\nIt starts by parsing a Newick format string representation of a tree using the parse_newick function. This function creates a graph representation of the tree.\nThe small_parsimony function is the core of the algorithm. It calculates the most parsimonious ancestral sequences for internal nodes of the tree.\nThe algorithm works bottom-up, starting from the leaves and moving towards the root:\n\nFor leaves, it initializes scores based on their known character states.\nFor internal nodes, it calculates scores for each possible base by considering the scores of its children.\n\nThe traceback function is used to reconstruct the most parsimonious ancestral sequences by traversing the tree from root to leaves.\nThe alph function applies the Small Parsimony algorithm to each position in the sequences, building up the full ancestral sequences.\nFinally, the code reads a sample input (in FASTA format), constructs the tree, applies the algorithm, and prints the results.\n\nThis algorithm aims to find the ancestral sequences that minimize the total number of mutations (changes) along the branches of the phylogenetic tree, based on the principle of maximum parsimony."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-91",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-91",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "92.1 Sample Dataset",
    "text": "92.1 Sample Dataset\nGATTACA\nTACTACTAC\nATTGAT\nGAAGA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-92",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-92",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "92.2 Sample Output",
    "text": "92.2 Sample Output\n7 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-88",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-88",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "92.3 Solution",
    "text": "92.3 Solution\ndef calculate_nxx(contigs, xx):\n    total_length = sum(len(contig) for contig in contigs)\n    target_length = total_length * xx / 100\n    \n    sorted_contigs = sorted(contigs, key=len, reverse=True)\n    cumulative_length = 0\n    \n    for contig in sorted_contigs:\n        cumulative_length += len(contig)\n        if cumulative_length &gt;= target_length:\n            return len(contig)\n    \n    return 0\n\n# Read input\nsample_input = \"\"\"\nGATTACA\nTACTACTAC\nATTGAT\nGAAGA\n\"\"\"\ncontigs = [line.strip() for line in sample_input.strip().split(\"\\n\")]\n\n# Calculate N50 and N75\nn50 = calculate_nxx(contigs, 50)\nn75 = calculate_nxx(contigs, 75)\n\n# Print results\nprint(f\"{n50} {n75}\")\nThe code calculates N50 and N75 values, which are measures used to asses the quality of DNA sequence assemblies."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#breaking-down-the-steps",
    "href": "posts/qmd/Rosalind_stronghold.html#breaking-down-the-steps",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "92.4 Breaking Down the Steps:",
    "text": "92.4 Breaking Down the Steps:\n\ncalculate_nxx(contigs, xx) Function:\n\nInput: A list of DNA sequences (contigs) and a percentage (xx like 50 for N50).\nOutput: The length of the sequence (contig) where the cumulative length reaches the specified percentage of the total length.\nHow It Works:\n\nStep 1: Add up the lengths of all sequences to get the total length.\nStep 2: Sort the sequences from longest to shortest.\nStep 3: Add lengths one by one from the sorted list until the sum reaches the specified percentage of the total length. The length of the last added sequence is the NXX value.\n\n\nMain Code:\n\nThe sample input is split into individual DNA sequences.\nThe code then calculates:\n\nN50: The sequence length where 50% of the total length is reached.\nN75: The sequence length where 75% of the total length is reached.\n\nFinally, it prints these N50 and N75 values."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-92",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-92",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "93.1 Sample Dataset",
    "text": "93.1 Sample Dataset\n100001\n000110\n111000\n100111"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-93",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-93",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "93.2 Sample Output",
    "text": "93.2 Sample Output\n000110\n100001\n100111"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-89",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-89",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "93.3 Solution",
    "text": "93.3 Solution\nfrom collections import defaultdict\n\n\ndef conflict(c1, c2):\n    # 모든 인덱스에 대해 한 번에 비교하여 충돌 여부 확인\n    return any((c1[i] == 1 and c2[i] == 0) or (c1[i] == 0 and c2[i] == 1) for i in range(len(c1)))\n\n\ndef conflicts(characters):\n    count = defaultdict(int)\n    for i in range(len(characters)):\n        for j in range(i + 1, len(characters)):\n            if conflict(characters[i], characters[j]):\n                count[i] += 1\n                count[j] += 1\n    return count\n\n\n# 입력 처리\nsample_input = \"\"\"\n100001\n000110\n111000\n100111\n\"\"\"\n\nlines = sample_input.strip().split(\"\\n\")\ncharacters = [[int(x) for x in ch] for ch in lines]\n\n# 충돌 계산\ncount = conflicts(characters)\n\n# 가장 많은 충돌을 가진 행 제거\nrm = max(count, key=count.get)\n\n# 결과 출력\nprint(*lines[:rm], *lines[rm + 1:], sep=\"\\n\")\nThe code identifies and removes the row from a set of binary sequences (like 100001) that has the most conflicts with other rows. A “conflict” is defined as one sequence having a 1 where another has a 0, and vice versa."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#breaking-down-the-steps-1",
    "href": "posts/qmd/Rosalind_stronghold.html#breaking-down-the-steps-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "93.4 Breaking Down the Steps:",
    "text": "93.4 Breaking Down the Steps:\n\nconflict(c1, c2) Function:\n\nPurpose: Check if two sequences (c1 and c2) conflict with each other.\nHow It Works:\n\nIt compares the two sequences at each index.\nIf at any index, one sequence has 1 and the other has 0, they are in conflict.\nThe function returns True if there is any conflict; otherwise, it returns False.\n\n\nconflicts(characters) Function:\n\nPurpose: Count how many conflicts each sequence has with all other sequences.\nHow It Works:\n\nIt compares each sequence with every other sequence.\nIf two sequences conflict, it increments a conflict counter for both sequences.\nIt returns a dictionary where the key is the sequence index, and the value is the number of conflicts that sequence has.\n\n\nMain Code:\n\nInput Processing:\n\nThe binary sequences are read and converted into lists of integers.\n\nConflict Counting:\n\nThe code uses the conflicts function to count how many conflicts each sequence has.\n\nRemoving the Most Conflicting Sequence:\n\nThe sequence with the highest number of conflicts is identified.\nThis sequence is then removed from the list.\n\nOutput:\n\nThe remaining sequences (with the most conflicting one removed) are printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-93",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-93",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "94.1 Sample Dataset",
    "text": "94.1 Sample Dataset\n17\n0.1 0.2 0.3"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-94",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-94",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "94.2 Sample Output",
    "text": "94.2 Sample Output\n1.7 3.4 5.1"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-90",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-90",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "94.3 Solution",
    "text": "94.3 Solution\nThe problem asks us to calculate the expected value of a binomial random variable given a population size \\(n\\) and an array \\(P\\) of allele frequencies. For each element \\(p\\) in the array \\(P\\), we need to compute the expected value \\(E(Bin(n, p))\\).\nFor a binomial random variable \\(Bin(n, p)\\), where: - \\(n\\) is the number of trials (in this case, the number of individuals in the population), - \\(p\\) is the probability of succes (or the allele frequency),\nThe expected value \\(E(Bin(n, p))\\) is calculated as:\n[ E(Bin(n, p)) = n p ]\nGiven that, the task is to compute this value for each probability in the array \\(P\\).We can implement this in Python as follows:\n# Sample Input\nsample_input = \"\"\"\n17\n0.1 0.2 0.3\n\"\"\"\n\n# Parse input\nlines = sample_input.strip().split('\\n')\nn = int(lines[0])\nP = list(map(float, lines[1].split()))\n\n# Calculate the expected values\nB = [n * p for p in P]\n\n# Print the result\nprint(' '.join(map(str, B)))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-46",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-46",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "94.4 Explanation",
    "text": "94.4 Explanation\n\nInput Parsing: We read the population size \\(n\\) and the array \\(P\\) of allele frequencies.\nComputation: For each \\(p\\) in \\(P\\), we compute \\(n \\times p\\) and store it in array \\(B\\).\nOutput: Finally, we print the values in \\(B\\) as a space-separated string."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-94",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-94",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "95.1 Sample Dataset",
    "text": "95.1 Sample Dataset\n4 3\n0 1 2"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-95",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-95",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "95.2 Sample Output",
    "text": "95.2 Sample Output\n0.0 -0.463935575821 -0.999509892866\n0.0 -0.301424998891 -0.641668367342\n0.0 -0.229066698008 -0.485798552456"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-91",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-91",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "95.3 Solution",
    "text": "95.3 Solution\nfrom scipy.special import comb\nimport numpy as np\n\ndef wright_fisher_genetic_drift(N, m, g):\n    \"\"\"\n    Calculate the log10 of the probability that no copies of the recessive allele remain in the population\n    after g generations, given an initial count of m recessive alleles.\n    \"\"\"\n    q = m / (2 * N)  # Initial dominant allele frequency\n    p = 1 - q  # Initial recessive allele frequency\n\n    # Initialize probability of exactly t recessive alleles in the first generation\n    prob = np.array([comb(2 * N, i) * (q ** i) * (p ** (2 * N - i)) for i in range(1, 2 * N + 1)])\n\n    # Iterate through generations\n    for _ in range(1, g):\n        # Calculate probabilities for the next generation\n        next_prob = np.zeros(2 * N)\n        for t in range(1, 2 * N + 1):\n            # Calculate probability of having exactly t recessive alleles in the current generation\n            prob_t = np.array([comb(2 * N, t) * ((i / (2 * N)) ** t) * ((1 - (i / (2 * N))) ** (2 * N - t)) for i in range(1, 2 * N + 1)])\n            next_prob[t - 1] = np.sum(prob_t * prob)\n        prob = next_prob\n\n    # Return the log10 of the probability of no recessive alleles remaining\n    return np.log10(1 - np.sum(prob))\n\ndef calculate_genetic_drift_matrix(N, m, A):\n    \"\"\"\n    Generate the matrix B where B[i, j] represents the common logarithm of the probability that after i generations,\n    no copies of the recessive allele for the j-th factor will remain in the population.\n    \"\"\"\n    k = len(A)\n    B = np.zeros((m, k))\n\n    for i in range(m):\n        for j in range(k):\n            B[i, j] = wright_fisher_genetic_drift(N, A[j], i + 1)\n\n    return B\n\n# Sample Input\nsample_input = \"\"\"\n4 3\n0 1 2\n\"\"\"\n\n# Parse input\nlines = sample_input.strip().split('\\n')\nN, m = map(int, lines[0].split())\nA = list(map(int, lines[1].split()))\n\n# Calculate the matrix B\nB = calculate_genetic_drift_matrix(N, m, A)\n\n# Print the results\nfor row in B:\n    print(' '.join(map(str, row)))\nThis code calculates the probability of losing all copies of a recessive allele in a population over several generations, based on the Wright-Fisher model of genetic drift. The result is a matrix where each entry tells us the likelihood (in logarithmic form) that no recessive alleles remain after a given number of generations."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#functions-and-their-roles",
    "href": "posts/qmd/Rosalind_stronghold.html#functions-and-their-roles",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "95.4 Functions and Their Roles",
    "text": "95.4 Functions and Their Roles\n\nwright_fisher_genetic_drift(N, m, g)\nPurpose: Calculates the probability of losing all recessive alleles after g generations, starting with m recessive alleles in a population of size N.\nHow It Works:\n\nInitial Setup:\n\nq is the frequency of dominant alleles.\np is the frequency of recessive alleles.\n\nFirst Generation:\n\nCalculate the probability of having exactly t recessive alleles in the first generation.\n\nSubsequent Generations:\n\nFor each generation, update the probabilities based on the previous generation.\n\nFinal Calculation:\n\nCompute the probability that no recessive alleles remain after g generations and return its log base 10.\n\n\ncalculate_genetic_drift_matrix(N, m, A)\nPurpose: Creates a matrix where each entry shows the log probability that no recessive alleles remain after a certain number of generations for various initial counts of recessive alleles.\nHow It Works:\n\nMatrix Initialization:\n\nB is initialized as a zero matrix.\n\nFilling the Matrix:\n\nFor each possible number of generations and each initial count of recessive alleles, calculate the log probability using wright_fisher_genetic_drift and store it in the matrix B."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#key-points-1",
    "href": "posts/qmd/Rosalind_stronghold.html#key-points-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "95.5 Key Points",
    "text": "95.5 Key Points\n\nwright_fisher_genetic_drift focuses on updating probabilities generation by generation.\ncalculate_genetic_drift_matrix builds a matrix from these probabilities for different scenarios."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-95",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-95",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "96.1 Sample Dataset",
    "text": "96.1 Sample Dataset\n&gt;Rosalind_49\nPRTEINS\n&gt;Rosalind_47\nPRTWPSEIN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-96",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-96",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "96.2 Sample Output",
    "text": "96.2 Sample Output\n8\nPRT---EINS\nPRTWPSEIN-"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-92",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-92",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "96.3 Solution",
    "text": "96.3 Solution\n# BLOSUM62 matrix as a string\nblosum62_str = \"\"\"\nA  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y\nA  4  0 -2 -1 -2  0 -2 -1 -1 -1 -1 -2 -1 -1 -1  1  0  0 -3 -2\nC  0  9 -3 -4 -2 -3 -3 -1 -3 -1 -1 -3 -3 -3 -3 -1 -1 -1 -2 -2\nD -2 -3  6  2 -3 -1 -1 -3 -1 -4 -3  1 -1  0 -2  0 -1 -3 -4 -3\nE -1 -4  2  5 -3 -2  0 -3  1 -2 -2  0 -1  2  0  0 -1 -2 -3 -2\nF -2 -2 -3 -3  6 -3 -1  0 -3  0  0 -3 -4 -3 -3 -2 -2 -1  1  3\nG  0 -3 -1 -2 -3  6 -2 -4 -2 -4 -3  0 -2 -2 -3  0 -2 -3 -2 -3\nH -2 -3 -1  0 -1 -2  8 -3 -1 -3 -2  1 -2  0  0 -1 -2 -3 -2  2\nI -1 -1 -3 -3  0 -4 -3  4 -3  2  1 -3 -3 -3 -3 -2 -1  3 -3 -1\nK -1 -3 -1  1 -3 -2 -1 -3  5 -2 -1  0 -1  1  2  0 -1 -2 -3 -2\nL -1 -1 -4 -2  0 -4 -3  2 -2  4  2 -3 -3 -2 -2 -2 -1  1 -2 -1\nM -1 -1 -3 -2  0 -3 -2  1 -1  2  5 -2 -2  0 -1 -1 -1  1 -1 -1\nN -2 -3  1  0 -3  0  1 -3  0 -3 -2  6 -2  0  0  1  0 -3 -4 -2\nP -1 -3 -1 -1 -4 -2 -2 -3 -1 -3 -2 -2  7 -1 -2 -1 -1 -3 -4 -3\nQ -1 -3  0  2 -3 -2  0 -3  1 -2  0  0 -1  5  1  0 -1 -2 -2 -1\nR -1 -3 -2  0 -3 -3  0 -3  2 -2 -1  0 -2  1  5 -1 -1 -3 -3 -2\nS  1 -1  0  0 -2  0 -1 -2  0 -2 -1  1 -1  0 -1  4  1 -2 -3 -2\nT  0 -1 -1 -1 -2 -2 -2 -1 -1 -1 -1  0 -1 -1 -1  1  5  0 -2 -2\nV  0 -1 -3 -2 -1 -3 -3  3 -2  1  1 -3 -3 -2 -3 -2  0  4 -3 -1\nW -3 -2 -4 -3  1 -2 -2 -3 -3 -2 -1 -4 -4 -2 -3 -3 -2 -3 11  2\nY -2 -2 -3 -2  3 -3  2 -1 -2 -1 -1 -2 -3 -1 -2 -2 -2 -1  2  7\n\"\"\"\n\ndef parse_blosum62(matrix_str):\n    \"\"\"Parse the BLOSUM62 matrix from a string into a dictionary.\"\"\"\n    lines = matrix_str.strip().split('\\n')\n    headers = lines[0].split()\n    matrix = {}\n    for line in lines[1:]:\n        values = line.split()\n        row = values[0]\n        scores = list(map(int, values[1:]))\n        matrix.update({(row, col): score for col, score in zip(headers, scores)})\n    return matrix\n\ndef parse_fasta(data):\n    \"\"\"Parse FASTA format data into a list of sequences.\"\"\"\n    sequences = []\n    seq = \"\"\n    for line in data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if seq:\n                sequences.append(seq)\n                seq = \"\"\n        else:\n            seq += line.strip()\n    if seq:\n        sequences.append(seq)\n    return sequences\n\ndef match_score(scoring_matrix, a, b):\n    \"\"\"Return the score from the scoring matrix, defaulting to 0 if not found.\"\"\"\n    return scoring_matrix.get((a, b), 0)\n\ndef global_align_with_affine(s, t, scores, gap, gap_e):\n    \"\"\"Perform global alignment with affine gap penalties.\"\"\"\n    m, n = len(s), len(t)\n    # Initialize matrices\n    M = [[0] * (n + 1) for _ in range(m + 1)]\n    X = [[0] * (n + 1) for _ in range(m + 1)]\n    Y = [[0] * (n + 1) for _ in range(m + 1)]\n    traceM = [[0] * (n + 1) for _ in range(m + 1)]\n    traceX = [[0] * (n + 1) for _ in range(m + 1)]\n    traceY = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initialize edges\n    for i in range(1, m + 1):\n        M[i][0] = gap + gap_e * (i - 1)\n        X[i][0] = Y[i][0] = float('-inf')\n    for j in range(1, n + 1):\n        M[0][j] = gap + gap_e * (j - 1)\n        X[0][j] = Y[0][j] = float('-inf')\n\n    # Fill matrices\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            costX = [M[i-1][j] + gap, X[i-1][j] + gap_e]\n            X[i][j] = max(costX)\n            traceX[i][j] = costX.index(X[i][j])\n            \n            costY = [M[i][j-1] + gap, Y[i][j-1] + gap_e]\n            Y[i][j] = max(costY)\n            traceY[i][j] = costY.index(Y[i][j])\n\n            costM = [M[i-1][j-1] + match_score(scores, s[i-1], t[j-1]), X[i][j], Y[i][j]]\n            M[i][j] = max(costM)\n            traceM[i][j] = costM.index(M[i][j])\n    \n    # Get maximum score and initialize aligned strings\n    max_score = M[m][n]\n    s_align, t_align = s, t\n\n    # Traceback\n    i, j = m, n\n    while i &gt; 0 or j &gt; 0:\n        traceback = max([(X[i][j], 0), (Y[i][j], 1), (M[i][j], 2)], key=lambda x: x[0])[1]\n        if traceback == 0:\n            t_align = t_align[:j] + '-' + t_align[j:]\n            i -= 1\n        elif traceback == 1:\n            s_align = s_align[:i] + '-' + s_align[i:]\n            j -= 1\n        elif traceback == 2:\n            if traceM[i][j] == 0:\n                traceback = 0\n            elif traceM[i][j] == 1:\n                traceback = 1\n            i -= 1\n            j -= 1\n\n    # Handle leading gaps\n    s_align = '-' * j + s_align\n    t_align = '-' * i + t_align\n\n    return str(max_score), s_align, t_align\n\n# Sample dataset in FASTA format\nsample_input = \"\"\"\n&gt;Rosalind_49\nPRTEINS\n&gt;Rosalind_47\nPRTWPSEIN\n\"\"\"\n\n# Parse the FASTA input to get the sequences\nsequences = parse_fasta(sample_input)\ns, t = sequences[0], sequences[1]\n\n# Parse the BLOSUM62 matrix\nblosum62 = parse_blosum62(blosum62_str)\n\n# Perform global alignment with affine gap penalties\nalignment = global_align_with_affine(s, t, blosum62, -11, -1)\n\nprint('\\n'.join(alignment))\nThis Python code performs global sequence alignment between two protein sequences using the BLOSUM62 substitution matrix and affine gap penalties. The alignment proces is a common technique in bioinformatics to compare two sequences and find the best way to align them by inserting gaps and matching characters."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-4",
    "href": "posts/qmd/Rosalind_stronghold.html#detailed-explanation-4",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "96.4 Detailed Explanation",
    "text": "96.4 Detailed Explanation\n\nBLOSUM62 Matrix as a String:\n\nThe BLOSUM62 matrix, a commonly used substitution matrix in bioinformatics, is provided as a multiline string. It contains scores representing how likely it is for each amino acid pair to substitute for each other.\n\nparse_blosum62(matrix_str) Function:\n\nPurpose: Converts the BLOSUM62 string into a dictionary for easier lookup.\nHow It Works:\n\nThe string is split into lines and then into individual elements.\nThe first line contains the amino acid headers.\nEach subsequent line contains scores for substituting one amino acid with others.\nA dictionary is created where each key is a tuple of two amino acids, and the value is the corresponding substitution score.\n\n\nparse_fasta(data) Function:\n\nPurpose: Parses sequences from the FASTA format, which is a standard text-based format for representing sequences.\nHow It Works:\n\nThe function reads the input line by line.\nLines starting with &gt; indicate sequence headers, which are ignored.\nSequence data is collected into a list of sequences.\n\n\nmatch_score(scoring_matrix, a, b) Function:\n\nPurpose: Retrieves the substitution score for a pair of amino acids from the BLOSUM62 matrix.\nHow It Works:\n\nIt looks up the score for the amino acid pair (a, b) in the dictionary. If the pair is not found, it returns 0.\n\n\nglobal_align_with_affine(s, t, scores, gap, gap_e) Function:\n\nPurpose: Performs global alignment of two sequences using affine gap penalties.\nHow It Works:\n\nInitialization: Three matrices (M, X, Y) are used to keep track of the scores for matches, gaps in one sequence, and gaps in the other sequence, respectively. traceM, traceX, and traceY track the path for traceback.\nMatrix Filling: The matrices are filled in a nested loop:\n\nM[i][j]: Maximum score considering a match or mismatch.\nX[i][j]: Maximum score considering a gap in sequence t.\nY[i][j]: Maximum score considering a gap in sequence s.\n\nTraceback: After filling the matrices, the function traces back from the last cell to reconstruct the aligned sequences, inserting gaps where needed.\nThe traceback ensures that the sequences are aligned optimally according to the scoring matrix and gap penalties.\n\n\nSample Input and Execution:\n\nSample Input: Two sequences (PRTEINS and PRTWPSEIN) are provided in FASTA format.\nExecution:\n\nThe sequences are parsed from the input.\nThe BLOSUM62 matrix is parsed.\nGlobal alignment with affine gap penalties is performed using the parsed sequences and matrix.\nThe alignment result, including the score and the aligned sequences, is printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-96",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-96",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "97.1 Sample Dataset",
    "text": "97.1 Sample Dataset\nCAG\nAGT\nGTT\nTTT\nTTG\nTGG\nGGC\nGCG\nCGT\nGTT\nTTC\nTCA\nCAA\nAAT\nATT\nTTC\nTCA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-97",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-97",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "97.2 Sample Output",
    "text": "97.2 Sample Output\nCAGTTCAATTTGGCGTT\nCAGTTCAATTGGCGTTT\nCAGTTTCAATTGGCGTT\nCAGTTTGGCGTTCAATT\nCAGTTGGCGTTCAATTT\nCAGTTGGCGTTTCAATT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-93",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-93",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "97.3 Solution",
    "text": "97.3 Solution\nclas DeBruijnGraph:\n    clas Node:\n        def __init__(self, kmer):\n            self.kmer = kmer\n            self.neighbors = []\n            self.in_degree = 0\n            self.out_degree = 0\n\n    def __init__(self, reads):\n        self.graph = {}\n        self.start_kmer = reads[0]\n\n        for read in reads:\n            left_kmer, right_kmer = read[:-1], read[1:]\n            left_hash, right_hash = hash(left_kmer), hash(right_kmer)\n\n            left_node = self.graph.setdefault(left_hash, self.Node(left_kmer))\n            right_node = self.graph.setdefault(right_hash, self.Node(right_kmer))\n\n            left_node.neighbors.append(right_node)\n            left_node.out_degree += 1\n            right_node.in_degree += 1\n\n    def circular_string(self):\n        potential_starts = [node for node in self.graph.values() if node.out_degree &gt; 1]\n        assert potential_starts, \"No potential start nodes found!\"\n\n        contigs = []\n        strings = set()\n        k = len(self.start_kmer) - 1\n\n        def dfs(node, sequence):\n            if node.out_degree &gt; 1:\n                contigs.append(sequence + node.kmer[-1])\n            else:\n                dfs(node.neighbors[0], sequence + node.kmer[-1])\n\n        for start_node in potential_starts:\n            for neighbor in start_node.neighbors:\n                dfs(neighbor, start_node.kmer)\n\n        def find_circular_strings(current_sequence, accumulated_string, used_contigs):\n            if len(used_contigs) == len(contigs):\n                strings.add(accumulated_string)\n            else:\n                for idx in set(range(len(contigs))).difference(used_contigs):\n                    if not current_sequence.endswith(contigs[idx][:k]):\n                        continue\n                    find_circular_strings(contigs[idx], accumulated_string + contigs[idx][:-k], used_contigs + (idx,))\n\n        for i, contig in enumerate(contigs):\n            if contig.startswith(self.start_kmer):\n                find_circular_strings(contig, contig[:-k], (i,))\n                break\n\n        return strings\n\n\n# Sample input\nsample_input = \"\"\"\nCAG\nAGT\nGTT\nTTT\nTTG\nTGG\nGGC\nGCG\nCGT\nGTT\nTTC\nTCA\nCAA\nAAT\nATT\nTTC\nTCA\n\"\"\"\n\nreads = sample_input.strip().split(\"\\n\")\ngraph = DeBruijnGraph(reads)\nprint(*graph.circular_string(), sep='\\n')"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-47",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-47",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "97.4 Explanation",
    "text": "97.4 Explanation\n\nGraph Construction: The code constructs a De Bruijn graph using the provided k-mers (reads). Each k-mer’s prefix (all but the last character) and suffix (all but the first character) are treated as nodes in the graph. The graph edges represent transitions from one k-mer to another based on these prefixes and suffixes.\nNode Structure: Each node in the graph stores its k-mer, its neighbors (other nodes it can connect to), and its in-degree and out-degree (how many edges enter and leave the node).\nGraph Traversal: The code identifies nodes with more than one outgoing edge (out_degree &gt; 1) as potential starting points for generating circular sequences (possible cyclic paths in the graph).\nDepth-First Search (DFS): The code uses DFS to traverse from these potential starting nodes to build “contigs,” which are sequences representing possible paths through the graph.\nGenerating Circular Strings: After building contigs, the code recursively combines these contigs to generate complete circular strings that encompas all the original k-mers.\nOutput: The final set of circular strings that represent possible solutions is printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-97",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-97",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "98.1 Sample Dataset",
    "text": "98.1 Sample Dataset\n&gt;Rosalind_54\nGCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC\n&gt;Rosalind_46\nGCCGTCAGGCTGGTGTCCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-98",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-98",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "98.2 Sample Output",
    "text": "98.2 Sample Output\n5\nACCATAAGCCCTACGTG-CCG\nGCCGTCAGGC-TG-GTGTCCG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-94",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-94",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "98.3 Solution",
    "text": "98.3 Solution\nfrom typing import List, Tuple\n\nGAP_PENALTY = 1\nMATCH_SCORE = 1\nMISMATCH_PENALTY = 1\n\ndef parse_fasta(data: str) -&gt; List[str]:\n    \"\"\"Parse FASTA format data into a list of sequences.\"\"\"\n    sequences = []\n    current_seq = []\n    for line in data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_seq:\n                sequences.append(''.join(current_seq))\n                current_seq = []\n        else:\n            current_seq.append(line.strip())\n    if current_seq:\n        sequences.append(''.join(current_seq))\n    return sequences\n\ndef initialize_dp_matrix(m: int, n: int) -&gt; List[List[int]]:\n    \"\"\"Initialize the dynamic programming matrix.\"\"\"\n    return [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\ndef fill_dp_matrix(c: str, d: str, dp: List[List[int]]) -&gt; None:\n    \"\"\"Fill the dynamic programming matrix.\"\"\"\n    for i in range(len(c) + 1):\n        for j in range(1, len(d) + 1):\n            ans = float('-inf')\n            if i &gt; 0:\n                ans = max(ans, dp[i - 1][j] - GAP_PENALTY)\n            if j &gt; 0:\n                ans = max(ans, dp[i][j - 1] - GAP_PENALTY)\n            if i &gt; 0 and j &gt; 0:\n                if c[i - 1] == d[j - 1]:\n                    ans = max(ans, dp[i - 1][j - 1] + MATCH_SCORE)\n                else:\n                    ans = max(ans, dp[i - 1][j - 1] - MISMATCH_PENALTY)\n            dp[i][j] = ans\n\ndef find_best_score(dp: List[List[int]], m: int, n: int) -&gt; Tuple[int, int, int]:\n    \"\"\"Find the best score and its position in the DP matrix.\"\"\"\n    score = float('-inf')\n    bi, bj = -1, -1\n    for i in range(m + 1):\n        if score &lt; dp[i][n]:\n            score = dp[i][n]\n            bi, bj = i, n\n    return int(score), bi, bj\n\ndef backtrack(c: str, d: str, dp: List[List[int]], bi: int, bj: int) -&gt; Tuple[str, str]:\n    \"\"\"Backtrack to find the aligned sequences.\"\"\"\n    s1, s2 = [], []\n    while bj &gt; 0:\n        if bi &gt; 0 and dp[bi - 1][bj] - GAP_PENALTY == dp[bi][bj]:\n            s1.append(c[bi - 1])\n            s2.append('-')\n            bi -= 1\n        elif bj &gt; 0 and dp[bi][bj - 1] - GAP_PENALTY == dp[bi][bj]:\n            s1.append('-')\n            s2.append(d[bj - 1])\n            bj -= 1\n        else:\n            s1.append(c[bi - 1])\n            s2.append(d[bj - 1])\n            bi -= 1\n            bj -= 1\n    return ''.join(s1[::-1]), ''.join(s2[::-1])\n\nsample_input = \"\"\"\n&gt;Rosalind_54\nGCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC\n&gt;Rosalind_46\nGCCGTCAGGCTGGTGTCCG\n\"\"\"\n\nsequences = parse_fasta(sample_input)\nc, d = sequences\n\ndp = initialize_dp_matrix(len(c), len(d))\nfill_dp_matrix(c, d, dp)\n\nscore, bi, bj = find_best_score(dp, len(c), len(d))\naligned_c, aligned_d = backtrack(c, d, dp, bi, bj)\n\nprint(score)\nprint(aligned_c)\nprint(aligned_d)\nThis code performs a sequence alignment between two DNA sequences using a dynamic programming approach. Sequence alignment is a method used in bioinformatics to compare two sequences and determine the best match between them, accounting for matches, mismatches, and gaps."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#how-the-code-works",
    "href": "posts/qmd/Rosalind_stronghold.html#how-the-code-works",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "98.4 How the Code Works",
    "text": "98.4 How the Code Works\n\nConstants:\n\nGAP_PENALTY: Penalty for introducing a gap (insertion/deletion) in the sequence alignment.\nMATCH_SCORE: Score for matching characters between the two sequences.\nMISMATCH_PENALTY: Penalty for mismatched characters.\n\nFunctions:\n\nparse_fasta(data: str) -&gt; List[str]:\n\nPurpose: Converts a FASTA format string into a list of sequences.\nHow It Works: The function reads the input data, ignoring lines starting with ‘&gt;’ (which are headers), and combines the remaining lines into sequences.\n\ninitialize_dp_matrix(m: int, n: int) -&gt; List[List[int]]:\n\nPurpose: Initializes a matrix for dynamic programming (DP) with dimensions (m+1) x (n+1), where m and n are the lengths of the two sequences.\nHow It Works: Creates a 2D list filled with zeros.\n\nfill_dp_matrix(c: str, d: str, dp: List[List[int]]) -&gt; None:\n\nPurpose: Fills the DP matrix with scores based on the alignment of sequences c and d.\nHow It Works:\n\nIterates over all possible alignments of c and d.\nFor each position, it calculates the best score considering three possible moves: match/mismatch, insertion, and deletion.\nThe score is updated based on whether characters match or mismatch, and whether gaps are introduced.\n\n\nfind_best_score(dp: List[List[int]], m: int, n: int) -&gt; Tuple[int, int, int]:\n\nPurpose: Finds the best alignment score and its position in the DP matrix.\nHow It Works:\n\nScans the last column of the DP matrix to find the highest score and its position. This represents the optimal alignment score.\n\n\nbacktrack(c: str, d: str, dp: List[List[int]], bi: int, bj: int) -&gt; Tuple[str, str]:\n\nPurpose: Traces back through the DP matrix to construct the aligned sequences based on the best alignment score.\nHow It Works:\n\nStarting from the best score position, it determines the path that led to this score, reconstructing the aligned sequences with gaps (-) where necessary.\n\n\n\nExecution:\n\nSample Input: The FASTA input contains two sequences labeled Rosalind_54 and Rosalind_46.\nProcessing:\n\nThe sequences are extracted using parse_fasta.\nA DP matrix is initialized using initialize_dp_matrix.\nThe matrix is filled with alignment scores using fill_dp_matrix.\nThe best alignment score and position are found with find_best_score.\nThe best alignment itself is reconstructed using backtrack.\n\nOutput:\n\nThe alignment score and the two aligned sequences are printed."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-98",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-98",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "99.1 Sample Dataset",
    "text": "99.1 Sample Dataset\n&gt;Rosalind_35\nATAGATA\n&gt;Rosalind_5\nACAGGTA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-99",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-99",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "99.2 Sample Output",
    "text": "99.2 Sample Output\n3\n-139"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-95",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-95",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "99.3 Solution",
    "text": "99.3 Solution\nfrom typing import List, Tuple\n\ndef parse_fasta(data: str) -&gt; List[str]:\n    \"\"\"Parse FASTA format data into a list of sequences.\"\"\"\n    sequences = []\n    current_seq = []\n    for line in data.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_seq:\n                sequences.append(''.join(current_seq))\n                current_seq = []\n        else:\n            current_seq.append(line.strip())\n    if current_seq:\n        sequences.append(''.join(current_seq))\n    return sequences\n\ndef initialize_score_matrix(rows: int, cols: int) -&gt; List[List[int]]:\n    \"\"\"Initialize the score matrix with gap penalties.\"\"\"\n    S = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(1, rows):\n        S[i][0] = -i\n    for j in range(1, cols):\n        S[0][j] = -j\n    return S\n\ndef calculate_cell_score(S: List[List[int]], i: int, j: int, s: str, t: str) -&gt; int:\n    \"\"\"Calculate the score for a cell in the alignment matrix.\"\"\"\n    match_score = 1 if s[i-1] == t[j-1] else -1\n    return max(\n        S[i-1][j-1] + match_score,\n        S[i-1][j] - 1,\n        S[i][j-1] - 1\n    )\n\ndef global_alignment(s: str, t: str) -&gt; List[List[int]]:\n    \"\"\"Perform global alignment and return the score matrix.\"\"\"\n    rows, cols = len(s) + 1, len(t) + 1\n    S = initialize_score_matrix(rows, cols)\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            S[i][j] = calculate_cell_score(S, i, j, s, t)\n\n    return S\n\ndef align_to_symbols(s: str, t: str) -&gt; Tuple[int, int]:\n    \"\"\"Compute the maximum alignment score and sum of all alignment scores.\"\"\"\n    prefix_matrix = global_alignment(s, t)\n    suffix_matrix = global_alignment(s[::-1], t[::-1])\n\n    total = 0\n    best = -(len(s) + len(t))\n\n    for i in range(len(s)):\n        for j in range(len(t)):\n            match_score = 1 if s[i] == t[j] else -1\n            score = prefix_matrix[i][j] + match_score + suffix_matrix[len(s)-1-i][len(t)-1-j]\n            total += score\n            best = max(best, score)\n\n    return best, total\n\nsample_input = \"\"\"\n&gt;Rosalind_35\nATAGATA\n&gt;Rosalind_5\nACAGGTA\n\"\"\"\n\nsequences = parse_fasta(sample_input)\nif len(sequences) != 2:\n    raise ValueError(\"Expected exactly two sequences in the input.\")\n\ns, t = sequences\nbest_score, total_score = align_to_symbols(s, t)\n\nprint(f\"{best_score}\")\nprint(f\"{total_score}\")"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#code-breakdown",
    "href": "posts/qmd/Rosalind_stronghold.html#code-breakdown",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "99.4 Code Breakdown",
    "text": "99.4 Code Breakdown\n\nParsing FASTA Format (parse_fasta function):\n\nPurpose: Extracts DNA sequences from a FASTA formatted string.\nHow It Works:\n\nInput: A string with lines that include sequences starting with &gt; (sequence headers) and followed by sequence data.\nProcess:\n\nIt reads the input line by line.\nWhen it encounters a line starting with &gt;, it recognizes it as a header and finishes the current sequence.\nIt collects sequence data lines and joins them into a single sequence string.\nIt returns a list of sequences.\n\n\nOutput: A list of DNA sequences.\n\nInitializing the Score Matrix (initialize_score_matrix function):\n\nPurpose: Set up a matrix to track alignment scores between two sequences, initializing with gap penalties.\nHow It Works:\n\nInput: Number of rows (sequence length + 1) and columns (sequence length + 1).\nProcess:\n\nCreates a matrix of zeros.\nFills the first row and column with penalties for gaps (negative values), representing the cost of inserting gaps.\n\n\nOutput: A score matrix with initialized gap penalties.\n\nCalculating Cell Scores (calculate_cell_score function):\n\nPurpose: Determine the alignment score for a specific cell in the matrix.\nHow It Works:\n\nInput: Current cell indices, the score matrix, and the sequences being aligned.\nProcess:\n\nCalculates the score for matching or mismatching characters, and the penalty for gaps.\nTakes the maximum score among possible scenarios: match/mismatch, gap in one sequence, or gap in the other sequence.\n\n\nOutput: The best score for the current cell.\n\nGlobal Alignment (global_alignment function):\n\nPurpose: Create and fill a score matrix for global alignment of two sequences.\nHow It Works:\n\nInput: Two sequences.\nProcess:\n\nInitializes the score matrix with gap penalties.\nFills the matrix using calculate_cell_score for each cell.\n\n\nOutput: A filled score matrix representing global alignment scores.\n\nAligning to Symbols (align_to_symbols function):\n\nPurpose: Calculate the best alignment score and total score sum by considering both the original and reversed sequences.\nHow It Works:\n\nInput: Two sequences.\nProcess:\n\nComputes the alignment score matrices for both the original sequences and their reversed versions.\nCalculates scores by combining the prefix (forward alignment) and suffix (reverse alignment) matrices.\nFinds the best score and sums all scores from the matrix.\n\n\nOutput: The highest alignment score and the total sum of all scores."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-99",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-99",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "100.1 Sample Dataset",
    "text": "100.1 Sample Dataset\n2\nACGTAG\nACGGATCGGCATCGT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-100",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-100",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "100.2 Sample Output",
    "text": "100.2 Sample Output\n1 4\n1 5\n1 6"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-96",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-96",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "100.3 Solution",
    "text": "100.3 Solution\nimport sys\nimport re\nimport multiprocessing as mp\n\ndef get_seeds(x, seq, k):\n    seed_size = len(x) // (k + 1)\n    for s1 in range(0, len(x) - seed_size + 1, seed_size):\n        px = (s1, s1 + seed_size)\n        seed = x[px[0] : px[1]]\n        for m in re.finditer(rf\"(?=({seed}))\", seq):\n            ps = (m.span()[0], m.span()[0] + seed_size)\n            yield (px, ps)\n\ndef process_seed(args):\n    def extend_fwd(i, j, score):\n        if (i, j, score) not in seen:\n            seen.update([(i, j, score)])\n            if score &lt;= k:\n                if i == len(x) - 1:\n                    yield i, j, score\n                if i + 1 &lt; len(x):\n                    yield from extend_fwd(i + 1, j, score + 1)\n                if j + 1 &lt; len(seq):\n                    yield from extend_fwd(i, j + 1, score + 1)\n                if i + 1 &lt; len(x) and j + 1 &lt; len(seq):\n                    yield from extend_fwd(\n                        i + 1, j + 1, score + int(x[i + 1] != seq[j + 1])\n                    )\n\n    def extend_rev(i, j, score):\n        if (i, j, score) not in seen:\n            seen.update([(i, j, score)])\n            if score &lt;= k:\n                if i == 0:\n                    yield i, j, score\n                if i - 1 &gt;= 0:\n                    yield from extend_rev(i - 1, j, score + 1)\n                if j - 1 &gt;= 0:\n                    yield from extend_rev(i, j - 1, score + 1)\n                if i - 1 &gt;= 0 and j - 1 &gt;= 0:\n                    yield from extend_rev(\n                        i - 1, j - 1, score + int(x[i - 1] != seq[j - 1])\n                    )\n\n    print(\".\", end=\"\", file=sys.stderr)\n    sys.stderr.flush()\n    sys.setrecursionlimit(10000)\n    seed, k, x, seq = args\n    xcoord, seqcoord = seed\n    res = set()\n    seen = set()\n    fwds = list(extend_fwd(xcoord[1] - 1, seqcoord[1] - 1, 0))\n    if not fwds:\n        return set()\n    seen = set()\n    revs = list(extend_rev(xcoord[0], seqcoord[0], 0))\n    if not revs:\n        return set()\n    for i0, j0, s0 in revs:\n        for i1, j1, s1 in fwds:\n            if s0 + s1 &lt;= k:\n                res.add((j0 + 1, j1 - j0 + 1))\n    return res\n\n# Sample input\nsample_input = \"\"\"\n1\nACGTAG\nGGACGATAGGTAAAGTAGTAGCGACGTAGG\n\"\"\"\n\nk, x, seq = sample_input.strip().split(\"\\n\")\nk = int(k)\nseeds = list(get_seeds(x, seq, k))\nprint(f\"found {len(seeds)} seeds\", file=sys.stderr)\n\npool = mp.Pool(mp.cpu_count())\nargs = ([seed, k, x, seq] for seed in seeds)\nres = pool.map(process_seed, args)\nres = set().union(*res)\n\n# 결과 출력\nfor start, length in sorted(list(res)):\n    print(f\"{start} {length}\")\n\n\n\n\n\n\nNote\n\n\n\n해당 문제는 계산량이 많아 파이썬을 사용하는 것이 적절하지 않습니다. 그래도 위 코드를 download dataset 에 적용해 실행한 결과 1 분 45 초 정도가 소요되어 통과할 수 있었습니다.(사용한 CPU: 13th Gen Intel i9-13900F (32) @ 5.3GHz)\n\n\nThis Python code is designed to find approximate matches of a short DNA sequence x within a longer DNA sequence seq. It does this by breaking down the problem into smaller “seed” sequences and then extending those seeds to find matches, even if there are a few mismatches allowed (controlled by the parameter k)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#overview-of-the-code",
    "href": "posts/qmd/Rosalind_stronghold.html#overview-of-the-code",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "100.4 Overview of the Code",
    "text": "100.4 Overview of the Code\n\nSeeding (get_seeds function):\n\nThe get_seeds function divides the sequence x into smaller overlapping segments called “seeds.”\nFor each seed, it searches within the longer sequence seq to find exact matches of the seed.\nIt returns the positions in both x and seq where these seeds match.\n\nExtending Seeds (process_seed function):\n\nThis function takes a seed and tries to extend it in both directions (forward and backward) to see if a longer match can be found between x and seq, even with up to k mismatches.\nTwo helper functions, extend_fwd and extend_rev, recursively extend the seed by comparing characters in x and seq while keeping track of mismatches.\nThe results are stored as starting positions and lengths of the matching segments.\n\nParallel Processing:\n\nThe script uses multiprocessing to speed up the search by running the seed extension proces in parallel acros multiple CPU cores.\nEach seed is processed independently, and the results are combined.\n\nResult Compilation:\n\nThe final matching segments are collected, and the unique results are sorted and printed as the start position and length of each matching segment in seq.\n\n\n\nThe code searches for parts of a short DNA sequence (x) within a longer DNA sequence (seq), allowing for a small number of mismatches (k).\nIt does this by first finding small exact matches (seeds) and then extending these matches to find longer sequences with few mismatches.\nThe proces is parallelized to improve performance, especially when dealing with large DNA sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-100",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-100",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "101.1 Sample Dataset",
    "text": "101.1 Sample Dataset\n&gt;Rosalind_54\nCTAAGGGATTCCGGTAATTAGACAG\n&gt;Rosalind_45\nATAGACCATATGTCAGTGACTGTGTAA"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-101",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-101",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "101.2 Sample Output",
    "text": "101.2 Sample Output\n1\nATTAGAC-AG\nAT-AGACCAT"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-97",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-97",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "101.3 Solution",
    "text": "101.3 Solution\nimport numpy as np\n\ndef oap(s1, s2, penalty=-2):\n    score = np.empty((len(s2) + 1, len(s1) + 1), dtype=int)\n    ptr = np.empty((len(s2) + 1, len(s1) + 1), dtype=int)\n\n    for j in range(len(s2) + 1):\n        score[j][0] = j * penalty\n        ptr[j][0] = 1\n    for i in range(len(s1) + 1):\n        score[0][i] = 0\n        ptr[0][i] = 2\n\n    score[0][0] = 0\n    for j in range(len(s2)):\n        for i in range(len(s1)):\n            opt = [\n                score[j][i] + (1 if s1[i] == s2[j] else penalty),\n                score[j][i + 1] + penalty,\n                score[j + 1][i] + penalty,\n            ]\n            best = max(opt)\n            score[j + 1][i + 1] = best\n            ptr[j + 1][i + 1] = opt.index(best)\n\n    sc = [score[j][len(s1)] for j in range(len(s2) + 1)]\n    max_score = max(sc)\n    j = [j for j, s in enumerate(sc) if s == max_score][-1]\n    i = len(s1)\n    a1, a2 = \"\", \"\"\n    while i &gt; 0 and j &gt; 0:\n        if ptr[j][i] == 0:\n            a1 += s1[i - 1]\n            a2 += s2[j - 1]\n            j, i = j - 1, i - 1\n        elif ptr[j][i] == 1:\n            a1 += \"-\"\n            a2 += s2[j - 1]\n            j = j - 1\n        elif ptr[j][i] == 2:\n            a1 += s1[i - 1]\n            a2 += \"-\"\n            i = i - 1\n\n    return max_score, a1[::-1], a2[::-1]\n\ndef read_fasta(fasta_string):\n    \"\"\"\n    Parses a FASTA formatted string and returns a list of sequences.\n    \"\"\"\n    sequences = []\n    current_sequence = []\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            if current_sequence:\n                sequences.append(''.join(current_sequence))\n                current_sequence = []\n        else:\n            current_sequence.append(line.strip())\n    if current_sequence:\n        sequences.append(''.join(current_sequence))\n    return sequences\n\nsample_input = \"\"\"\n&gt;Rosalind_54\nCTAAGGGATTCCGGTAATTAGACAG\n&gt;Rosalind_45\nATAGACCATATGTCAGTGACTGTGTAA\n\"\"\"\n\ns1, s2 = read_fasta(sample_input)\nprint(*oap(s1, s2, -2), sep=\"\\n\")\nThis code implements a semi-global sequence alignment algorithm, also known as overlap alignment. Here’s a brief explanation of how it works:\n\nInitialization:\n\nCreates two matrices: ‘score’ for alignment scores and ‘ptr’ for backtracking.\nInitializes the first row and column of these matrices.\n\nFilling the matrices:\n\nIterates through both sequences, filling the ‘score’ and ‘ptr’ matrices.\nFor each cell, calculates three possible scores: match/mismatch, gap in s1, gap in s2.\nChooses the maximum score and stores it along with a pointer to its origin.\n\nFinding the best alignment:\n\nFinds the maximum score in the last column of the ‘score’ matrix.\nThis allows for free end gaps in s2 (overlap alignment).\n\nTraceback:\n\nStarts from the position of the maximum score.\nFollows the pointers back to construct the aligned sequences.\nAdds gaps (‘-’) where necessary.\n\nResult:\n\nReturns the maximum alignment score and the two aligned sequences.\n\n\nThe ‘read_fasta’ function parses a FASTA-formatted string into sequences.\nFinally, it applies this alignment algorithm to two sequences from the sample input and prints the results.\nThis algorithm is particularly useful for finding the best overlap between two sequences, allowing for free end gaps in one of the sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-101",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-101",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "102.1 Sample Dataset",
    "text": "102.1 Sample Dataset\nA B C D E\n(A,C,((B,D),E));\n(C,(B,D),(A,E));"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-102",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-102",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "102.2 Sample Output",
    "text": "102.2 Sample Output\n4"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-98",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-98",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "102.3 Solution",
    "text": "102.3 Solution\nimport re\nimport math\n\n\ndef quartet_distance(taxa, t1, t2):\n    def parse_newick(taxa, tree_str):\n        tree = {}\n        parent = {}\n        node_names = {}\n        new_node_id = 0\n        root = new_node_id\n        tree[root] = []\n        current_node = root\n\n        for match in re.finditer(r\"\\(|\\)|,|;|([^\\(\\),;]+)\", tree_str):\n            token = match.group()\n            if token == '(':\n                new_node_id += 1\n                tree[current_node].append(new_node_id)\n                parent[new_node_id] = current_node\n                current_node = new_node_id\n                tree[current_node] = []\n            elif token == ',':\n                new_node_id += 1\n                tree[parent[current_node]].append(new_node_id)\n                parent[new_node_id] = parent[current_node]\n                current_node = new_node_id\n                tree[current_node] = []\n            elif token == ')':\n                current_node = parent[current_node]\n            elif token == ';':\n                break\n            else:\n                node_names[current_node] = token\n        \n        return tree, parent, node_names\n\n    def get_children(tree, parent, edge_id):\n        if edge_id &gt; 0:\n            return tree[edge_id]\n        else:\n            parent_id = parent[-edge_id]\n            if parent_id == 0:\n                return [e for e in tree[parent_id] if e != -edge_id]\n            else:\n                return [-parent_id] + [e for e in tree[parent_id] if e != -edge_id]\n\n    def compute_shared_leaves(i, j):\n        if shared_leaves[i][j] is None:\n            if not children1[i] and not children2[j]:  # Both are leaves\n                shared_leaves[i][j] = int(leaves1[i] == leaves2[j])\n            elif not children1[i]:  # i is a leaf\n                j1, j2 = children2[j]\n                shared_leaves[i][j] = compute_shared_leaves(i, j1) + compute_shared_leaves(i, j2)\n            elif not children2[j]:  # j is a leaf\n                i1, i2 = children1[i]\n                shared_leaves[i][j] = compute_shared_leaves(i1, j) + compute_shared_leaves(i2, j)\n            else:  # Both are internal nodes\n                i1, i2 = children1[i]\n                j1, j2 = children2[j]\n                shared_leaves[i][j] = (\n                    compute_shared_leaves(i1, j1) + compute_shared_leaves(i1, j2) +\n                    compute_shared_leaves(i2, j1) + compute_shared_leaves(i2, j2)\n                )\n        return shared_leaves[i][j]\n\n    def calculate_quartet_distances():\n        for i in all_edges1:\n            for j in all_edges2:\n                compute_shared_leaves(i, j)\n\n        total_distance = 0\n        for c1 in internal_edges1:\n            for c2 in internal_edges2:\n                a1, b1 = children1[-c1]\n                a2, b2 = children2[-c2]\n                quartet_value = (\n                    shared_leaves[a1][a2] * shared_leaves[b1][b2] +\n                    shared_leaves[a1][b2] * shared_leaves[b1][a2]\n                )\n                total_distance += quartet_value * (shared_leaves[c1][c2] * (shared_leaves[c1][c2] - 1) / 2)\n\n        return total_distance\n\n    # Parse Newick trees\n    tree1, parent1, leaves1 = parse_newick(taxa, t1)\n    tree2, parent2, leaves2 = parse_newick(taxa, t2)\n\n    # Number of taxa\n    n = len(taxa)\n\n    # Get children of each edge\n    children1 = [None] * (4 * n - 5)\n    children2 = [None] * (4 * n - 5)\n\n    for i in range(1, 2 * n - 2):\n        children1[i] = get_children(tree1, parent1, i)\n    for i in range(3 - 2 * n, 0):\n        children1[i] = get_children(tree1, parent1, i)\n\n    for j in range(1, 2 * n - 2):\n        children2[j] = get_children(tree2, parent2, j)\n    for j in range(3 - 2 * n, 0):\n        children2[j] = get_children(tree2, parent2, j)\n\n    # Initialize shared leaves matrix\n    shared_leaves = [[None] * (4 * n - 5) for _ in range(4 * n - 5)]\n\n    # List of all edges and internal edges\n    all_edges1 = list(range(1, 2 * n - 2)) + [edge for edge in range(3 - 2 * n, 0) if leaves1.get(-edge) is None]\n    all_edges2 = list(range(1, 2 * n - 2)) + [edge for edge in range(3 - 2 * n, 0) if leaves2.get(-edge) is None]\n    internal_edges1 = [edge for edge in all_edges1 if leaves1.get(edge) is None]\n    internal_edges2 = [edge for edge in all_edges2 if leaves2.get(edge) is None]\n\n    # Calculate quartet distances\n    total_quartets = calculate_quartet_distances()\n\n    # Calculate and return the quartet distance\n    max_possible_quartets = 2 * math.comb(n, 4)\n    return max_possible_quartets - total_quartets\n\n\n# Sample input\nsample_input = \"\"\"\nA B C D E\n(A,C,((B,D),E));\n(C,(B,D),(A,E));\n\"\"\".strip().split(\"\\n\")\n\ntaxa = sample_input[0].split()\nnwck1 = sample_input[1]\nnwck2 = sample_input[2]\n\nprint(quartet_distance(taxa, nwck1, nwck2))"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#explanation-of-how-it-works",
    "href": "posts/qmd/Rosalind_stronghold.html#explanation-of-how-it-works",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "102.4 Explanation of How It Works",
    "text": "102.4 Explanation of How It Works\n\nNewick Parsing (parse_newick):\n\nThe function parse_newick parses a Newick-formatted tree string and constructs a representation of the tree using a dictionary tree, which maps node IDs to their children. It also maintains a parent dictionary to track parent-child relationships and a name dictionary to map node IDs to taxa names.\nThis parsed tree allows us to later traverse and compare the structures of the two trees.\n\nChildren Function (get_children):\n\nThe get_children function retrieves the children of a given edge in the tree. If the edge is positive, it directly retrieves children from the tree structure. If the edge is negative, it handles the reversed direction by excluding the edge itself from the parent’s list.\n\nShared Leaves Calculation (compute_shared_leaves):\n\nThe compute_shared_leaves function computes the number of shared leaves between two subtrees (one from each tree) by recursively exploring their child nodes. It caches results to avoid redundant calculations, significantly optimizing performance.\n\nQuartet Calculation (calculate_quartet_distances):\n\nThe calculate_quartet_distances function iterates over all pairs of internal edges from the two trees and calculates the quartet distances. A quartet distance measures the difference in tree structure by comparing the shared leaves for each quartet configuration.\nThis function sums up these quartet values, representing the differences between the two trees.\n\nQuartet Distance Calculation:\n\nFinally, the quartet_distance function subtracts the calculated quartet differences from the total possible quartets for the number of taxa (given by math.comb(n, 4)). This provides the quartet distance, a measure of how dissimilar the two trees are in terms of their quartets."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-102",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-102",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "103.1 Sample Dataset",
    "text": "103.1 Sample Dataset\n&gt;Rosalind_79\nCAGCACTTGGATTCTCGG\n&gt;Rosalind_98\nCAGCGTGG"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-103",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-103",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "103.2 Sample Output",
    "text": "103.2 Sample Output\n4\nCAGCA-CTTGGATTCTCGG\n---CAGCGTGG--------"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-99",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-99",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "103.3 Solution",
    "text": "103.3 Solution\ndef semiglobal_alignment(seq1, seq2):\n    seq1 = \"-\" + seq1\n    seq2 = \"-\" + seq2\n\n    score_matrix = [[0 for j in range(len(seq2))] for i in range(len(seq1))]\n    direction_matrix = [[None for j in range(len(seq2))] for i in range(len(seq1))]\n\n    for i in range(1, len(seq1)):\n        for j in range(1, len(seq2)):\n\n            match_score = score_matrix[i - 1][j - 1] + (1 if seq1[i] == seq2[j] else -1)\n            delete_score = score_matrix[i - 1][j] - 1\n            insert_score = score_matrix[i][j - 1] - 1\n            score_matrix[i][j] = max(match_score, delete_score, insert_score)\n            if score_matrix[i][j] == match_score:\n                direction_matrix[i][j] = \"diagonal\"\n            elif score_matrix[i][j] == delete_score:\n                direction_matrix[i][j] = \"up\"\n            else:\n                direction_matrix[i][j] = \"left\"\n\n    last_row_max = max(range(len(seq2)), key=lambda x: score_matrix[len(seq1) - 1][x])\n    last_col_max = max(range(len(seq1)), key=lambda x: score_matrix[x][len(seq2) - 1])\n    if score_matrix[len(seq1) - 1][last_row_max] &gt;= score_matrix[last_col_max][len(seq2) - 1]:\n        i = len(seq1) - 1\n        j = last_row_max\n    else:\n        i = last_col_max\n        j = len(seq2) - 1\n    max_score = score_matrix[i][j]\n\n    insert_gap = lambda word, i: word[:i] + '-' + word[i:]\n\n    # Initialize the aligned sequences as the input sequences.\n    aligned_seq1, aligned_seq2 = seq1[1:], seq2[1:]\n\n    for _ in range(len(seq1) - 1 - i):\n        aligned_seq2 += '-'\n    for _ in range(len(seq2) - 1 - j):\n        aligned_seq1 += '-'\n\n    while i * j != 0:\n        if direction_matrix[i][j] == \"up\":\n            i -= 1\n            aligned_seq2 = insert_gap(aligned_seq2, j)\n        elif direction_matrix[i][j] == \"left\":\n            j -= 1\n            aligned_seq1 = insert_gap(aligned_seq1, i)\n        else:\n            i -= 1\n            j -= 1\n\n    for _ in range(i):\n        aligned_seq2 = insert_gap(aligned_seq2, 0)\n    for _ in range(j):\n        aligned_seq1 = insert_gap(aligned_seq1, 0)\n\n    return max_score, aligned_seq1, aligned_seq2\n\ndef parse_fasta(fasta_string):\n    sequences = {}\n    current_label = None\n    for line in fasta_string.strip().split('\\n'):\n        if line.startswith('&gt;'):\n            current_label = line[1:].strip()\n            sequences[current_label] = ''\n        else:\n            sequences[current_label] += line.strip()\n    return list(sequences.values())\n\nsample_input = \"\"\"\n&gt;Rosalind_79\nCAGCACTTGGATTCTCGG\n&gt;Rosalind_98\nCAGCGTGG\n\"\"\"\n\nsequence_A, sequence_B = parse_fasta(sample_input)\nfinal_score, aligned_sequence_A, aligned_sequence_B = semiglobal_alignment(sequence_A, sequence_B)\n\nprint(final_score)\nprint(aligned_sequence_A)\nprint(aligned_sequence_B)\n\nThe semiglobal_alignment function implements a semi-global alignment algorithm for two sequences:\n\nIt adds a gap character “-” at the beginning of both sequences.\nIt creates two matrices: score_matrix for alignment scores and direction_matrix for backtracking.\n\nThe function then fills these matrices:\n\nIt calculates scores for matches (1), mismatches (-1), and gaps (-1).\nIt chooses the maximum score among match, deletion, and insertion for each cell.\nIt records the direction (diagonal, up, or left) in the direction_matrix.\n\nAfter filling the matrices, it finds the best alignment end point:\n\nIt checks the maximum score in the last row and last column.\nIt chooses the higher of these two as the ending point of the alignment.\n\nThe function then performs a traceback to construct the aligned sequences:\n\nIt starts from the best end point and follows the directions in direction_matrix.\nIt adds gaps to the sequences as needed during the traceback.\n\nFinally, it returns the maximum score and the two aligned sequences.\nThe parse_fasta function reads a FASTA-formatted string:\n\nIt separates the sequences and their labels.\nIt returns a list of sequences without the labels.\n\nThe main part of the code:\n\nDefines a sample input in FASTA format.\nParses the input using parse_fasta.\nCalls semiglobal_alignment with the parsed sequences.\nPrints the final score and the aligned sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-103",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-103",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "104.1 Sample Dataset",
    "text": "104.1 Sample Dataset\n&gt;Rosalind_8\nPLEASANTLY\n&gt;Rosalind_18\nMEANLY"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-104",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-104",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "104.2 Sample Output",
    "text": "104.2 Sample Output\n12\nLEAS\nMEAN"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-100",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-100",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "104.3 Solution",
    "text": "104.3 Solution\nBLOSUM62 = {\n    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,\n    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,\n    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,\n    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,\n    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,\n    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,\n    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,\n    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,\n    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,\n    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,\n    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,\n    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,\n    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,\n    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,\n    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,\n    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,\n    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,\n    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,\n    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,\n    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,\n    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,\n    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,\n    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,\n    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,\n    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,\n    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,\n    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,\n    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,\n    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,\n    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,\n    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,\n    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,\n    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,\n    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,\n    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,\n    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,\n    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,\n    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,\n    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,\n    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,\n    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,\n    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,\n    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,\n    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,\n    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,\n    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,\n    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,\n    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,\n    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,\n    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,\n    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,\n    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,\n    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,\n    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,\n    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,\n    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,\n    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,\n    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,\n    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,\n    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,\n    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,\n    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,\n    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,\n    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,\n    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,\n    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,\n    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,\n    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,\n    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4\n}\n\ndef local_alignment_with_affine_gap(str1, str2, gap_open=11, gap_extend=1):\n    m, n = len(str1), len(str2)\n    \n    # Initialize score matrices\n    M = [[0] * (n + 1) for _ in range(m + 1)]\n    X = [[-float('inf')] * (n + 1) for _ in range(m + 1)]\n    Y = [[-float('inf')] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize backtrack matrices\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    max_score, max_i, max_j = 0, 0, 0\n    \n    # Fill matrices\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            X[i][j] = max(X[i][j-1] - gap_extend, M[i][j-1] - gap_open - gap_extend)\n            Y[i][j] = max(Y[i-1][j] - gap_extend, M[i-1][j] - gap_open - gap_extend)\n            \n            key = (str1[i-1], str2[j-1]) if (str1[i-1], str2[j-1]) in BLOSUM62 else (str2[j-1], str1[i-1])\n            match_score = BLOSUM62[key]\n            \n            M[i][j] = max(0, M[i-1][j-1] + match_score, X[i][j], Y[i][j])\n            \n            if M[i][j] &gt; max_score:\n                max_score, max_i, max_j = M[i][j], i, j\n            \n            if M[i][j] == 0:\n                B[i][j] = 0\n            elif M[i][j] == M[i-1][j-1] + match_score:\n                B[i][j] = 1\n            elif M[i][j] == X[i][j]:\n                B[i][j] = 2\n            else:\n                B[i][j] = 3\n    \n    # Backtrack\n    i, j = max_i, max_j\n    aligned_1, aligned_2 = [], []\n    \n    while B[i][j] != 0:\n        if B[i][j] == 1:\n            aligned_1.append(str1[i-1])\n            aligned_2.append(str2[j-1])\n            i -= 1\n            j -= 1\n        elif B[i][j] == 2:\n            aligned_1.append('-')\n            aligned_2.append(str2[j-1])\n            j -= 1\n        else:\n            aligned_1.append(str1[i-1])\n            aligned_2.append('-')\n            i -= 1\n    \n    return max_score, ''.join(reversed(aligned_1)), ''.join(reversed(aligned_2))\n\ndef parse_fasta(fasta_str):\n    sequences = {}\n    for record in fasta_str.strip().split('&gt;')[1:]:\n        lines = record.split('\\n')\n        sequences[lines[0]] = ''.join(lines[1:])\n    return list(sequences.values())\n\nsample_input = \"\"\"\n&gt;Rosalind_8\nPLEASANTLY\n&gt;Rosalind_18\nMEANLY\n\"\"\"\n\nstringA, stringB = parse_fasta(sample_input)\nscore, aligned_strA, aligned_strB = local_alignment_with_affine_gap(stringA, stringB)\n\nprint(score)\nprint(aligned_strA.replace(\"-\", \"\"))\nprint(aligned_strB.replace(\"-\", \"\"))\n\nBLOSUM62 Matrix:\n\nBLOSUM62 is a dictionary containing scores for amino acid substitutions based on the BLOSUM62 matrix. It provides a scoring scheme for amino acid matches and mismatches.\n\nlocal_alignment_with_affine_gap Function:\n\nInputs: str1 and str2 (the sequences to align), gap_open and gap_extend (penalties for opening and extending gaps).\nInitialization:\n\nM, X, and Y are matrices used to store scores for alignments and gaps.\nB is a backtracking matrix to reconstruct the optimal alignment.\n\nMatrix Filling:\n\nIterates over each position in the matrices, computing scores based on the BLOSUM62 matrix and gap penalties.\nUpdates the matrices to reflect the best alignment score at each position.\n\nBacktracking:\n\nConstructs the optimal local alignment by following the backtracking matrix.\n\n\nparse_fasta Function:\n\nInput: A string in FASTA format containing sequences.\nOutput: A list of sequences parsed from the FASTA format.\n\nExample Usage:\n\nsample_input: A FASTA formatted string with two example sequences.\nExecution:\n\nParses the FASTA string into sequences.\nPerforms local alignment on these sequences.\nPrints the alignment score and the aligned sequences (with gaps removed)."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-dataset-104",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-dataset-104",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "105.1 Sample Dataset",
    "text": "105.1 Sample Dataset\n(((ostrich,cat)rat,mouse)dog,elephant)robot;\n&gt;robot\nAATTG\n&gt;dog\nGGGCA\n&gt;mouse\nAAGAC\n&gt;rat\nGTTGT\n&gt;cat\nGAGGC\n&gt;ostrich\nGTGTC\n&gt;elephant\nAATTC"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#sample-output-105",
    "href": "posts/qmd/Rosalind_stronghold.html#sample-output-105",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "105.2 Sample Output",
    "text": "105.2 Sample Output\ndog mouse 1 A-&gt;G-&gt;A\ndog mouse 2 A-&gt;G-&gt;A\nrat ostrich 3 G-&gt;T-&gt;G\nrat cat 3 G-&gt;T-&gt;G\ndog rat 3 T-&gt;G-&gt;T"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#solution-101",
    "href": "posts/qmd/Rosalind_stronghold.html#solution-101",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "105.3 Solution",
    "text": "105.3 Solution\nclas Node:\n    def __init__(self, number, parent, name=None):\n        self.number = number\n        self.parent = parent\n        self.children = []\n        self.name = name or f\"Node_{number}\"\n\n    def __repr__(self):\n        return f\"Node_{self.number}({self.name})\" if self.name != f\"Node_{self.number}\" else f\"Node_{self.number}\"\n\n    def add_child(self, child):\n        self.children.append(child)\n\nclas Newick:\n    def __init__(self, data):\n        self.nodes = []\n        self.edges = []\n        self.construct_tree(data)\n        self.name_index = {node.name: node.number for node in self.nodes}\n        self.inv_name_index = {node.number: node.name for node in self.nodes}\n\n    def construct_tree(self, data):\n        tokens = data.replace(',', ' ').replace('(', '( ').replace(')', ' )').strip(';').split()\n        stack = [Node(-1, None)]\n        for token in tokens:\n            if token == '(':\n                new_node = Node(len(self.nodes), stack[-1].number)\n                self.nodes.append(new_node)\n                if len(self.nodes) &gt; 1:\n                    self.nodes[new_node.parent].add_child(new_node.number)\n                    self.edges.append((new_node.parent, new_node.number))\n                stack.append(new_node)\n            elif token == ')':\n                stack.pop()\n            elif token.startswith(')'):\n                stack[-1].name = token[1:]\n                stack.pop()\n            else:\n                new_node = Node(len(self.nodes), stack[-1].number, token)\n                self.nodes.append(new_node)\n                self.nodes[new_node.parent].add_child(new_node.number)\n                self.edges.append((new_node.parent, new_node.number))\n\n    def traverse(self, node_index=0, order='pre'):\n        node = self.nodes[node_index]\n        if order == 'pre':\n            result = [node]\n            for child in node.children:\n                result.extend(self.traverse(child, order))\n        else:  # post-order\n            result = []\n            for child in node.children:\n                result.extend(self.traverse(child, order))\n            result.append(node)\n        return result\n\n    def max_depth(self, node):\n        return max([self.max_depth(self.nodes[child]) for child in node.children], default=-1) + 1\n\n    def all_paths(self, node):\n        if not node.children:\n            return []\n\n        paths = []\n        stack = [(node, [node.name])]\n        while stack:\n            current, path = stack.pop()\n            for child_idx in current.children:\n                child = self.nodes[child_idx]\n                new_path = path + [child.name]\n                if len(new_path) &gt;= 3:\n                    paths.append(new_path)\n                stack.append((child, new_path))\n        return paths\n\n    def rsub(self, DNA_strings):\n        rsub_list = []\n        pre_order = self.traverse(order='pre')\n        k = len(next(iter(DNA_strings.values())))\n        \n        for pos in range(k):\n            for node in pre_order:\n                if node.children:\n                    for path in self.all_paths(node):\n                        nucs = [DNA_strings[label][pos] for label in path]\n                        if nucs[0] == nucs[-1] != nucs[1] and all(x == nucs[1] for x in nucs[1:-1]):\n                            rsub_list.append([path[1], path[-1], str(pos + 1), \"-&gt;\".join([nucs[0], nucs[1], nucs[-1]])])\n        return rsub_list\n\ndef parse_fasta(lines):\n    sequences = {}\n    current_seq = []\n    current_name = \"\"\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\"&gt;\"):\n            if current_name:\n                sequences[current_name] = \"\".join(current_seq)\n            current_name = line[1:]\n            current_seq = []\n        else:\n            current_seq.append(line)\n    if current_name:\n        sequences[current_name] = \"\".join(current_seq)\n    return sequences\n\n\nsample_input = \"\"\"\n(((ostrich,cat)rat,mouse)dog,elephant)robot;\n&gt;robot\nAATTG\n&gt;dog\nGGGCA\n&gt;mouse\nAAGAC\n&gt;rat\nGTTGT\n&gt;cat\nGAGGC\n&gt;ostrich\nGTGTC\n&gt;elephant\nAATTC\n\"\"\".strip().split(\"\\n\")\n\nnewick = sample_input[0]\nDNA_strings = parse_fasta(sample_input[1:])\n\ntree = Newick(newick)\nresult = tree.rsub(DNA_strings)\nfor r in result:\n    print(\" \".join(r))\nHere’s a refactored version of the provided code with explanations:\nclas Node:\n    def __init__(self, number, parent, name=None):\n        self.number = number\n        self.parent = parent\n        self.children = []\n        self.name = name or f\"Node_{number}\"\n\n    def __repr__(self):\n        return f\"Node_{self.number}({self.name})\" if self.name != f\"Node_{self.number}\" else f\"Node_{self.number}\"\n\n    def add_child(self, child):\n        self.children.append(child)\n\nclas Newick:\n    def __init__(self, data):\n        self.nodes = []\n        self.edges = []\n        self.construct_tree(data)\n        self.name_index = {node.name: node.number for node in self.nodes}\n        self.inv_name_index = {node.number: node.name for node in self.nodes}\n\n    def construct_tree(self, data):\n        tokens = data.replace(',', ' ').replace('(', '( ').replace(')', ' )').strip(';').split()\n        stack = [Node(-1, None)]\n        for token in tokens:\n            if token == '(':\n                new_node = Node(len(self.nodes), stack[-1].number)\n                self.nodes.append(new_node)\n                if len(self.nodes) &gt; 1:\n                    self.nodes[new_node.parent].add_child(new_node.number)\n                    self.edges.append((new_node.parent, new_node.number))\n                stack.append(new_node)\n            elif token == ')':\n                stack.pop()\n            elif token.startswith(')'):\n                stack[-1].name = token[1:]\n                stack.pop()\n            else:\n                new_node = Node(len(self.nodes), stack[-1].number, token)\n                self.nodes.append(new_node)\n                self.nodes[new_node.parent].add_child(new_node.number)\n                self.edges.append((new_node.parent, new_node.number))\n\n    def traverse(self, node_index=0, order='pre'):\n        node = self.nodes[node_index]\n        if order == 'pre':\n            result = [node]\n            for child in node.children:\n                result.extend(self.traverse(child, order))\n        else:  # post-order\n            result = []\n            for child in node.children:\n                result.extend(self.traverse(child, order))\n            result.append(node)\n        return result\n\n    def max_depth(self, node):\n        return max([self.max_depth(self.nodes[child]) for child in node.children], default=-1) + 1\n\n    def all_paths(self, node):\n        if not node.children:\n            return []\n\n        paths = []\n        stack = [(node, [node.name])]\n        while stack:\n            current, path = stack.pop()\n            for child_idx in current.children:\n                child = self.nodes[child_idx]\n                new_path = path + [child.name]\n                if len(new_path) &gt;= 3:\n                    paths.append(new_path)\n                stack.append((child, new_path))\n        return paths\n\n    def rsub(self, DNA_strings):\n        rsub_list = []\n        pre_order = self.traverse(order='pre')\n        k = len(next(iter(DNA_strings.values())))\n        \n        for pos in range(k):\n            for node in pre_order:\n                if node.children:\n                    for path in self.all_paths(node):\n                        nucs = [DNA_strings[label][pos] for label in path]\n                        if nucs[0] == nucs[-1] != nucs[1] and all(x == nucs[1] for x in nucs[1:-1]):\n                            rsub_list.append([path[1], path[-1], str(pos + 1), \"-&gt;\".join([nucs[0], nucs[1], nucs[-1]])])\n        return rsub_list\n\ndef parse_fasta(lines):\n    sequences = {}\n    current_seq = []\n    current_name = \"\"\n    for line in lines:\n        line = line.strip()\n        if line.startswith(\"&gt;\"):\n            if current_name:\n                sequences[current_name] = \"\".join(current_seq)\n            current_name = line[1:]\n            current_seq = []\n        else:\n            current_seq.append(line)\n    if current_name:\n        sequences[current_name] = \"\".join(current_seq)\n    return sequences"
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#classes-and-their-functions",
    "href": "posts/qmd/Rosalind_stronghold.html#classes-and-their-functions",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "105.4 Classes and Their Functions",
    "text": "105.4 Classes and Their Functions\n\nNode Class:\n\nRepresents a single node in the tree.\nEach node has a unique number, a parent node, a list of children, and a name.\n\nNewick Class:\n\nPurpose: Parses and builds a tree from a Newick format string.\nKey Methods:\n\nconstruct_tree(data): Builds the tree structure from the Newick format string.\ntraverse(): Gets all nodes in a specific order (pre-order or post-order).\nmax_depth(node): Finds the maximum depth of the tree from a given node.\nall_paths(node): Lists all paths starting from a node.\nrsub(DNA_strings): Finds specific patterns in the DNA sequences based on the tree.\n\n\nparse_fasta(lines):\n\n\nConverts FASTA formatted sequence data into a dictionary. Keys are sequence names, and values are the sequences."
  },
  {
    "objectID": "posts/qmd/Rosalind_stronghold.html#how-it-works-1",
    "href": "posts/qmd/Rosalind_stronghold.html#how-it-works-1",
    "title": "Rosalind Stronghold 문제풀이",
    "section": "105.5 How It Works",
    "text": "105.5 How It Works\n\nParse the Tree and Sequences:\n\nNewick Tree: Convert the Newick format string into a tree structure.\nFASTA Sequences: Read and store DNA sequences.\n\nFind Patterns:\n\nUse the tree structure and DNA sequences to find and list patterns where:\n\nThe first and last characters of a pattern are the same.\nThe middle characters are all the same but different from the first/last character."
  },
  {
    "objectID": "posts/qmd/guide_FixEncoding.html#footnotes",
    "href": "posts/qmd/guide_FixEncoding.html#footnotes",
    "title": "문자열 인코딩 문제",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://realpython.com/python-encodings-guide/↩︎"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html",
    "href": "posts/qmd/guide_ML4math.html",
    "title": "머신러닝을 위한 수학",
    "section": "",
    "text": "책 “아카이시 마사노리, 딥러닝을 위한 수학, 위키북스, 2020”을 읽고 저자가 정리한 딥러닝을 위한 수학의 최단기 코스 목차를 참고해 내용을 하였습니다. 더 자세한 설명과 파이썬 코드를 알고 싶으시다면 책을 읽어보시는 걸 추천드립니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#알아야하는-필수-개념",
    "href": "posts/qmd/guide_ML4math.html#알아야하는-필수-개념",
    "title": "머신러닝을 위한 수학",
    "section": "1.1 알아야하는 필수 개념",
    "text": "1.1 알아야하는 필수 개념\n\n손실함수\n행렬과 행렬 연산\n경사하강법\n시그모이드 함수\n소프트맥스 함수\n가능도함수와 최대가능도 추정\n오차역전파"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#함수",
    "href": "posts/qmd/guide_ML4math.html#함수",
    "title": "머신러닝을 위한 수학",
    "section": "2.1 함수",
    "text": "2.1 함수\n관련 개념: 합성함수와 역함수, 극한과 미분, 다변수 함수\n함수는 정의역의 각 원소에 공역의 원소를 오직 하나씩 대응시키는 관계입니다.4 함수는 종종 ’ 보이지 않는 마술상자 ’ 에 비유됩니다. 입력값을 넣으면 특정한 출력값이 나오는 구조이기 때문입니다. 이 비유는 단순해 보이지만 함수의 본질적인 개념을 잘 표현합니다\n\n입력값 (정의역) 에 대해 단 하나의 출력값 (공역) 이 존재합니다.\n모든 입력값은 반드시 하나의 출력값을 가져야 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#합성함수와-역함수",
    "href": "posts/qmd/guide_ML4math.html#합성함수와-역함수",
    "title": "머신러닝을 위한 수학",
    "section": "2.2 합성함수와 역함수",
    "text": "2.2 합성함수와 역함수\n관련 개념: 로그함수\n합성함수와 역함수는 함수의 성질을 이해하고 복잡한 관계를 분석하는 데 중요한 도구입니다. 특히 합성함수는 여러 단계의 변환을 하나의 함수로 표현할 수 있게 해주며, 역함수는 함수의 가역성을 나타내는 중요한 개념입니다.\n합성함수: 합성함수는 두 개 이상의 함수를 연속적으로 적용하여 만든 새로운 함수입니다. 함수 \\(f\\) 와 \\(g\\) 가 있을 때 \\(g∘f(x) = g(f(x))\\) 로 정의되는 함수를 \\(f\\) 와 \\(g\\) 의 합성함수라고 합니다. 합성함수는 여러 함수를 거쳐 한 집합에서 다른 집합으로 직접 연결하는 ” 다리 ” 역할을 합니다.5\n\n교환법칙이 성립하지 않습니다. \\(g∘f ≠ f∘g\\)\n결합법칙은 성립합니다. \\((h∘g)∘f = h∘(g∘f)\\)\n\n역함수: 역함수는 주어진 함수의 입력과 출력을 서로 바꾼 함수입니다. 함수 \\(f\\) 에 대해 \\(y = f(x)\\) 이면 \\(x = f^(-1)(y)\\) 가 성립하는 함수 \\(f^(-1)\\) 를 \\(f\\) 의 역함수라고 합니다. 역함수는 원래 함수의 ” 되돌리기 ” 연산으로 볼 수 있습니다.\n\n모든 함수가 역함수를 가지는 것은 아닙니다. 일대일대응 함수만이 역함수를 가집니다.6\n\\(f(f^(-1)(x)) = f^(-1)(f(x)) = x\\) 가 성립합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#극한과-미분",
    "href": "posts/qmd/guide_ML4math.html#극한과-미분",
    "title": "머신러닝을 위한 수학",
    "section": "2.3 극한과 미분",
    "text": "2.3 극한과 미분\n관련개념: 극대와 극소, 다항식의 미분, 곱의 미분, 적분, 합성함수의 미분, 로그함수의 미분, 편미분, 전미분\n극한은 어떤 변수가 특정 값에 한없이 가까워질 때 함수값이 수렴하는 값을 의미합니다.\n\n엡실론 - 델타 정의: 함수 \\(f(x)\\) 의 \\(x\\) 가 \\(a\\) 로 접근할 때의 극한 \\(L\\) 은 다음과 같이 정의됩니다: 모든 \\(ε &gt; 0\\) 에 대해, \\(δ &gt; 0\\) 이 존재하여 \\(0 &lt; |x - a| &lt; δ\\) 일 때 \\(|f(x) - L| &lt; ε\\) 이 성립합니다.\n직관적으로 \\(x\\) 가 \\(a\\) 에 충분히 가까워지면 \\(f(x)\\) 는 \\(L\\) 에 원하는 만큼 가까워질 수 있다는 의미입니다.\n엡실론 - 델타 정의는 해석학의 기초가 되며 이를 통해 함수의 성질을 엄밀하게 분석할 수 있습니다.\n\n미분은 함수의 순간변화율을 나타내는 개념입니다.\n\n극한을 이용한 정의: 함수 \\(f(x)\\) 의 \\(x = a\\) 에서의 미분은 다음과 같이 정의됩니다: \\(f'(a) = lim_{h→0} [f(a+h) - f(a)] / h\\)\n이는 함수의 그래프 상의 한 점에서의 접선의 기울기를 의미하며 \\(f'(a)\\) 를 함수 \\(f(a)\\) 의 도함수라 합니다.\n\n극한과 미분의 관계\n\n미분은 극한의 개념을 기반으로 정의됩니다. 미분 계수는 특정한 형태의 극한값입니다.\n함수가 미분 가능하려면 해당 점에서 극한이 존재해야 합니다. 즉, 좌극한과 우극한이 같아야 합니다.\n극한의 존재가 미분 가능성을 보장하지는 않습니다. 예를 들어, \\(|x|\\) 는 \\(x = 0\\) 에서 극한은 존재하지만 미분은 불가능합니다.\n미분 가능한 함수는 반드시 연속함수이지만 그 역은 성립하지 않습니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#극대와-극소",
    "href": "posts/qmd/guide_ML4math.html#극대와-극소",
    "title": "머신러닝을 위한 수학",
    "section": "2.4 극대와 극소",
    "text": "2.4 극대와 극소\n관련개념: 경사하강법, 가능도함수와 최대가능도 추정\n극대와 극소는 함수의 그래프에서 봉우리와 골짜기를 나타내며, 이러한 점들을 찾는 것은 함수의 최적화 및 분석에 있어 매우 중요합니다. 극대와 극소를 찾기 위해서는 도함수를 사용하여 함수의 기울기가 \\(0\\) 이 되는 지점을 찾고, 이 지점들이 극대인지 극소인지 추가적인 분석을 통해 확인합니다. 이 개념들은 최적화 문제와 함수의 그래프 분석에서 중요한 역할을 합니다.\n극대: 함수 \\(y = f(x)\\) 가 \\(x = a\\) 에서 극대 (maximum) 를 가진다고 할 때, 이는 \\(f(a)\\) 가 \\(a\\) 의 근처에 있는 모든 \\(x\\) 에 대해 \\(f(x) \\leq f(a)\\) 를 만족하는 경우를 의미합니다.\n\n극대점에서는 함수의 기울기가 \\(0\\) 이 되거나, 변화가 없는 상태가 됩니다. 즉, 도함수 \\(f'(x) = 0\\) 이거나 정의되지 않는 점일 수 있습니다.\n\n극소: 함수 \\(y = f(x)\\) 가 \\(x = b\\) 에서 극소 (minimum) 를 가진다고 할 때 이는 \\(f(b)\\) 가 \\(b\\) 의 근처에 있는 모든 \\(x\\) 에 대해 \\(f(x) \\geq f(b)\\) 를 만족하는 경우를 의미합니다.\n\n극소점에서도 마찬가지로 함수의 기울기가 \\(0\\) 이 되거나 변화가 없는 상태가 됩니다. 즉, 도함수 \\(f'(x) = 0\\) 이거나 정의되지 않는 점일 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#다항식의-미분",
    "href": "posts/qmd/guide_ML4math.html#다항식의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "2.5 다항식의 미분",
    "text": "2.5 다항식의 미분\n관련개념: 시그모이드 함수\n다항식의 미분은 함수의 순간 변화율을 나타내며, 곡선의 기울기를 구하거나 최적화 문제를 해결하는 데 사용됩니다. 다항식의 미분은 각 항을 개별적으로 미분한 후 그 결과를 더하는 방식으로 이루어집니다. 다항식 미분의 주요 특징은 다음과 같습니다:\n\n상수항의 미분: 상수 c 에 대해 \\((c)' = 0\\)\n거듭제곱 함수의 미분: \\(x^n\\) 의 미분은 \\(nx^(n-1)\\) 입니다. 즉, \\((x^n)' = nx^(n-1)\\).\n선형성: \\((f(x) + g(x))' = f'(x) + g'(x)\\), \\((cf(x))' = c * f'(x)\\). 여기서 \\(c\\) 는 상수.\n\n다항식의 미분 정의: 다항식 \\(f(x) = a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0\\) 의 미분은 다음과 같이 정의됩니다:\n\n\\(f'(x) = n * a_n x^(n-1) + (n-1) * a_(n-1) x^(n-2) + ... + 2 * a_2 x + a_1\\) 이 정의를 사용하면 모든 다항식의 미분을 쉽게 계산할 수 있습니다.\n\n예를 들면 아래와 같습니다: - \\((3x^2 + 2x - 1)'= 6x + 2\\) - \\((x^3 - 5x + 7)' = 3x^2 - 5\\)"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#곱의-미분",
    "href": "posts/qmd/guide_ML4math.html#곱의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "2.6 곱의 미분",
    "text": "2.6 곱의 미분\n관련개념: 몫의 미분\n곱의 미분법칙 (product rule) 은 두 함수의 곱을 미분할 때 사용하는 규칙으로 복잡한 함수의 미분을 단순화하고 해결하는 데 활용됩니다.\n곱의 미분은 두 함수 \\(u(x)\\) 와 \\(v(x)\\) 의 곱 \\(f(x) = u(x)v(x)\\) 에 대한 미분은 다음과 같이 정의됩니다: \\(f'(x) = u'(x)v(x) + u(x)v'(x)\\). 여기서 \\(f'(x)\\) 는 \\(f(x)\\) 의 도함수이며 \\(u'(x)\\) 는 \\(u(x)\\) 의 도함수이고 \\(v'(x)\\) 는 \\(v(x)\\) 의 도함수입니다.\n곱의 미분 특징:\n\n이 법칙은 두 함수의 곱을 미분할 때 각 함수를 개별적으로 미분한 후 조합하는 방법을 제공합니다.\n첫 번째 함수의 미분에 두 번째 함수를 곱하고, 두 번째 함수의 미분에 첫 번째 함수를 곱한 후 이 둘을 더합니다.\n이 법칙은 두 개 이상의 함수의 곱에도 확장 적용할 수 있습니다.\n곱의 미분법칙은 합의 미분법칙과 함께 복잡한 함수의 미분을 가능하게 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#합성함수의-미분",
    "href": "posts/qmd/guide_ML4math.html#합성함수의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "2.7 합성함수의 미분",
    "text": "2.7 합성함수의 미분\n관련 개념: 몫의 미분, 지수함수의 미분, 전미분과 합성함수\n합성함수의 미분, 즉 연쇄법칙 (chain rule) 은 신경망과 같은 복잡한 구조의 미분을 계산할 때 핵심적인 역할을 합니다.\n합성함수의 미분 정의: 두 함수 \\(f(x)\\) 와 \\(g(x)\\) 의 합성함수 \\(h(x) = f(g(x))\\) 에 대한 미분은 다음과 같이 정의됩니다: \\(h'(x) = f'(g(x)) * g'(x)\\) . 여기서 \\(h'(x)\\) 는 합성함수 \\(h(x)\\) 의 도함수, \\(f'(g(x))\\) 는 \\(f\\) 의 도함수를 \\(g(x)\\) 에 대해 계산한 것, \\(g'(x)\\) 는 \\(g(x)\\) 의 도함수입니다.\n연쇄법칙의 특징\n\n이 법칙은 ” 바깥 함수의 미분 ” 곱하기 ” 안쪽 함수의 미분 ” 으로 이해할 수 있습니다.\n연쇄법칙은 여러 함수가 중첩된 복잡한 함수의 미분을 가능하게 합니다.\n이 법칙은 다변수 함수의 편미분에도 확장 적용될 수 있습니다.\n연쇄법칙은 역함수의 미분을 구할 때도 유용합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#몫의-미분",
    "href": "posts/qmd/guide_ML4math.html#몫의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "2.8 몫의 미분",
    "text": "2.8 몫의 미분\n관련 개념: 소프트맥스 함수\n몫의 미분법칙 (quotient rule) 은 두 함수의 몫을 미분할 때 사용하는 규칙입니다. 두 함수 \\(u(x)\\)$와 \\(v(x)\\)$ 의 몫 \\(f(x) = \\frac{u(x)}{v(x)}\\) 에 대한 미분은 다음과 같이 정의됩니다:\n\\[\nf'(x) = \\frac{u'(x)v(x) - u(x)v'(x)}{[v(x)]^2}\n\\]\n여기서\n\n\\(f'(x)\\) 는 \\(f(x)\\) 의 도함수입니다.\n\\(u'(x)\\) 는 \\(u(x)\\) 의 도함수입니다.\n\\(v'(x)\\) 는 \\(v(x)\\) 의 도함수입니다.\n\n몫의 미분법칙은 복잡한 함수의 미분을 단순화하고, 다양한 수학적 문제를 해결하는 데 중요한 도구입니다. 이 법칙의 특징은 다음과 같습니다:\n\n분자와 분모의 역할: 분자의 미분에 분모를 곱하고, 분모의 미분에 분자를 곱한 후, 이 두 값을 뺍니다.\n분모의 제곱: 결과적으로 분모의 제곱이 분모로 들어갑니다.\n적용 조건: 분모 \\(v(x)\\) 는 0 이 아니어야 합니다. 이는 함수가 정의되지 않는 점을 피하기 위함입니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#적분",
    "href": "posts/qmd/guide_ML4math.html#적분",
    "title": "머신러닝을 위한 수학",
    "section": "2.9 적분",
    "text": "2.9 적분\n관련 개념: 확률밀도함수와 확률분포함수\n적분은 고대 그리스의 아르키메데스가 처음 아이디어를 제시했으며, 이후 앙리 르베그와 같은 수학자들에 의해 이론적으로 완성되었습니다. 적분은 물리학, 공학, 경제학 등 다양한 분야에서 널리 사용되며, 예를 들어 곡면으로 이루어진 수영장을 채우기 위해 필요한 물의 양을 계산하는 데 활용될 수 있습니다.7\n적분은 크게 두 가지로 나뉩니다: 부정적분과 정적분입니다. 부정적분은 함수의 원시함수를 찾는 과정이며, 정적분은 특정 구간에서의 함수의 값을 계산하는 과정입니다.8 적분의 주요 특징과 의미는 다음과 같습니다:\n\n정의: 적분은 함수의 그래프 아래 면적을 계산하는 방법입니다.\n종류:\n\n부정적분: 함수의 원시함수를 찾는 과정\n정적분: 특정 구간에서의 함수의 값을 계산하는 과정 9\n\n정적분의 개념: 주어진 함수의 구간을 아주 작은 직사각형들로 나누어 그 넓이의 합을 구하는 방식입니다.\n리만 적분: 가장 일반적으로 사용되는 적분 형식 중 하나로, 함수를 잘게 나누어 근사값을 구하는 방식입니다.\n미적분학의 기본 정리: 미분과 적분이 서로 역연산 관계에 있음을 보여주는 중요한 정리입니다.10\n응용: 적분은 물리학, 공학, 경제학 등 다양한 분야에서 사용되며, 면적, 부피, 일, 에너지 등 다양한 물리량을 계산하는 데 활용됩니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#벡터",
    "href": "posts/qmd/guide_ML4math.html#벡터",
    "title": "머신러닝을 위한 수학",
    "section": "3.1 벡터",
    "text": "3.1 벡터\n관련개념: 덧셈, 뺄셈, 스칼라 곱셈, 편미분\n벡터는 수학과 물리학에서 크기와 방향을 동시에 가지는 양을 나타내는 개념입니다. 벡터는 일반적으로 화살표로 표현되며, 시작점과 끝점을 통해 방향과 크기를 나타냅니다. 주요 특징은 다음과 같습니다:\n\n크기와 방향: 벡터는 크기 (길이) 와 방향을 가지며, 이 두 가지 요소로 정의됩니다. 크기는 벡터의 길이를 나타내고, 방향은 벡터가 가리키는 방향을 나타냅니다.\n자유벡터: 벡터는 시점 (시작점) 이 자유로울 수 있으며, 같은 크기와 방향을 가지면 동일한 벡터로 간주됩니다. 이러한 벡터를 자유벡터라고 합니다.\n벡터의 연산: 벡터는 덧셈, 뺄셈, 스칼라 곱 등의 연산이 가능합니다. 이러한 연산을 통해 벡터의 크기와 방향을 조작할 수 있습니다.11\n벡터 공간: 벡터는 벡터 공간의 원소로 간주되며, 벡터 공간은 벡터의 선형 결합으로 구성됩니다. 벡터 공간은 수학적 구조를 정의하는 데 중요한 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#덧셈-뺄셈-스칼라-곱셈",
    "href": "posts/qmd/guide_ML4math.html#덧셈-뺄셈-스칼라-곱셈",
    "title": "머신러닝을 위한 수학",
    "section": "3.2 덧셈, 뺄셈, 스칼라 곱셈",
    "text": "3.2 덧셈, 뺄셈, 스칼라 곱셈\n관련개념: 길이와 거리\n벡터의 덧셈과 뺄셈은 벡터의 결합과 분리를 나타내며, 스칼라 곱셈은 벡터의 크기를 조절하는 데 사용됩니다.12 각 연산의 정의는 다음과 같습니다:\n벡터의 덧셈: 두 벡터 \\(\\mathbf{a}\\) 와 \\(\\mathbf{b}\\) 의 덧셈은 대응하는 성분끼리 더하는 것입니다. - 수식: \\(\\mathbf{a} + \\mathbf{b} = (a_1 + b_1, a_2 + b_2, \\ldots, a_n + b_n)\\) - 특징: 벡터 덧셈은 교환법칙과 결합법칙이 성립합니다.\n벡터의 뺄셈: 두 벡터 \\(\\mathbf{a}\\) 와 \\(\\mathbf{b}\\) 의 뺄셈은 대응하는 성분끼리 빼는 것입니다. - 수식: \\(\\mathbf{a} - \\mathbf{b} = (a_1 - b_1, a_2 - b_2, \\ldots, a_n - b_n)\\) - 특징: 벡터 뺄셈은 벡터 덧셈과 유사하게 처리되며, 벡터의 방향을 반대로 하는 것과 같습니다.\n스칼라 곱셈: 벡터 \\(\\mathbf{a}\\) 에 스칼라 \\(c\\) 를 곱하는 것은 벡터의 각 성분에 \\(c\\) 를 곱하는 것입니다.\n\n수식: \\(c\\mathbf{a} = (ca_1, ca_2, \\ldots, ca_n)\\)\n특징: 스칼라 곱셈은 벡터의 크기를 변화시키며, 방향은 변하지 않습니다. 스칼라가 음수일 경우 벡터의 방향이 반대가 됩니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#길이와-거리",
    "href": "posts/qmd/guide_ML4math.html#길이와-거리",
    "title": "머신러닝을 위한 수학",
    "section": "3.3 길이와 거리",
    "text": "3.3 길이와 거리\n관련개념: 내적, 코사인 유사도\n벡터의 길이: 벡터의 길이 (또는 크기) 는 벡터가 나타내는 화살표의 길이를 의미하며, 이는 벡터의 각 성분의 제곱의 합의 제곱근으로 계산됩니다.\n\n수식: 벡터 \\(\\mathbf{v} = (v_1, v_2, \\ldots, v_n)\\) 의 길이는 다음과 같이 정의됩니다: \\[\n\\|\\mathbf{v}\\| = \\sqrt{v_1^2 + v_2^2 + \\ldots + v_n^2}\n\\]\n특징: 벡터의 길이는 항상 0 이상의 값을 가지며, 벡터가 원점에서 얼마나 떨어져 있는지를 나타냅니다.\n\n벡터 간의 거리: 두 벡터 사이의 거리는 두 벡터를 연결하는 선분의 길이를 의미합니다. - 수식: 벡터 \\(\\mathbf{u} = (u_1, u_2, \\ldots, u_n)\\) 와 \\(\\mathbf{v} = (v_1, v_2, \\ldots, v_n)\\) 사이의 거리는 다음과 같이 정의됩니다: \\[\n  \\text{거리}(\\mathbf{u}, \\mathbf{v}) = \\sqrt{(u_1 - v_1)^2 + (u_2 - v_2)^2 + \\ldots + (u_n - v_n)^2}\n  \\] - 특징: 이 거리는 유클리드 거리로, 두 점 사이의 직선 거리를 측정하며, 항상 0 이상의 값을 가집니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#삼각함수",
    "href": "posts/qmd/guide_ML4math.html#삼각함수",
    "title": "머신러닝을 위한 수학",
    "section": "3.4 삼각함수",
    "text": "3.4 삼각함수\n관련개념: 내적\n삼각함수는 삼각형의 각과 변의 관계를 나타내는 함수로, 주로 직각삼각형에서 정의됩니다.13 삼각함수의 주요 정의는 다음과 같습니다:\n\n사인 (Sine, \\(\\sin\\)): 직각삼각형에서 한 각의 사인은 그 각의 대변의 길이를 빗변의 길이로 나눈 값입니다.\n코사인 (Cosine, \\(\\cos\\)): 직각삼각형에서 한 각의 코사인은 그 각의 인접변의 길이를 빗변의 길이로 나눈 값입니다.\n탄젠트 (Tangent, \\(\\tan\\)): 직각삼각형에서 한 각의 탄젠트는 그 각의 대변의 길이를 인접변의 길이로 나눈 값입니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#내적",
    "href": "posts/qmd/guide_ML4math.html#내적",
    "title": "머신러닝을 위한 수학",
    "section": "3.5 내적",
    "text": "3.5 내적\n관련개념: 코사인 유사도, 행렬과 행렬 연산, 경사하강법\n내적은 두 벡터의 각 성분을 곱한 후 더하는 연산으로, 실수체에서는 이중선형 (bilinear) 함수로 정의됩니다. 이는 두 벡터의 방향이 얼마나 일치하는지를 나타냅니다.14 내적의 정의는 다음과 같습니다:\n\n수식: 두 벡터 \\(\\mathbf{a} = (a_1, a_2, \\ldots, a_n)\\) 와 \\(\\mathbf{b} = (b_1, b_2, \\ldots, b_n)\\) 의 내적은 다음과 같이 계산됩니다: \\[\n\\mathbf{a} \\cdot \\mathbf{b} = a_1b_1 + a_2b_2 + \\ldots + a_nb_n\n\\]\n성질:\n\n교환법칙: \\(\\mathbf{a} \\cdot \\mathbf{b} = \\mathbf{b} \\cdot \\mathbf{a}\\)\n분배법칙: \\(\\mathbf{a} \\cdot (\\mathbf{b} + \\mathbf{c}) = \\mathbf{a} \\cdot \\mathbf{b} + \\mathbf{a} \\cdot \\mathbf{c}\\)\n스칼라곱과의 호환성: \\(c(\\mathbf{a} \\cdot \\mathbf{b}) = (c\\mathbf{a}) \\cdot \\mathbf{b} = \\mathbf{a} \\cdot (c\\mathbf{b})\\), 여기서 \\(c\\) 는 스칼라입니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#코사인-유사도",
    "href": "posts/qmd/guide_ML4math.html#코사인-유사도",
    "title": "머신러닝을 위한 수학",
    "section": "3.6 코사인 유사도",
    "text": "3.6 코사인 유사도\n코사인 유사도 (Cosine Similarity) 는 두 벡터 간의 유사도를 측정하는 방법으로, 두 벡터 사이의 코사인 각도를 이용하여 유사도를 계산합니다. 코사인 유사도는 벡터의 방향에 기반하여 유사성을 측정하기 때문에, 크기에 영향을 받지 않고 패턴이나 방향의 유사성을 평가하는 데 적합합니다. 따라서 자연어 처리 (NLP) 에서 문서 간의 유사도를 측정하거나 추천 시스템에서 아이템 간의 유사도를 계산하는 데 널리 사용됩니다. 코사인 유사도는 다음과 같은 특징을 가지고 있습니다:\n\n정의: 코사인 유사도는 두 벡터가 이루는 각의 코사인을 계산하여 두 벡터의 방향이 얼마나 유사한지를 나타냅니다. 수식으로는 다음과 같이 표현됩니다: \\[\n\\text{Cosine Similarity} = \\frac{\\mathbf{A} \\cdot \\mathbf{B}}{\\|\\mathbf{A}\\| \\|\\mathbf{B}\\|}\n\\] 여기서 \\(\\mathbf{A} \\cdot \\mathbf{B}\\) 는 두 벡터의 내적이고, \\(\\|\\mathbf{A}\\|\\) 와 \\(\\|\\mathbf{B}\\|\\) 는 각각 벡터의 크기 (길이) 입니다.\n특징:\n\n코사인 유사도는 -1 에서 1 사이의 값을 가지며, 1 에 가까울수록 두 벡터의 방향이 유사하다는 것을 의미합니다.\n벡터의 크기보다는 방향에 초점을 맞추기 때문에, 문서의 길이가 다르거나 크기가 다른 벡터를 비교할 때 유용합니다 15"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#행렬과-행렬-연산",
    "href": "posts/qmd/guide_ML4math.html#행렬과-행렬-연산",
    "title": "머신러닝을 위한 수학",
    "section": "3.7 행렬과 행렬 연산",
    "text": "3.7 행렬과 행렬 연산\n행렬은 수 또는 다항식 등을 직사각형 모양으로 배열한 것입니다. 행렬은 수학과 과학의 다양한 분야에서 사용되며, 특히 물리학, 컴퓨터 그래픽스, 확률론, 통계학 등에서 중요한 역할을 합니다. 행렬에 대한 주요 연산은 다음과 같습니다:\n\n덧셈: 같은 크기의 두 행렬에 대해서만 정의되며, 대응하는 원소끼리 더합니다.\n스칼라배: 행렬의 각 원소에 스칼라를 곱하는 연산입니다.\n곱셈: 첫 번째 행렬의 열의 수와 두 번째 행렬의 행의 수가 같을 때 정의됩니다. 결과 행렬의 각 원소는 첫 번째 행렬의 행과 두 번째 행렬의 열의 원소를 곱한 후 합한 값입니다.\n전치 행렬: 행과 열을 교환한 행렬입니다. 즉, 원래 행렬의 \\(i\\)- 행, \\(j\\)- 열의 원소가 전치 행렬에서는 \\(j\\)- 행, \\(i\\)- 열의 원소가 됩니다.16\n역행렬: 정방행렬 (정사각 행렬) 에 대해서만 정의되며, 행렬 곱셈의 역원 역할을 합니다. 모든 정방행렬이 역행렬을 가지는 것은 아닙니다.\n행렬식: 정방행렬에 대해 정의되는 값으로, 행렬의 특성을 나타냅니다. 기하학적으로는 행렬이 나타내는 변환의 부피 스케일링을 의미합니다.17"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#다변수-함수",
    "href": "posts/qmd/guide_ML4math.html#다변수-함수",
    "title": "머신러닝을 위한 수학",
    "section": "4.1 다변수 함수",
    "text": "4.1 다변수 함수\n관련개념: 함수, 편미분\n다변수 함수는 두 개 이상의 독립변수를 가지는 함수를 의미합니다. 단변수 함수의 개념을 고차원으로 확장한 것으로 더 복잡한 현상을 수학적으로 표현할 때 사용합니다. 주요 특징과 정의는 다음과 같습니다:\n\n정의: 다변수 함수는 여러 개의 입력 변수를 받아 하나의 출력값을 반환하는 함수입니다. 일반적으로 다음과 같이 표현됩니다: \\(f(x_1, x_2, ..., x_n) = y\\) 여기서 \\(x_1, x_2, ..., x_n\\) 은 독립변수이고, \\(y\\) 는 종속변수입니다.\n정의역: 다변수 함수의 정의역은 n 차원 공간의 부분집합입니다. 예를 들어, 2 변수 함수의 경우 정의역은 2 차원 평면의 일부가 됩니다.\n치역: 함수의 출력값들의 집합으로 일반적으로 실수 집합의 부분집합입니다.\n그래프: 다변수 함수의 그래프는 \\(n+1\\) 차원 공간에 존재합니다. 예를 들어, 2 변수 함수의 그래프는 3 차원 공간에 표현됩니다.\n연속성과 미분가능성: 단변수 함수와 마찬가지로 다변수 함수도 연속성과 미분가능성을 가질 수 있습니다. 다만, 이를 판단하는 기준이 더 복잡해집니다.\n편미분: 다변수 함수에서는 각 변수에 대한 편미분을 고려해야 합니다. 이는 다른 변수들을 상수로 취급하고 한 변수에 대해서만 미분하는 것을 의미합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#편미분",
    "href": "posts/qmd/guide_ML4math.html#편미분",
    "title": "머신러닝을 위한 수학",
    "section": "4.2 편미분",
    "text": "4.2 편미분\n관련개념: 극한과 미분, 벡터, 전미분, 전미분과 함성함수\n편미분은 다변수 함수에서 특정 변수에 대해 미분하는 것을 의미합니다. 편미분의 주요 특징과 정의는 다음과 같습니다:\n\n정의: 다변수 함수 \\(f(x, y, z, ...)\\) 에서 한 변수에 대해서만 미분하고 나머지 변수들은 상수로 취급하여 미분하는 것입니다.\n표기법: 편미분은 일반적으로 \\(∂\\) 기호를 사용하여 표현합니다. 예를 들어, \\(f(x,y)\\) 의 \\(x\\) 에 대한 편미분은 \\(∂f/∂x\\) 로 표기합니다.\n계산 방법: 편미분을 계산할 때는 미분하려는 변수 이외의 모든 변수를 상수로 취급하고 일반적인 미분 규칙을 적용합니다.\n기하학적 의미: 편미분은 다변수 함수의 그래프에서 특정 방향으로의 기울기를 나타냅니다.\n전미분과의 관계: 모든 변수에 대한 편미분을 종합하여 전미분을 구할 수 있습니다.\n\n편미분은 복잡한 다변수 함수의 동작을 이해하고 분석하는 데 중요한 도구로, 현대 과학과 공학의 여러 분야에서 핵심적인 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#전미분",
    "href": "posts/qmd/guide_ML4math.html#전미분",
    "title": "머신러닝을 위한 수학",
    "section": "4.3 전미분",
    "text": "4.3 전미분\n관련개념: 편미분, 극한과 미분, 전미분과 합성함수, 경사하강법\n전미분은 다변수 함수의 변화량을 특정 지점에서 근사화하는 방법으로, 각 변수의 변화에 따른 함수 값의 총 변화를 나타냅니다. 전미분은 다변수 함수의 변화를 이해하고 분석하는 데 중요한 도구로, 특히 복잡한 시스템의 근사해를 구하는 데 유용합니다.18 전미분은 다음과 같이 정의할 수 있습니다:\n\n정의: 다변수 함수 \\(f(x_1, x_2, \\ldots, x_n)\\) 의 전미분은 각 변수의 작은 변화에 대한 함수의 총 변화량을 근사화하는 선형 표현입니다. 이는 함수의 변화량을 각 변수의 변화량에 비례하여 나타냅니다.\n수식: 함수 \\(f(x, y)\\) 의 전미분은 다음과 같이 표현됩니다: \\[\ndf = \\frac{\\partial f}{\\partial x} dx + \\frac{\\partial f}{\\partial y} dy\n\\] 여기서 \\(\\frac{\\partial f}{\\partial x}\\) 와 \\(\\frac{\\partial f}{\\partial y}\\) 는 각각 \\(x\\) 와 \\(y\\) 에 대한 편미분이며, \\(dx\\) 와 \\(dy\\) 는 \\(x\\) 와 \\(y\\) 의 작은 변화량입니다.\n기하학적 의미: 전미분은 함수의 그래프에서 접평면의 방정식을 구성하며, 이는 함수의 변화율을 각 변수 방향으로 나타내는 벡터의 합으로 이해할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#전미분과-합성함수",
    "href": "posts/qmd/guide_ML4math.html#전미분과-합성함수",
    "title": "머신러닝을 위한 수학",
    "section": "4.4 전미분과 합성함수",
    "text": "4.4 전미분과 합성함수\n관련개념: 편미분, 전미분, 합성함수의 미분\n전미분과 합성함수는 모두 복잡한 함수의 변화를 분석하는 데 중요한 도구입니다. 전미분은 다변수 함수의 전체적인 변화를 이해하는 데 사용되며, 합성함수는 여러 단계의 변환을 거치는 함수를 다룰 때 유용합니다.\n전미분: 전미분은 다변수 함수의 모든 변수에 대한 변화를 동시에 고려한 미분입니다.\n\n다변수 함수 \\(f(x, y, ...)\\) 의 전미분은 각 변수의 편미분을 모두 더한 형태로 표현됩니다.\n예를 들어, 2 변수 함수 \\(f(x, y)\\) 의 전미분은 다음과 같이 정의됩니다: \\[df = (∂f/∂x)dx + (∂f/∂y)dy\\]\n여기서 \\(∂f/∂x\\) 와 \\(∂f/∂y\\) 는 각각 \\(x\\) 와 \\(y\\) 에 대한 편미분이며, \\(dx\\) 와 \\(dy\\) 는 \\(x\\) 와 \\(y\\) 의 미소 변화량을 나타냅니다.\n\n합성함수: 합성함수는 두 개 이상의 함수를 연속적으로 적용하여 만든 새로운 함수입니다.\n\n함수 \\(f\\) 와 \\(g\\) 가 있을 때, \\((g ∘ f)(x) = g(f(x))\\) 로 정의되는 함수를 \\(f\\) 와 \\(g\\) 의 합성함수라고 합니다.\n합성함수는 한 함수의 출력을 다른 함수의 입력으로 사용하는 것을 의미합니다.\n합성함수의 미분에는 연쇄법칙이 적용됩니다. 즉, \\((g ∘ f)'(x) = g'(f(x)) · f'(x)\\) 입니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#손실함수",
    "href": "posts/qmd/guide_ML4math.html#손실함수",
    "title": "머신러닝을 위한 수학",
    "section": "4.5 손실함수",
    "text": "4.5 손실함수\n관련개념: 미분과 적분, 편미분, 가능도함수와 최대가능도 추정, 경사하강법\n손실함수는 모델이 예측한 값과 실제 정답 사이의 차이를 수치화하는 함수입니다. 이는 모델이 얼마나 잘못 예측하고 있는지를 측정하는 도구로, 학습 과정에서 모델의 성능을 개선하는 데 사용됩니다.\n\n4.5.1 역할\n\n성능 평가: 모델의 예측 정확도를 평가합니다.\n학습 방향 제시: 손실값을 최소화하는 방향으로 모델을 조정합니다.\n최적화 기준: 모델 파라미터를 조정하는 기준이 됩니다.\n\n\n\n4.5.2 주요 손실함수 종류\n회귀 문제에서의 손실함수:\n\nMSE (Mean Squared Error): 가장 기본적인 손실함수, 예측값과 실제값의 차이를 제곱하여 평균을 냄, 이상치에 민감할 수 있음.\nMAE (Mean Absolute Error): 예측값과 실제값의 절대 차이의 평균, MSE 에 비해 이상치에 덜 민감함.\nRMSE (Root Mean Squared Error): MSE 에 제곱근을 취한 값\n\n분류 문제에서의 손실함수:\n\n엔트로피 개념을 활용한 손실함수를 주로 사용합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#경사하강법",
    "href": "posts/qmd/guide_ML4math.html#경사하강법",
    "title": "머신러닝을 위한 수학",
    "section": "4.6 경사하강법",
    "text": "4.6 경사하강법\n관련개념: 극대와 극소, 내적\n경사하강법 (Gradient Descent) 은 주어진 함수의 최소값을 찾기 위한 최적화 알고리즘입니다. 이 방법은 함수의 기울기 (gradient) 를 이용하여 함수의 값을 점진적으로 줄여나가는 방식으로 작동합니다. 경사하강법은 함수의 최적화 문제를 해결하는 데 중요한 도구로, 특히 기계 학습에서 모델의 학습과 최적화에 사용됩니다 .경사하강법의 주요 특징은 다음과 같습니다:\n\n목적: 경사하강법은 함수의 최소값을 찾는 것을 목표로 합니다. 이는 손실 함수 (loss function) 를 최소화하는 데 사용되며, 특히 기계 학습에서 모델의 최적화에 널리 활용됩니다.\n작동 원리:\n\n함수의 현재 위치에서의 기울기를 계산합니다.\n기울기의 반대 방향으로 일정한 크기 (step size 또는 learning rate) 만큼 이동합니다.\n이 과정을 반복하여 함수의 값을 점진적으로 줄입니다.\n\n수식:\n\n변수 \\(\\theta\\) 에 대해 경사하강법의 업데이트 규칙은 다음과 같이 표현됩니다: \\[\n\\theta := \\theta - \\alpha \\nabla f(\\theta)\n\\] 여기서 \\(\\alpha\\) 는 학습률 (learning rate), \\(\\nabla f(\\theta)\\) 는 함수 \\(f\\) 의 \\(\\theta\\) 에서의 기울기입니다.\n\n변형: 경사하강법에는 여러 변형이 존재합니다. 예를 들어, 확률적 경사하강법 (Stochastic Gradient Descent, SGD) 은 데이터의 전체 집합 대신 무작위로 선택된 일부 데이터를 사용하여 기울기를 계산합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#지수함수",
    "href": "posts/qmd/guide_ML4math.html#지수함수",
    "title": "머신러닝을 위한 수학",
    "section": "5.1 지수함수",
    "text": "5.1 지수함수\n관련개념: 로그함수, 시그모이드 함수, 소프트맥스 함수, 확률밀도함수와 확률분포함수\n지수함수는 일반적으로 \\(f(x) = a^x\\) 형태로 표현되며, 여기서 \\(a\\) 는 양의 상수 (기저, base) 이고, \\(x\\) 는 지수입니다. 가장 흔히 사용되는 기저는 자연상수 \\(e\\) 로, 이 경우의 지수함수는 \\(f(x) = e^x\\) 입니다.\n\n특징:\n\n연속성과 미분 가능성: 지수함수는 모든 실수 \\(x\\) 에 대해 연속적이며 미분 가능합니다.\n증가 또는 감소: 기저 \\(a\\) 가 1 보다 크면 함수는 증가하고, 0 보다 크고 1 보다 작으면 함수는 감소합니다.\n고유한 미분 특성: 특히 \\(f(x) = e^x\\) 의 경우, 미분해도 자기 자신이 되는 고유한 성질을 가집니다. 즉, \\(\\frac{d}{dx} e^x = e^x\\)."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#로그함수",
    "href": "posts/qmd/guide_ML4math.html#로그함수",
    "title": "머신러닝을 위한 수학",
    "section": "5.2 로그함수",
    "text": "5.2 로그함수\n관련개념: 합성함수와 역함수, 로그함수와 미분, 가능도함수와 최대가능도 추정\n로그함수는 지수함수의 역함수로 정의되며, 다음과 같은 특징을 가집니다:\n\n정의: 로그함수는 일반적으로 \\(y = \\log_a x\\) 형태로 표현됩니다. 여기서 \\(a\\) 는 로그의 밑 (base) 이며, \\(x\\) 는 진수입니다. 이는 \\(a^y = x\\) 와 동일한 의미를 가집니다.\n주요 성질:\n\n로그함수는 양수에 대해서만 정의됩니다. 즉, \\(x &gt; 0\\) 일 때만 정의됩니다.\n\\(\\log_a 1 = 0\\) (모든 양의 실수 \\(a\\) 에 대해)\n\\(\\log_a a = 1\\)\n로그함수는 단조 증가 함수입니다.\n\n\n\n\n\n\n\n\nNote\n\n\n\n 단조 증가 함수란 x 값이 증가할 때 y 값도 항상 증가하거나 같은 값을 유지하는 함수를 말합니다. 이 성질 때문에 로그함수는 넓은 범위의 값을 좁은 범위로 압축하는 데 유용하게 사용됩니다. 예를 들어, 지진의 규모나 소리의 강도를 표현하는 데 사용됩니다.\n\n\n\n특별한 경우:\n\n자연로그: \\(\\ln x = \\log_e x\\) (밑이 자연상수 \\(e\\) 인 경우)\n상용로그: \\(\\log x = \\log_{10} x\\) (밑이 10 인 경우)\n\n로그의 성질:\n\n곱의 로그: \\(\\log_a (xy) = \\log_a x + \\log_a y\\)\n몫의 로그: \\(\\log_a (x/y) = \\log_a x - \\log_a y\\)\n거듭제곱의 로그: \\(log_a (x^n) = n \\log_a x\\)"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#로그함수의-미분",
    "href": "posts/qmd/guide_ML4math.html#로그함수의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "5.3 로그함수의 미분",
    "text": "5.3 로그함수의 미분\n관련개념: 극한과 미분, 지수함수의 미분, 가능도함수와 최대가능도 추정\n로그함수의 미분은 다음과 같이 정의됩니다:\n\n자연로그 함수 \\(ln(x)\\) 의 미분: \\[ \\frac{d}{dx} \\ln(x) = \\frac{1}{x}, \\quad x &gt; 0 \\]\n일반적인 로그함수 \\(log_a(x)\\) 의 미분: \\[ \\frac{d}{dx} \\log_a(x) = \\frac{1}{x \\ln(a)}, \\quad x &gt; 0, a &gt; 0, a \\neq 1 \\]\n\n로그함수의 주요 특징은 다음과 같습니다:\n\n로그함수의 미분은 항상 함수 자체의 역수에 비례합니다.\n자연로그의 경우, 미분 결과가 단순히 \\(1/x\\) 로 나타납니다. 이는 자연로그가 미분 관점에서 가장 단순한 형태를 가진다는 것을 보여줍니다.\n일반 로그함수의 경우, 밑 (base) 에 따라 추가적인 상수 \\(1/ln(a)\\) 가 곱해집니다.\n로그함수의 미분은 \\(x &gt; 0\\) 인 양수 영역에서만 정의됩니다. 이는 로그함수 자체가 양수 영역에서만 정의되기 때문입니다.\n로그함수의 미분은 \\(x\\) 가 증가함에 따라 감소하는 형태를 보입니다. 이는 로그함수의 증가 속도가 \\(x\\) 가 커질수록 느려짐을 의미합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#지수함수의-미분",
    "href": "posts/qmd/guide_ML4math.html#지수함수의-미분",
    "title": "머신러닝을 위한 수학",
    "section": "5.4 지수함수의 미분",
    "text": "5.4 지수함수의 미분\n관련개념: 합성함수의 미분, 시그모이드 함수\n지수함수의 미분은 다음과 같이 정의됩니다:\n\n자연지수 함수 \\(e^x\\) 의 미분: \\[ \\frac{d}{dx} e^x = e^x \\] 이는 자연지수 함수의 가장 중요한 특징 중 하나로, 미분해도 자기 자신이 됩니다.\n일반적인 지수함수 a^x 의 미분 (\\(a &gt; 0, a ≠ 1\\)): \\[ \\frac{d}{dx} a^x = a^x \\ln(a) \\]\n\n이 정의의 주요 특징은 다음과 같습니다:\n\n지수함수의 미분은 항상 자기 자신에 비례합니다. 이는 지수함수의 성장률이 함수값에 비례한다는 것을 의미합니다.\n자연지수 함수 \\(e^x\\) 의 경우, 미분 결과가 단순히 자기 자신이 됩니다. 이는 \\(e^x\\) 가 미분 관점에서 가장 단순한 형태를 가진다는 것을 보여줍니다.\n일반 지수함수의 경우, 밑 (base) 에 따라 추가적인 상수 \\(ln(a)\\) 가 곱해집니다.\n지수함수의 미분은 모든 실수에 대해 정의되며, 항상 양수입니다 (\\(a &gt; 0\\) 인 경우).\n지수함수의 미분은 \\(x\\) 가 증가함에 따라 지수적으로 증가하는 형태를 보입니다. 이는 지수함수의 성장 속도가 \\(x\\) 가 커질수록 빨라짐을 의미합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#시그모이드-함수",
    "href": "posts/qmd/guide_ML4math.html#시그모이드-함수",
    "title": "머신러닝을 위한 수학",
    "section": "5.5 시그모이드 함수",
    "text": "5.5 시그모이드 함수\n관련개념: 다항식의 미분, 지수함수의 미분, 합성함수의 미분, 로그함수\n시그모이드 함수 (Sigmoid function) 는 S 자 모양의 곡선을 그리는 함수로, 주로 기계학습과 신경망에서 활성화 함수로 사용됩니다. 시그모이드 함수의 정의와 주요 특징은 다음과 같습니다:\n\n정의: 시그모이드 함수는 일반적으로 다음과 같이 정의됩니다: \\[ f(x) = \\frac{1}{1 + e^{-x}} \\] 여기서 \\(e\\) 는 자연상수 (약 2.71828) 입니다.\n특징:\n\n함수의 출력 범위는 0 에서 1 사이입니다.\n\\(x\\) 가 음의 무한대로 갈 때 함수값은 0 에 가까워지고, 양의 무한대로 갈 때 1 에 가까워집니다.\n\\(x = 0\\) 일 때 함수값은 0.5 입니다.\n함수는 연속적이며 모든 점에서 미분 가능합니다.\n\n미분: 시그모이드 함수의 미분은 다음과 같습니다: \\[ f'(x) = f(x)(1 - f(x)) \\] 이 특성은 신경망의 역전파 알고리즘에서 중요하게 사용됩니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#소프트맥스-함수",
    "href": "posts/qmd/guide_ML4math.html#소프트맥스-함수",
    "title": "머신러닝을 위한 수학",
    "section": "5.6 소프트맥스 함수",
    "text": "5.6 소프트맥스 함수\n관련개념: 합성함수의 미분, 시그모이드함수, 몫의 미분, 편미분\n소프트맥스 함수는 다중 클래스 분류 문제에서 주로 사용되는 함수로, 주어진 입력 벡터를 확률 분포로 변환하는 역할을 합니다. 이 함수는 다음과 같은 특징과 정의를 가집니다:\n\n정의: 소프트맥스 함수는 \\(k\\) 차원의 입력 벡터 \\(z\\) 를 받아 각 클래스에 대한 확률을 계산합니다. 각 클래스 \\(i\\) 에 대한 확률 \\(p_i\\) 는 다음과 같이 정의됩니다:\n\\[ p_i = \\frac{e^{z_i}}{\\sum_{j=1}^{k} e^{z_j}} \\]\n여기서 \\(e\\) 는 자연상수이고, \\(z_i\\) 는 입력 벡터의 \\(i\\) 번째 요소입니다.\n특징:\n\n확률 분포: 소프트맥스 함수의 출력은 확률 분포를 이루며, 모든 출력 값의 합은 1 이 됩니다.\n분류 작업: 각 요소가 특정 클래스에 속할 확률을 나타내므로, 다중 클래스 분류 작업에 적합합니다.19\n\n응용:\n\n신경망의 출력층: 신경망에서 소프트맥스 함수는 출력층에 사용되어 각 클래스에 대한 확률을 계산합니다.\n역전파 가능: 미분 가능하기 때문에 신경망의 학습 과정에서 역전파 알고리즘을 통해 최적화할 수 있습니다.20"
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#확률변수와-확률-분포",
    "href": "posts/qmd/guide_ML4math.html#확률변수와-확률-분포",
    "title": "머신러닝을 위한 수학",
    "section": "6.1 확률변수와 확률 분포",
    "text": "6.1 확률변수와 확률 분포\n확률변수는 확률적인 결과에 따라 값이 바뀌는 변수를 의미합니다. 이는 확률실험의 가능한 결과에 수치적 값을 할당하는 함수로 이해할 수 있습니다. 확률변수는 다음과 같은 유형으로 나뉩니다:\n\n이산확률변수: 가능한 값이 유한하거나 셀 수 있는 경우. 예를 들어, 주사위를 던졌을 때 나오는 숫자.\n연속확률변수: 가능한 값이 연속적인 경우. 예를 들어, 특정 구간 내에서의 온도 측정값.\n\n확률변수는 측정 가능한 함수로, 확률공간에서 정의되며, 일반적으로 실수값을 가집니다.21\n확률 분포는 확률변수가 취할 수 있는 값과 그 값이 발생할 확률을 나타내는 함수입니다. 확률 분포는 확률변수의 유형에 따라 다음과 같이 구분됩니다:\n\n이산확률분포: 이산확률변수의 확률 분포로, 각 가능한 값에 대해 확률을 할당합니다. 예를 들어, 이항분포, 포아송분포 등이 있습니다.\n연속확률분포: 연속확률변수의 확률 분포로, 확률 밀도 함수를 통해 정의됩니다. 예를 들어, 정규분포, 지수분포 등이 있습니다.\n\n확률 분포는 확률변수의 특성을 설명하고, 데이터 분석 및 예측 모델링에 필수적인 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#확률밀도함수와-확률분포함수",
    "href": "posts/qmd/guide_ML4math.html#확률밀도함수와-확률분포함수",
    "title": "머신러닝을 위한 수학",
    "section": "6.2 확률밀도함수와 확률분포함수",
    "text": "6.2 확률밀도함수와 확률분포함수\n관련개념: 극한과 미분, 적분, 지수함수\n확률밀도함수 (Probability Density Function, PDF): 확률밀도함수는 연속 확률변수의 확률 분포를 나타내는 함수입니다. 특정 구간 내에서 확률변수가 취할 수 있는 값의 확률을 나타내며, 특정 값에서의 확률은 정의되지 않습니다.\n\n확률밀도함수의 적분은 확률을 나타내며, 전체 영역에 대한 적분은 1 이 됩니다.\n특정 구간 \\([a, b]\\) 에서 확률변수가 존재할 확률은 확률밀도함수를 해당 구간에서 적분한 값으로 계산됩니다.\n특정 값에서의 확률은 0 이지만, 구간을 통해 확률을 계산합니다.22\n\n확률분포함수 (Probability Distribution Function, CDF): 확률분포함수는 확률변수가 특정 값 이하일 확률을 나타내는 함수입니다. 이산 확률변수와 연속 확률변수 모두에 대해 정의됩니다.\n\n확률분포함수는 단조 증가 함수이며, 0 에서 1 사이의 값을 가집니다.\n연속 확률변수의 경우, 확률밀도함수의 적분으로 표현할 수 있습니다.\n이산 확률변수의 경우, 각 값의 확률을 누적하여 나타냅니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#가능도함수와-최대가능도-추정",
    "href": "posts/qmd/guide_ML4math.html#가능도함수와-최대가능도-추정",
    "title": "머신러닝을 위한 수학",
    "section": "6.3 가능도함수와 최대가능도 추정",
    "text": "6.3 가능도함수와 최대가능도 추정\n관련개념: 극대와 극소, 로그함수, 로그함수의 미분, 확률밀도함수와 확률분포함수\n가능도 함수 (Likelihood Function): 가능도 함수는 주어진 데이터가 특정한 확률 분포를 따를 확률을 나타내는 함수입니다. 이는 주로 모수 추정에서 사용되며, 특정 모수 값이 주어졌을 때 관측된 데이터가 발생할 가능성을 계산합니다.\n\n표기: 일반적으로 가능도 함수는 \\(L(\\theta | x)\\) 로 표현되며, 여기서 \\(\\theta\\) 는 모수 (parameter), \\(x\\) 는 관측된 데이터입니다.\n특징: 가능도 함수는 확률 분포의 모수에 대한 함수로, 데이터가 주어졌을 때 모수가 어떤 값을 가질 가능성이 높은지를 평가합니다.\n\n최대가능도 추정 (Maximum Likelihood Estimation, MLE): 최대가능도 추정은 가능도 함수를 최대화하는 모수 값을 찾는 방법입니다. 즉, 주어진 데이터에 대해 가장 가능성이 높은 모수 값을 추정하는 방법입니다.\n\n방법: MLE 는 가능도 함수의 최대값을 찾는 최적화 문제로, 보통 미분을 통해 가능도 함수의 극대점을 찾습니다.\n응용: MLE 는 다양한 통계 모델에서 모수 추정에 널리 사용되며, 특히 회귀 분석, 분류 문제, 베이지안 통계 등에서 중요한 역할을 합니다."
  },
  {
    "objectID": "posts/qmd/guide_ML4math.html#footnotes",
    "href": "posts/qmd/guide_ML4math.html#footnotes",
    "title": "머신러닝을 위한 수학",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://thebook.io/007019/↩︎\nhttps://darkpgmr.tistory.com/45↩︎\nhttps://darkpgmr.tistory.com/45↩︎\nhttps://namu.wiki/w/%ED%95%A8%EC%88%98↩︎\nhttps://holymath.tistory.com/entry/%ED%95%A9%EC%84%B1%ED%95%A8%EC%88%98%EC%9D%98-%EA%B8%B0%EB%B3%B8%EC%84%B1%EC%A7%88↩︎\nhttps://namu.wiki/w/%ED%95%A8%EC%88%98↩︎\nhttps://ko.wikipedia.org/wiki/%EC%A0%81%EB%B6%84↩︎\nhttps://namu.wiki/w/%EC%A0%81%EB%B6%84↩︎\nhttps://unolab.tistory.com/entry/%EC%A0%81%EB%B6%84%EC%9D%98-%EC%A0%95%EC%9D%98-%EC%A0%95%EC%A0%81%EB%B6%84%EC%9D%98-%EC%A0%95%EC%9D%98↩︎\nhttps://www.youtube.com/watch?v=LEr4RdMxpLY↩︎\nhttps://www.youtube.com/watch?v=LsQoiETuBBc↩︎\nhttps://angeloyeo.github.io/2020/09/07/basic_vector_operation.html↩︎\nhttps://blog.naver.com/pss2072/220798287435↩︎\nhttps://namu.wiki/w/%EB%82%B4%EC%A0%81↩︎\nhttps://wikidocs.net/24603↩︎\nhttp://bigdata.dongguk.ac.kr/lectures/disc_math/_book/matrix.html↩︎\nhttps://minusi.tistory.com/entry/%ED%96%89%EB%A0%AC-%EB%8C%80%EC%88%98↩︎\nhttps://namu.wiki/w/%EB%AF%B8%EB%B6%84%ED%98%95%EC%8B%9D↩︎\nhttps://syj9700.tistory.com/38↩︎\nhttps://hyunhp.tistory.com/696↩︎\nhttps://www.datadata.link/qa66/↩︎\nhttps://www.youtube.com/watch?v=S1WIW662LJQ↩︎"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#레벨-1",
    "href": "posts/qmd/learn_pythonCoding.html#레벨-1",
    "title": "파이썬 코딩 팁",
    "section": "1.1 레벨 1",
    "text": "1.1 레벨 1\n\n1.1.1 기본적인 명명법\n함수나 변수(Variables)를 명명할 때는 아래의 규칙을 따르는 것이 좋습니다.\n\n1.1.1.1 변수, 함수, 메소드, 모듈\n소문자만 사용하고 필요에 따라 언더스코어(_)로 단어를 구분하는 스네이크 표기법을 따르세요. 읽는 사람이 쉽게 이해할 수 있도록 하는 것이 중요합니다. 예를 들어 test_set이 있습니다.\n\n\n1.1.1.2 클래스명\n클래스의 이름은 첫 글자를 대문자로 작성하고, 단어는 언더스코어가 아닌 대문자로 구별합니다. 예시로 ClassAll이 있습니다.\n\n1.1.1.2.1 클래스 내에서만 사용되는 프라이빗 변수\n변수명 맨 앞에 언더스코어를 붙여야 합니다. 예를 들어 _single_leading_underscores가 있습니다. 클래스 내에서만 사용되는 프라이빗 메소드 또한 메소드명 앞에 언더스코어를 붙입니다. 예시로 _single_leading_underscore(self, ...)가 있습니다.\n\n\n\n1.1.1.3 상수 (Constants)\n상수는 값이 변하지 않으므로 대문자만 사용하여 명명합니다. 단어들은 언더스코어(_)로 구분합니다. 예시로 ALL_CAPS_WITH_UNDERSCORES가 있습니다.\n\n\n1.1.1.4 패키지명\n패키지명은 소문자만 사용해야 합니다. 예시로 lowers가 있습니다.\n\n\n\n\n\n\nNote\n\n\n\n\n함수와 메소드의 차이점: 함수는 클래스 안에 독립적으로 존재하며, 메소드는 클래스 내에 있는 함수를 의미합니다.\n모듈과 패키지: 패키지는 가장 상위 레벨이며, 모듈은 패키지 내의 파일을 의미합니다. 예를 들어 sklearn은 패키지이고, sklearn.linear_model은 모듈입니다.\n\n\n\n\n\n1.1.1.5 명명법 1: 장황한 부분 제거하기\n클래스의 메소드 이름에는 클래스명이 반복되어서는 안 됩니다. 예를 들어 class_1.class_1_max_length = 10보다 class_1.max_length = 10이 더 적절합니다. 즉, 미리 클래스명.변수명을 고려하여 명명해야 합니다.\n\n\n1.1.1.6 라이브러리 import 규칙\n\n1.1.1.6.1 라이브러리 순서\n외부 클래스나 함수를 import할 때 주의해야 할 점은 다음 세 가지입니다. 첫 번째는 import하는 순서입니다. 아래와 같은 순서로 라이브러리를 불러오세요.\n#| echo: false\nimport 표준라이브러리\nimport 서드파티라이브러리\nimport 개인적으로_작성한라이브러리\n모듈 단위로 불러오는 것이 좋습니다. 예를 들어 from pkg.module_1 import class_1 대신 from pkg import module_1으로 하고, 이후에 my_class = module_1.class_1()과 같이 코드를 작성합니다.\n\n\n1.1.1.6.2 여러 라이브러리를 한 줄에 불러오지 않기\n#| echo: false\nimport pkg, pkg2  # 이 경우 아래와 같이 한 줄씩 작성합니다.\n\nimport pkg\nimport pkg2\n\n# 그러나 모듈의 경우 한 줄에 여러 개를 가져와도 괜찮습니다.\nfrom pkg import module_1, module_2\n\n\n\n\n1.1.2 재현성을 위해 seed 고정하기\n데이터 분석의 재현성을 위해 seed 값을 지정하는 것이 좋습니다.\nimport os\nimport random\nimport numpy as np\nimport torch\n\nSEED_VALUE = 42  # 값은 무엇이든 괜찮습니다.\nos.environ['PYTHONHASHSEED'] = str(SEED_VALUE)\nrandom.seed(SEED_VALUE)\nnp.random.seed(SEED_VALUE)\ntorch.manual_seed(SEED_VALUE)  # PyTorch의 경우\nPyTorch에서 GPU를 사용해 연산하는 경우에는 아래와 같이 설정해야 합니다. 다만 계산 속도가 떨어지기 때문에 추천하지는 않습니다.\ntorch.backends.cudnn.deterministic = True\ntorch.backends.cudnn.benchmark = False\nScikit-learn의 경우 각 알고리즘에 seed 값을 정하는 부분이 있습니다. 예를 들어 아래와 같습니다.\nfrom sklearn.linear_model import LogisticRegression\n\nSEED_VALUE = 42\nclf = LogisticRegression(random_state=SEED_VALUE)"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#레벨-2",
    "href": "posts/qmd/learn_pythonCoding.html#레벨-2",
    "title": "파이썬 코딩 팁",
    "section": "1.2 레벨 2",
    "text": "1.2 레벨 2\n\n1.2.1 역방향 변수 명명 (Reverse Notation)\n예를 들어 a의 길이, b의 길이, c의 길이와 같은 세 가지 변수를 만들고 싶다면, a_length, b_length, c_length 대신 length_a, length_b, length_c로 작성하는 것이 좋습니다. 이렇게 하면 단어의 앞부분이 동일해져 코드가 더 읽기 쉬워집니다. 만약 특정 변수인 a에 더 집중하고 싶다면, a_length, a_width, a_max_length와 같이 작성할 수 있습니다. 주목해야 할 대상을 변수명 앞에 두어 통일성을 유지하는 것이 바람직합니다.\n\n\n1.2.2 SOLID 원칙 따르기\nSOLID는 로버트 마틴이 제안한 소프트웨어 설계 원리입니다. 모든 원리를 알 필요는 없지만, 첫 번째 원칙인 단일 책임 원리(Single Responsibility Principle)는 반드시 기억해야 합니다.\n단일 책임 원리는 “함수나 클래스, 메소드는 단 하나의 책임만을 가져야 한다”는 의미입니다. 여기서 “단 하나”의 정의가 다소 모호할 수 있지만, 가능한 한 함수나 클래스, 메소드를 짧게 작성하여 상위 개념 변경에 영향을 받도록 하라는 의미로 이해하면 됩니다.\n데이터 사이언티스트나 AI 엔지니어가 수행하는 작업은 보통 “데이터 전처리, 학습, 추론”과 같은 정형화된 흐름으로 진행됩니다. 따라서 구현하는 프로그램도 이러한 순서를 따르게 되며, 하나의 메인 클래스나 메소드가 비대해지고 여러 작업(책무)을 수행하게 되는 경우가 많습니다.\nJupyter Notebook에서 그치는 수준이라면 괜찮지만, 시스템 개발에 데이터 과학이나 AI를 도입하기 위해서는 이러한 상태가 바람직하지 않습니다.\nAI 시스템에서 SoE(System of Engagement)의 개발은 SoR(System of Records)와 같이 요구 사항 정의 및 외부/내부 설계를 철저히 하는 워터폴 개발 방식이 아닌 애자일 개발 형태가 많습니다. 애자일 개발에서는 CI(Continuous Integration), 즉 자동 테스트를 실시하는 것이 기본입니다. 따라서 실제로 프로토타입을 만들고 동작을 살펴본 후 개선점을 발견하여 더 나은 결과물을 만드는 것이 목표입니다.\n이러한 “개선” 과정에서 단일 클래스나 메소드의 책임이 클수록 수정해야 할 코드의 양도 많아집니다. 수정해야 할 코드가 많으면 영향 범위도 커지고, 새로운 단위 테스트를 작성해야 할 필요성도 증가합니다. 동시에 기존에 작성한 단위 테스트도 대부분 무용지물이 될 수 있습니다.\n단위 테스트의 대폭적인 수정이나 변화가 빈번하게 발생하는 상황에서 개발을 진행하면, 단위 테스트를 제대로 수행할 수 없게 되고 시스템 전체의 품질도 저하될 수 있습니다. 또한, 개선을 위한 수정이 예상치 못한 부분에 영향을 미쳐 버그가 발생하기 쉬워집니다.\n\n\n1.2.3 함수와 메소드에 타입 힌트 작성하기\n“SOLID의 S: 단일 책임”을 염두에 두고 함수나 메소드를 분할하면 많은 함수와 메소드가 생성됩니다. 이처럼 많은 함수와 메소드가 존재하면 이해하기 어려워질 수 있습니다. 코드 작성 시에는 괜찮지만, 3개월 후에 수정하거나 다른 사람이 코드를 사용할 때 “이 함수의 인수에는 무엇이 들어 있고, 어떤 것이 출력되는가?”라는 혼란스러운 상황이 발생할 수 있습니다.\n따라서 함수를 구현할 때 타입 힌트를 붙이는 것이 좋습니다. 타입 힌트는 아래와 같이 작성할 수 있습니다.\ndef calc_billing_amount(amount: int, price: int) -&gt; int:\n    billing_amount = amount * price\n    return billing_amount\n인수 변수의 데이터형을 인수명 뒤에 기재하여 알 수 있도록 하고, 함수에서 반환되는 변수의 데이터형도 명시해주면 좋습니다.\n타입 힌트는 강제성이 없으며, 위 예제에서 첫 번째 인수인 amount에 int가 아닌 float를 지정하고 calc_billing_amount(0.5, 100)을 실행해도 에러는 발생하지 않습니다.\n리스트나 사전형을 사용할 경우 또는 여러 데이터형을 허용하고 싶다면 다음과 같이 작성합니다.\nfrom typing import Dict, List, Union\n\ndef calc_billing_amount(\n    amount_list: List[int], price_dictionary: Dict[str, Union[int, float]]\n) -&gt; int:\n    billing_amount = 0\n    for index, (key, value) in enumerate(price_dictionary.items()):\n        billing_amount += amount_list[index] * value\n\n    return int(billing_amount)\n타입 힌트를 위해 리스트와 사전형을 사용하려면 from typing import List, Dict, Union으로 임포트합니다. 예를 들어 요소가 int형 리스트인 경우는 List[int]로 기재하고, 키가 string형이며 값이 int 또는 float일 경우는 Dict[str, Union[int, float]]로 작성합니다.\n실행하면 605가 출력됩니다.\namount = [3, 10]\nprice = {\"item1\": 100, \"item2\": 30.5}\ncalc_billing_amount(amount, price)\n타입 힌트를 작성하는 것은 번거롭지만 많은 클래스와 메소드를 파악하기 쉽게 만들어주므로 추천합니다.\n\n\n1.2.4 클래스와 메소드에는 docstring 기재하기\ndocstring은 클래스나 메소드, 함수의 사양이나 사용 방법을 설명하는 것입니다. 앞서 언급했듯이 단일 책임 원칙으로 인해 생성된 많은 클래스나 함수를 쉽게 파악하기 어려운 경우가 많습니다. 타입 힌트만으로는 여전히 알기 어렵기 때문에 상세한 설명으로 docstring을 작성하는 것이 좋습니다.\n그러나 너무 세세하게 작성하는 것은 번거로운 일이므로 프라이빗 메소드나 행 수가 적은 메소드 등은 한 줄의 docstring으로 충분하다고 생각됩니다. 반면 다른 팀원이 사용하는 클래스나 메소드 또는 AI 시스템에서 중요한 역할을 하는 주요 클래스 등은 상세한 설명이 필요합니다.\ndocstring 작성 방식은 여러 가지가 있지만 보통은 reStructuredText, Google style 또는 Numpy style이 많이 사용됩니다. 이 세 가지 중 하나를 사용하는 이유는 나중에 Sphinx를 통해 자동으로 문서화할 수 있기 때문입니다. 따라서 Sphinx에서 지원하는 docstring 형식을 채택하는 것이 좋습니다. docstring의 세 가지 종류에 대한 설명은 나중에 기회가 있을 때 다루도록 하겠습니다.\nGoogle style과 Numpy style은 길이가 길어 저는 reStructuredText style을 선호합니다. 예시는 아래와 같습니다.\nclass User:\n    \"\"\"본 시스템을 사용하는 어카운트 유저를 표시하는 클래스이다.\n    :param name: 유저명\n    :param user_type: 어카운트 타입 (admin 또는 normal)\n    \"\"\"\n\n    def __init__(self, name: str, user_type: str):\n        self.name = name\n        self.user_type = user_type\n\n    def print_user_type(self):\n        \"\"\"유저의 타입을 출력한다.\n        :param None: 입력 인수가 없다.\n        :return: user_type을 문자열로 출력한다.\n        :rtype: str\n        \"\"\"\n        print(self.user_type)\nExample까지 포함하면 매우 유용합니다. 얼마나 자세하게 쓸지는 Example이나 인수 및 반환 값 설명 후 결정하면 됩니다.\n위와 같이 적으면 VS Code 등의 에디터에서 해당 프로그램 부분에 마우스를 올리면 docstring이 표시되어 프로그램 이해를 돕습니다.\n\n\n1.2.5 학습 완료 모델과 전처리 및 하이퍼파라미터 정보 저장하기\nAI, 머신러닝 및 딥러닝에서는 학습 완료 모델만 저장하는 것이 아니라 전처리 파라미터와 모델 하이퍼파라미터 설정 등 학습 재현에 필요한 모든 정보를 저장해야 합니다.\n모든 정보가 포함되어 있으면 어떤 저장 방법을 사용하든 상관없지만 scikit-learn과 PyTorch에서 예시는 다음과 같습니다.\n\n1.2.5.1 Scikit-learn 예시\nfrom datetime import datetime, timedelta, timezone\nimport numpy as np\nfrom joblib import dump, load\nfrom sklearn.datasets import load_iris\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures, StandardScaler\n\n# iris 데이터 준비\nX, y = load_iris(return_X_y=True)\n\n# 전처리(표준화 및 제곱항 추가)\npreprocess_pipeline = Pipeline(steps=[(\"standard_scaler\", StandardScaler())])\npreprocess_pipeline.steps.append((\"polynomial_features_2\", PolynomialFeatures(2)))\n\n# 전처리 적용\nX_preprocessed = preprocess_pipeline.fit_transform(X)\n\n# 학습기 준비\nC = 1.2  # 하이퍼파라미터 설정\nmodel = LogisticRegression(random_state=0, C=C)\n\n# 학습 실시\nmodel.fit(X_preprocessed, y)\n\n# 학습 데이터 성능 평가\naccuracy_training = model.score(X_preprocessed, y)\n\n# 저장할 데이터 준비\nKST = timezone(timedelta(hours=9), \"KST\") \nnow = datetime.now(KST).strftime(\"%Y%m%d_%H%M%S\")\n\ntraining_info = {\n    \"training_data\": \"iris\",\n    \"model_type\": \"LogisticRegression\",\n    \"hyper_param_logreg_C\": C,\n    \"accuracy_training\": accuracy_training,\n    \"save_date\": now,\n}\n\nsave_data = {\n    \"preprocess_pipeline\": preprocess_pipeline,\n    \"trained_model\": model,\n    \"training_info\": training_info,\n}\nfilename = \"./iris_model_\" + now + \".joblib\"\n\n# 저장\ndump(save_data, filename)\n저장한 파일을 불러올 경우 아래와 같이 작성합니다.\nload_data = load(filename)\n\npreprocess_pipeline = load_data[\"preprocess_pipeline\"]\nmodel = load_data[\"trained_model\"]\nprint(load_data[\"training_info\"])\n위 코드의 출력은 다음과 같습니다.\n{'training_data': 'iris', 'model_type': 'LogisticRegression', 'hyper_param_logreg_C': 1.2, 'accuracy_training': 0.9866666666666667, 'save_date': '20200503_205145'}\n\n\n1.2.5.2 PyTorch 예시\nPATH = './checkpoint_' + str(epoch) + '.pt'\n\ntorch.save({\n    'epoch': epoch,\n    'total_epoch': total_epoch,\n    'model_state_dict': model.state_dict(),\n    'scheduler_state_dict': scheduler.state_dict(),\n    'optimizer_state_dict': optimizer.state_dict(),\n    'loss_train': loss_train,\n    'loss_eval': loss_eval,\n}, PATH)\n모델을 불러오는 경우 예제 코드는 다음과 같습니다.\nmodel = TheModelClass()\nscheduler = TheSchedulerClass()\noptimizer = TheOptimizerClass()\n\ncheckpoint = torch.load(PATH)\nmodel.load_state_dict(checkpoint['model_state_dict'])\nscheduler.load_state_dict(checkpoint['scheduler_state_dict'])\noptimizer.load_state_dict(checkpoint['optimizer_state_dict'])\ntotal_epoch = checkpoint['total_epoch']\nepoch = checkpoint['epoch']\nloss_train = checkpoint['loss_train']\nloss_eval = checkpoint['loss_eval']\n\nmodel.train()\n# model.eval()\n딥러닝의 데이터 세트와 데이터 로더까지 체크포인트로 저장하면 파일 크기가 너무 커지므로 별도로 저장하는 것을 추천합니다.\n# 데이터 세트 및 데이터 로더 저장\ntorch.save(trainset, './trainset.pt')\ntorch.save(trainloader, './dataloader.pt')\n다시 불러오는 코드는 다음과 같습니다.\ntrainset = torch.load('./trainset.pt')\ntrainloader = torch.load('./dataloader.pt')"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#레벨-3",
    "href": "posts/qmd/learn_pythonCoding.html#레벨-3",
    "title": "파이썬 코딩 팁",
    "section": "1.3 레벨 3",
    "text": "1.3 레벨 3\n\n1.3.1 적절한 영어 단어와 품사로 명명하기\n클래스, 메소드, 함수를 많이 만들수록 명명 규칙이 더욱 중요해집니다. 이상적으로는 이름만 보고도 “어떤 처리를 하고 있는가? 즉, 어떤 기능을 수행하며, 어떤 입력을 받고 어떤 출력을 하는가?”를 알 수 있어야 합니다.\n하지만 데이터 사이언스나 AI 분야에서는 알고리즘 자체가 복잡하기 때문에, 처음 보는 사람이 주석 없이 클래스나 메소드를 이해하기는 어렵습니다. 따라서 명명 방법은 가능한 한 의도를 명확히 전달하는 것을 목표로 해야 합니다.\n지켜야 할 최소한의 규칙은 다음과 같습니다:\n\n클래스명과 변수명은 명사로 작성합니다.\n메소드와 함수의 이름은 동사로 시작합니다.\n멤버 변수의 boolean 형은 동사로 시작하는 것이 좋습니다. 예) is_admin, has_item, can_drive 등\n코딩 규칙을 준수합니다.\n\n\n\n1.3.2 적절한 예외 처리 구현하기\n에러(예외)에 대한 try-catch 구문은 데이터 사이언티스트와 AI 엔지니어에게 매우 중요한 부분입니다. AI를 시스템에 구현할 때는 에러 핸들링이 필수적입니다. 예외가 발생하면 시스템 전체가 중단될 수 있기 때문입니다.\n따라서 구현 코드에서 try 블록이 상위 레벨에 위치하도록 하여, 코드가 try: 블록 안에 들어가지 않도록 해야 합니다. 아래 예제를 살펴보겠습니다.\n예를 들어 나눗셈 함수를 정의할 때:\ndef func_division(a, b):\n    ret = a / b\n    return ret\n위 함수에 func_division(10, 0)과 같이 입력하면 에러가 발생하여 프로그램이 중단됩니다. 따라서 예외 처리를 추가해야 합니다.\ndef func_division(a, b):\n    try:\n        ret = a / b\n        return ret\n    except:\n        print(\"예외가 발생했습니다.\")\n그러나 이것만으로는 충분하지 않습니다. 발생할 수 있는 예외를 구체적으로 처리해야 합니다.\ndef func_division(a, b):\n    try:\n        ret = a / b\n        return ret\n    except ZeroDivisionError as err:\n        print('0으로 나누는 에러가 발생했습니다:', err)\n    except Exception as err:\n        print(\"예기치 못한 에러가 발생했습니다:\", err)\n이제 이전에 발생했던 ans = func_division(10, 0)을 다시 실행하면 “0으로 나누는 에러가 발생했습니다: division by zero”라는 메시지가 출력됩니다. 또한 ans = func_division(\"hoge\", \"fuga\")를 실행하면 숫자가 아니므로 또 다른 에러가 발생합니다.\n\n\n1.3.3 적절하게 로그 출력하기\n코드의 작동을 확인하기 위해 print 문을 사용하는 습관은 좋지 않습니다. 대신 적절한 로그를 출력하도록 작성해야 합니다. 로그 사용법은 다음과 같습니다.\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# 로그에 기록할 내용\ntotal_epoch = 1000\nepoch = 100\nloss_train = 5.44444\n\n# 로그 리스트 생성\nlog_list = [total_epoch, epoch, loss_train]\n\n# 로그 기록\nlogger.info(\n    \"total_epoch: {0[0]}, epoch: {0[1]}, loss_train: {0[2]:.2f}\".format(log_list)\n)\n\n# 기록된 내용을 출력하여 확인\nprint(\"total_epoch: {0[0]}, epoch: {0[1]}, loss_train: {0[2]:.2f}\".format(log_list))\n저장된 로그를 print 문으로 확인하면 다음과 같이 출력됩니다.\ntotal_epoch: 1000, epoch: 100, loss_train: 5.44\n여기서 {0:.2f}는 .format으로 받은 리스트의 두 번째 요소를 소수점 두 자리까지 표시하는 것을 의미합니다. 로그 작성에 대한 자세한 내용은 공식 문서를 참고하세요.\n파이썬 3.8 이상을 사용하는 경우 f-string을 사용하여 다음과 같이 작성할 수 있습니다.\n# 로그에 기록할 값 설정\ntotal_epoch = 1000\nepoch = 100\nloss_train = 5.44444\n\n# 로그 기록\nlogger.info(f\"{total_epoch=}, {epoch=}, loss_train: {loss_train=:.2f}\")\n\n\n1.3.4 함수와 메소드의 인수는 3개 이하로 제한하기\n함수나 메소드의 인수는 많아도 최대 3개까지로 제한하는 것이 좋습니다. 4개 이상의 인수는 피하는 것이 바람직합니다. 인수가 많으면 해당 함수의 사용법을 이해하기 어려워지고, 단위 테스트 준비나 관리도 복잡해집니다.\n많은 인수를 다루고 싶다면 사전형 변수를 사용하여 hogehoge_config와 같은 형태로 하나의 사전 변수를 전달하는 방법이 있습니다.\n예를 들어 복잡한 계산 함수를 정의할 때:\ndef func_many_calculation(a, b, c, d, e):\n    ret = a * b * c / d / e\n    return ret\n위 함수는 ans = func_many_calculation(10, 2, 3, 5, 2)와 같이 사용하면 인수가 많아 다루기 불편하고 오류가 발생할 가능성이 높습니다. 따라서 다음과 같이 사전형으로 정의하는 것이 좋습니다.\ndef func_many_calculation(func_config):\n    a = func_config[\"a\"]\n    b = func_config[\"b\"]\n    c = func_config[\"c\"]\n    d = func_config[\"d\"]\n    e = func_config[\"e\"]\n    ret = a * b * c / d / e\n    return ret\n이렇게 하면 func_config = {\"a\": 10,\"b\": 2,\"c\": 3,\"d\": 5,\"e\": 2}를 대입하여 ans = func_many_calculation(func_config)를 실행할 수 있습니다.\n그러나 이러한 방식은 함수 정의를 더욱 복잡하게 만들 수 있으므로, 함수 정의 부분에서는 인수를 보통대로 작성하고 실행하는 부분에서는 인수를 적게 사용하는 것이 좋습니다.\ndef func_many_calculation(a, b, c, d, e):\n    ret = a * b * c / d / e\n    return ret\n\nfunc_config = {\"a\": 10, \"b\": 2, \"c\": 3, \"d\": 5, \"e\": 2}\nans = func_many_calculation(**func_config)\n\n\n1.3.5 *args, **kwargs 를 적절히 사용하기\n\n\n\n\n\n\nNote\n\n\n\nargs는 arguments, kwargs는 keyword arguments의 약어입니다.\n\n\n*args와 **kwargs는 가변 길이 인수를 나타냅니다. 여기서 *는 리스트 변수의 언팩(unpacking) 조작이며, **는 사전형 변수의 언팩 조작입니다. 가변 길이 인수를 사용하는 이유는 크게 세 가지입니다.\n첫 번째 이유는 함수의 인수에 여분의 값을 받아들이기 위해서입니다. 예를 들어 아래 함수를 실행하면 func_args_kwargs2(10, 20, 30)의 출력이 10이 되어 에러 없이 실행됩니다.\ndef func_args_kwargs2(a, *args):\n    print(a)\n두 번째 이유는 함수를 확장하여 인수를 나중에 추가하고 싶을 때입니다. 이 경우 *args로 받으면 함수 본체나 인수 정의 부분을 수정할 필요가 없습니다.\n세 번째 이유는 함수나 메소드를 실행할 때 선택적으로 전달할 수 있는 인수를 받아들이기 위해서입니다. 이때에는 기본값을 설정해 두어야 합니다. 예를 들어 다음과 같이 작성할 수 있습니다.\ndef func_args_kwargs3(a, *args, **kwargs):\n    b = kwargs.pop(\"b\", 2.0)\n    print(a * b)\n이렇게 하면 기본값을 설정하면서도 가변 길이 인수를 사용할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#레벨-4",
    "href": "posts/qmd/learn_pythonCoding.html#레벨-4",
    "title": "파이썬 코딩 팁",
    "section": "1.4 레벨 4",
    "text": "1.4 레벨 4\n\n1.4.1 if 문을 간결하게 작성하기\n파이썬에서는 if 문을 한 줄로 작성할 수 있습니다.\n# 짝수인지 홀수인지 판별\nnum = 10\n\nif num % 2 == 0:\n    print(\"짝수\")\nelse:\n    print(\"홀수\")\n위 코드는 다음과 같이 간단하게 표현할 수 있습니다.\n# 짝수인지 홀수인지 판별\nnum = 10\n\nprint(\"짝수\") if num % 2 == 0 else print(\"홀수\")\n\n\n1.4.2 sklearn 규격에 맞춰 전처리 및 모델 클래스 구현하기\nsklearn 규격이란 scikit-learn의 BaseEstimator, TransformerMixin, ClassifierMixin 등을 상속받아, scikit-learn의 다른 객체와 함께 사용될 수 있도록 구현된 클래스를 의미합니다. 자신이 만든 전처리 클래스나 모델을 sklearn 규격으로 만들면, scikit-learn의 Pipeline과 함께 사용할 수 있어 매우 편리합니다.\n예를 들어, 전처리 클래스를 구현할 때는 TransformerMixin과 BaseEstimator를 상속합니다.\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_array, check_is_fitted\n\nclass TemplateTransformer(TransformerMixin, BaseEstimator):\n    def __init__(self, demo_param='demo'):\n        self.demo_param = demo_param\n        \n    def fit(self, X, y=None):\n        X = check_array(X, accept_sparse=True)\n        self.n_features_ = X.shape[1]\n        return self\n\n    def transform(self, X):\n        \"\"\" 인수 X에 전처리를 적용한다. \"\"\"\n        check_is_fitted(self, 'n_features_')\n        X = check_array(X, accept_sparse=True)\n        X_transformed = hogehoge(X)  # 여기서 hogehoge는 실제 변환 로직으로 대체해야 합니다.\n        return X_transformed\n모델 클래스는 ClassifierMixin과 BaseEstimator를 상속하여 구현할 수 있습니다.\nfrom sklearn.base import BaseEstimator, ClassifierMixin\nfrom sklearn.utils.validation import check_array, check_is_fitted, check_X_y\n\nclass TemplateClassifier(ClassifierMixin, BaseEstimator):\n    \"\"\" 모델 클래스의 예시 \"\"\"\n    \n    def __init__(self, demo_param=\"demo\"):\n        self.demo_param = demo_param \n        \n    def fit(self, X, y):\n        X, y = check_X_y(X, y)\n        self.fugafuga = piyopiyo(X, y)  # piyopiyo는 모델 학습 로직으로 대체해야 합니다.\n        return self\n\n    def predict(self, X):\n        \"\"\" 미지의 데이터 추론 \"\"\"\n        check_is_fitted(self, [\"fugafuga\"])\n        X = check_array(X)\n        y_predicted = self.fugafuga(X)  # 여기서도 추론 로직으로 대체해야 합니다.\n        return y_predicted\nsklearn 규격으로 클래스를 구현할 때는 scikit-learn에서 제공하는 템플릿을 기반으로 변경하는 것을 추천합니다.\n\n\n1.4.3 데코레이터를 적절히 활용하기\n데코레이터는 @hogehoge와 같은 형태로 주로 메소드나 함수 위에서 사용됩니다. 파이썬에는 표준 데코레이터와 사용자 정의 데코레이터가 있습니다. 자주 사용되는 표준 데코레이터로는 @property, @staticmethod, @classmethod, @abstractmethod 등이 있습니다. 하나씩 살펴보겠습니다.\n\n1.4.3.1 @property\n@property는 클래스 외부에서 해당 멤버 변수를 변경할 수 없도록 만드는 데코레이터입니다.\nclass User:\n    def __init__(self, name: str, user_type: str):\n        self.name = name\n        self.__user_type = user_type\n\n    @property\n    def user_type(self):\n        return self.__user_type\n위의 예에서 User 클래스의 user_type은 @property로 정의되어 있습니다. 따라서 taro = User(\"taro\", \"admin\") 후에 print(taro.user_type)를 실행하면 “admin”이 출력됩니다. 그러나 taro.user_type = \"normal\"과 같이 변경하려고 하면 에러가 발생합니다. 이렇게 외부에서 변경할 수 없는 변수를 정의할 수 있습니다.\n\n\n1.4.3.2 @staticmethod 및 @classmethod\n@staticmethod와 @classmethod는 객체를 생성하지 않고도 메소드를 호출할 수 있게 해줍니다.\nclass User:\n    def __init__(self, name: str, user_type: str):\n        self.name = name\n        self.user_type = user_type\n\n    @staticmethod\n    def say_hello(name):\n        print(\"Hello \" + name)\n위와 같이 정의한 후 아래와 같이 실행하면 “Hello Hanako”가 출력됩니다.\nUser.say_hello(\"Hanako\")\n\n\n1.4.3.3 @abstractmethod\n다른 표준 Python 데코레이터인 @abstractmethod는 클래스의 메소드에 붙여 사용하며, 해당 클래스를 상속받은 자식 클래스에서 반드시 그 메소드를 구현해야 합니다. 구현하지 않으면 에러가 발생합니다. 즉, 추상 클래스를 정의하고 자식 클래스에서 메소드 구현을 강제하고 싶을 때 사용합니다.\n\n\n1.4.3.4 사용자 정의 데코레이터\n사용자 정의 데코레이터를 통해 특정 조건을 만족하는 경우에만 메소드를 실행하도록 할 수 있습니다. 예를 들어, 사용자가 ’admin’일 때만 특정 작업을 수행하도록 하는 경우입니다.\ndef admin_only(func):\n    \"\"\"데코레이터 정의\"\"\"\n    def wrapper(self, *args, **kwargs):\n        if self.user_type == \"admin\":\n            return func(self, *args, **kwargs)\n        else:\n            print(\"권한 오류: 이 기능은 admin만 사용할 수 있습니다.\")\n    \n    return wrapper\n\n\nclass User:\n    def __init__(self, name: str, user_type: str):\n        self.name = name\n        self.user_type = user_type\n\n    @admin_only\n    def func_admin_can_do(self):\n        print(\"I'm admin.\")\n이렇게 정의하면 @admin_only 데코레이터를 붙이는 것만으로 사용자가 ‘admin’인 경우에만 처리가 실행됩니다. ’admin’ 여부를 판단하는 로직이 여러 메소드에 필요하거나 동일한 코드를 반복 작성해야 하는 경우에 데코레이터가 특히 유용합니다.\n\n\n1.4.3.5 데코레이터 사용의 이점\n데코레이터를 사용하면 다음과 같은 이점이 있습니다:\n\n코드 중복을 줄일 수 있습니다.\n권한 체크 로직을 한 곳에서 관리할 수 있어 유지보수가 쉬워집니다.\n메소드의 본래 기능과 권한 체크 로직을 분리하여 코드의 가독성을 향상시킬 수 있습니다.\n새로운 admin 전용 메소드를 추가할 때 데코레이터만 붙이면 되므로 개발 효율성이 높아집니다."
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#마치며",
    "href": "posts/qmd/learn_pythonCoding.html#마치며",
    "title": "파이썬 코딩 팁",
    "section": "1.5 마치며",
    "text": "1.5 마치며\n이 글에서는 데이터 사이언티스트와 AI 엔지니어가 Python을 활용하여 효율적으로 작업할 수 있는 다양한 방법과 유용한 팁을 소개했습니다. 마지막으로 이 글이 여러분의 프로그래밍 여정에 작은 도움이 되기를 바라며 앞으로도 지속적인 학습과 개선을 통해 더 나은 개발자가 되시길 응원합니다. 읽어 주셔서 감사합니다."
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#변수",
    "href": "posts/qmd/learn_pythonCoding.html#변수",
    "title": "파이썬 코딩 팁",
    "section": "2.1 변수",
    "text": "2.1 변수\nage: int = 1\n\nchild: bool\nif age &lt; 18:\n    child = True\nelse:\n    child = False"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#유용한-내부-타입",
    "href": "posts/qmd/learn_pythonCoding.html#유용한-내부-타입",
    "title": "파이썬 코딩 팁",
    "section": "2.2 유용한 내부 타입",
    "text": "2.2 유용한 내부 타입\nx: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"string\"\nx: bytes = b\"test\"\nx: list[int] = [1]\nx: set[int] = {6, 7}\nx: dict[str, float] = {\"field\": 2.0}"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#함수",
    "href": "posts/qmd/learn_pythonCoding.html#함수",
    "title": "파이썬 코딩 팁",
    "section": "2.3 함수",
    "text": "2.3 함수\nfrom typing import Callable, Iteractor, Union, Optional\n\ndef stringfy(num: int) -&gt; str:\n    return str(num)\n\ndef plus(num1: int, num: int) -&gt; int:\n    return num1 + num2"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#객체-지향-프로그래밍",
    "href": "posts/qmd/learn_pythonCoding.html#객체-지향-프로그래밍",
    "title": "파이썬 코딩 팁",
    "section": "2.4 객체 지향 프로그래밍",
    "text": "2.4 객체 지향 프로그래밍\nfrom typing import Union\n\nclass Calculator:\n    def __init__(self):\n        self.result: Union[int, float] = 0\n    def add(self, a: Union[int, float], b: Union[int, float]) -&gt; Union[int, float]:\n    self.result = a + b\n    return self.result\n    def subtract(self, a: Union[int, float], b: Union[int, float]) -&gt; Union[int, float]:\n    self.result = a - b\n    return self.result\n    def multiply(self, a: Union[int, float], b: Union[int, float]) -&gt; Union[int, float]:\n    self.result = a * b\n    return self.result\n    def devide(self, a: Union[int, float], b: Union[int, float]) -&gt; Union[int, float]:\n    self.result = a / b\n    return self.result"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#jupyter에서-사용하지-않는-커널-삭제",
    "href": "posts/qmd/learn_pythonCoding.html#jupyter에서-사용하지-않는-커널-삭제",
    "title": "파이썬 코딩 팁",
    "section": "3.1 Jupyter에서 사용하지 않는 커널 삭제",
    "text": "3.1 Jupyter에서 사용하지 않는 커널 삭제\n\n3.1.1 커널 리스트 확인\njupyter kernelspec list\n\n\n3.1.2 커널 삭제\njupyter kernelspec uninstall [unwanted_kernel_name]"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#api-키-안전하게-사용하기",
    "href": "posts/qmd/learn_pythonCoding.html#api-키-안전하게-사용하기",
    "title": "파이썬 코딩 팁",
    "section": "3.2 API 키 안전하게 사용하기",
    "text": "3.2 API 키 안전하게 사용하기\n\n3.2.1 python-dotenv 사용1\nAPI 토큰을 변수에 담아서 사용하는 것은 보안상 좋지 않은 방법이다. 여러가지 우회방법이 있지만 가장 유명한것은 아무래도 python-dotenv를 사용하는 방법이다.\n\n3.2.1.1 설치\n(venv) uv pip install python-dotenv\n\n\n3.2.1.2 .env 파일 만들기\n설치가 끝나면 .env 파일을 작성해준다. 문자열이더라도 따옴표는 안 붙여도 된다. 파일 경로는 아무데나 저장해도 상관없는데 보통 프로젝트 루트 디렉토리에 저장한다. 프로젝트 루트 폴더에 .env를 만들고 아래와 같이 API 토큰을 입력한다.\nHK_TOKEN=hf_cTKyTsXtqSHWyXPLAuxSIGECiIctuNsBona\n\n\n3.2.1.3 .gitignore 파일에 예외처리\n일반적으로는 이미 명시되어 있겠지만 노파심에 한번 .gitignore파일에 아래 내용이 있는지 확인합니다.\n# dotenv environment variable files\n.env\n.env.development.local\n.env.test.local\n.env.production.local\n.env.local\n\n\n3.2.1.4 코드 예시\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv(verbose=True)\nTOKEN = os.getenv('HK_TOKEN')\nprint(TOKEN)\nload_dotenv() 함수에 사용되는 변수는 다음과 같다.\n\ndotenv_path: .env 파일의 절대경로 및 상대경로\nstream: .env 파일 내용에 대한 StringIO 객체\nverbose: .env 파일 누락 등의 경고 메시지를 출력할 것인지에 대한 옵션\noverride: 시스템 환경변수를 .env 파일에 정의한 환경변수가 덮어쓸지에 대한 옵션"
  },
  {
    "objectID": "posts/qmd/learn_pythonCoding.html#footnotes",
    "href": "posts/qmd/learn_pythonCoding.html#footnotes",
    "title": "파이썬 코딩 팁",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://pypi.org/project/python-dotenv/↩︎"
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html",
    "href": "posts/qmd/guide_sabotage.html",
    "title": "사보타지 매뉴얼",
    "section": "",
    "text": "2008 년에 CIA 에서 공개한 Simple Sabotage Field Manual 의 번역본입니다. 문서가 1944 년도에 작성된 것이다보니 현재와는 맞지 않는 내용이 많습니다. 그래도 읽다보면 재치 있는 부분도 있고 읽어볼 가치가 있는 팁들인 것 같습니다. 특히 직장에 관련된 내용은 그때나 지금이나 별반 차이가 없는 것 처럼 보입니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#개인적-동기",
    "href": "posts/qmd/guide_sabotage.html#개인적-동기",
    "title": "사보타지 매뉴얼",
    "section": "4.1 개인적 동기",
    "text": "4.1 개인적 동기\n\n일반 시민에게는 사보타지를 수행할 직접적이고 개인적인 동기가 없을 가능성이 높다. 그러니 적의 퇴각이나 통치 정부 조직의 붕괴 등을 통해 간접적인 개인적 이득을 기대하도록 해야 한다. 예를 들면 사보타지 행위는 X 위원장과 그의 대리인 Y 와 Z 가 쫓겨나는 날, 특히 불쾌한 법령과 제한이 폐지되는 날, 식량이 도착하는 날 등 해당 분야에 대한 이득을 가능한 한 구체적으로 명시한다. 개인의 자유, 언론의 자유 등에 대한 추상적인 표현은 전 세계 대부분의 지역에서 설득력을 얻지 못할 것이며 많은 지역의 시민들은 이해조차 할 수 없을 것이다.\n개별적인 행동은 그 효과가 제한적이기 때문에 사보타지 행위자가 자신이 조직의 일원이라는 느낌을 갖지 못하면 용기를 잃게 될 수 있다. 이런 감정은 특정 사보타지가 성공했다는 소식을 듣거나 읽음으로써 간접적으로 얻을 수도 있다. 비록 그 사보타지가 자신의 주변에서는 적용되지 않을지라도 다른 사람의 성공은 유사한 행동을 시도할 용기를 줄 수 있기 때문이다. 이는 사보타지의 효과를 칭송하는 메시지를 방송함으로써 직접적으로 전달될 수도 있다. 따라서 성공적인 사보타지는 참여하는 인구 비율에 대한 추정치가 방송으로 널리 퍼지고 지속적으로 행위자가 늘어나는 것이다.\n\n나 (b) 보다 더 중요한 것은 시민 사보타지 행위자가 책임감을 느끼고 다른 사람에게 사보타지를 교육하기 시작하는 상황을 만드는 것이다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#파괴-장려",
    "href": "posts/qmd/guide_sabotage.html#파괴-장려",
    "title": "사보타지 매뉴얼",
    "section": "4.2 파괴 장려",
    "text": "4.2 파괴 장려\n상황이 적절한 경우 방해 행위자에게 그가 적에 대한 정당방위 또는 다른 파괴 행위에 대한 보복으로 행동하고 있음을 강조해야 한다. 사보타지에 대한 제안을 제시할 때 유머를 적절히 섞으면 공포의 긴장을 완화할 수 있다.\n\n사보타지 행위자는 생각을 바꿔 이전에는 도구를 날카롭게 유지했다면 이제는 무뎌지게 내버려 두어야 한다. 이전에는 윤활유를 바른 표면에 이제 샌딩을 해야 하며 평소 부지런했다면 이제 게으르고 부주의하게 행동해야 한다. 자신과 일상 생활의 사물에 대해 거꾸로 생각하도록 격려하면 행위자는 가까운 환경에서 많은 사보타지 기회를 보게 될 것이다.다시 말해 무엇이든 방해할 수 있다는 마음가짐을 갖도록 격려해야 한다.\n물리적 파괴에 가담할 수 있는 잠재적 시민 사보타지 행위자들 중에는 두 가지 극단적인 유형이 있다. 첫번째는 기술적으로 훈련받지 않고 고용된 사람이다. 이런 사람들은 자신이 파괴할 수 있는 대상과 파괴해야 하는 대상에 대한 구체적인 정보가 필요하다.\n다른 극단적인 유형에는 선반 작업자나 자동차 정비공과 같은 기술자들이 있다. 이 사람들은 구체적인 정보 없이도 시설에 적합한 사보타지 방법을 고안해낼 수 있다.\n사보타지에 관한 제안과 정보를 전파하기 위해 다양한 매체가 사용될 수 있다. 즉각적인 상황에 따라 사용할 수 있는 매체로는 방송국이나 라디오 방송 또는 전단지가 있으며 특정 지역 또는 직업군을 대상으로 할 수 있다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#안전-조치",
    "href": "posts/qmd/guide_sabotage.html#안전-조치",
    "title": "사보타지 매뉴얼",
    "section": "4.3 안전 조치",
    "text": "4.3 안전 조치\n\n사보타지 행위자의 활동량은 그가 가진 기회뿐만 아니라 그가 느끼는 위험의 정도에 따라 결정된다. 사보타지 행위자가 너무 많이 체포되면 나쁜 소식은 빠르게 전파되어 사보타지 행위가 억제된다.\n사보타지 행위자가 탐지 및 보복을 당하지 않도록 무기, 시간, 표적 선택에 대한 준비하는 것은 어렵지 않다. 다음과 같은 예시가 있다:\n\n\n\n무해한 것으로 보이는 도구를 사용하라. 칼이나 톱은 다용도 도구이므로 쉽게 휴대할 수 있다. 성냥, 자갈, 머리카락, 소금, 못 및 기타 수십 가지의 파괴 도구들은 의심을 받지 않고 휴대하거나 거주지에 보관할 수 있다. 또한 특정 업종에서 일하는 하는 경우 렌치, 망치등을 쉽게 휴대하고 보관할 수 있습을 것이다.\n\n\n책임을 회피 할 수 있는 행위를 시도하라. 예를 들어 공장의 중앙 화재 상자에 있는 배선을 끊는 행위는 실수로 그럴 수 있기 때문에 책임을 회피 할 수 있다. 또는 다른 사람들의 눈을 피해 군용 차량이나 트럭을 대상으로 저지르는 사보타지 행위도 있다.\n\n\n전날 잠을 설쳐서 너무 졸려 전기 회로에 렌치를 떨어뜨렸다 같은 그럴듯한 핑계가 있다면 비난받을 수 있는 행동을 하는 것도 두려워하지 마라. 항상 사과를 충분히 하고, 어리석음, 무지를 가장해 그러한 사보타지를 ‘빠져나갈’ 수 있는 경우가 많다.\n\n\n사보타지를 저지른 후에 무슨 일이 일어나는지 확인하고 싶은 유혹을 뿌리쳐야 한다. 괜히 주위를 배회하면 의심을 불러온다. 물론 바로 퇴근하는 것이 의심스러운 상황도 있을 수 있으니 업무방해 행위를 저지른 경우라면 얼마간 직장에 남아 있어야 한다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#평상시",
    "href": "posts/qmd/guide_sabotage.html#평상시",
    "title": "사보타지 매뉴얼",
    "section": "5.1 평상시",
    "text": "5.1 평상시\n\n단순한 사보타지는 악의적인 장난 그 이상이며, 항상 적의 물자와 인력에 해를 끼칠 수 있는 행위로 구성되어야 합니다.\n사보타지는 일상적인 장비를 독창적으로 사용해야 합니다. 주변을 다른 시각으로 바라보면 온갖 종류의 무기가 나타날 것입니다.\n사보타지는 자신의 능력이나 도구의 용량을 넘어서는 목표물을 공격해서는 안 됩니다. 예를 들어 경험이 없는 사람은 폭발물을 사용하려고 시도해서는 안 되며 성냥이나 기타 익숙한 도구를 사용해야 합니다.\n사보타지는 적이 사용 중이거나 적이 조기에 사용할 예정인 것으로 알려진 물체와 재료만 손상하려고 시도해야 합니다. 중공업의 거의 모든 제품 그리고 연료와 윤활유는 적이 사용할 것이라고 가정할 수 있으나 특별한 지식이 없는 사람이 식량 작물이나 식료품의 파괴 행위를 시도하는 것은 바람직하지 않습니다.\n시민 사보타지 행위자는 군용 물자에 접근할 수 있는 경우가 드물지만 이러한 물자를 우선적으로 파괴하는 것을 고려해야 합니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#전시전",
    "href": "posts/qmd/guide_sabotage.html#전시전",
    "title": "사보타지 매뉴얼",
    "section": "5.2 전시전",
    "text": "5.2 전시전\n군사적 의미에서 평온한 시기에는 적에게 자재와 장비의 흐름을 줄이기 위해 산업 생산 공정의 사보타지에 집중합니다. 예를 들면 군용 트럭의 고무 타이어를 찢는 것은 가치 있는 행위보다 생산 공장의 타이어를 망치는 것은 훨씬 더 가치 있는 행위입니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#전시중",
    "href": "posts/qmd/guide_sabotage.html#전시중",
    "title": "사보타지 매뉴얼",
    "section": "5.3 전시중",
    "text": "5.3 전시중\n\n전투 작전 지역이거나 곧 전투 작전 지역이 될 예정인 지역에 대한 가장 중대한 사보타지는 그 효과가 직접적이고 즉각적인 것입니다. 비록 그 영향이 상대적으로 경미하고 국지적이더라도 이런 유형의 사보타지는 그 영향이 광범위하지만 간접적이고 지연되는 활동보다 선호되어야 합니다.\n\n\n\n사보타지는 모든 종류의 교통 시설을 공격하도록 장려해야 합니다. 이러한 시설에는 도로, 철도, 자동차, 트럭, 오토바이, 자전거, 기차, 트램 등이 포함됩니다.\n\n\n당국이 지시나 사기 진작 자료를 전송하는 데 사용할 수 있는 모든 통신 시설은 사보타지의 대상이 되어야 합니다. 여기에는 전화, 전신 및 전력 시스템, 라디오, 신문, 현수막이 포함됩니다.\n\n\n그 자체로 가치가 있거나 교통 및 통신의 효율적인 기능에 필요한 중요 물자도 사보타지의 표적이 되어야 합니다. 여기에는 석유, 휘발유, 타이어, 음식, 물 등이 포함될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#건물",
    "href": "posts/qmd/guide_sabotage.html#건물",
    "title": "사보타지 매뉴얼",
    "section": "6.1 건물",
    "text": "6.1 건물\n창고, 병영, 사무실, 호텔 및 공장 건물은 사보타지의 탁월한 목표입니다. 이들은 특히 화재 피해에 극히 취약하며 관리인, 청소부 및 일반 방문객과 같은 훈련 받지 않은 사람도 시도가 가능합니다. 또, 피해를 입었을 시에는 적에게 상대적으로 큰 피해를 주게 됩니다.\n\n6.1.1 화재\n화재는 가연성 물질이 쌓여있는 곳 어디에서든지 시작될 수 있습니다. 창고가 명백히 좋은 목표이겠으나 화재 사보타지가 거기에만 국한될 필요는 없을 것입니다.\n\n가능하면 장소를 떠난 상태에서 불이 시작하도록 준비하세요. 예를 들면 양초와 종이를 함께 사용하여 태우려는 가연성 물질에 최대한 가깝게 놓습니다: 종이에서 3~4 센티미터 너비의 띠를 찢어 양초 바닥에 두세 번 감습니다. 종이를 더 꼬아서 느슨한 끈으로 만들어 양초 바닥에 감습니다. 양초 불꽃이 감싸고 있는 띠에 도달하면 양초에 불이 붙고 주변 종이에 차례로 불이 붙을 겁니다.\n이런 종류의 방화는 인화성 물질에 적합합니다. 인화성이 없는 물질에 불을 붙이려고 시도하지 마세요. 만약 인화성이 없는 물질에 불을 붙이려면 양초와 휘발유에 적신 종이를 단단히 말거나 꼬아서 사용하세요.\n간이 도화선을 만들려면 끈의 한쪽 끝을 기름에 담급니다. 기름기가 묻은 끈과 깨끗한 끈이 만나는 부분에 화약을 넉넉히 묻혀서 문지릅니다. 그런 다음 깨끗한 끈의 끝부분에 불을 붙입니다. 기름과 화약이 닿을 때까지 불꽃 없이 천천히 타다가 (담배가 타는 것과 거의 같은 방식) 갑자기 타오를 것입니다. 그러면 그리스로 처리된 끈이 불꽃과 함께 연소됩니다. 그리스와 화약 대신 성냥을 사용해도 같은 효과를 얻을 수 있습니다. 끈이 눌리거나 매듭이 생기지 않도록 주의하면서 성냥 머리 위로 끈을 통과시키세요. 이 역시 갑작스러운 불꽃을 일으킬 수 있습니다. 이 유형의 도화선은 끈이 정해진 속도로 연소한다는 장점이 있습니다. 선택한 끈의 길이와 두께에 따라 불의 시간을 정할 수 있습니다.\n위에서 제안한 도화선을 사용하여 근무 시간 이후에 사무실에서 불을 피우세요. 기록 및 기타 유형의 문서를 파괴하는 것은 적에게 심각한 손해를 끼칠 수 있습니다.\n폐기물을 보관하는 지하실에 기름기가 많은 폐기물을 쌓아두는 경우 때때로 자연 발화하기도 하지만 담배나 성냥으로 쉽게 불이 붙을 수 있습니다. 당신이 야간 근무를 하는 청소부라면 화재를 가장 먼저 신고할 수도 있지만 너무 빨리 신고하지는 말아야합니다.\n깨끗한 공장은 화재에 취약하지 않지만 더러운 공장은 화재에 취약합니다. 작업자는 쓰레기를 함부로 버리고 청소부는 청소에 똑바로 하지 않음으로 더럽게 할 수 있습니다. 만약 먼지와 쓰레기가 충분히 쌓이면 내화 건물이 인화성이 될 수 있습니다.\n야간에 비어 있는 방에서 조명용 가스를 사용하는 경우 창문을 단단히 닫고 가스를 켜고 촛불을 켜둔 채로 두세요. 시간이 지나면 가스가 폭발하여 화재가 발생할 수도 있고 그렇지 않을 수도 있습니다.\n\n\n\n6.1.2 물 및 기타\n\n스프링쿨러 시스템을 작동시켜 창고 속의 물품들을 못쓰게 만듭니다. 스프링클러 헤드를 망치로 세게 두드리거나 그 아래에 성냥을 대면 됩니다.\n화장실에 휴지를 비치하지 말고 휴지, 머리카락, 기타 장애물을 단단히 말아서 화장실에 넣습니다. 스펀지에 두꺼운 전분 또는 설탕 용액을 적신뒤 꽉 짜서 끈으로 감싸고 말립니다. 완전히 마르면 끈을 제거합니다. 이제 스펀지는 단단하고 단단한 공 모양이 될 것입니다. 그것을 하수구에 넣으면 스펀지가 서서히 정상 크기로 팽창하여 하수 시스템을 막습니다.\n낮에 공공건물의 전구 아래에 동전을 넣어두면 밤에 조명이 켜지면 퓨즈가 끊어집니다. 퓨즈 뒤에 동전을 넣거나 무거운 전선을 넣으면 퓨즈 자체가 무력화될 수 있습니다. 그러면 합선으로 인해 화재가 발생하거나 변압기가 손상되거나 넓은 지역으로 전기 공급이 중단될 수 있습니다.\n경비원이 없는 공공건물의 모든 출입문 자물쇠에 종이, 나무 조각, 머리핀 등 들어갈 수 있는 모든 것을 끼워 넣으세요."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#공업-생산-제조",
    "href": "posts/qmd/guide_sabotage.html#공업-생산-제조",
    "title": "사보타지 매뉴얼",
    "section": "6.2 공업 생산: 제조",
    "text": "6.2 공업 생산: 제조\n\n6.2.1 도구\n\n절삭 도구들이 무뎌지게 합니다. 그러면 효율 떨어져 생산성이 떨어지면 다른 자재와 부품에 손상을 줄 수 있습니다.\n사용하지 않는 톱은 약간 뒤틀리게 보관하면 사용하게 될 때 잘 부서집니다.\n줄날을 사용할 때 아주 빠르게 움직이면 강한 압력을 줄 수 있습니다.\n줄날은 바이스나 공작물에 두드려서 청소하세요. 이렇게 하면 쉽게 부러집니다.\n비트와 드릴은 옆쪽에서 강한 압력을 받으면 부러지기 쉽습니다.\n프레스 펀치에 정해진 것보다 많은 재료 (예: 블랭크 1 개가 아닌 2 개) 를 넣으면 펀치가 고장날 수 있습니다.\n공압 드릴, 리벳터 등과 같은 동력 구동 공구는 더러워지면 효율이 떨어집니다. 윤활과 전기 접점에 먼지가 쌓이게 두고 이물질을 넣어 오염시킵니다.\n\n\n\n6.2.2 기름 및 윤활유\n오일 및 윤활 시스템은 쉽게 파괴될 수 있을 뿐만 아니라 움직이는 부품이 있는 모든 기계에서 중요합니다. 오일 및 윤활 시스템을 방해하면 산업 공정의 주요 지점에서 생산 속도가 느려지거나 작업이 완전히 중단될 수 있습니다.\n\n금속 먼지나 고운 모래, 유리 가루, 연마제 및 이와 유사한 단단하고 거친 물질을 윤활 시스템에 직접 넣습니다. 이러한 물질은 매끄러운 표면을 긁어 피스톤, 실린더 벽, 샤프트 및 베어링을 망가뜨릴 수 있습니다. 모터가 과열되어 멈추게 되면 광범위한 수리가 필요합니다.\n필터 시스템을 열어 연필이나 기타 날카로운 물체로 필터 망을 찌른 다음 다시 덮으면 기계가 마모될 수 있습니다. 또는 신속하게 처리할 수 있다면 필터를 제거하세요.\n윤활 시스템이나 필터에 직접 접근할 수 없는 경우, 보관 중에 오일을 희석하여 오일의 효과를 줄일 수 있습니다. 이 경우 거의 모든 액체가 오일을 묽게 만들 수 있습니다. 소량의 황산, 광택제, 물 또는 아마씨유가 특히 효과적입니다.\n중유가 필요한 곳에 묽은 오일을 사용하면 기계가 고장 나거나 움직이는 축이 가열되어 멈출 수 있습니다.\n막히는 물질을 윤활 시스템에 넣거나 떠다니는 경우 보관 중인 오일에 넣습니다. 머리카락, 노끈 조각, 죽은 곤충 및 기타 여러 가지 일반적인 물체를 꼬아서 빗으면 공급 라인과 필터를 통한 오일의 흐름을 막거나 방해하는 데 효과적입니다.\n일부 상황에서는 윤활 시스템에서 마개를 제거하거나 오일이 저장된 드럼과 캔에 구멍을 뚫어 오일의 효과를 방해하는 대신 완전히 파괴할 수 있습니다.\n\n\n\n6.2.3 냉각 시스템\n\n수냉식 냉각 시스템에 쌀이나 밀과 같은 딱딱한 곡물을 몇 꼬집 넣으면 엔진이나 모터가 상당히 손상되어 상당히 짧은 시간 내에 작동을 멈출 수 있습니다. 그들은 부풀어 오르고 물의 순환을 막아 방해물을 제거하기 위해 냉각 시스템을 분해해야합니다. 톱밥이나 머리카락도 수냉 시스템을 막는 데 사용될 수 있습니다.\n과열된 모터의 냉각 시스템에 매우 차가운 물을 빠르게 주입하면 엔진 하우징에 수축과 상당한 변형이 발생합니다. 이러한 처리를 몇 번 반복하면 균열과 심각한 손상이 발생할 수 있습니다.\n흡기 또는 배기 밸브에 먼지와 폐기물이 막히면 공기 냉각 시스템의 효율을 떨어뜨릴 수 있습니다. 벨트로 작동하는 팬을 시스템에 사용하는 경우 벨트의 절반 이상을 들쭉날쭉하게 자르면 벨트가 미끄러져 결국 부하를 받아 분리되고 모터가 과열될 수 있습니다.\n\n\n\n6.2.4 가솔린 및 기름 연료\n연료 탱크와 연료 공급 엔진은 일반적으로 접근이 용이하고 쉽게 열 수 있습니다. 따라서 간단한 사보타지 활동에 매우 취약한 표적이 될 수 있습니다.\n\n가솔린 엔진의 연료 탱크에 톱밥이나 쌀이나 밀과 같은 딱딱한 곡물을 몇 꼬집 넣습니다. 입자가 공급 라인을 막아서 엔진이 멈추게 됩니다. 문제의 원인을 찾으려면 시간이 좀 걸릴 수 있습니다. 구하기는 어렵지만 오래된 고무줄이나 연필 지우개에서 찾을 수 있는 천연 고무 부스러기도 효과적입니다.\n설탕을 모을 수 있다면 휘발유 엔진의 연료 탱크에 넣으세요. 휘발유와 함께 타면서 끈적끈적한 덩어리로 변해 엔진을 완전히 망가뜨리고 대대적인 청소와 수리가 필요하게 됩니다. 꿀과 당밀은 설탕만큼 좋습니다. 휘발유 10 갤런당 약 75~100 그램을 사용하세요.\n휘발유에 다른 불순물이 유입되면 엔진이 빠르게 마모되고 결국 고장을 일으킬 수 있습니다. 부석, 모래, 분쇄 유리 및 금속 먼지의 미세 입자는 휘발유 탱크에 쉽게 유입될 수 있습니다. 입자가 매우 미세해야 카뷰레터를 통과할 수 있습니다.\n물, 소변, 와인 또는 기타 비교적 많은 양의 간단한 액체는 실린더에서 연소가 일어나지 않고 엔진이 움직이지 않을 정도로 휘발유를 희석시킬 수 있습니다. 휘발유 1 파인트에서 20 갤런이면 충분합니다. 소금물을 사용하면 부식과 영구적인 모터 손상의 원인이 됩니다.\n디젤 엔진의 경우 인화점이 낮은 오일을 연료 탱크에 넣으면 엔진이 작동하지 않습니다. 잘못된 종류의 오일을 넣었을 때 이미 탱크에 적절한 오일이 있는 경우 엔진이 흔들리며 헛도는 현상만 발생합니다.\n\n가솔린 및 오일 엔진의 연료 라인은 배기관을 자주 통과합니다. 기계가 정지해 있을 때 연료 라인에 작은 구멍을 뚫고 왁스로 구멍을 막으면 됩니다. 엔진이 작동하고 배기관이 뜨거워지면 왁스가 녹아 연료가 배기관으로 떨어지고 불꽃이 시작됩니다.\n휘발유가 보관된 방에 접근할 수 있는 경우, 촛불을 켜둔 채로 방에 들어가면 밀폐된 방에 축적된 유증기가 시간이 지나면 폭발할 수 있다는 점을 기억하세요. 그러나 휘발유 통에서 실내 공기 중으로 상당한 양의 증발이 일어나야 합니다. 통의 윗부분을 제거해도 충분한 양의 휘발유가 공기 중에 노출되지 않으면 칼또는 송곳으로 통에 구멍을 뚫습니다. 이렇게 하면 증발 속도가 크게 빨라집니다. 촛불에 불을 붙이기 전에 창문을 닫고 방을 최대한 밀폐해야 합니다. 옆 방의 창문이 활짝 열려 있으면 휘발유뿐만 아니라 주변의 모든 것을 파괴하는 큰 불이 날 수 있습니다.\n\n\n\n6.2.5 전기 모터\n전기 모터는 전문가가 아니라면 망가트리기 쉽지 않고 비숙련자는 부상의 위험이 있습니다.\n\n모든 유형의 전기 모터에서 가변 저항기를 높은 저항 지점으로 설정하세요. 과열되어 화재가 발생할 수 있습니다.\n과부하 릴레이를 모터의 용량을 초과하는 매우 높은 값으로 조정하세요. 그런 다음 모터가 과열되어 고장날 정도로 과부하를 가하세요.\n먼지, 흙, 수분은 전자 장비의 적이라는 것을 기억하세요. 전기 모터의 전선이 종단과 연결되는 부분과 절연되어 있는 부분에 먼지와 흙을 흘리면 전류가 비효율적으로 흐르거나, 쇼트가 발생할 것입니다.\n전선의 피복을 손상시키고, 연결 부위의 너트를 헐겁게 하고, 전선의 땜과 연결 부위를 엉망으로 처리하여 전류를 낭비하고 전기 모터의 출력을 저하시키세요.\n고정자가 손상되면 직류 모터의 출력이 감소하거나 단락이 발생할 수 있습니다: 고정자 고정 링을 풀거나 제거합니다. 고정자에 탄소, 흑연 또는 금속 먼지를 뿌립니다. 고정자 접촉부에 그리스나 오일을 약간 발라줍니다. 고정자 막대가 서로 가까이 있는 경우 금속 가루로 막대 사이의 간격을 메우거나 끌로 가장자리를 톱질하여 인접한 막대의 톱니가 만나거나 거의 만나 전류가 한 막대에서 다른 막대로 흐를 수 있도록 합니다.\n회전하는 브러시를 마모시킬 수 있는 곳에 우표 크기의 절반 정도의 고운 입자의 사포를 놓습니다. 그러면 모터가 화재로 인해 파괴됩니다.\n슬립 링에 탄소, 흑연 또는 금속 가루를 뿌려 전류가 누설되거나 단락이 발생할 수 있습니다. 모터가 유휴 상태일 때는 끌로 슬립링에 흠집을 내세요.\n전기자 표면에 그리스가 섞인 먼지가 묻으면 접촉이 제대로 이루어지지 않아 모터가 멈추거나 효율이 떨어집니다.\n전기 모터를 과열시키려면 모래와 진한 그리스를 섞어 고정자와 회전자 사이에 바르거나 얇은 금속 조각을 그 사이에 끼워 넣으십시오. 전류가 효율적으로 생성되지 않도록 기름, 타르 또는 페인트를 넣으십시오.\n3 상 전류를 사용하는 모터의 경우, 기계가 정지한 상태에서 인입선 중 하나에 칼이나 줄로 깊게 상처를 내거나 퓨즈 3 개 중 하나를 끊어진 퓨즈로 교체합니다. 첫 번째 경우에는 모터가 잠시 작동한 후 멈추고 두 번째 경우에는 시동이 걸리지 않습니다.\n\n\n\n6.2.6 변압기\n\n오일 충전식 변압기는 오일 탱크에 물이나 소금을 부으면 고장이 날 수 있습니다.\n공랭식 변압기의 경우, 주변에 잔해를 쌓아 통풍을 막아주세요.\n모든 유형의 변압기의 경우 외부 부싱 및 기타 노출된 전기 부품에 탄소, 흑연 또는 금속 먼지를 뿌려 주세요.\n\n\n\n6.2.7 터빈\n대부분의 터빈은 무겁고 견고하게 제작되어 있으며 망가트리기 어렵습니다.\n\n수력 터빈을 점검하거나 수리한 후에는 커버가 날아가서 발전소에 물이 넘치지 않도록 커버를 단단히 고정하세요. 증기 터빈의 덮개가 느슨하면 누수가 발생하고 속도가 느려집니다.\n수력 터빈에서는 펜 스톡 헤드의 스크리닝 바로 너머에 큰 고철 조각을 삽입하여 물이 손상된 재료를 플랜트 장비로 운반 할 수 있도록합니다.\n수리를 위해 터빈의 증기 라인을 열면 고철 조각을 넣어 증기가 다시 올라올 때 터빈 기계에 분사되도록 합니다.\n터빈의 연료 공급 라인에 구멍을 뚫어 뜨거운 증기 파이프에 떨어진 기름으로 불이 나도록 하세요.\n\n\n\n6.2.8 보일러\n\n가능한 모든 방법으로 증기 보일러의 효율을 줄이세요. 물을 너무 많이 넣어서 시동이 느리게 걸리게 하거나 불을 낮게 유지하여 비효율적으로 만듭니다. 증기 보일러가 마르지 않은 상태에서 불을 올리면 금이 가고 망가질 수 있습니다. 특히 좋은 방법은 석회석이나 석회가 포함된 물을 보일러에 계속 넣으면 바닥과 측면에 석회가 쌓이는 것입니다. 이 침전물은 열에 대해 매우 우수한 단열 효과를 제공하며 충분히 쌓이면 보일러는 완전히 쓸모없어집니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#생산.-금속",
    "href": "posts/qmd/guide_sabotage.html#생산.-금속",
    "title": "사보타지 매뉴얼",
    "section": "6.3 생산. 금속",
    "text": "6.3 생산. 금속\n\n6.3.1 철과 강철\n\n용광로는 수리를 위해 자주 가동을 중단해야 하는 상태로 유지합니다. 용광로 내부 라이닝용 내화벽돌을 만들 때는 타르의 비율을 늘려서 빨리 마모되고 지속적으로 라이닝을 다시 하도록 합니다.\n주조용 코어에 기포가 가득 차 불완전한 주조 결과가 나오도록 코어를 만듭니다.\n금형의 코어가 제대로 지지되지 않아 코어의 위치가 잘못되어 코어가 흘러내리거나 주물이 손상되게 합니다.\n철이나 강철을 열처리할 때 과도한 열을 가하여 철근과 강괴의 품질을 낮추세요.\n\n\n\n6.3.2 다른 금속\n\n가능한 제안 사항이 없습니다.\n\n\n\n6.3.3 생산: 채광 및 광물 추출\n\n\n6.3.4 탄광\n\n오일 램프를 꺼버리세요, 오일램프를 다시 켜려면 눅눅하지 않은 곳을 찾아야 하기 때문에 오랜 시간이 필요합니다.\n공압식 픽을 만들때 픽을 제대로 굳히지 않으면 금방 무뎌집니다.\n공압식 픽은 쉽게 고장날 수 있습니다. 오일 레버에 소량의 물을 부으면 픽이 작동을 멈춥니다. 석탄 먼지와 부적절한 윤활도 고장을 일으킬 수 있습니다.\n석탄을 운반하는 버킷 컨베이어를 당기는 체인을 약화시키세요. 픽이나 삽으로 때리면 체인이 정상적인 힘에도 끊어질 수 있습니다.\n레일과 전환 지점에 장애물을 설치해 광산 차량이 탈선하도록 만듭니다.\n석탄에 돌이나 다른 쓸모없는 물건을 섞어 보내세요.\n\n\n\n6.3.5 생산: 농업\n\n\n6.3.6 기계류\n\n공업 생산: 제조 &gt; 가솔린 및 기름 연료, 전기 모터, 작물과 가축 항목 참고.\n\n\n\n6.3.7 작물과 가축\n농작물과 가축은 식량 공급이 많거나 적이 식량을 요구하는 것으로 알려진 곳에서만 파괴해야 합니다.\n\n가축에게 농작물을 먹이십시오. 농작물을 너무 일찍 또는 늦게 수확하세요. 저장된 곡물, 과일, 채소를 물에 담가 썩게 합니다. 과일과 채소를 햇볕에 방치하여 상하게 합니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#교통-수단-철도",
    "href": "posts/qmd/guide_sabotage.html#교통-수단-철도",
    "title": "사보타지 매뉴얼",
    "section": "6.4 교통 수단: 철도",
    "text": "6.4 교통 수단: 철도\n\n6.4.1 승객\n\n열차 여행이 되도록 불편하도록 만드세요. 티켓을 잘못 발행하고 여정의 일부를 빼먹도록 하세요. 열차의 한 자리에 두 개의 티켓을 발급하여 다툼이 발생하게 만들고 열차가 떠날 때까지 시간을 지연시키세요. 열차의 출발 및 도착을 알리는 알림을 고의로 잘못되게 만드세요.\n목적지를 향해 가고 있는 열차에서 승무원들은 음식을 특별히 맛없게 만들고 한밤중에 티켓을 확인하는등 손님을 최대한 귀찮게 만들어야 합니다.\n짐이 잘못 놓여지거나 다른 역에 내려지게 하세요.\n열차 운전자는 열차를 고의로 지연시키거나 예정에 없던 정차를 하게 만들어야 합니다.\n\n\n\n6.4.2 스위치, 신호 및 라우팅\n\n신호기와 스위치가 포함된 배전반의 전선이 잘못된 단자에 연결되지 않도록 교환합니다.\n신호 암이 작동하지 않도록 푸시 막대를 풀고, 신호등을 고장내고, 적색 및 녹색 신호등의 컬러 렌즈를 교환합니다.\n선로에서 스위치 지점이 움직이지 않도록 펼쳐서 고정하거나 스위치 지점 사이에 돌이나 흙더미를 놓습니다.\n스위치 포인트의 전기 연결부와 인근 바닥에 소금을 충분히 뿌립니다. 비가 오면 스위치가 단락될 수 있습니다.\n차량이 잘못된 열차에 투입되도록 수리가 필요한 차량의 표지를 떼어내고 차량과 차량 사이의 커플링은 가능한 느슨하게 유지합니다.\n\n\n\n6.4.3 선로\n\n곡선에서 외부 레일 섹션에 연결되는 연결 플레이트에서 볼트를 빼고 연결 조인트의 양쪽에서 자갈, 콘크리트 또는 흙을 몇 피트 정도 퍼냅니다.\n조인트에서 연결 플레이트를 분리하고 양쪽의 침목 못을 풀면 레일이 서로 벌려집니다.\n\n\n\n6.4.4 기름과 윤활유\n\n공업 생산: 제조 &gt; 가솔린과 기름 연료 참고\n윤활 파이프를 집게로 꽉 쥐거나 망치로 찌그러뜨려 오일의 흐름이 막히게 합니다.\n\n\n\n6.4.5 냉각 시스템\n\n공업 생산: 제조 &gt; 냉각 시스템 참고.\n\n\n\n6.4.6 가솔린 및 기름 연료\n\n공업 생산: 제조 &gt; 가솔린 및 기름연료 참고.\n\n\n\n6.4.7 전기 모터\n\n공업 생산: 제조 &gt; 냉각 시스템 및 가솔린 및 기름 연료 참고.\n\n\n\n6.4.8 보일러\n\n공업 생산: 제조 &gt; 보일러 참고\n검사 후 엔진의 보일러에 중유 또는 타르를 넣거나 비누 0.5 킬로그램을 물에 넣으십시오.\n\n\n\n6.4.9 브레이크 및 기타\n\n일부러 고속으로 주행하고 커브길과 내리막길에서는 브레이크를 과도하게 사용해 엔진에 과부하를 줍니다.\n에어 브레이크 밸브 또는 급수관에 구멍을 뚫습니다.\n여객 열차의 마지막 칸이나 화물의 앞칸에서는 저널 박스의 솜을 제거하고 기름 묻은 헝겊으로 교체합니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#교통-수단-자동차",
    "href": "posts/qmd/guide_sabotage.html#교통-수단-자동차",
    "title": "사보타지 매뉴얼",
    "section": "6.5 교통 수단: 자동차",
    "text": "6.5 교통 수단: 자동차\n\n6.5.1 도로\n도로에 가하는 사보타지는 시간이 오래 걸리기 때문에 작전 당일에 하는 것은 비효율적입니다.\n\n교차로와 갈림길의 표지판을 변경합니다. 적이 잘못된 길로 가면 실수를 발견하기까지 수 킬로미터가 걸릴 수 있습니다.\n길을 물어보면 잘못된 길을 알려줍니다.\n통행량이 많은 도로를 손상시키면 지나가는 차량과 자연이 나머지를 처리해 줍니다. 비포장 도로는 삽으로 파낼 수도 있습니다. 작은 개울이 흘러 도로를 잠식하게 하면 도로를 손상시키는 데 몇 분 밖에 걸리지 않을 것입니다.\n깨진 유리, 못, 날카로운 돌을 도로에 뿌려 타이어를 펑크 낼 수 있습니다.\n\n\n\n6.5.2 승객\n\n버스기사는 적이 내리길 원하는 정류장을 지나칠 수 있습니다. 택시기사는 적의 목적지로 가는 가장 먼 경로를 선택하여 적의 시간과 돈을 낭비하게 할 수 있습니다.\n\n\n\n6.5.3 기름 및 윤활유\n\n공업 생산: 제조 &gt; 냉각 시스템 참고\n윤활유 펌프를 끊어버리면 80km 를 운행하기 전에 베어링이 망가질 것입니다.\n\n\n\n6.5.4 레디에이터\n\n공업 생산: 제조 &gt; 냉각 시스템 참고\n\n\n\n6.5.5 연료\n\n공업 생산: 제조 &gt; 가솔린 및 기름 연료 참고\n\n\n\n6.5.6 배터리 및 점화\n\n점화 잠금장치에 나무 조각을 끼우거나 배전반 뒤의 연결부를 풀고 점화 플러그에 먼지를 넣어서 손상 시킬 수 있습니다.\n주차된 차량의 조명을 켜서 배터리가 방전되도록 합니다.\n기계공은 여러 가지 방법으로 교모하게 배터리를 망칠 수 있습니다: 베터리 셀에서 밸브 캡을 떼어내고 드라이버를 비스듬히 밀어 넣어 셀의 판을 깨뜨리면 밖에서는 손상이 보이지 않습니다. 베터리 셀에 철이나 구리를 넣으면 셀의 수명이 크게 단축됩니다. 특히 각 베터리 셀에 식초를 조금 넣으면 배터리 수명이 크게 줄어듭니다.\n\n\n\n6.5.7 기어\n\n변속기 및 기타 기어에서 윤활유를 제거하거나 가벼운 윤활유를 넣으세요.\n트럭, 트랙터 및 기타 무거운 기어가 장착된 기계의 경우 기어 케이스가 불안정하게 고정되도록 볼트 구멍의 절반에만 볼트를 끼우세요. 사용 중 기어가 심하게 흔들려 곧 수리가 필요할 수 있습니다.\n\n\n\n6.5.8 타이어\n\n방치된 차량의 타이어에 구멍을 내거나 펑크를 내세요. 성냥갑이나 기타 작은 상자 안에 못을 넣고 정지된 자동차의 뒷바퀴 앞에 수직으로 세워두면 자동차가 출발할 때 못이 타이어를 깔끔하게 뚫을 수 있습니다.\n타이어 수리점은 타이어를 손상시키기 쉽습니다: 펑크 수리 시 유리, 가성소다 등을 안에 흘리면 튜브에 금방 구멍이 나거나 부식될 수 있습니다. 또는 펑크 난 타이어를 수리할 때 펑크를 일으킨 물체를 그대로 두면 됩니다.\n수리 후 타이어를 조립할 때는 타이어 림과 휠 림 사이에 이물질이 끼게 만드세요.\n타이어에 공기를 넣을 때는 정상 공기압보다 낮게 유지하세요. 타이어가 더 많이 마모될 수 있습니다. 양쪽 바퀴에 타이어를 채울 때는 안쪽 타이어에 바깥쪽 타이어보다 훨씬 높은 압력으로 공기를 넣어야 하며, 이렇게 하면 두 타이어 모두 더 빨리 마모됩니다. 바퀴의 정렬이 잘못되면 타이어도 빨리 마모되므로 바퀴를 조정하기 위해 들어올 때 정렬이 맞지 않은 상태로 둡니다.\n타이어 재고가 많이 있는 경우 휘발유 등을 타이어에 흘려서 타이어를 경화되게 할 수 있습니다. 다만 합성 고무는 이러한 화학 물질에 덜 민감합니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#교통-수단-물",
    "href": "posts/qmd/guide_sabotage.html#교통-수단-물",
    "title": "사보타지 매뉴얼",
    "section": "6.6 교통 수단: 물",
    "text": "6.6 교통 수단: 물\n\n6.6.1 항해\n\n바지선 및 선박 항해사는 이동하는 수로의 상태에 대한 잘못된 소문을 퍼뜨립니다. 다른 바지선 및 보트 선장에게 시간이 더 걸리거나 운하를 우회해야 하는 수로를 따라가라고 알립니다.\n바지선 및 선박의 항해사는 다리 근처에서는 시간을 낭비하고 대기해야 하는 다른 선박의 시간을 낭비합니다. 또한 선박이 ‘실수로’ 좌초되는 것도 매우 효율적인 시간 낭비가 됩니다.\n도개교에 근무하는 직원은 실수로 다리를 올렸다가 내렸다 하며 다리 위나 아래 수로의 교통을 지연시킬 수 있습니다.\n화물선의 나침반에 자성을 망가트립니다. 나침반의 자성을 제거하거나 나침반 근처에 큰 철근이나 철을 숨겨서 나침반이 잘못 작동되도록 합니다.\n\n\n\n6.6.2 화물\n\n화물을 적재하거나 하역할 때 부주의하게 취급하면 화물이 손상될 수 있습니다. 가장 약하고 가벼운 상자와 상자가 화물칸 바닥에 있고 가장 무거운 상자가 그 위에 오도록 화물을 적치합니다. 비와 갑판 세척으로 인해 화물이 손상되도록 커버와 타포린은 허술하게 씌웁니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#통신",
    "href": "posts/qmd/guide_sabotage.html#통신",
    "title": "사보타지 매뉴얼",
    "section": "6.7 통신",
    "text": "6.7 통신\n\n6.7.1 전화\n\n사무실, 호텔, 교환실에서 적의 전화 연결을 지연시키거나, 잘못된 번호를 알려주거나, 실수로 끊거나, 회선을 다시 사용할 수 없도록 계속 연결을 시도합니다.\n적 본부에 하루에 한 번 이상 전화를 걸어 공식 업무, 특히 군사 업무를 방해하고, 전화를 받으면 잘못된 번호를 받았다고 말합니다. 군대나 경찰서에 전화하여 익명으로 다음과 같은 허위 신고를 합니다. 화재, 공습, 폭탄에 대해 익명으로 허위 신고합니다.\n적이 사용하는 사무실과 건물에서는 전화기의 수화기를 망가트립니다. 전기 기술자와 전화 수리공은 연결 상태가 좋지 않고 절연이 손상되어 혼신 및 기타 종류의 전기 간섭을 만들어 통화가 어렵거나 불가능하게 만들 수 있습니다.\n자동 교환기의 배터리는 못, 또는 동전으로 손상시킬 수 있습니다. 이런 식으로 배터리의 절반을 처리할 수 있다면 교환기의 작동이 중단됩니다.\n\n\n\n6.7.2 전신\n\n전보 전달을 고의로 지연시킵니다.\n적지로의 전보를 왜곡하여 다른 전보를 보내거나 장거리 통화를 해야만 하는 상황으로 만듭니다. 예를 들어, “최소”를 “최대”로 변경하여 전보를 받는 사람이 “최소” 인지 “최대” 인지 알 수 없도록 하는 등 단어의 한 글자를 변경하여 이를 수행할 수 있는 경우도 있습니다.\n\n\n\n6.7.3 전화선\n\n전화 및 전신 통신선을 자르고 피복을 망가뜨려 간섭을 발생시키세요.\n\n\n\n6.7.4 우편\n\n우체국 직원은 적의 우편을 잘못된 행낭에 넣는 등의 행위를 통해 우편이 하루 이상 지연되도록 할 수 있습니다.\n\n\n\n6.7.5 영화\n\n영사기 관리자는 초점을 흐리거나 필름을 빠르게 또는 종종 멈추게 함으로써 뉴스와 적의 선전 영화를 망칠 수 있습니다.\n관객들은 박수를 쳐 연사의 말을 묻히게 하거나, 큰 소리로 잡담을 함으로써 적의 선전 영화를 망칠 수 있습니다.\n나방 20 ~ 30 마리를 종이백에 넣어 감으로써 적 선전 영화의 상영을 중단시킬 수 있습니다. 종이백을 가지고 들어가 영화관의 빈 바닥에 내려놓은 뒤 열어두면 나방들이 튀어나와 영사기의 빛으로 몰려들어 펄럭거리는 그림자로 화면을 뒤덮을 것입니다.\n\n\n\n6.7.6 라디오\n\n방송국 기술자들은 목소리 송출을 과다 변조함으로써 손쉽게 적의 선전 방송이나 지시사항이 마치 물속에서 말하는 것처럼 들리게 할 수 있습니다.\n자신의 아파트 건물에서는 적이 모든 사람이 듣기를 원할 때 라디오 수신을 방해할 수 있습니다. 전등 코드 끝에서 전등 플러그를 뽑고, 코드에서 전선을 꺼내 2구 플러그의 두 단자 또는 4구 플러그의 세 단자에 묶습니다. 그런 다음 전선을 가지고 다니면서 벽이나 바닥에 있는 콘센트에 최대한 많이 꽂아보세요. 플러그를 새 회로에 꽂을 때마다 퓨즈가 끊어지고 새 퓨즈로 교체할 때까지 모든 무전기가 고장 상태가 됩니다.\n어떤 전자 장비이든 절연체를 손상시킴으로써 이웃집, 거대 발전기, 네온사인, 형광등, 엑스레이 장치 및 송전선 등에 무선 간섭을 일으킬 수 있습니다. 만약 작업자가 적 비행장 근처 고압선의 절연체를 손상시킬 수 있다면 지상에서 비행기로의 무선 통신이 장시간동안 어려워질 것입니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#전력",
    "href": "posts/qmd/guide_sabotage.html#전력",
    "title": "사보타지 매뉴얼",
    "section": "6.8 전력",
    "text": "6.8 전력\n\n6.8.1 터빈, 전기 모터, 변압기\n\n공업 생산: 제조 &gt; 전기모터, 변압기, 터빈 참고\n\n\n\n6.8.2 송전 선로\n\n전선 작업자는 절연체를 느슨하게 하고 더러워지게 하여 고의로 누전을 일으킬 수 있습니다. 두 개의 평행한 송전선 사이에 매우 무거운 끈을 여러 번 앞뒤로 묶어 매번 전선 주위를 여러 바퀴 감는 것도 매우 쉬울 것입니다. 미리 끈을 소금으로 심하게 절인뒤 감습니다. 그러면 비가 오면 줄이 도체가 되어 단락이 발생할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#조직-전반적인-사보타지",
    "href": "posts/qmd/guide_sabotage.html#조직-전반적인-사보타지",
    "title": "사보타지 매뉴얼",
    "section": "6.9 조직 전반적인 사보타지",
    "text": "6.9 조직 전반적인 사보타지\n\n6.9.1 회의\n\n모든 일은 절차를 통해 하자고 주장합니다. 신속한 결정을 하기 위한 절차는 절대 허용하지 않습니다.\n회의 시간에는 연설을 하세요. 가능한 자주 그리고 굉장히 길게 일화와 개인 경험담에 대한 이야기를 하므로 요점을 찾을 수 없도록 하세요. 특히 적절한 “애국적” 코멘트를 추가하는 것을 중요합니다.\n항상 ” 추가적인 고려 ” 를 위해 위원회를 만들어 내용을 검토하세요. 위원회는 5 인 이상으로 가능한 크게 만들어야 합니다.\n무의미한 이슈를 가능한 자주 끌어 들입니다.\n보도문, 의사록, 결의안에 대한 표현을 계속 검토하고 수정하세요.\n지난 회의에서 결정된 사항을 되돌아보고 그 결정의 타당성에 대해 다시 의문을 제기하세요.\n“조심” 하자고 주장하고 다른 회의 참석자들에게도 “합리적” 으로 생각하며 서두르지 않아야 나중에 당황하지 않는다고 말하세요.\n어떤 결정이든 그 타당성에 대해 걱정하세요. 그 결정이 조직 내에서 숙고된 것인지 아니면 다른 상위 조직의 정책과 상충되지는 않는지 계속 의문을 제기하세요.\n\n\n\n6.9.2 관리자 및 감독자\n\n항상 서면으로 된 주문서를 요구하세요.\n주문서의 내용을 의도적으로 오해합니다. 그러한 주문서에 대해 끝 없이 질문을 할 수 있고 긴 서신을 서로 주고 받을 수 있습니다. 그리고 아주 애매한 용어를 사용합니다.\n주문서 전달을 지연시킵니다. 주문서 일부가 완성되었어도 전체가 준비될 때까지는 전달하지 마세요.\n주문을 이행하는 중 조금의 지연도 전체 중단으로 이어질 수 있도록 현재 재고를 거의 다 써버릴 때까지 새로운 작업 재료를 주문하지 마세요.\n확보하기 어려운 자재를 주문하세요. 저급한 자재는 저급한 산출물로 이어진다고 따지세요.\n작업 할당 시에는 항상 중요하지 않은 작업부터 나눠주세요. 중요한 작업은 실력 없는 노동자에게 할당 하세요.\n상대적으로 덜 중요한 제품에 완벽한 작업이 필요하다고 고집 부리세요. 눈에 보이는 결함이 있는 것은 다시 보완하도록 돌려보내고 맨 눈으로는 볼 수 없는 결함을 가진 부품은 통과시키세요.\n부품과 자재가 공장 내의 잘못된 곳으로 보내지도록 잘못된 경로로 보내세요.\n새로운 노동자를 훈련시킬 때는 불완전하거나 잘못된 지시를 하세요.\n사기를 낮춰 생산량을 감소시키기 위해 실력 없는 노동자를 부적절하게 승진시키세요. 실력 있는 노동자는 차별하고 작업물에 대해 불평하세요.\n더 중요한 일이 있을 때는 새로운 회의를 개최하세요.\n그럴 듯한 방법으로 서류 작업을 늘리세요.\n지침 발행, 수표 발행 등과 관련된 절차와 허가를 늘리고 한 명이면 됐을 모든 일을 세 명이 승인해야 하게 만드세요.\n모든 규정을 빼놓지 않고 다 적용하세요.\n\n\n\n6.9.3 회사원\n\n주문을 받아 적을 때 자재의 수량을 잘 못적으세요. 그리고 비슷한 이름들은 서로 헷갈리게 적고 잘못된 주소를 사용하세요.\n정부 기관과의 의사소통이 길어지게 하세요.\n중요 문서를 잘못되게 정리하세요.\n사본을 만들 때는 하나를 덜 만들어서 추후에 복사 작업이 추가로 필요하게 만드세요.\n상관에게 중요한 전화가 오면 바쁘거나 통화 중이라고 말하세요.\n다음 번 수거 때까지 우편물을 보내지 말고 보관하고 있으세요.\n내부 정보처럼 위장된 흉흉한 소문을 퍼뜨리세요.\n\n\n\n6.9.4 종업원\n\n천천히 일하세요. 작업할때 필요한 동작의 수를 늘리세요. 예를 들면 무거운 망치 대신 가벼운 망치를 쓰거나, 큰 렌치가 필요할 때 작은 렌치를 사용하거나, 충분한 힘이 필요할 때 힘을 거의 쓰지 않는다거나 등등이 있습니다.\n일할 때 가능한 많은 중단이 발생하도록 하세요. 선반이나 펀치머신 위에서 작업 중 자재를 바꿔야할 때, 쓸 데 없이 많은 시간을 들이세요. 절단 작업 또는 치수 작업 중이라면, 필요한 것보다 두 배 더 자주 수치를 확인하세요. 화장실을 갈 경우 쓸 데 없이 더 길게 다녀오세요. 항상 도구를 잃어버리고 다니도록 하세요.\n실제로는 이해하더라도 외국어로 된 지시사항은 못알아 듣는 척하세요.\n지시사항이 이해하기 어려운 척 하여 한 번 이상 더 반복하도록 물어보세요. 또는 특별히 걱정이 많은 척 하여 쓸데 없는 질문으로 관리자를 훼방 놓으세요.\n작업을 엉망으로 한 뒤 나쁜 도구, 기계, 또는 장비 탓을 하세요. 그리고 일을 제대로 할 수 없다고 불평하세요.\n신입 노동자에게 기술과 경험을 전수하지 마세요.\n가능한 모든 방법으로 관리를 어렵게 하세요. 문서의 양식을 이해하기 어렵게 작성하여 실수를 하거나 필수 정보를 빼놓아서 다시 작성하게 만드세요.\n가능하다면 직원의 고충을 관리자에게 보고하는 조직에 가입하거나 만드세요. 보고 절차가 관리자를 불편하게 하는지, 각 보고에 많은 수의 직원이 참여하는지 고충에 대해 최소 하나 이상의 회의를 수반하는지 등등을 확인하세요.\n주문 받은 자재를 잘못 납품하세요.\n정상 부품들을 불량 부품들과 함께 섞어 놓으세요."
  },
  {
    "objectID": "posts/qmd/guide_sabotage.html#조직의-사기를-낮추고-혼란을-일으키는-행동들",
    "href": "posts/qmd/guide_sabotage.html#조직의-사기를-낮추고-혼란을-일으키는-행동들",
    "title": "사보타지 매뉴얼",
    "section": "6.10 조직의 사기를 낮추고 혼란을 일으키는 행동들",
    "text": "6.10 조직의 사기를 낮추고 혼란을 일으키는 행동들\n\n질문에 대해 불필요하게 복잡하고 모호하게 답변하기\n근거 없는 위협이나 위험을 당국에 신고하기\n의도적으로 무지한 척 행동하기\n법적 문제를 일으키지 않는 선에서 타인을 불편하게 만들기\n공공 서비스나 규정을 고의로 잘못 해석하기\n사소한 일에도 과도하게 불만을 표출하기\n특정 국적이나 배경을 가진 사람들을 공개적으로 차별하기\n특정인의 등장 시 대화를 갑자기 중단하기\n상황에 맞지 않게 과도한 감정 표현하기\n공식 매체나 문화 행사를 의도적으로 외면하기\n공동체 활동에 비협조적인 태도 보이기"
  },
  {
    "objectID": "posts/qmd/learn_programmingFont.html",
    "href": "posts/qmd/learn_programmingFont.html",
    "title": "프로그래밍을 위한 고정폭 폰트",
    "section": "",
    "text": "프로그래머라면 코드 에디터를 열 때마다 어떤 폰트를 사용할지 고민해 본 적이 있을 것입니다. 일반적으로 문서 작성에는 가변폭(proportional) 폰트가 많이 쓰이지만, 프로그래밍에서는 대부분 고정폭(monospaced) 폰트를 사용합니다. 그 이유는 무엇일까요?"
  },
  {
    "objectID": "posts/qmd/learn_programmingFont.html#끝없는-폰트-욕심",
    "href": "posts/qmd/learn_programmingFont.html#끝없는-폰트-욕심",
    "title": "프로그래밍을 위한 고정폭 폰트",
    "section": "3.1 끝없는 폰트 욕심",
    "text": "3.1 끝없는 폰트 욕심\n폰트는 취향을 많이 타다보니 저도 그동안 위의 여러 폰트를 시도해보았습니다. 그럼에도 만족하지 못하고 틈나면 폰트를 변경하던 중 최근 JetBrains Mono와 D2Coding을 결합한 폰트인 JetBrainsMonoHangul을 찾았고 fork해 약간의 수정을 거쳐 사용하고 있습니다4. 이 블로그에서도 웹폰트로 사용하고 있는데 상당히 만족스럽습니다.\n물론 서로 다른 글리프를 임의 결합한 것이다보니 스타일이 조금 다르다는 단점이 있습니다. 이 문제를 해결하려면 폰트 디자인을 공부해 한글 글리프를 (대략 2,500개) 수정해야 합니다. 쉽지 않은 일이지요."
  },
  {
    "objectID": "posts/qmd/learn_programmingFont.html#footnotes",
    "href": "posts/qmd/learn_programmingFont.html#footnotes",
    "title": "프로그래밍을 위한 고정폭 폰트",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://steemit.com/kr/@jwsohn/8-fixed-width-font↩︎\nhttps://html4silver.tistory.com/152↩︎\nhttps://slowalk.com/2195↩︎\nhttps://github.com/partrita/JBD2/↩︎"
  },
  {
    "objectID": "posts/qmd/learn_scRNAseq.html",
    "href": "posts/qmd/learn_scRNAseq.html",
    "title": "scRNA-seq 소개",
    "section": "",
    "text": "얼마전 뉴욕 타임즈에 A.I. Is Learning What It Means to Be Alive 라는 제목의 기사가 공개되었습니다. 해당 기사에서 에 scRNA-seq 기초 모델이 단일 세포 RNA 시퀀싱 (scRNA) 데이터를 해석, 사용, 적용하는 방식을 어떻게 변화시킬 수 있는지에 대한 이야기가 있었는데 이 포스팅에서 더 깊이 파고들어 살펴보고자 합니다."
  },
  {
    "objectID": "posts/qmd/learn_scRNAseq.html#역사",
    "href": "posts/qmd/learn_scRNAseq.html#역사",
    "title": "scRNA-seq 소개",
    "section": "4.1 역사",
    "text": "4.1 역사\n기반 모델 (Foundation Models) 은 일반적으로 광범위한 데이터에 대해 학습된 모델로 다양한 다운스트림 분석을 적용 (예: 미세 조정) 할 수 있는 모델입니다. 이런 기술은 자연어 처리 분야에서 가장 널리 사용되지만 최근에는 이미지 (DALL-E), 오디오 (MusicGen), 심지어 아미노산 서열 (ESM2) 등 다양한 분야로 확장되었습니다.\n거의 모든 다른 개념과 마찬가지로 임베딩 개념은 2010 년대 초까지 거슬러 올라가는 등 이전에도 광범위하게 시도되어 왔으며 기반 모델이 임베딩 개념을 처음 고안한 것은 아닙니다. 하지만 단순한 선형 임베딩 방식에 의존하거나 훈련된 정확한 섭동에 국한되거나 비교적 작은 데이터 세트에 대해 훈련되는 등 그 범위는 제한적이었습니다. 마크오브바이오의 블로그 게시물 에서 이런 단점에 대해 자세히 설명합니다. scVI 와 같이 다양한 데이터 세트에서 훈련된 비선형 데이터 변환을 다룬 논문이 몇 편 있었지만, 그 결과는 논문으로서 흥미롭기는 하지만 실제로 유용하기에는 여전히 모호한 영역에 머물러 있었습니다.\n하지만 혁신적인 Attention Is All You Need 논문에 의해 거대 모델과 방대한 양의 데이터가 특별한 모델을 만들 수 있다는 믿음이 점점 커지면서 생물학자들은 자체적인 scRNA-seq 기반 모델을 구축하기 시작했습니다. 2024 년 3 월 현재, scFormer, scFoundation, GeneFormer, scBERT, scGPT, Universal Cell Embeddings 등 여러 가지의 기반 모델이 공개되었습니다. 이런 모델들이 만들어질 수 있었던 원동력은 앞서 이야기한 바 있는 세포 지도입니다. 각각의 모델은 지난 10 년 동안 모아왔던 여러 개의 세포 지도 데이터를 학습 데이터로 사용해 그 어떤 모델보다 세포 상태를 더 잘 이해할 수 있게 되었습니다."
  },
  {
    "objectID": "posts/qmd/learn_scRNAseq.html#universal-cell-embeddings",
    "href": "posts/qmd/learn_scRNAseq.html#universal-cell-embeddings",
    "title": "scRNA-seq 소개",
    "section": "4.2 Universal Cell Embeddings",
    "text": "4.2 Universal Cell Embeddings\nUCE 는 2023 년 11 월에 공개되었으며 scRNA-seq 데이터를 분석하는 사람들에게 정말 중요한 도구가 될 것으로 보입니다. 아래와 같은 특징이 있기 때문이죠.\n\n다른 기반 모델들은 인간 세포에 한정된 반면에 UCE 모델은 인간, 생쥐, 여우원숭이, 제브라피쉬, 돼지, 붉은털원숭이, 필리핀원숭이 (cynomolgus monkey), 발톱개구리등의 총 8 가지 종의 데이터셋을 학습에 사용하였습니다.\nUCE 모델은 미세 조정이 필요 없는 유일한 모델입니다. 즉, 추가적인 학습없이도 103 개의 조직 및 다양한 종의 세포를 분류 할 수 있습니다.\nChan Zuckerberg Biohub Network 의 지원을 받고 있습니다. Chan Zuckerberg Biohub Network 은 타불라 사피엔스, 타불라 무리스, 타불라 무리스 세니스, 타불라 마이크로세버스, CellXGene 등 scRNA-seq 데이터를 가장 많이 생성하고 공개하는 곳입니다.\n다른 기반 모델보다 성능이 뛰어납니다.\n완전히 새로운 종에서 수집한 세포의 임베딩을 UMAP 으로 그려볼 수 있습니다. UCE 는 종간의 정보도 학습했기 때문에 (물론 임베딩 플롯은 항상 약간의 논란이 있을 수 있지만) 영장류와 닭 세포 유형을 분리할 수도 있습니다. 자세한 알아보기.\n새로운 세포 유형을 찾을 수 있습니다. 희귀한 세포 유형이 포함된 scRNA 데이터셋을 통해 제로 샷 임베딩을 수행하면 새로운 세포 유형을 구분하는 간단한 이진 분류기를 만들 수 있습니다. 이 분류기를 사용하면 그동안 데이터 세트에 흩어져 있는 세포들을 찾아 낼 수 있는 것입니다.\n마지막으로 암조직(COPD 및 IPF)과 정상 조직의 유전자 발현 차이를 조사할 수 도 있습니다. 여기서 흥미로운 점은 이 유전자 발현의 차이가 새롭게 발견한 희귀 세포 유형에서 발생했다는 것입니다.\n\n3 년이 지난 후에도 여전히 강세를 보이는 알파폴드 같은 모델처럼 UCE 가 기반 모델의 승자가 될까요? 아직 확신하긴 어렵습니다. 다만 UCE이 현재 가장 좋은 성능을 보이는 모델이라는 것은 확실해 보입니다."
  },
  {
    "objectID": "posts/qmd/setup_ds_env.html#pip-virtualenv",
    "href": "posts/qmd/setup_ds_env.html#pip-virtualenv",
    "title": "데이터사이언스를 위한 파이썬과 R 개발 환경",
    "section": "2.1 pip + virtualenv",
    "text": "2.1 pip + virtualenv\npip와 virtualenv는 파이썬 개발 환경에서 가장 오래 사용되었고 또한 자주 사용되는 도구입니다. pip는 파이썬에 기본적으로 포함되어 있는 패키지 관리자로 PyPI(Python Package Index) 에 등록된 패키지를 설치하고 관리할 수 있습니다. virtualenv 는 가상 환경을 생성하여 프로젝트마다 독립된 파이썬 환경을 가질 수 있게 해주는 패키지입니다. 다른 프로젝트와 충돌 없이 패키지를 관리하려면 필수적으로 사용해야 합니다.\n\n\n\n\n\n\nWarning\n\n\n\npip 는 아래와 같은 몇 가지 근본적인 문제를 가지고 있습니다.\n\n\n\n의존성 충돌 (Dependency Conflicts) 여러 패키지를 설치할 때 각 패키지가 서로 다른 버전의 동일한 종속성을 요구할 경우 의존성 충돌이 발생하며 프로젝트에서 예기치 않은 동작이나 오류를 발생시킬 수 있습니다.\n글로벌 설치 문제 기본적으로 pip 는 전역 파이썬 환경에 패키지를 설치합니다. 이로 인해, 여러 프로젝트에서 동일한 패키지 버전을 공유하게 되어 프로젝트 간에 종속성 충돌이 발생할 수 있습니다. 특히, 프로젝트마다 요구되는 패키지 버전이 다른 경우에 문제가 됩니다.\n환경 관리의 어려움 pip 는 파이썬 환경을 별도로 관리하지 않으므로 전역 환경에 설치된 패키지들이 서로 영향을 미칠 수 있습니다. 이로 인해, 동일한 시스템에서 여러 프로젝트를 작업할 때 각 프로젝트의 요구 사항을 일관되게 유지하기 어려워집니다. 이를 해결하기 위해 virtualenv 와 같은 도구를 사용해 가상 환경을 생성해야 합니다.\n보안 문제 pip 는 기본적으로 모든 패키지를 신뢰합니다. 악의적인 사용자가 배포한 패키지가 PyPI 에 업로드되면, 이를 설치하는 과정에서 보안 문제가 발생할 수 있습니다.\n복잡한 패키지 관리 복잡한 프로젝트에서는 수많은 패키지와 버전들을 관리해야 하는데, pip 는 기본적으로 이러한 복잡한 종속성 트리를 관리하는 데 최적화되어 있지 않습니다. 이는 특정 패키지 설치 시 종속성 문제가 발생할 때 수동으로 해결해야 하는 번거로움으로 이어질 수 있습니다. 이러한 문제들로 인해, 많은 개발자들이 pipenv 또는 poetry 같은 도구들을 사용하여 환경과 패키지 관리를 하고 있습니다.\n\npip 는 파이썬에 기본적으로 설치되어 있어 상관이 없지만, virtualenv 는 pip 를 사용해 설치할 수 있습니다. 다음 단계를 따라 설치하면 됩니다. 먼저 터미널 (또는 명령 프롬프트) 을 열고 다음 명령어를 입력합니다. 이 명령어는 최신 버전의 virtualenv 를 설치합니다.\npip install virtualenv\nvirtualenv 가 올바르게 설치되었는지 확인하려면, 다음 명령어를 입력하여 버전을 확인할 수 있습니다.\nvirtualenv --version\n버전 번호가 출력되면 virtualenv 가 성공적으로 설치된 것입니다.\n\n2.1.1 가상환경\n기본적으로 pip 는 전역 (global) 파이썬 환경에 패키지를 설치하기 때문에 필연적으로 의존성 문제가 발생합니다. 그러나 virtualenv 를 사용하면 각 프로젝트마다 별도의 가상 환경을 만들어 서로 다른 패키지 버전이나 설정을 유지할 수 있습니다. 이는 프로젝트 간의 종속성 충돌을 방지하고, 개발 환경을 안정적으로 유지하는 데 도움이 됩니다.\n\n2.1.1.1 virtualenv 주요 커맨드\n\nvirtualenv 설치: bash pip install virtualenv\n가상 환경 생성: bash python -m virtualenv 가상환경명 가상환경명 은 원하는 이름으로 지정할 수 있습니다. 이 명령어는 가상환경명 이라는 폴더를 생성하고, 그 안에 독립된 파이썬 실행 파일과 pip 를 포함한 환경을 구성합니다.\n가상 환경 활성화:\n\nWindows: bash 가상환경명\\Scripts\\activate\nMac/Linux: bash source 가상환경명/bin/activate 가상 환경이 활성화되면, 터미널 프롬프트에 (가상환경명) 이 표시됩니다. 이 상태에서 pip 로 설치된 패키지는 전역 환경이 아닌 해당 가상 환경에 설치됩니다.\n\n가상 환경 비활성화: bash deactivate 가상 환경에서 벗어나기 위해 이 명령어를 사용합니다.\n가상 환경 내 패키지 관리:\n\n패키지 설치: bash pip install 패키지명 활성화된 가상 환경에 패키지를 설치합니다.\n설치된 패키지 목록 저장 (dependencies list): bash pip freeze &gt; requirements.txt 현재 가상 환경에 설치된 모든 패키지의 목록을 requirements.txt 파일로 저장합니다.\n목록에 따른 패키지 설치: bash pip install -r requirements.txt requirements.txt 파일에 기록된 패키지들을 한 번에 설치합니다.\n\n\n\n\n\n2.1.2 의존성 관리하기\npip 는 다음과 같은 기능을 지원합니다:\n\n패키지 설치: 파이썬 패키지를 설치합니다.\n패키지 업그레이드: 기존에 설치된 패키지를 최신 버전으로 업그레이드합니다.\n패키지 제거: 더 이상 필요하지 않은 패키지를 삭제합니다.\n패키지 목록 보기: 현재 설치된 패키지의 목록을 볼 수 있습니다.\n\n\n2.1.2.1 주요 pip 커맨드\n\n패키지 설치: bash pip install 패키지명\n패키지 업그레이드: bash pip install --upgrade 패키지명\n패키지 제거: bash pip uninstall 패키지명\n설치된 패키지 목록 보기: bash pip list\n패키지의 특정 버전 설치: bash pip install 패키지명==버전\n\n\n\n\n\n\n\nTip\n\n\n\n가상환경과 라이브러리 관리 팁 1. 프로젝트마다 가상 환경 생성: 프로젝트를 시작할 때마다 새로운 가상 환경을 생성하여, 프로젝트 간에 라이브러리 충돌을 방지하는 것이 좋습니다. 2. requirements.txt 활용: 프로젝트의 의존성을 공유하거나 배포할 때 requirements.txt 파일을 사용하면, 다른 사람이 동일한 환경을 쉽게 설정할 수 있습니다. 3. 가상 환경 폴더 관리: virtualenv 로 생성된 가상 환경 폴더는 일반적으로 프로젝트 폴더 내에 두거나, 중앙 관리 폴더를 만들어 관리할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/setup_ds_env.html#conda",
    "href": "posts/qmd/setup_ds_env.html#conda",
    "title": "데이터사이언스를 위한 파이썬과 R 개발 환경",
    "section": "2.2 Conda",
    "text": "2.2 Conda\nconda 는 패키지 매니저로 가상환경을 만들고 파이썬 패키지의 의존성을 관리하고, 설치, 삭제, 업데이트 등을 할 수 있습니다. conda 는 기본적으로 Anaconda 라는 파이썬 기반의 데이터 분석에 특화된 각종 패키지를 모아놓은 플랫폼에서 개발되었습니다. 다시말해 Anaconda 를 설치하면 자동으로 conda 도 설치가 됩니다.\n만약 Anaconda 에서 패키지 관리 메니저인 conda 만을 설치 하고 싶다면 miniconda 를 설치 하면 됩니다. 저는 개인적으로 Miniconda 를 사용하는 것을 추천합니다. Anaconda 는 라이센스 문제와 설치 용량이 크다는 단점이 있기 때문입니다.\n\n2.2.1 Conda 사용법\n\n2.2.1.1 가상환경\n새로운 프로젝트를 시작할때면 항상 새로운 가상환경을 만들어 작업하는것이 좋습니다. 새로운 가상환경 ENV_NAME 을 만드는 예시를 들어보겠습니다.\n\n터미널에 다음과 같이 입력해 새로운 가상환경을 만듭니다.\n\nconda env create -n ENV_NAME\nconda env create -n ENV_NAME -f requirements.txt # 의존성 파일로 부터 가상환경을 만들때 사용하는 코드\n\n가상환경을 사용하기 위해서는 활성화 (activate) 시켜줘야 합니다. 활성화되면 터미널에 (ENV_NAME) 이 표시됩니다.\n\nconda activate ENV_NAME\n\n만약 가상환경을 종료하고 싶다면 비활성화 (deactivate) 하면 됩니다.\n\nconda deactivate\n\n이미 생성한 가상환경의 목록은 다음과 같이 확인 할 수 있습니다.\n\nconda env list\n\n생성한 가상환경을 제거하는 명령어는 다음과 같습니다.\n\nconda env remove -n ENV_NAME\n\n\n2.2.1.2 의존성 관리하기\n자주 사용하는 conda 명령어는 아래와 같습니다. 예시로 numpy 를 설치하는 상황을 가정합니다.\n\n\n\n기능\n명령어\n\n\n\n\n패키지 설치\nconda install numpy\n\n\n동시에 여러 패키지를 설치\nconda install numpy scipy pandas\n\n\n특정 버전 설치\nconda install “numpy=1.10”\n\n\n패키지 제거\nconda remove numpy\n\n\n패키지 업데이트\nconda update numpy\n\n\n모든 패키지 업데이트\nconda update –all\n\n\n설치된 목록 출력\nconda list\n\n\n설치하려는 패키지 검색\nconda search numpy\n\n\n\n만약 Conda 에서 패키지를 찾을 수 없다면 pip 을 사용해보세요\n\n\n\n2.2.2 Conda 제거하기\n만약 conda 를 제거하고 싶다면 다음과 같이 하면 됩니다.\n\nWindowsLinux, MacOS\n\n\n제어판에 들어가서 Python(Anaconda) 혹은 Python(Miniconda) 를 제거합니다.\n\n\n단순하게 아래 디렉토리만 삭제하면 됩니다.\nrm -rf ~/miniconda\nrm -rf ~/anaconda"
  },
  {
    "objectID": "posts/qmd/setup_ds_env.html#rstudio-설치",
    "href": "posts/qmd/setup_ds_env.html#rstudio-설치",
    "title": "데이터사이언스를 위한 파이썬과 R 개발 환경",
    "section": "3.1 RStudio 설치",
    "text": "3.1 RStudio 설치\nR 의 기본 콘솔 외에 통합 개발 환경 (IDE) 를 사용하고 싶다면 RStudio 를 설치할 수 있습니다. 다만 개인용도로만 무료임으로 라이센스를 항상 확인하세요.\n\nRStudio 다운로드:\n\nRStudio 공식 웹사이트 에서 운영 체제에 맞는 설치 파일을 다운로드합니다.\n\nRStudio 설치:\n\n다운로드한 파일을 실행하여 설치를 진행합니다. 설치 과정은 간단하며, 기본값으로 진행하면 됩니다.\n\nRStudio 실행:\n\n설치가 완료되면, RStudio 를 실행하여 R 환경을 더욱 효율적으로 사용할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/setup_ds_env.html#가상환경-2",
    "href": "posts/qmd/setup_ds_env.html#가상환경-2",
    "title": "데이터사이언스를 위한 파이썬과 R 개발 환경",
    "section": "4.1 가상환경",
    "text": "4.1 가상환경\n\n4.1.1 renv\nrenv 는 R 의 가상환경 관리 도구로, Python 의 virtualenv 나 conda 와 유사한 역할을 합니다. renv 는 각 프로젝트마다 독립된 라이브러리 환경을 설정하여, 서로 다른 프로젝트에서 사용하는 패키지가 충돌하지 않도록 도와줍니다.\nrenv 의 주요 기능\n\n프로젝트별로 패키지 라이브러리 폴더를 생성하여, 각 프로젝트마다 고유한 환경을 유지.\nrenv.lock 파일을 사용하여 프로젝트에 필요한 패키지 버전과 의존성을 기록.\nrenv 를 사용하면 특정 시점의 패키지 상태를 다른 시스템에서 동일하게 재현 가능.\n\n\nrenv 설치:\ninstall.packages(\"renv\")\n프로젝트 초기화: 프로젝트 디렉토리에서 renv 를 초기화합니다. 이는 새로운 가상환경을 생성하고, renv.lock 파일을 생성합니다.\nrenv::init()\n패키지 설치: 일반적인 방법으로 패키지를 설치하면 해당 패키지는 현재 renv 환경에 설치됩니다.\ninstall.packages(\"ggplot2\")\n환경 스냅샷 생성: 프로젝트의 현재 상태를 기록하여 renv.lock 파일에 저장합니다.\nrenv::snapshot()\n환경 복원: 다른 시스템에서 동일한 환경을 재현하기 위해, renv.lock 파일을 사용하여 패키지 환경을 복원합니다.\nrenv::restore()\n가상환경 해제: 프로젝트의 가상환경을 해제하고 전역 라이브러리를 사용하도록 변경합니다.\nrenv::deactivate()"
  },
  {
    "objectID": "posts/qmd/setup_ds_env.html#의존성-관리하기-2",
    "href": "posts/qmd/setup_ds_env.html#의존성-관리하기-2",
    "title": "데이터사이언스를 위한 파이썬과 R 개발 환경",
    "section": "4.2 의존성 관리하기",
    "text": "4.2 의존성 관리하기\n\n4.2.1 CRAN\n대부분의 R 패키지는 CRAN(Comprehensive R Archive Network) 을 통해 설치 및 관리됩니다. CRAN 은 R 패키지의 공식 저장소로 일반적인 분석 작업에 필요한 대부분의 패키지를 제공합니다.\n\n4.2.1.1 주요 CRAN 커맨드\n\ninstall.packages(): 기본적으로 CRAN 에서 패키지를 설치하는 함수입니다.\nlibrary(): 패키지를 로드하는 함수입니다. 한 번 설치된 패키지는 프로젝트에서 사용할 때마다 library(패키지명) 을 통해 불러올 수 있습니다.\nupdate.packages(): 설치된 모든 패키지를 최신 버전으로 업데이트하는 함수입니다.\nremove.packages(): 설치된 패키지를 제거하는 함수입니다.\n\n\n\n\n4.2.2 Bioconductor: 생물정보학용 패키지 매니저\n생물정보학 연구에서 자주 사용되는 R 패키지는 Bioconductor 를 통해 관리됩니다. Bioconductor 는 CRAN 을 통해 설치해 사용할 수 있습니다. 주요 명령어는 아래와 같습니다.\n\nBiocManager 설치:\ninstall.packages(\"BiocManager\")\nBioconductor 패키지 설치:\nBiocManager::install(\"패키지명\")\nBioconductor 패키지 제거\n\n특정 Bioconductor 패키지를 제거하려면 remove.packages() 함수를 사용합니다:\nremove.packages(\"패키지명\")\n\n특정 Bioconductor 버전을 사용하고 싶다면 (예: 3.13):\n\nBiocManager::install(version = \"3.13\")\n\nBioconductor 패키지 검색\n\nBioconductor 에서 특정 패키지를 검색하려면:\nBiocManager::available(\"패키지명\")\n이러한 명령어들을 활용하면 Bioconductor 패키지를 효과적으로 관리하고, 필요한 생물정보학 도구들을 손쉽게 사용할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_PARA_methods.html#project",
    "href": "posts/qmd/guide_PARA_methods.html#project",
    "title": "미니멀한 폴더 정리: PARA method",
    "section": "2.1 PROJECT",
    "text": "2.1 PROJECT\nPROJECT 는 특정 목표를 가지고 시작한 짧은 기간의 작업을 나타냅니다. 몇 가지 예시는 아래와 같습니다.\n\n웹페이지 디자인\n새로운 컴퓨터 구매\n연구 보고서 작성\n욕실 리모델링\n스페인어 학습"
  },
  {
    "objectID": "posts/qmd/guide_PARA_methods.html#area",
    "href": "posts/qmd/guide_PARA_methods.html#area",
    "title": "미니멀한 폴더 정리: PARA method",
    "section": "2.2 AREA",
    "text": "2.2 AREA\nAREA 는 지속적인 관심이 필요한 업무와 삶의 중요한 부분을 나타냅니다. 다음은 몇 가지 예시입니다.\n\n업무적인 책임: 마케팅, 인사, 제품 관리, 연구 및 개발, 엔지니어링\n개인적인 책임: 건강, 재정, 가족, 글쓰기, 자동차, 주택"
  },
  {
    "objectID": "posts/qmd/guide_PARA_methods.html#resource",
    "href": "posts/qmd/guide_PARA_methods.html#resource",
    "title": "미니멀한 폴더 정리: PARA method",
    "section": "2.3 RESOURCE",
    "text": "2.3 RESOURCE\nRESOURCE 는 관심이 있는 주제나 배우고 싶은 자료가 포함합니다. 예시는 다음과 같습니다.\n\n그래픽 디자인\n가드닝\n커피\n웹 디자인\n일본어\n습관 형성\n사진 촬영"
  },
  {
    "objectID": "posts/qmd/guide_PARA_methods.html#archive",
    "href": "posts/qmd/guide_PARA_methods.html#archive",
    "title": "미니멀한 폴더 정리: PARA method",
    "section": "2.4 ARCHIVE",
    "text": "2.4 ARCHIVE\n마지막으로, 이전 세 가지 범주에 속하지 않는 항목을 포함하는 ARCHIVE 가 있습니다. 이 항목에는 향후 필요할 것으로 예상되는 것들이 포함됩니다. 몇 가지 예시는 다음과 같습니다.\n\n완료한 프로젝트나 보류 중인 프로젝트\n이제 관심이 없는 자료\n\n이것이 전부입니다! PROJECT, AREA, RESOURCE, ARCHIVE 네 가지 상위 폴더면 됩니다.\n삶을 네 가지 범주로 축소하는 것이 어렵겠지만 그러나 이것이 핵심입니다. 정리 시스템이 복잡하다면 그건 유지하기도 어렵고 정리하느라 더 많은 시간을 쓰게 될 것입니다. 그러니 최대한 간단한 시스템이어야 합니다. 그래야 문서 정리 시스템이 당신에게 여유 시간을 만들어 줄 수 있습니다."
  },
  {
    "objectID": "posts/qmd/guide_PARA_methods.html#프로젝트에-대하여",
    "href": "posts/qmd/guide_PARA_methods.html#프로젝트에-대하여",
    "title": "미니멀한 폴더 정리: PARA method",
    "section": "3.1 프로젝트에 대하여",
    "text": "3.1 프로젝트에 대하여\n프로젝트 목록을 만드는 것은 일의 성격, 업무량, 그리고 우선순위와 결과을 예측하는데 필요합니다. 아래 항목을 살펴보세요.\n    내 프로젝트 목록\n    1. 채용/인력 확보\n    2. 이벤트\n    3. 직속 보고\n    4. 전략적 계획\n    5. 연구\n    6. 휴가\n    7. 전문 개발\n    8. 생산성\n\n\n\n\n\n\nImportant\n\n\n\n문제점이 뭔지 아시겠나요?\n\n\n이 목록의 항목 하나하나는 사실은 프로젝트가 아닙니다. ” 전략적 계획 ” 이 언제 완료되는지를 정확히 말할 수 있나요? ” 휴가 ” 를 목록에서 지워버릴 수 있나요? 확실하지가 않습니다.\n사실 이 목록에 있는 모든 항목은 책임 영역입니다. 이것은 단순한 언어적인 문제로만 보이지만, 사실 그렇지 않습니다. 얼마나 똑똑하고 열정적인 사람이더라도, 책임 영역을 구체적인 프로젝트로 세분화하지 않는 한, 중요한 작업을 제때에 수행하기는 어렵습니다.\n\n3.1.1 문제점 1. 범위가 명확하지 않습니다\n위 목록을 보면 실제로 얼마나 많은 일을 했는지 정확히 알기 어렵습니다. ” 채용 ” 이라는 항목이 얼마나 많은 작업을 포함하는지 어떻게 알 수 있을까요? 이것은 6 개월마다 파트타임 채용부터 이번 분기에 50 명의 사원을 채용하는 것까지 다양할 수 있습니다. 이러한 불확실성은 업무를 실제보다 더 부담스럽게 만듭니다. 만약 ” 채용 ” 이라는 책임 영역에서 여러 프로젝트를 식별하고 그 목록을 매일 앞에 두면 어떤 작업을 더 해야할지 알 수 있을 것입니다. 예를 들어 아래와 같이요.\n     채용 프로젝트\n     1. \"기계공학 연구원\" 고용\n     2. \"프로젝트 분석가\" 고용\n     3. \"마케팅 책임자\" 고용\n     4. \"현장 요원\" 고용\n     5. \"재무 관리자\" 고용\n\n\n3.1.2 문제점 2. 현재 노력과 장기적인 목표가 연결되지 않습니다\n지식근로자의 가장 어려운 측면 중 하나는 창의성이 필요하다는 것입니다. 그리고 창의성은 동기 부여 없이는 지속할 수 없습니다. 다시 말해 의욕을 잃으면 최선의 결과를 얻을 수 없습니다. 그렇다면 동기는 어떻게 부여할 수 있을까요? 대부분은 진전에 달려 있습니다. 우리가 어딘가로 향하는 것을 안다면, 우리는 단기간의 스트레스와 좌절을 견딜 수 있습니다.\n다시 위 목록을 살펴보세요. 채용 프로젝트 목록에 있는 항목 중 하나도 종료일자나 기간에 대해 언급되어 있지 않습니다. 이러한 상황은 마치 끝없는 지평선과도 같아서 어떻게 노력하든 도달할 수 없는 목표로 보입니다. 솔직히 말해서, 이것보다 일의 의욕을 상실시키는 더 효과적인 방법은 없을 것 같습니다.\n그러니 큰 프로젝트를 더 작은 프로젝트로 만들고 기간을 정해야 합니다. 그래야 작은 성공을 통한 동기 부여가 가능합니다. 예를 들면 ” 이벤트 ” 라는 넓은 범주의 프로젝트를 아래와 같이 더 작은 개별 프로젝트로 나눌 수 있을 겁니다.\n     이벤트 프로젝트\n     1. 분기별 직원 워크샵\n     2. 연례 이해관계자 컨퍼런스\n     3. 연구 방법 워크샵\n     4. 연말 채용 박람회\n     5. 임원 여름 워크샵\n이렇게 하면 현재의 노력이 어떻게 장기적인 목표와 연결되는지 알 수 있을 것입니다. 작업 영역이 얼마나 광범위하든, 시간을 들여서 항상 그것들을 작은 프로젝트로 나눌 수 있습니다. 장기 목표에 대한 진전 상황을 알고 싶다면, 반드시 꼭 그렇게 해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html",
    "href": "posts/qmd/learn_dataVisualization.html",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "",
    "text": "Bang Wong, Martin Krzywinski, Nils Gehlenborg, Cydney Nielsen, Noam Shoresh, Rikke Schmidt Kjaergaard, Erica Savig, Alberto Cairo이 Nature Methods에 데이터 시각화에 대한 컬럼을 35편 썼습니다. 이글은 이런 자료들을 더 쉽게 찾아볼 수 있도록 한곳에 모아 정리한 것으로 많은 분들이 데이터 시각화를 하는데 도움이 되길 바랍니다.1"
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#쉽고-명확한-정보-전달을-위한-디자인",
    "href": "posts/qmd/learn_dataVisualization.html#쉽고-명확한-정보-전달을-위한-디자인",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "2.1 쉽고 명확한 정보 전달을 위한 디자인",
    "text": "2.1 쉽고 명확한 정보 전달을 위한 디자인\n디자인의 가장 중요한 원칙은 유용성과 기능입니다. 잘 만들어진 물건이 쓰기 쉬운 것처럼 여러분의 그래프와 포스터도 보고 이해하기 쉬워야 합니다. 훌륭한 디자인은 그 물건이 어떤 기능을 하는지 명확한 단서를 주는 것입니다. 예를 들어, 지하철 노선도는 도시의 한 곳에서 다른 곳으로 이동하는 방법을 찾는 데 매우 효율적인 도구입니다. 만약 기차 정보를 단순히 정류장과 연결 표로만 제공한다면, 두 지점 사이의 가장 빠른 길을 찾는 것은 훨씬 더 어려울 겁니다.\n따라서 그래프를 디자인할 때는 정보를 표현하는 체계적인 방법을 사용 하는 것이 중요합니다. 다른 종류의 정보를 명확하게 구분해 독자들이 발표 내용을 쉽게 이해할 수 있게 해야합니다.\n또한 탄탄한 디자인 아이디어 개념과 뛰어난 기술 실행 능력이 좋은 결과물을 만드는 데 필요합니다. 디자인은 탐색적인 과정이므로 머릿속의 아이디어를 현실로 만들고 필요에 따라 그래픽 요소를 다듬을 수 있는 능력이 필요합니다. 그러니 그래픽 소프트웨어를 능숙하게 다룰 수 있도록 시간을 투자하세요."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#레이아웃-정보-전달을-위한-시각적-정리의-기술",
    "href": "posts/qmd/learn_dataVisualization.html#레이아웃-정보-전달을-위한-시각적-정리의-기술",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "2.2 레이아웃: 정보 전달을 위한 시각적 정리의 기술",
    "text": "2.2 레이아웃: 정보 전달을 위한 시각적 정리의 기술\n레이아웃은 발표 자료를 명확하게 만들기 위해 글과 그림을 페이지에 보기 좋게 배치하는 작업입니다. 그래픽 디자인에서는 모든 시각적인 정보를 전달하는 데 레이아웃이 가장 기본이 됩니다. 내용을 잘 정리하면 복잡한 정보도 독자들이 쉽게 따라갈 수 있지만 자료가 뒤죽박죽이면 독자들을 헷갈리게 합니다.\n많은 예술가들은 ’황금 비율’이라는 특별한 수학적 관계를 사용합니다. 황금 비율은 어떤 선을 두 부분으로 나눴을 때, 전체 길이와 긴 부분의 비율이 긴 부분과 짧은 부분의 비율과 같아지는 것을 말합니다(대략 13:8 비율). 또한 황금 비율과 관련이 있는 ’피보나치 수열’은 그래픽 디자인에 많은 영향을 줍니다.(예 1, 2, 3, 5, 8, 13 등). 피보나치 숫자는 사용해 글꼴 크기나 책 페이지 레이아웃을 결정에 자주 사용되기 때문이죠.\n황금 비율을 실제로 활용하는 방법은 우리가 만드는 슬라이드와 포스터에 조화로운 비율을 적용하는 것입니다. 이는 단순히 예술적인 이유뿐만이 아닙니다. 페이지에 요소를 어디에 배치하느냐에 따라 의미를 전달할 수 있기 때문입니다. 황금 비율을 간단하게 적용한 것이 바로 ‘삼등분할 법칙’입니다. 이 법칙은 페이지를 가로세로로 3등분 하여 총 9개의 구획을 만들고, 이 선을 따라 또는 선이 교차하는 지점(이른바 ’파워 포인트’)에 중요한 요소를 배치하면 시각적으로 더 눈에 띄게 됩니다. 시선 추적 연구에 따르면 사람들은 이미지를 볼 때 이러한 선으로 표시된 영역에 시선이 더 오래 머무는 경향이 있다고 합니다.\n’그리드’를 사용하여 레이아웃을 잡으면 내용의 크기나 배치를 대충 짐작하지 않아도 되므로 디자인 과정을 훨씬 쉽게 만들 수 있습니다. 작업을 시작하기 전에 파워포인트나 어도비 일러스트레이터 같은 프로그램에서 미리 안내선(가이드)을 전략적으로 배치해보세요. 그리드는 내용을 고정시켜 디자인 전체에 안정감을 주고, 슬라이드 간의 일관성을 만들어 독자들이 다음에 나올 내용이 어디쯤에 나타날지 예상할 수 있도록 돕습니다.\n레이아웃은 단순히 그리드 선을 그리는 것이 아니라 독자의 시선이 어떤 경로로 움직이기를 원하는지 계획하는 과정입니다. 이는 내용의 중요도를 파악하여 무엇을 먼저 읽고 무엇을 나중에 읽을지 명확하게 보여주는 것입니다.\n우리는 모든 자료에 똑같은 시각적 내용으로 가득 찬 슬라이드와 포스터를 종종 보게 됩니다. 이런 경우 어디서부터 읽어야 할지 알기 어렵습니다. 전설적인 그래픽 디자이너 폴 랜드는 “대비가 없으면 죽은 것이나 마찬가지다”라고 말했습니다. 이처럼 레이아웃은 그래픽 디자인의 기본이자 정보 이해에 큰 영향을 줍니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#게슈탈트-이론",
    "href": "posts/qmd/learn_dataVisualization.html#게슈탈트-이론",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "2.3 게슈탈트 이론",
    "text": "2.3 게슈탈트 이론\n게슈탈트 이론은 사람들이 시각 정보를 어떻게 인식하고 정리하는지를 설명하기 위해 1920년대에 제안된 심리학 이론입니다. 독일어로 ‘형태’ 또는 ’형식’을 뜻하는 ’게슈탈트’는 우리가 개별적인 시각적 요소들을 모아 하나의 ’통합된 전체’로 인식하는 방식을 설명합니다.\n게슈탈트는 부분과 전체의 상호작용을 강조합니다. 게슈탈트 심리학의 창시자 중 한 명인 쿠르트 코프카는 “전체는 부분의 합과는 다르다”고 말했습니다. 단순히 각 부분의 합을 넘어서는 새로운 의미가 창출된다는 점입니다. 이 이론의 핵심 개념은 그룹화입니다. 우리는 비슷하게 보이거나, 가까이 배치되거나, 선으로 연결되거나, 공통된 공간 안에 둘러싸인 객체들을 함께 속한 것으로 인식하는 경향이 있습니다. 이는 정보에 대한 맥락을 구축하는 강력한 방법입니다.\n\n2.3.1 유사성 원리\n유사성 원리는 우리가 시각적으로 비슷한 요소들을 한 그룹으로 묶어 인식하는 경향을 설명합니다. 즉, 색상, 크기, 모양 등이 비슷한 것들은 서로 관련이 있다고 생각하는 것이죠. 이 원리는 데이터 시각화에서 범주를 구분할 때 흔히 사용됩니다. 또한, 글꼴, 글꼴 크기, 방향, 여백과 같은 그래픽 처리 방식을 반복적으로 사용하여 문서 내의 요소들이 서로 더 관련 있어 보이도록 디자인할 수 있습니다.\n\n\n2.3.2 근접성 원리\n근접성 원리는 서로 가까이 배치된 객체들을 한 그룹으로 인식하는 경향을 말합니다. 이 원리는 그림 패널을 배열할 때 유용하게 적용됩니다. 예를 들어, 여러 개의 패널이 균일하게 떨어져 있을 때는 무엇을 기준으로 분석해야 할지 모호할 수 있습니다. 하지만 비교해야 할 패널들을 가깝게 배치하여 그룹화하면, 독자는 자연스럽게 그 관계를 파악하게 됩니다. 반대로, 패널을 순서대로 읽도록 유도하고 싶다면 한 줄로 배열하는 것이 효과적입니다.\n\n\n2.3.3 연결성 및 폐쇄성 원리\n연결성 원리는 선이나 다른 시각적 연결 고리로 이어진 객체들을 통합된 그룹으로 인식하는 경향입니다. 유사성이나 근접성으로 묶인 객체들이 느슨한 연합으로 보이는 반면, 선으로 연결하면 연결성 원리에 의해 객체들을 훨씬 더 강하게 연관되게 보입니다.\n폐쇄성 원리는 공통된 영역 안에 요소들이 둘러싸여 있을 때 하나의 그룹으로 인식하는 경향을 말합니다. 이 원리는 유사성, 근접성, 심지어 연결성보다도 강력하게 객체들을 통합된 전체로 묶어줍니다.\n\n\n2.3.4 시각적 완성 원리\n시각적 완성(Visual Completion), 또는 시각적 보간(interpolation)은 실제로 존재하지 않는 윤곽선을 보게 되는 흥미로운 착시 현상을 만듭니다. 우리는 가능한 보이는 것에서 패턴을 찾으려는 경향이 있습니다. 따라서 우리는 프레젠테이션을 어지럽히는 불필요한 선, 상자, 글머리 기호 및 기타 그래픽 요소를 생략하여 깔끔하고 효과적인 디자인을 해야합니다.\n\n\n2.3.5 연속성 원리\n우리 눈은 작은 정렬 불일치에도 매우 민감합니다. 이것을 연속성(Continuity) 원리라고 합니다. 따라서 시각적 요소를 가이드에 맞춰 정렬하는 것이 보는 사람이 패턴을 식별하는 데 도움이 됩니다. 그래서 정렬 가이드를 사용하여 구성된 그림은 깔끔하고 전문적으로 보이게 됩니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#여백negative-space-디자인의-숨겨진-힘",
    "href": "posts/qmd/learn_dataVisualization.html#여백negative-space-디자인의-숨겨진-힘",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "2.4 여백(Negative Space): 디자인의 숨겨진 힘",
    "text": "2.4 여백(Negative Space): 디자인의 숨겨진 힘\n여백(Negative Space)은 페이지의 여백뿐만 아니라 텍스트 블록, 이미지 사이의 간격등을 의미 합니다. 여백은 제목, 글, 그림만큼이나 디자인에 중요한 부분으로 디자인 요소들에게 숨 쉴 공간을 줄 뿐만 아니라 시각적 매력과 효과를 극적으로 향상시킬 수 있습니다.\n\n2.4.1 여백의 중요성\n과학자의 발표 자료는 대개 내용으로 빽빽하게 채워져 있습니다. 일부 사람은 여백이 불필요하다고 여기거나 심지어 페이지가 가득 채워지지 않는다고 불평하기도 합니다. 그러나 내용이 빽빽한 없는 슬라이드와 포스터는 여백이 불규칙하기 때문에 이해하기 어렵습니다.\n\n\n2.4.2 효과적인 여백 넣기\n이미지와 텍스트를 글자 그대로 또는 시각적으로 추상화된 ‘상자’ 안에 넣어서 레이아웃을 만드세요. 그러면 양의 공간과 음의 공간의 분포가 명확해집니다. 일반적인 팁을 주자면 섹션을 구분할 때 더 넓은 간격을 사용하고 섹션 내의 항목을 분리 할때는 더 얇은 간격을 사용하는 것입니다. 그리고 텍스트의 경우 글자 사이의 간격, 줄의 길이, 줄 사이의 간격을 조절해 추상화된 상자에 맞춥니다. 이런 방식의 여백은 독자에게 콘텐츠의 계층과 구성을 전달할 수 있습니다.\n\n\n2.4.3 여백으로 시선 집중시키기\n여백은 독자의 주의를 끄는 가장 효과적인 방법 중 하나입니다. 강조하고 싶은 콘텐츠를 상대적으로 더 많은 여백으로 둘러싸 보세요. 페이지의 해당 부분으로 시선을 이끌 것입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#중요한-부분-강조하기",
    "href": "posts/qmd/learn_dataVisualization.html#중요한-부분-강조하기",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "2.5 중요한 부분 강조하기",
    "text": "2.5 중요한 부분 강조하기\n두드러짐(Salience)은 객체를 주변 환경과 차별화시키는 속성입니다. 특히 슬라이드 프레젠테이션과 같은 시각 자료에서는 두드러짐과 정보의 관련성(relevance)이 일치하는지 확인하는 것이 필수적입니다. 청중이 내용을 동시에 듣고 읽는 상황이므로 정보 전달의 효율성이 무엇보다 중요하기 때문이죠.\n예를 들어, 표의 특정 행이나 열에 색깔을 입히면 선택된 자료에 시선이 집중될 것입니다. 표 형식의 정보는 일반적으로 균일하게 보이기 때문에, 가장 중요한 것이 무엇인지 명확히 하는 것이 도움이 됩니다. 그래프에도 데이터의 특정 부분을 강조 구분을 하면 청중이 발표 내용과 시각 자료를 더 잘 이해하도록 돕는 방법이 될 수 있습니다.\n\n2.5.1 의도치 않은 두드러짐의 위험성\n반대로 부주의하게 두드러짐을 남용하면 오히려 독자에게 잘못된 메세지를 줄 수 있습니다. 예를 들어 움직이는 이미지(예: 회전하는 3차원 단백질 구조)을 넣을 때는 주의해야 합니다. 왜냐하면 움직이는 이미지가 독자의 주의를 전부 집중시켜 다른 콘텐츠를 보지 못하게 합니다. 따라서 파워포인트 애니메이션은 신중하게 사용해야 하며, 움직이는 요소는 반드시 슬라이드의 주요 메시지를 뒷받침하는 콘텐츠여야 합니다.\n동일한 콘텐츠도 어떻게 제시되느냐에 따라 이해도에 극적인 영향을 줍니다. 항상 화면에서 잠시 물러서서 무엇이 가장 두드러지는지 파악하려고 하세요. 그리고 가장 시각적으로 두드러지는 정보는 당신의 핵심 메시지여야 합니다.\n\n\n2.5.2 효과적인 글쓰기 원칙을 그림 디자인에 적용하기\n효과적인 글쓰기 원칙을 그림 디자인에 적용하면 어려움을 극복하고 체계적인 방식으로 시각 자료를 만들 수 있습니다. 마치 글의 단어 하나하나를 다듬듯이, 그림의 각 부분도 평가하고 최적화되야 합니다.\n핵심 원칙:\n\n명확성과 간결성: 복잡하고 이해하기 어려운 문장처럼 혼란스럽고 과도하게 꾸며진 그림(‘차트 잡동사니’)은 피해야 합니다. 번쩍이는 질감, 그라데이션, 불필요한 형태의 증식은 데이터를 해석하기 어렵게 만들고, 특정 부분을 강조하는 것을 방해하며 빈약한 데이터를 결코 구제할 수 없습니다.\n평행 구조와 시각적 강조: 관련 아이디어를 시각적으로 강화하려면 ’평행 구조’를 사용하세요. 즉, 유사한 아이디어를 비슷한 시각적 형태로 표현하여 정보 간의 관계를 명확히 보여주세요. 중첩, 범주 계층, 중요성을 직관적으로 나타내는 모양과 색상을 선택하는 것이 중요합니다.\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#색상의-선택",
    "href": "posts/qmd/learn_dataVisualization.html#색상의-선택",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "3.1 색상의 선택",
    "text": "3.1 색상의 선택\n색상은 명확성을 더할 수 있는 강력한 도구이지만 잘못 사용하면 오히려 혼란을 초래하거나 잘못된 정보를 전달할 수 있습니다.\n\n3.1.1 색상의 올바른 사용법\n\n무지개색을 정량적 데이터에 사용하지 마세요. 무지개 색상은 그 자체로 순서에 대한 모호성이 있어 혼란을 줄 수 있습니다. 또한 특정 색상이 시각적으로 더 길거나 짧게 느껴지는 착시를 유발할 수 있습니다.\n무지개색은 범주형 데이터에 사용하세요. 반면에 무지개색은 범주형 데이터(예: 실험 조건 구분)를 나타내는 데 효과적입니다.\n색상 편향에 주의하세요. 특정 범주에 강렬하거나 약한 색상을 사용하면 독자에게 편향을 줄 수 있습니다. 구분 가능하면서도 시각적 가시성이 비슷한 색상을 선택하세요.\n\n\n\n3.1.2 색상의 세 가지 속성과 활용법\n모든 색상은 색조(hue), 채도(saturation), 명도(lightness)의 세 가지 속성으로 설명됩니다.\n\n색조: 색상을 빨간색, 노란색 등으로 분류하는 속성입니다.\n채도: 색상의 순수함, 예를 들면 흰색이 거의 없는 빨간색 물체는 채도가 매우 높다고 합니다.\n명도: 색상의 밝기 또는 어둡기를 나타냅니다.\n\n색상 선택 팁:\n\n흑백으로 변환해도 구별 가능하도록 명도를 변화시키면서 색상환을 나선형으로 통과하는 색상을 선택하세요.\n이러한 방식으로 6~8가지 색상 그룹을 정의하는 것이 이상적입니다. 그 이상은 독특한 색상을 선택하기 어려워집니다.\n더 많은 범주를 표시해야 한다면 색상 외에 질감(texture)의 차이를 활용할 수 있습니다(예: 빨간색 십자가와 빨간색 원).\n시각적 개체의 크기도 중요합니다. 개체가 작거나 선이 얇을수록 색조, 채도, 명도의 더 큰 변화가 필요합니다.\n\n\n\n3.1.3 색맹을 고려한 색상 사용\n적록 색맹(protanopia/deuteranopia)은 생각보다 많이 존재합니다. 따라서 색맹 독자에게도 적합한 색상을 선택하는 것이 좋습니다. 도구 활용: 소프트웨어를 사용하여 적록 색맹인 사람들에게 이미지가 어떻게 보일지 시뮬레이션해 볼 수 있습니다.\n\nVischeck: 웹 기반 도구라 간편합니다.\nDanKam 앱 (iPhone/Android): 휴대폰 카메라로 들어오는 색상 스펙트럼을 색맹인 사람들이 볼 수 있는 범위 내로 이동시킵니다.\neyePilot 및 Visolve Deflector를 사용하여 화면의 모든 색상을 조작할 수 있도록 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#과한-색상-사용의-문제점",
    "href": "posts/qmd/learn_dataVisualization.html#과한-색상-사용의-문제점",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "3.2 과한 색상 사용의 문제점",
    "text": "3.2 과한 색상 사용의 문제점\n때로는 색상을 사용하지 않는 것이 더 나은 선택일 수 있습니다.\n\n데이터 왜곡 및 편향: 색상이 잘못 사용되면 전혀 사용하지 않는 것보다 못할 수 있습니다. 색상이 잘못된 정보를 눈에 띄게 하거나, 의미 있는 정보를 보기 어렵게 만들 수 있기 때문입니다.\n시각적 혼란: 과도한 색상 사용은 혼란을 야기해 수많은 요소들이 우리의 주의를 끌기 위해 경쟁하게 만듭니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#정량적-데이터의-색상-고려사항",
    "href": "posts/qmd/learn_dataVisualization.html#정량적-데이터의-색상-고려사항",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "3.3 정량적 데이터의 색상 고려사항",
    "text": "3.3 정량적 데이터의 색상 고려사항\n데이터를 시각화할 때 색상 사용은 매우 중요합니다. 특히 숫자 값을 가지는 정량적 데이터는 그 특성상 색상 매핑에 신중을 기해야 합니다. 데이터의 구조에 따라 색상 선택이 달라지며, 이는 전달하고자 하는 정보의 정확성과 명확성에 큰 영향을 미칩니다.\n데이터를 시각화하기 위해 먼저 데이터에 내재적인 순서가 있는지 없는지를 구분해야 합니다. 예를 들어 박테리아 종 목록은 순서가 없는 ’범주형 데이터’입니다. 반면 유전자 발현 값은 낮은 값부터 높은 값까지 정렬할 수 있는 ’순서가 있는 데이터’로 분류됩니다. 이런 정량적 데이터에 적절한 색상 맵을 만드는 것이 중요합니다.\n색상은 의료 영상부터 원형 차트에 이르기까지 데이터 표현에서 가장 중요한 시각적 요소 중 하나입니다. 색상의 세 가지 주요 구성 요소인 색조(hue), 채도(saturation), 명도(lightness)를 조절함으로써 색상은 레이블링, 수량 표시, 현실 표현 또는 시뮬레이션, 활성화 및 장식과 같은 다양한 기본적인 의사소통 요구를 충족시킬 수 있습니다.\n정량적 데이터는 그 요소들이 수치적인 척도 위에 놓여 서로의 상대적인 위치와 크기를 나타낸다는 점에서 범주형 데이터와 다릅니다. 이러한 상호 관계 때문에 데이터의 범위와 크기 변화에 지각적으로 일관된 색상 맵을 설계하는 것이 중요합니다.\n\n3.3.1 색상맵 고려사항\n색상맵을 설계하기 전에 데이터에서 강조하고자 하는 주요 영역이나 지점을 먼저 정의해야 합니다.\n\n양수 또는 음수 값만 있는 데이터: 데이터에 양수 값 또는 음수 값만 있는 경우, 순차적인 색상 맵을 사용하는 것이 직관적입니다. 이는 명도만 10%에서 90% 검정까지 변화시키는 방식입니다. 이러한 색상 진행은 전체 범위에 걸쳐 균일한 전환을 만듭니다. 색상 그라디언트의 끝을 0과 이론적 최대값에 매핑하거나 관찰된 최소값과 최대값에 매핑하는 두 가지 옵션이 있습니다. 후자의 접근 방식은 시각적 표현에서 더 높은 대비가 필요하고 0이 기준점으로 관련이 없을 때 유용합니다.\n두 개 이상의 관심 영역을 포함하는 데이터: 데이터에 양수 및 음수 값이 모두 포함되어 분포의 하단과 상단 그리고 0을 구분해야 하는 경우, 분기형(diverging, 또는 양극성) 색상 스키마가 효과적입니다. 이 스키마는 색조와 채도를 모두 사용합니다. 색조는 양수와 음수 값을 구분하는 데 사용하고(예: 빨간색과 파란색), 채도는 상대적인 크기를 나타내는 데 사용하며, 채도가 높을수록 더 큰 크기의 값을 나타내고 채도가 없으면 0을 나타냅니다.\n\n\n\n3.3.2 색상맵에 유용한 도구들\n색상 전문 지식이 없는 사용자도 적절한 색상 맵을 선택하는 데 도움을 줍니다.\n\n펜실베이니아 주립대학교의 ColorBrewer\nNASA의 Color Tool\n4 데이터 그림의 요소"
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#타이포그래피",
    "href": "posts/qmd/learn_dataVisualization.html#타이포그래피",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "4.1 타이포그래피",
    "text": "4.1 타이포그래피\n타이포그래피는 글자를 배열하는 기술이자 예술입니다.\n\n4.1.1 서체와 글꼴의 이해\n서체(typeface)의 글자 형태는 세리프(serif)와 산세리프(sans serif)로 나뉩니다.\n\n세리프 서체: 대체로 얇고 더 격식 있으며 ‘serif’ 부분이 눈이 줄을 따라가는 데 도움이 되므로 여러 줄의 텍스트 블록에서 읽기 쉽습니다.\n산세리프 서체: 글자 형태가 더 단순하고 긴 텍스트에서는 가독성이 떨어진다고 주장하므로 제목이나 레이블과 같은 짧은 텍스트에 적합합니다. 일반적으로 슬라이드에는 산세리프 글꼴이 잘 어울리고 포스터나 인쇄물에는 세리프 글꼴이 적합합니다.\n\n\n\n4.1.2 서체 선택의 원칙\n가장 흔한 네 가지 서체는 Baskerville, Helvetica, Palatino, Times New Roman입니다. 제일 간단한 조언은 컴퓨터에 이 네 가지 서체를 설치하고 문서를 작성하라는 것입니다. 그렇게 하면 통일성을 가질 수 있으며 다른 컴퓨터에서 일관성있게 보여질 수 있을 것입니다. 물론 다양한 서체를 조합해 사용할 수 있지만 이는 세심한 주의와 기술을 요합니다.\n\n\n4.1.3 간격 조정과 문서 구조화\n타이포그래피는 문서의 분위기를 드러내고 텍스트의 구조와 의미를 명확히 할 수 있습니다. 또한 단어, 구문, 문장 및 텍스트 블록은 그들의 근본적인 의미에 따라 간격을 두어야 합니다. 단락 사이의 간격은 줄 사이의 간격보다 커야 하며, 목록 항목은 서로 관련되어 보이지만 인접 텍스트와는 분리되도록 간격을 두어야 합니다. 게슈탈트 원리에 따라 정렬되거나 서로 가까이 배치된 개체는 함께 속하는 것으로 인식됩니다.\n의미 있는 간격을 가진 텍스트를 만들려면 ‘단락 앞 간격’ 및 ‘단락 뒤 간격’ 설정을 사용하세요. 이 설정은 글꼴 메뉴 &gt; 단락(파워포인트) 또는 서식 메뉴 &gt; 단락(워드)에서 찾을 수 있습니다. 예를 들어 단락 텍스트는 뒤에 5포인트 간격이 설정되고, 글머리 기호 목록은 뒤에 3포인트 간격이 설정될 수 있습니다. 또한 왼쪽 정렬된 텍스트는 들쭉날쭉한 오른쪽 가장자리를 남기는데 Shift + Enter을 사용해 수동으로 줄을 끊으면 더 규칙적으로 만들 수 있습니다.\n\n\n4.1.4 단순함과 통일성의 미덕\n대부분의 문서는 하나의 서체를 사용하고 최대 두세 가지 글자 크기로 볼드체와 이탤릭체를 적절히 사용하면 완벽하게 작성할 수 있습니다. 이렇게 글꼴과 글꼴 처리의 변화를 제한함으로써 슬라이드나 포스터에 제시될 시각 정보의 구성을 통일할 수 있습니다. 통일된 타이포그래피 요소들이 문서를 더 읽기 쉽게 만듭니다.\n\n\n4.1.5 축\n데이터에 좌표 시스템이 있다면 그림의 축은 독자의 방향을 잡아주는 기반이자 핵심입니다.\n\n축의 두께: 축의 두께는 적당해야 합니다. 0.5pt면 충분하며 그림이 특별히 크지 않다면 사방을 축으로 둘러싸는 것을 피해야 합니다.\n화살표 사용 지양: 축에 화살표를 배치하는 것을 자제하세요. 축의 방향은 거의 의심할 여지가 없습니다.\n다중 패널 그림의 스케일: 다중 패널 그림은 가능한 한 고정된 스케일을 유지해 비교하기 쉬워야 합니다.\n\n\n\n4.1.6 눈금\n눈금이 너무 빽빽하게 있으면 가독성이 떨어집니다.\n\n\n4.1.7 그리드\n그리드는 비율을 비교하고 위치를 축 눈금과 연관시키는 시선(sight lines)으로 사용됩니다. 궁극적으로는 잘못된 그리드보다 그리드가 없는 것이 나을 수도 있습니다. 그리드는 기본적으로 사용하기보다는 필요할 때만 사용하세요.\n\n\n4.1.8 레이블\n그림의 레이블은 하나의 고정된 크기를 사용하고, 게슈탈트 원리에 따라 하나의 그룹으로 정렬되야 합니다. 또한 레이블의 내용은 간결하지만 명확해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#심볼-명확하고-의미-있는-데이터-표현",
    "href": "posts/qmd/learn_dataVisualization.html#심볼-명확하고-의미-있는-데이터-표현",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "4.2 심볼: 명확하고 의미 있는 데이터 표현",
    "text": "4.2 심볼: 명확하고 의미 있는 데이터 표현\n데이터 포인트 심볼은 산점도(scatter plot)에서 시각적인 패턴과 변수 간의 관계를 파악하는 데 도움이 됩니다. 잘 선택된 심볼은 데이터 가려짐(occlusion)을 줄이고 다양한 데이터 범주의 시각적 독립성을 유지하는 데 도움이 됩니다.\n\n4.2.1 단일 데이터 범주에서의 심볼\n단일 데이터 범주를 가진 플롯에서는 겹치는 심볼로 인해 발생하는 데이터 가려짐을 최소화하는 것이 가장 중요합니다. 이 경우 속이 빈 원이 최선의 선택입니다. 다른 일반적인 기하학적 모양(사각형, 삼각형, 마름모 등)과 달리, 원은 다른 원과 교차되도 새로운 원을 만들지 않습니다. 그리고 속이 빈 형태의 장점은 겹치는 부분이 페이지에 더 밀도 높은 잉크 영역을 만들어 실용적인 밀도 맵을 대체할 수 있습니다.\n\n\n4.2.2 다중 데이터 범주에서의 심볼\n여러 데이터 범주는 강력한 시각적 경계를 형성하는 뚜렷한 심볼로 인코딩되어야 합니다. 모양이 유사한 심볼은 특히 심볼이 겹치는 영역에서 데이터를 식별하기 어려울 수 있습니다.\n데이터 범주 간에 명확하고 간단한 구별하는 방법은 범주 이름의 첫 글자를 플로팅 심볼로 사용하는 것입니다. 이 방법은 글자가 시각적으로 뚜렷하다면(예: H, Q, X) 독자가 범례를 반복해 확인할 필요가 없어 해석을 더 쉽게 만듭니다.\n사용 가능하다면 색상은 매우 효과적인 구분자입니다. 그러나 색조의 수가 증가함에 따라 그 중요성이 감소하므로 신중하게 사용해야 합니다. 데이터 범주에 대한 좋은 색상 선택은 정성적 브루어 팔레트에서 찾을 수 있습니다.\n\n\n4.2.3 데이터 구조 반영\n종종 데이터 포인트들은 계층 구조를 가집니다. 예를 들어 유전자의 상태(‘끔’ 또는 ‘켬’)에 따라 분류된 데이터는 구별하고 부각시키기 위해 시각적 비중(채움 및/또는 색상)을 가진 심볼을 사용하여 중요성을 나타낼 수 있습니다. 특히 관련성이 낮은 데이터(예: 맥락을 위해 포함된 참조 데이터)에는 덜 눈에 띄는 심볼을 사용하는 것이 좋습니다.\n\n\n4.2.4 심볼 수가 많을 때의 대처\n심볼의 수가 많으면 구별하기 어렵습니다. 플롯에 6-7개 이상의 범주가 있다면 스몰 멀티플(small multiples)을 사용해 여러 패널로 데이터를 제시하는 것을 고려하세요."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#화살표",
    "href": "posts/qmd/learn_dataVisualization.html#화살표",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "4.3 화살표",
    "text": "4.3 화살표\n화살표는 가장 흔히 사용되는 그래픽 요소 중 하나입니다. 화살표는 복잡한 정보를 안내하는 매우 효율적인 시각적 의사소통 도구로 사용됩니다. 분자 생물학에서 화살표 관련 관례가 몇가지 있습니다. 예를 들어, 직각 선분과 함께 있는 화살표는 전사 시작 지점 또는 프로모터, 선과 평행하게 배치된 짧은 화살표는 일반적으로 PCR 프라이머를 나타냅니다.\n\n4.3.1 화살표 사용 주의점\n화살표는 요소 자체보다는 요소 간의 기능적 관계에 주의를 집중시키는 데 가장 효과적으로 사용됩니다. 따라서 방향이나 순서를 나타내는 데 화살표를 사용하고 시스템의 구조등의 공간적 상호 관계를 강조하려면 요소를 연결할때 화살표 대신 선을 사용해야 합니다. 한 가지 예외는 현미경 사진이나 기타 영상에서 두드러진 특징을 나타내는 데는 일반적으로 화살표를 사용합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#막대-그래프와-상자-그림",
    "href": "posts/qmd/learn_dataVisualization.html#막대-그래프와-상자-그림",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.1 막대 그래프와 상자 그림",
    "text": "6.1 막대 그래프와 상자 그림\n막대 그래프(Bar charts)와 상자 그림(Box plots)은 과학 문헌에서 매우 흔하게 사용되는 방법입니다. 특히 막대 그래프는 개수를 나타내는 데 적합하며, 상자 그림은 분포의 특성을 나타내는 데 적합합니다.\n\n6.1.1 막대 그래프 활용\n막대 그래프는 길이를 사용하여 양을 나타냅니다. 일반적으로 아래와 같은 몇 가지 옵션이 있습니다.\n\n누적 막대 그래프(Stacked bar charts): 전체 양을 비교하면서 각 범주가 전체에 기여하는 바를 보여주고 싶을 때 가장 좋습니다. 흔히 여러 속성에서 순위를 시각화하는 데 사용됩니다.\n계층형 막대 그래프(Layered bar chart): 전체 양의 분포보다는 각 범주 내 값의 분포를 모든 항목에 걸쳐 비교하는 데 주로 관심이 있을 때 적합합니다. 각 범주에 공통 기준선을 제공하므로 누적 막대 그래프보다 범주 내 비교에 더 정확합니다.\n그룹화된 막대 그래프(Grouped bar chart): 각 항목 내에서 범주 간 값 비교를 가능하게 하면서 항목 간 비교도 가능하게 하는 것이 주 목표입니다. 각 항목의 양이 동일한 총합을 이룬다면 그룹화된 막대 그래프가 값을 더 정확하게 읽고 비교할 수 있습니다.\n\n\n\n6.1.2 상자 그림\n우리의 목표가 분포를 나타내고 비교하는 것이라면 막대 그래프보다 상자 그림이 더 좋은 선택입니다.상자 그림(Box plots), 또는 상자-수염 그림(box-and-whiskers plots)은 분포의 다섯 가지 특성을 위치와 길이로 인코딩하여 데이터를 효과적으로 요약합니다.\n\n상자: 분포의 첫 번째 사분위수(Q1)부터 세 번째 사분위수(Q3)까지를 나타내며, 사분위 범위(IQR)를 표현합니다.\n중앙선: 상자 내부의 선은 중앙값(median)을 나타냅니다.\n수염(Whiskers): Q1과 Q3에서 뻗어 나오는 선으로 일반적으로 Q1 – 1.5 × IQR 및 Q3 + 1.5 × IQR 이내의 가장 극단적인 데이터 포인트를 끝점으로 정의합니다.\n이상치(Outliers): 수염 바깥의 각 이상치는 개별적인 점으로 표시됩니다.\n\n\n\n6.1.3 막대 그래프와 상자 그림을 위한 권장 사항\n\n정렬: 암묵적인 항목 순서가 없는 한 막대는 높이 순서로 상자 그림은 중앙값 순서로 정렬해 쉽게 읽을 수 있도록 하세요.\n기준선: 막대 그래프의 시작점은 0으로 하세요. 특별한 이유가 없다면 말이죠.\n눈금 및 격자선: 데이터 해석 및 비교를 용이하게 하려면 눈금(tick marks)을 추가하고, 필요한 경우 축보다 얇은 격자선(grid lines)을 추가하여 작은 차이를 강조하세요.\n색상: 상자와 막대는 단색으로 채우고 윤곽선은 생략하세요. 그리고 일반적으로 독자가 구별할 수 있는 최대 색상 수는 8~12개 입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#집합과-교집합",
    "href": "posts/qmd/learn_dataVisualization.html#집합과-교집합",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.2 집합과 교집합",
    "text": "6.2 집합과 교집합\n집합(Sets)은 과학 데이터 분석에서 보편적인 개념입니다. 예를 들어 토양 샘플에서 발견된 박테리아 종, 생화학 경로에서 발견된 효소, 게놈에서 발견된 변이체, 질량 분석법으로 혈청 샘플에서 검출된 단백질, 또는 암 환자 코호트에서 돌연변이된 유전자 등 이 모든 것을 집합으로 다룰 수 있습니다. 일부 연구의 목표는 흔히 여러 집합의 공통점과 차이점을 교집합을 통해 분석하는 작업이 이루어집니다.\n집합과 그 교집합은 3~4개 정도까지는 시각화하기 쉽습니다. 그러나 집합의 수가 늘러나면 쉽지 않습니다. 예를 들어 3개의 집합은 8가지 가능한 교집합을 갖는 반면, \\(n\\)개의 집합에 대해 \\(2^n\\)가지 가능한 교집합이 존재하므로 10개의 집합은 1,024가지 가능한 교집합을 갖기 때문입니다.\n\n6.2.1 오일러 다이어그램과 벤 다이어그램\n집합의 교집합은 일반적으로 오일러 다이어그램(Euler diagrams) 또는 벤 다이어그램(Venn diagrams)을 사용해 시각화 합니다.\n\n오일러 다이어그램: 교집합을 겹치는 모양(일반적으로 원이나 타원)으로 나타냅니다. 이 모양들은 종종 면적이 나타내는 요소의 수에 비례하도록 그려집니다.\n벤 다이어그램: 오일러 다이어그램과 동일하지만 모든 가능한 교집합(비어 있는 교집합 포함)을 보여준다는 점에서 차이가 있습니다. 오일러 다이어그램에서는 비어 있는 교집합을 그리지 않습니다.\n\n오일러 다이어그램은 2~3개의 교집합 크기를 나타내는 데 적합하며 만드는 도구는 EulerAPE를 추천합니다.\n\n\n6.2.2 다수 집합 교집합 시각화\n3개 이상의 집합에 대한 교집합을 효과적으로 시각화하려면 다른 접근법이 필요합니다.\n\n이진 패턴 및 막대 사용: 모든 집합 교집합을 이진 패턴을 사용하여 행렬의 열에 인코딩하고 행렬 열 위에 막대를 렌더링하여 각 교집합의 요소 수를 나타내는 것입니다.\n\n막대는 교집합 크기의 큰 변화를 수용하기 위해 로그 변환될 수 있으며 교집합 크기의 분포를 보여주기 위해 정렬될 수 있습니다.\n목적에 따라 막대는 집합 조합별로 정렬하여 겹치는 집합의 수에 따라 교집합을 그룹화하거나 특정 집합의 모든 교집합을 서로 옆에 배치할 수도 있습니다.\n많은 수의 집합을 그릴 때는 공간을 절약하기 위해 비어 있는 교집합을 제거할 수 있습니다. 이러한 시각화를 웹 브라우저에서 생성하는 도구에 upset가 있습니다.\n\n클러스터링된 히트맵: 10개 이상의 집합의 모든 교집합을 클러스터링된 히트맵을 사용하여 모든 쌍별 교집합 크기를 그리는 것은 좋은 시각화 방법입니다.\n\n집합 크기는 히트맵의 행이나 열을 따라 막대 그래프로 그려야 합니다.\n다만 이 히트맵의 단점은 고차 교집합에 대한 정보가 숨겨진다는 것입니다.\n\n\n교집합 수가 많아지는 경우 시각화할 때는 거의 항상 절충(trade-offs)이 필요합니다. 그러니 시각화에 따른 장단점을 이해하고 데이터 구조를 인식하는 것이 필수적입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#히트맵",
    "href": "posts/qmd/learn_dataVisualization.html#히트맵",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.3 히트맵",
    "text": "6.3 히트맵\n히트맵은 2차원 숫자 데이터를 색상의 음영으로 표현하는 시각화 기법입니다. 생물학 분야에서 유전자 발현과 같은 대량의 다변량 데이터를 밀도 높고 직관적으로 보여주는 데 널리 사용됩니다. 수백 개의 행과 열을 한 화면에 표시할 수 있다는 장점이 있습니다. 히트맵은 기본적으로 색상 인코딩과 행 및 열의 의미 있는 재정렬에 의존합니다. 이 두 가지 요소 중 하나라도 제대로 적용되지 않으면 시각화의 유용성이 크게 떨어질 수 있습니다.\n\n6.3.1 색상을 지정하는 문제와 해결책\n숫자를 색상으로 나타내는 것은 오래된 아이디어이지만 색상은 상대적인 매체이므로 개별적인 값을 표현하는 데에는 신뢰성이 떨어질 수 있습니다. 같은 색상이라도 주변 셀의 색상에 따라 다르게 보일 수 있기 때문이죠. 따라서 우리가 ‘봐야 할 것’과 ’실제로 보는 것’ 사이의 불일치를 고려하여 효과적인 색상 맵을 설계해야 합니다.\n히트맵은 일반적으로 다양한 값의 범위를 보여주므로, 해당 스펙트럼의 한쪽 또는 양쪽 끝을 강조하기 위한 적절한 색상 맵을 설계하는 것이 중요합니다.\n\n발산형(Divergent) 색상 그라디언트: 낮은 값과 높은 값을 모두 강조할 때 좋습니다. 세 가지 색조(예: 파란색-흰색-빨간색)로 정의된 그라디언트는 범위의 양 끝을 시각적으로 명확하게 구분합니다.\n단일 색조의 명도 변화 그라디언트: 한쪽 극단(가장 높거나 낮은 값)을 강조할 때 효과적입니다. 예를 들어 10%에서 90% 검정까지의 회색조는 선형적인 색상 변화를 잘 보여줍니다.\n피해야 할 색상 조합: 빨간색-초록색 조합은 피해야 합니다. 색맹인 사람들이 어려움을 겪을 수 있기 때문입니다.\n\n\n\n6.3.2 클러스터링의 중요성과 히트맵의 한계\n적절한 색상 스케일과 함께 사용될 때 클러스터링은 히트맵에서 데이터의 구조를 파악하는 능력을 극적으로 향상시킬 수 있습니다. 행과 열이 유사성에 따라 재배열되면 패턴이 명확해집니다. 하지만 계층적 클러스터링은 몇 가지 시각화 문제를 야기합니다.\n\n다양한 배열 가능성: \\(n\\)개의 행 또는 열이 클러스터 트리에 의해 연결될 때 \\(2^{n-1}\\)가지의 가능한 배열이 존재하므로 하나의 히트맵은 가능한 많은 결과 중 하나일 뿐입니다.\n관계 정보의 가려짐: 클러스터링은 일반적으로 매트릭스 양쪽에 표시되는 클러스터 트리에서 유용한 관계 정보를 생성합니다. 하지만 선형 순서화는 클러스터 트리에 반영된 중요한 관계를 가릴 수 있습니다.\n\n행과 열이 모두 클러스터링된 히트맵은 유사한 색상의 셀 블록을 생성하여 패턴을 쉽게 발견하게 합니다. 그러나 열에 내재된 순서가 있는 데이터(예: 시계열 또는 용량-반응 연구)를 히트맵으로 시각화할 때는 행에만 클러스터링이 적용됩니다. 이런 데이터에서는 한 행에 걸친 색상 시퀀스의 변동이 시간이나 농도와 어떻게 관련되는지 이해하는 것이 필요합니다. 이런 경우 평행 좌표 플롯(parallel coordinate plot)이 효과적인 대안이 될 수 있습니다.\n\n정확한 값 읽기: 공간 인코딩에 의존하여 절대값을 더 정확하게 읽을 수 있습니다.\n경향 이해 용이: 색상보다는 물결 모양의 프로파일 그래프로 복잡한 경향을 더 쉽게 이해할 수 있습니다.\n불일치 강조: 샘플 간의 작은 불일치를 강조하는 데 특히 적합합니다.\n\n\n주의할 점: 평행 좌표 플롯은 정보를 겹쳐서 보여주기 때문에 수십 개 이상의 프로파일을 그릴 경우 구별하기 어려울 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#시계열-데이터",
    "href": "posts/qmd/learn_dataVisualization.html#시계열-데이터",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.4 시계열 데이터",
    "text": "6.4 시계열 데이터\n시간은 연구에서 핵심적인 역할을 합니다. 왜냐하면 시간은 사건에 대한 자연스러운 순서를 제공하며 종종 주기적이고 반복적인 패턴을 보여주기 때문입니다. 일반적으로 시계열 데이터를 시각화하는 방법은 위치, 밝기 또는 채도, 그리고 애니메이션을 사용하는 것입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#서브플롯으로-복잡한-데이터-풀어내기",
    "href": "posts/qmd/learn_dataVisualization.html#서브플롯으로-복잡한-데이터-풀어내기",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.5 서브플롯으로 복잡한 데이터 풀어내기",
    "text": "6.5 서브플롯으로 복잡한 데이터 풀어내기\n서브플롯은 요인 실험(Factorial experiments)은 독립 변수(예: 용량, 균주, 온도 또는 성별)의 다양한 조합이 반응 변수에 미치는 영향을 조사하는 데 자주 사용됩니다. 서브 플롯은 데이터를 작은 다중 그래프(small multiples)로 구성하는 방법이며 각 그래프는 서로 다른 범위에 맞게 잘리고 조정되어 상대적인 변화를 강조하면서도 전체 데이터 범위의 맥락을 보존하여 절대적인 변화를 보여줍니다. 이런 전략은 비선형 스케일링(예: 로그, 프로빗, 로짓 또는 역수)과 함께 사용하여 동적 범위와 해상도를 높이고, 가우시안 및 S자형 데이터를 선형화할 수 있습니다.\n\n6.5.1 최소값과 최대값이 다른 데이터 다루기\n데이터 범주가 최소값과 최대값 모두에서 다를 때 단일 플롯은 패턴을 모호하게 만들 수 있습니다. 서브 플롯은 관심 있는 패턴과 측정 지표를 강조하기 위해 다양한 방식으로 개별적으로 스케일링될 수 있습니다.\n\n종횡비의 중요성: 플롯의 종횡비(aspect ratio) 선택은 기울기가 어떻게 인지되고 비교되는지에 영향을 미칩니다. 평균 트레이스가 45도를 향하도록 종횡비를 선택하는 것이 유용합니다.\n전체 및 잘린 범위 쌍: 전체 및 잘린 범위를 보여주는 작은 다중 그래프 쌍은 절대값의 차이를 강조하고, 각 범주의 범위에 걸친 패턴과 상관관계를 보여줍니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#경로-다이어그램",
    "href": "posts/qmd/learn_dataVisualization.html#경로-다이어그램",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "6.6 경로 다이어그램",
    "text": "6.6 경로 다이어그램\n경로 다이어그램은 생물학적 시스템에서 연결성과 정보의 흐름을 설명합니다. 세포 신호 전달 경로에서부터 전 지구적 생태계 네트워크에 이르기까지 놀랍도록 유사한 표현 방식으로 모든 것을 묘사할 수 있습니다.\n\n6.6.1 시각적 그룹핑과 정렬로 정보 흐름 강조\n시각적 그룹핑을 사용하여 경로 레이아웃에서 정보 흐름의 계층 구조를 만들고 명확한 정렬을 통해 노드 관계를 강조할 수 있습니다.\n\n엣지 디자인: 엣지는 노드 모양의 고정된 수의 점에 연결되어야 합니다. 불필요한 스타일링이나 화살표의 늘림을 피하고, 기본적인 화살촉을 사용해야 합니다. 엣지 각도는 30° 또는 45°의 배수로 제한해야 하며, 곡선 엣지는 원형 가이드를 사용하여 쉽게 그릴 수 있습니다. 엣지에는 0.5pt 선을 사용하고, 변의 길이가 2.5pt인 정삼각형 화살촉을 사용하는 것이 좋습니다.\n정보 흐름 방향: 일반적으로 정보는 왼쪽에서 오른쪽으로, 위에서 아래로 흐를 것으로 예상됩니다. 이 표준에서 벗어나거나 레이아웃에 비대칭을 도입하는 것은 차이점을 강조할 수 있지만, 독자의 이해를 돕는 경우에만 드물게 사용해야 합니다. 상류 노드로 되돌아가는 엣지는 시계 방향으로 흐르도록 해야 합니다.\n그리드 정렬: 노드를 그리드에 배치하면 그림 전체에 걸쳐 시선의 움직임을 돕습니다. 노드의 수평 정렬은 경로를 통한 정보의 흐름을 강조하는 반면, 방사형 정렬은 원천 노드를 강조합니다. 엣지 교차나 화살촉 충돌을 피하기 위해 그리드 패턴에서 국소적인 벗어남이 필요할 수 있습니다.\n\n\n\n6.6.2 연결성 및 포함으로 관계 표현\n경로 구성 요소 간의 강한 관계는 연결(connection)과 포함(enclosure)을 사용하여 설명할 수 있습니다.\n\n연결: 엣지는 연결을 통해 노드를 그룹화하는 역할을 합니다.\n포함: 핵과 같이 공유 구획 내에서 노드를 그룹화하는 데 사용할 수 있습니다.\n\n\n\n6.6.3 유사성 및 근접성으로 그룹핑 강화\n노드를 유사성(예: 색상 또는 모양)이나 근접성(proximity)을 통해 연결하면 연결 및 포함으로 생성된 그룹핑을 방해하지 않고 경로의 특정 부분을 강조할 수 있습니다.\n\n유사성 그룹: 효과적인 유사성 그룹을 만들려면 노드를 강조하는 데 사용되는 경우를 제외하고는 노드 색상이나 모양의 불필요한 변화를 피해야 합니다.\n근접성 그룹: 네거티브 공간(negative space), 즉 그룹 주위의 그리드에 빈 행이나 열을 사용하여 시각적 강조를 추가함으로써 근접성 그룹핑을 달성할 수 있습니다.\n차이점 식별: 특정 단백질 클래스와 관련된 레이블이나 모호하지 않은 모양으로 차이점을 식별할 수 있습니다. 예를 들어, GPCR의 7개 막 관통 도메인과 녹색 복합체로서 G 단백질을 보여줄 수 있습니다.\n\n경로 다이어그램에서 그룹핑을 사용하면 대체 시각적 진입점을 제공할 수 있습니다. 복잡한 경로에서는 가능한 모든 경로를 처음부터 끝까지 따라가기가 어려울 수 있습니다. 중요한 노드 하위 유형을 쉽게 식별할 수 있다면, 경로 다이어그램을 엄격하게 순차적으로가 아니라 여러 방향에서 탐색할 수 있습니다.\n\n\n6.6.4 노드 레이블링의 어려움과 해결책\n노드에 레이블을 추가하는 것은 종종 어려운 일입니다. 유전자 및 단백질 복합체의 이름이 길 수 있지만, 레이블에 맞게 노드 모양을 변경하면 그룹핑 효과가 희석됩니다.\n\n레이블 길이 고려: 가장 긴 레이블을 수용할 수 있는 노드 모양을 선택하거나 이름을 약어로 사용하는 것이 좋습니다.\n색상 및 스타일: 텍스트와의 대비 손실을 피하기 위해 노드 색상은 채도를 낮게 유지하고, 그라데이션이나 그림자와 같은 시각적 장식은 피해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#단순화하기",
    "href": "posts/qmd/learn_dataVisualization.html#단순화하기",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "7.1 단순화하기",
    "text": "7.1 단순화하기\n정보의 명확성을 높이는 핵심 전략입니다.\n\n7.1.1 요소 수 줄이기\n\n’표시’를 최소화하라\n\n단순화하는 가장 좋은 방법은 페이지의 요소 수를 줄이는 것입니다. 모든 그림과 텍스트 조각은 시각적 감각을 자극하고 프레젠테이션의 복잡성에 기여합니다. 목표는 세련됨을 희생하지 않으면서 메시지를 전달하기 위해 가능한 한 가장 적은 수의 ’표시(marks)’를 사용하는 것입니다. 우리의 일반적인 경향은 여백을 더 많은 정보로 채우는 것입니다. 따라서 재료를 신중하게 제거하는 것은 일반적으로 저작 과정의 자연스러운 부분이 아닙니다. 하지만 더 적게 포함함으로써 잃는 기회는 보여지는 것에 대한 더 큰 강조로 얻어집니다.\n저는 그림이나 슬라이드의 주요 목표에 집중하는 것이 구성 요소를 줄이는 지침이 된다고 생각합니다. 이 기준에 따라 모든 구성 요소를 평가하여 정보의 계층 구조를 만들고, 불필요한 요소를 제거하며, 메시지를 지원하기 위해 나머지를 다듬습니다. 예를 들어, 두 개의 융합 유전자를 생성하는 역위 이벤트를 나타낼 때, 불필요하게 복잡한 초기 과정을 단순화할 수 있습니다. 과정의 처음 두 단계를 결합하고 이동을 나타내는 화살표 수를 줄임으로써 디자인을 단순화하고 전달력을 효과적으로 향상시킬 수 있습니다.\n단순화함으로써 우리는 사람들이 정보를 보고 처리하는 방식을 활용하는 것입니다. 잘 정돈된 레이아웃과 깔끔한 선을 가진 단순화된 프레젠테이션은 읽는 데 더 매력적이고 더 잘 이해될 가능성이 높습니다.\n\n\n7.1.2 불필요한 요소 제거\n\n중복 피하기\n\n중복되는 요소를 제거하는 것은 프레젠테이션에서 추가적인 내용을 덜어내는 또 다른 방법입니다. 예를 들어, ‘반응 1’, ’반응 2’와 같이 시리즈를 나타내는 그림 레이블에서 반복을 흔히 볼 수 있습니다. 이런 경우, 레이블 간의 공통 단어를 추출하여 헤더로 사용하면 일반적으로 외관을 깔끔하게 정리할 수 있습니다. 또한, 저자들은 기본적인 다양성을 포착하기 위해 다양한 실험 구성 요소를 보여주는 경우가 있습니다. 그러나 필요 이상의 예시를 포함하면 오히려 독자를 혼란스럽게 할 수 있습니다.\n\n\n7.1.3 질서정연하게 배치\n단순성은 남은 요소를 체계적으로 구성함으로써도 달성할 수 있습니다. 그룹화를 통해 많은 독립적인 부분으로 이루어진 시스템이 더 적은 수의 요소로 보이게 할 수 있습니다.\n\n구조 생성: 무엇을 무엇과 함께 배치할지 결정하는 것이 구조를 만드는 첫 단계입니다. 한 단계에서 다음 단계로의 동작이나 변형을 설명하는 레이블은 진행 화살표와 함께 배치되어야 합니다. 개체 설명은 이미지 옆에 배치되어야 합니다.\n깔끔한 레이아웃: 또한, 깔끔하고 질서정연한 레이아웃은 더 단순하게 보입니다. 그룹화 외에도, 프레젠테이션에 적합한 몇 개의 가상의 수평선과 수직선에 요소를 정렬하고, 여백(negative space)에 주의를 기울여 그룹 간에 명확한 경계를 만드세요."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#효과적인-시각화를-위한-데이터-시각화-원칙",
    "href": "posts/qmd/learn_dataVisualization.html#효과적인-시각화를-위한-데이터-시각화-원칙",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "7.2 효과적인 시각화를 위한 데이터 시각화 원칙",
    "text": "7.2 효과적인 시각화를 위한 데이터 시각화 원칙\n1967년 프랑스 지도 제작자 자크 베르탕(Jacques Bertin)은 정보 시각화를 위한 광범위한 이론적 틀을 제공했습니다. 그의 분석은 양적 변화를 표시하기 위한 모양, 방향, 색상, 질감, 부피, 크기와 같은 그래픽 요소의 시각적 속성에 초점을 맞췄습니다. 그는 그래프에 저장된 정보를 추출하는 데 필요한 여러 시각적 작업을 정의했습니다.\n\n7.2.1 패턴과 추세 인지\n\n테이블과 그래프의 차이\n\n그래프는 독자가 패턴과 추세를 인지하도록 하는 것이 목표입니다. 이는 정확한 이름과 숫자를 보고하는 테이블을 통해 정보를 전달하는 것과는 다릅니다.\n\n\n7.2.2 그래프 유형별 시각적 평가와 효율성\n다양한 그래프 유형은 기본 추세를 파악하기 위해 다른 시각적 평가에 의존합니다. 파이 차트는 전체의 부분을 보여주는 일반적인 방법입니다. 대부분의 독자는 파이 차트에서 정보를 추출할 때 각도를 판단할 가능성이 높지만, 조각의 면적과 호 길이를 비교할 수도 있습니다. 이러한 각 지각 작업은 효율성과 정확성 면에서 낮은 순위를 차지합니다. 동일한 데이터를 막대 차트로 그리면 상대적인 값을 효과적으로 보여줍니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩",
    "href": "posts/qmd/learn_dataVisualization.html#시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "7.3 시각적 두드러짐(Salience): 그래프 가독성 향상과 정보 인코딩",
    "text": "7.3 시각적 두드러짐(Salience): 그래프 가독성 향상과 정보 인코딩\n시각적 두드러짐은 객체를 주변 환경과 차별화시키는 시각적 특성입니다. 그 의도는 대비(contrast)를 만드는 것입니다. 예를 들면 서로 직각을 이루는 두 선은 쉽게 보이지만, 유사한 객체들 사이에서 단일 비스듬한 선을 찾는 데는 더 오랜 시간이 걸립니다.\n\n7.3.1 정보가 즉시 인식되어야 하는 이유\n정보를 즉시 인식할 수 있도록 제시해야 하는 몇 가지 이유가 있습니다.\n\n인지 부하 감소: 첫째, 청중이 관련 패턴과 추세를 파악하는 데 걸리는 시간을 줄임으로써 인지 부하를 낮춥니다. 이는 시각 및 청각 정보가 일반적으로 주의를 놓고 경쟁하는 슬라이드 및 포스터 기반 프레젠테이션에서 특히 유용합니다.\n추가 시각 정보 처리: 둘째, 청중이 데이터의 특정 특징을 빠르게 볼 수 있도록 돕는 것은 시각 피질이 동시에 추가적인 시각 특징을 이해하도록 합니다.\n\n디자인 원칙은 상당히 간단합니다. 무언가를 쉽게 찾으려면, 그 객체의 주요 시각적 특징을 변화시켜 돋보이게 만드세요. 예를 들어, 객체에 페이지의 다른 객체와 크게 다른 색상, 크기 또는 방향을 부여하세요. 움직임(Motion)은 특히 강력한 차별화 요소입니다. 애니메이션 GIF나 튀어 오르는 아이콘이 우리의 주의를 사로잡는 능력을 생각해 보세요. 이러한 이유로, 애니메이션화되는 객체의 중요성에 비례하여 움직임 사용을 조절해야 합니다.\n\n\n7.3.2 복잡한 디자인 문제\n\n비경쟁적 시각적 특징 활용\n\n디자인 문제는 복잡합니다. 일반적으로 여러 매개변수를 동시에 쉽게 검색할 수 있기를 원합니다. 해결책은 경쟁하지 않는 시각적 특징을 사용하는 것입니다. 그러나 시각적 결합 검색(즉, 두 개 이상의 시각적 특징을 기반으로 대상을 찾는 것)은 집중력을 요구하며 패턴 구성을 위해 그러한 객체들을 기억 속에 유지하기 어려울 수 있으므로 얼마나 많은 특징을 서로 겹칠 수 있는지에는 한계가 있습니다.\n시각적 두드러짐을 생성하는 것은 청중이 정보를 빠르게 처리하는 능력을 향상시킬 것입니다. 이는 강연이나 여러 통신 채널이 동시에 사용될 때 특히 유용합니다. 또한, 대비가 생성되는 다양한 방식을 아는 것은 의도치 않은 사용을 피하는 데 도움이 됩니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#차원-시각화",
    "href": "posts/qmd/learn_dataVisualization.html#차원-시각화",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "8.1 3차원 시각화",
    "text": "8.1 3차원 시각화\n\n공간 데이터에 효과적이지만, 다른 데이터 유형에는 거의 그렇지 않습니다.\n\n고차원 데이터를 다룰 때, 추가적인 데이터 차원을 사용할 수 있다는 이유로 2차원(2D) ‘평면’ 표현보다 3차원(3D) 공간 시각화를 선택하고 싶은 유혹을 느낄 수 있습니다. 그러나 정량적, 범주형 및 관계형 데이터는 종종 공간 관계를 나타내지 않으므로, 이를 3D 공간에 그리면 시각적 복잡성이 추가되어 데이터 이해를 더 어렵게 만드는 경우가 많습니다. 따라서 이러한 데이터를 2D 평면에 그리고 비공간적 그래픽 인코딩에 의존하여 추가 차원을 나타내는 것이 더 효과적일 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#차원-시각화이-필요한-경우",
    "href": "posts/qmd/learn_dataVisualization.html#차원-시각화이-필요한-경우",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "8.2 3차원 시각화이 필요한 경우",
    "text": "8.2 3차원 시각화이 필요한 경우\n특정 유형의 데이터에는 3D 공간 시각화가 최선의 선택입니다. 예를 들어, X선 결정학 데이터는 분자 내 원자의 위치를 설명하므로 본질적으로 공간적인 것을 특징짓습니다. 이러한 원자의 3D 공간 구성을 시각화함으로써 분자 구조를 드러낼 수 있습니다. 공간 데이터는 측정값의 3D 위치 정보를 반영하는 시각적 표현에 적합합니다. 이는 종종 데이터 해석에 결정적인 역할을 합니다.\n객체의 2차원 투영은 깊이를 나타내는 시각적 단서를 사용하여 3차원을 표현합니다. 깊이를 나타내는 가장 강력한 시각적 단서는 부분 가려짐(partial occlusion)으로 한 객체가 다른 객체의 일부를 가리는 것입니다. 또 다른 깊이 단서는 평행선이 수렴하여 만들어지는 원근감(perspective)으로 특정 시점에서 객체까지의 거리를 추정할 수 있게 합니다. 이러한 깊이 단서는 2D 디스플레이에서 3D 객체를 묘사하는 데 필수적입니다.\n\n8.2.1 3차원 시각화의 단점\n예를 들어, 객체의 높이나 길이가 원근감에 의해 왜곡될 수 있어, 플롯 내 요소의 스케일을 판단하기 어렵게 만듭니다. 피할 수 없이, 전경의 데이터 객체는 시청자로부터 더 멀리 떨어진 요소의 가시성을 방해할 것입니다. 또한, 색상이 양을 나타내는 데 사용될 때, 컴퓨터 소프트웨어로 묘사되는 객체에 드리워지는 음영이나 그림자는 추가적인 모호성을 유발할 수 있습니다.\n\n\n8.2.2 2차원과 3차원시각화를 선택하는 방법\n평면 표현과 공간 표현 사이의 선택은 시각적 인코딩과 깊이 단서 사이의 간섭이 시각화 목표를 고려할 때 허용 가능한 절충안을 구성하는지에 달려야 합니다. 유전자 발현 또는 생물학적 네트워크와 같이 추상적인 데이터는 일반적으로 3D 공간 표현으로부터 이점을 얻지 못하며, 깊이 단서를 필요로 하지 않는 기술을 사용하여 그릴 때 가장 유용합니다.\n대부분의 경우, 고차원 데이터는 요소를 2D 평면에 배치하고 크기나 색상을 사용하여 데이터의 추가 차원을 인코딩하는 표현으로 안정적이고 효율적으로 시각화할 수 있습니다. 데이터 차원 중 하나가 범주형이고 범주가 몇 개에 불과하다면 모양을 사용하여 범주를 인코딩할 수 있습니다. 평면에 다차원 데이터를 효과적으로 표현할 수 있는 많은 일반적인 데이터 시각화 접근 방식이 있습니다. 예를 들어, 고차원 데이터 세트에서 변수의 쌍별 조합을 각각 보여주는 산점도 행렬은 상관 관계를 효과적으로 드러낼 수 있습니다. 유사하게, 히트맵과 평행 좌표 플롯은 평면에 다차원 데이터를 그리는 데 유용한 기술입니다. 일부 정보 손실이 허용된다면 주성분 분석 또는 다차원 척도화와 같은 차원 축소 방법을 사용하여 고차원 데이터 세트의 2D 표현을 얻을 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#차원-시각화로-다변량-데이터-시각화",
    "href": "posts/qmd/learn_dataVisualization.html#차원-시각화로-다변량-데이터-시각화",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "8.3 2차원 시각화로 다변량 데이터 시각화",
    "text": "8.3 2차원 시각화로 다변량 데이터 시각화\n고차원 데이터는 분석 및 표현에 있어 상당한 어려움을 제기합니다. 평행 좌표 플롯이나 산점도 행렬과 같은 데이터 시각화 방법은 고차원 데이터를 위한 매우 유용한 2D 시각화 기술입니다. 이들은 평면상의 위치를 사용하여 데이터를 나타내며 각각 데이터의 다른 측면을 강조하는 고유한 강점을 가집니다. 많은 데이터 분석 작업은 클러스터, 추세 및 이상치를 찾는 것을 포함하며 잘 선택되고 잘 설계된 2D 플롯은 데이터의 패턴을 드러내는 데 매우 유리할 수 있습니다.\n\n8.3.1 평행 좌표 플롯 (Parallel Coordinate Plots)\n근본적인 2D 플로팅 기술 중 하나는 평행 좌표를 사용하는 것입니다. 이 플롯의 특징적인 외관은 고유한 좌표계에서 비롯됩니다. 좌표는 서로 직교하지 않고 평행합니다. 각 수직 축은 최소값과 최대값 사이에서 스케일링된 데이터 값을 가진 다른 차원을 나타냅니다. 동일한 행에 속하는 데이터 포인트는 선분으로 연결되어 개별 데이터 특징이 전체 데이터 세트의 맥락에서 보여지도록 합니다.\n평행 좌표는 다양한 데이터 유형을 동시에 처리할 수 있습니다. 예를 들어, 유전자 발현 데이터 및 시간 또는 여러 조건에 걸친 다른 정량적 다변량 데이터는 종종 각 차원이 동일한 유형이고 모든 축이 동일한 범위로 스케일링되는 특수한 형태의 평행 좌표 플롯을 사용하여 시각화됩니다. 이 접근 방식은 차원 간의 정확한 비교를 가능하게 합니다. 또한, 이러한 유형의 플롯은 범주형, 순서형 또는 정량적 차원을 포함하는 데이터 세트도 나타낼 수 있습니다.\n강력한 그래픽 인코딩에 의존함으로써 평행 좌표 플롯은 특정 데이터 관계를 명확하게 보여줍니다. 예를 들어, 한 쌍의 축 사이에 많은 교차선이 나타나는 것은 해당 차원 간의 역관계(inverse relationship)를 나타내는 반면, 평행(또는 거의 평행)한 선은 인접 축으로 표현된 변수 간의 상관관계(correlation)를 시사할 수 있습니다. 이러한 유형의 특징은 평행 좌표 플롯에서 쉽게 볼 수 있습니다. 그러나 이 플롯은 범주형 정보가 지배적인 데이터나 적은 수의 값만을 통과하는 데이터 범위에는 적합하지 않습니다. 데이터 가려짐이 문제가 될 수 있기 때문입니다.\n평행 좌표를 사용할 때는 축 높이와 축 사이의 거리를 조정하여 모든 각도의 절대값 평균이 45도에 가깝도록 해야 합니다. 전체 플롯의 종횡비는 축 사이에 선분이 나타나는 각도에 영향을 미칩니다. 평행 좌표 플롯을 적절하게 형성하면 시청자의 축 방향 인식이 향상되고 선 교차를 더 쉽게 발견할 수 있어 개별 프로파일을 추적하는 데 유용합니다.\n\n\n8.3.2 산점도 행렬 (Scatter Plot Matrices)\n산점도 행렬은 다변량 데이터를 위한 또 다른 일반적인 평면 시각화 방법입니다. 이 플로팅 기술에서는 모든 쌍별 조합을 나타내는 산점도 그리드를 사용하여 데이터 세트의 모든 차원 간의 쌍별 관계를 쉽게 탐색할 수 있습니다.\n\n\n8.3.3 평행 좌표 플롯 vs. 산점도 행렬\n평행 좌표 플롯과 산점도 행렬 중 어떤 것을 선택할지는 지원할 분석 작업에 따라 달라집니다. 이 두 접근 방식의 근본적인 차이점은 여러 차원에 걸쳐 개별 데이터 특징을 표현하는 방식입니다.\n\n평행 좌표 플롯: 데이터 포인트가 단일 선 또는 프로파일로 묘사됩니다. 함께 나타나는 ’선 묶음’은 클러스터를 나타내고, 이상치도 명확하게 드러납니다.\n산점도 행렬: 데이터 특징이 산점도 간에 연결되지 않은 일련의 점으로 표현되므로, 개별 데이터 특징에 대한 결론을 도출하기 어렵습니다. 그러나 산점도 행렬은 점 구름의 특징적인 모양을 기반으로 전체 데이터 세트의 모든 차원 간의 쌍별 상관관계 및 기타 관계를 효율적으로 식별하는 데 사용할 수 있습니다.\n\n\n\n8.3.4 시각화 방법의 시너지 효과\n이러한 방법들은 서로 상호 보완적이며 동일한 데이터 세트에 대한 여러 조정된 시각화를 사용할 수 있는 대화형 환경에서 가장 좋은 결과를 제공합니다. 히트맵 및 차원 축소 도구와 함께 기본적인 2D 시각화 방법은 다변량 데이터에 대한 강력한 접근 방식이 될 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구",
    "href": "posts/qmd/learn_dataVisualization.html#연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.1 연필과 종이: 사고와 가설 생성에 도움이 되는 독특한 도구",
    "text": "9.1 연필과 종이: 사고와 가설 생성에 도움이 되는 독특한 도구\n그림을 그리는 것은 과학적 사고에 필수적입니다. 시각화 과정에서 연필로 종이에 그리는 행위는 내면의 성찰과 외면의 표현에 없어서는 안 될 부분입니다. 이는 우리의 사고를 구체적이고 명시적으로 만드는 건설적인 활동입니다.\n\n9.1.1 시각적 표현의 구체성\n\n사고의 명확화\n\n단어는 그림에서는 허용되지 않는 모호성을 부여합니다. 예를 들어, 단백질을 세포 내에 있다고 일반적인 용어로 구두로 설명할 수 있지만, 세포 내 단백질 그림을 그리면 단백질이 존재하는 세포 구획에 대해 구체적으로 생각하게 됩니다. 세포를 가장 일반적인 형태로 묘사하더라도, 단백질의 위치를 나타내려면 단백질을 세포질에, 핵 안에, 또는 그 사이 어딘가에 배치해야 합니다. 세포 내 모든 위치가 ’세포 내’라는 원래 매개변수를 준수하더라도, 그림의 해석은 더 직접적입니다. 즉, 단백질은 세포질성, 핵성 또는 핵막과 관련되어 있는 것으로 이해될 것입니다.\n시각적 묘사는 우리가 이해의 전제를 끊임없이 평가하도록 요구합니다. 정보를 합리화하는 방법으로 빠른 스케치나 낙서를 하는 것은 우리의 사고에서 간극을 드러내고 대안적인 결론과 새로운 아이디어로 이어질 수 있습니다. 탐구적인 그리기를 할 때는 시각적 정확성을 다소 포기하는 것이 유용합니다. 우리는 묘사하는 객체가 실제 객체처럼 보이기를 기대하는 경향이 있습니다. 이러한 기술적 숙련도에 대한 기대는 많은 성인들이 그림 그리기를 연습으로 포기하는 이유일 것입니다. 그림을 그릴 때는 많은 가능성을 탐색하기 위해 스케치를 빠르게 다듬는 것이 생산적입니다.\n\n\n9.1.2 연필과 종이의 즉각성과 유연성\n연필과 종이는 타의 추종을 불허하는 즉각성을 제공합니다. 이 매체를 사용하면 손이 닿는 곳에 있는 모든 것을 활용할 수 있습니다. 예를 들어, 저널 뒷면, 포스트잇, 또는 점심 식사 후의 냅킨이 될 수 있습니다. 그래픽 생성용 소프트웨어와는 달리 연필과 종이에는 학습 곡선이 없습니다. 컴퓨터의 일반적인 입력 장치(키보드와 마우스)는 정신을 몰입시키는 데 필요한 표현력과 유동성을 지원하기에 심각하게 부적절합니다. 디지털 매체의 실용적인 측면은 종종 인지 과정을 방해하는데 이는 우리가 자주 멈춰서 ‘어떻게’ 해야 할지 생각해야 하기 때문입니다.\n\n\n9.1.3 그리기의 인지적 이점\n\n기억력 확장 및 통찰력 확보\n\n그림 그리기 과정은 사고 과정과 연결되어 있으며 정신 모델을 생성하는 것은 과학 데이터에 대한 통찰력을 얻는 데 도움이 됩니다. 예를 들어, 우리의 지식을 유형의 형태로 외현화함으로써 우리는 동료들과 해석을 교환하고 의미를 명확히 할 기회를 만듭니다. 교육 환경에서 그림 그리기는 학동들의 과학 개념 이해를 향상시키는 것으로 나타났습니다. 학생들이 수업 자료의 시각적 표현을 생성하고, 정당화하며, 다듬도록 유도된 후 현저히 더 나은 성과를 보였습니다.\n그림 그리기 기능 중 하나는 우리의 단기 작업 기억(short working memory)을 확장하는 것입니다. 시각적 작업 기억은 특정 작업을 수행하기 위해 시각 정보를 유지하는 우리의 능력을 설명합니다(예: 지도를 읽는 것). 우리는 몇 초 이상 몇 개 이상의 객체 속성을 기억하기 어렵습니다. 노드(행과 열로 배열됨) 간의 연결이 채워진 셀로 표시된 간단한 네트워크를 설명하는 표를 통해 연결을 연속적으로 읽고 기억에 저장하여 기본 네트워크의 정신적 그림을 만드는 것은 쉽지 않습니다. 동일한 정보를 다이어그램으로 묘사함으로써, 우리는 작업 기억의 한계를 극복하고 어떤 노드 쌍 사이의 개입하는 노드 수와 같은 복잡한 관계를 쉽게 볼 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#그래픽으로-데이터-보기의-중요성",
    "href": "posts/qmd/learn_dataVisualization.html#그래픽으로-데이터-보기의-중요성",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.2 그래픽으로 데이터 보기의 중요성",
    "text": "9.2 그래픽으로 데이터 보기의 중요성\n그래픽으로 데이터를 보는 것은 계산된 지표에만 의존하는 것보다 훨씬 중요합니다. 앤스콤의 콰르텟은 동일한 요약 통계를 갖는 데이터 세트라도 시각화하면 크게 다름을 보여줍니다. 고차원 데이터에서 ’행동 클래스’를 찾기 위해 저차원 ’슬라이스’를 만들어 시각화하는 것이 유용하며 이때 플롯 간의 일관성 유지가 중요합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#스택-그래프-vs.-개별-플롯-패턴-발견의-차이",
    "href": "posts/qmd/learn_dataVisualization.html#스택-그래프-vs.-개별-플롯-패턴-발견의-차이",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.3 스택 그래프 vs. 개별 플롯: 패턴 발견의 차이",
    "text": "9.3 스택 그래프 vs. 개별 플롯: 패턴 발견의 차이\n스택 그래프는 전체 커뮤니티의 동적 변화를 보여주지만 각 구성 요소의 상세한 추세를 파악하기는 어렵습니다. 반면, 개별 플롯은 각 개체군의 행동을 명확하게 드러내 더 많은 패턴을 발견할 수 있게 합니다. 너무 많은 데이터를 한 번에 표시하는 것은 시각적 부담을 주므로, 데이터 일부를 제외하거나 샘플링하여 복잡성을 줄여야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#네트워크-탐색을-위한-그래프-기법",
    "href": "posts/qmd/learn_dataVisualization.html#네트워크-탐색을-위한-그래프-기법",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.4 네트워크 탐색을 위한 그래프 기법",
    "text": "9.4 네트워크 탐색을 위한 그래프 기법\n복잡한 생물학적 상호작용은 네트워크로 표현될 때 유용하며, 목적에 맞는 시각화 기법을 선택하면 의미 있는 통찰력을 얻을 수 있습니다. 네트워크 시각화는 허브(연결이 많은 노드)와 클러스터(고도로 상호 연결된 노드 집합) 같은 특징을 부각시킵니다.\n\n9.4.1 노드-링크 다이어그램\n노드-링크 다이어그램은 네트워크의 지역적 세부 사항을 잘 보여주며 노드와 연결을 시각화합니다. 다양한 레이아웃은 데이터 관계 인지에 큰 영향을 줄 수 있습니다. 하지만 이 다이어그램은 데이터 세트가 커질수록 복잡해져 확장성이 떨어집니다.\n\n\n9.4.2 인접 행렬\n큰 무방향성 네트워크에는 인접 행렬이 효과적입니다. 노드를 행과 열로 표시하여 연결성을 보여주므로, 노드-링크 다이어그램의 문제점을 피할 수 있습니다. 노드 순서를 재정렬하면 클러스터와 허브를 더 쉽게 파악할 수 있지만, 직접 연결되지 않은 노드 간의 관계를 파악하기는 어렵습니다.\n\n\n9.4.3 큰 규모 네트워크 시각화의 한계와 대안\n네트워크가 너무 크면 노드-링크 다이어그램이나 인접 행렬 모두 부적절할 수 있습니다. 이때는 부분 네트워크를 시각화하거나 클러스터링 계수 같은 통계 측정에 의존하는 것이 유용합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#데이터-통합-다양한-분석-작업을-위한-시각적-표현",
    "href": "posts/qmd/learn_dataVisualization.html#데이터-통합-다양한-분석-작업을-위한-시각적-표현",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.5 데이터 통합: 다양한 분석 작업을 위한 시각적 표현",
    "text": "9.5 데이터 통합: 다양한 분석 작업을 위한 시각적 표현\n다른 데이터 유형은 고유한 시각화 기법에 가장 적합합니다. 여러 데이터 유형을 결합한 시각화는 데이터 간의 상관관계, 공통 추세, 잠재적 인과 관계를 발견하는 데 도움이 됩니다.\n\n9.5.1 결합된 시각화 디자인\n결합된 시각화 디자인은 분석 작업에 따라 달라집니다. 예를 들어, 유전자 발현 데이터와 상호작용 네트워크를 결합할 때 ’히트 스트립’을 사용하면 특정 발현 프로파일을 가진 노드를 빠르게 찾을 수 있습니다.\n\n\n9.5.2 다수 시간 지점 데이터 처리\n많은 시간 지점 데이터를 다룰 때는 노드의 발현 수준을 색상으로 나타내고 대화형으로 진행하거나, 각 시간 지점을 나타내는 ’작은 다중 그래프’로 네트워크를 배열하여 복잡한 패턴을 한눈에 파악하도록 도울 수 있습니다.\n\n\n9.5.3 통합 도구의 중요성\n다양한 그래프 기법을 통합하는 도구는 데이터 탐색에 매우 유용합니다. Cytoscape 플러그인인 Cerebral처럼 여러 시각화 뷰를 제공하는 도구는 데이터 해석을 심화시킵니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#게놈-데이터-시각화-선형-게놈의-시각적-표현-선택",
    "href": "posts/qmd/learn_dataVisualization.html#게놈-데이터-시각화-선형-게놈의-시각적-표현-선택",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.6 게놈 데이터 시각화: 선형 게놈의 시각적 표현 선택",
    "text": "9.6 게놈 데이터 시각화: 선형 게놈의 시각적 표현 선택\n게놈 데이터는 게놈 좌표를 기반으로 표시되지만, 게놈의 거대한 크기는 시각화에 도전 과제를 제기합니다. 전통적인 선형 게놈 브라우저는 한계가 있어 다른 조직 프레임워크를 사용해야 합니다.\n\n9.6.1 게놈 데이터 개요 생성 및 문제점\n게놈을 동일한 크기로 나누어 요약 값을 보고하는 방식은 특징이 작을 때 중요한 정보를 가릴 수 있습니다. 게놈 브라우저의 확대/축소 기능은 다양한 규모로 게놈을 검사할 수 있도록 하여 이 문제를 해결합니다.\n\n\n9.6.2 의미 있는 개요를 위한 접근 방식\n관심 있는 특징만 분리하거나 게놈 중간 부분을 제거하여 관련 신호를 함께 모으는 것이 의미 있는 개요를 만드는 방법입니다. 공간 채움 곡선과 같이 게놈을 압축하여 표시하는 방법도 있지만, 왜곡이 발생할 수 있습니다. 경우에 따라 게놈 순서를 포기하고 전사 시작 부위와 같은 공통 참조 지점을 기준으로 데이터를 정렬하는 것이 더 유용할 수 있습니다.\n\n\n9.6.3 게놈의 3차원적 특징과 미래 시각화\n게놈의 3차원적 접힘 구조를 이해하게 되면 게놈 데이터를 조직하고 접근하는 방식도 바뀔 것입니다. 이는 선형 좌표 대신 기능적 상태에 따라 데이터를 그룹화하는 시각화를 가능하게 할 것입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리",
    "href": "posts/qmd/learn_dataVisualization.html#게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.7 게놈 브라우저를 통한 대량 데이터 관리: 증가하는 데이터 트랙 처리",
    "text": "9.7 게놈 브라우저를 통한 대량 데이터 관리: 증가하는 데이터 트랙 처리\n게놈 데이터는 종류와 양이 방대하며, 게놈 브라우저는 이를 효과적으로 시각화하는 데 중요합니다. 게놈 브라우저는 트랙을 수직으로 배열하여 비교를 용이하게 하지만, 트랙 수가 늘어나면 시각적 복잡성이 증가합니다.\n\n9.7.1 시각적 복잡성 줄이는 전략: 압축과 요약\n시각적 복잡성을 줄이기 위해 압축과 요약 전략을 사용할 수 있습니다. 압축은 데이터를 간결하게 표현하여 화면 공간을 확보하고, 여러 트랙을 합치거나 히트맵으로 봉우리 높이를 표현할 수 있습니다. 요약은 데이터 세부 사항을 희생하여 더 높은 수준의 추론을 제공하며, 실험 전반의 지표를 계산하여 데이터의 새로운 표현을 만듭니다.\n\n\n9.7.2 요약의 장점과 과제\n요약은 연구자들이 전역적인 추세에 집중하고 더 깊은 조사를 위한 지점을 우선순위화하는 데 도움을 줍니다. 하지만 추상화된 요약이 기본 데이터를 완전히 대체하지는 않으므로, 게놈 브라우저는 요약 트랙과 세부 트랙의 계층 구조를 지원해야 합니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시",
    "href": "posts/qmd/learn_dataVisualization.html#게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.8 게놈 구조 변이 표현: 멀리 떨어진 게놈 위치 간 관계 표시",
    "text": "9.8 게놈 구조 변이 표현: 멀리 떨어진 게놈 위치 간 관계 표시\n게놈 구조 변이는 전통적인 게놈 시각화에 새로운 도전을 제기합니다. 구조 변이의 시퀀스 경계는 넓은 범위에 걸쳐 있으며, 그 크기와 방향이 다양합니다.\n\n9.8.1 구조 변이 묘사를 위한 시각화 기법\n구조 변이를 묘사하기 위해 브레이크포인트 사이에 호(arc)를 그리는 방식이 있으나, 많은 호를 표시하면 시각적 혼란이 발생합니다. 원형 레이아웃인 Circos 이데오그램은 호를 압축하지만, 중첩에 취약합니다. 도트 플롯은 두 게놈의 서열 순서와 방향을 직접 보여주지만, 한 번에 하나의 변이-참조 서열 쌍만 표현할 수 있습니다.\n\n\n9.8.2 게놈 좌표계에서 벗어나 기능적 결과에 초점\n게놈 좌표계에 얽매이지 않고 기능적 결과에 초점을 맞추는 것이 더 의미 있을 수 있습니다. 예를 들어, 유전자 융합과 같이 생물학적으로 중요한 특징을 강조하기 위해 노드가 서열 세그먼트를 나타내고 화살표가 서열 순서를 나타내는 그래프를 사용할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#효과적인-데이터-시각화를-위한-검토-지점",
    "href": "posts/qmd/learn_dataVisualization.html#효과적인-데이터-시각화를-위한-검토-지점",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "9.9 효과적인 데이터 시각화를 위한 검토 지점",
    "text": "9.9 효과적인 데이터 시각화를 위한 검토 지점\n효과적인 데이터 시각화는 시각적 단서를 활용하여 그림의 내재된 의미를 명확하게 표현해야 합니다.\n\n9.9.1 개념적 그림: 명확한 구조화\n게슈탈트 원리를 활용하여 객체들을 근접성, 연결성, 포함 원리에 따라 그룹화하여 명확한 시각적 구조를 만듭니다. 네거티브 공간을 활용하고, 균일한 빈 공간을 만들어 콘텐츠를 조직화할 수 있습니다. 그림의 의도가 레이아웃을 안내하도록 하고, 시각적 완성 원리에 따라 요소를 정렬하여 순서를 명확히 합니다.\n\n\n9.9.2 데이터 그래프: 연결성 드러내기와 정확한 시각적 인코딩\n그래프는 데이터 간의 연결성을 드러내는 것이 주된 목적입니다. 그래픽 인코딩은 이러한 감지 과정을 지원해야 합니다. 막대 차트는 범주 간의 상대적 차이를 파악하는 데 효과적이며, 원형 차트는 전체의 부분을 묘사하는 데 유용합니다.\n여러 차원 데이터를 표시할 때는 다변량 산점도를 활용할 수 있으나, 너무 많은 시각적 변수는 구분을 어렵게 합니다. 색상 값과 크기 스케일을 제한하거나, 가장 중요한 매개변수만 그리는 것이 좋습니다. 색상은 정량적 정보 표현에 한계가 있으며, 특히 노란색이나 무지개 스펙트럼은 값 범위 표현에 비일관성을 야기할 수 있습니다. 일관된 시각적 스케일을 위해 흑백 그라데이션이 효과적입니다."
  },
  {
    "objectID": "posts/qmd/learn_dataVisualization.html#footnotes",
    "href": "posts/qmd/learn_dataVisualization.html#footnotes",
    "title": "Nature Methods 데이터 시각화 컬럼 모음",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://blogs.nature.com/methagora/2013/07/data-visualization-points-of-view.html↩︎"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html",
    "href": "posts/qmd/learn_coding_basic.html",
    "title": "코딩테스트 입문",
    "section": "",
    "text": "코딩테스트 입문 테스트의 출처는 https://school.programmers.co.kr 입니다."
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#두-수의-합",
    "href": "posts/qmd/learn_coding_basic.html#두-수의-합",
    "title": "코딩테스트 입문",
    "section": "1.1 두 수의 합",
    "text": "1.1 두 수의 합\n정수 num1 과 num2 가 주어질 때, num1 과 num2 의 합을 return 하도록 solution 함수를 완성해주세요.\n\n1.1.1 파이썬\ndef solution(num1:int, num2: int) -&gt; int:\n    return num1 + num2\n\n\n1.1.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    num1 + num2\n}\n\nfn main() {\n    let num1 = 5;\n    let num2 = 10;\n    let result = solution(num1, num2);\n    println!(\"The sum of {} and {} is {}\", num1, num2, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#두-수의-차",
    "href": "posts/qmd/learn_coding_basic.html#두-수의-차",
    "title": "코딩테스트 입문",
    "section": "1.2 두 수의 차",
    "text": "1.2 두 수의 차\n정수 num1 과 num2 가 주어질 때, num1 에서 num2 를 뺀 값을 return 하도록 solution 함수를 완성해주세요.\n\n1.2.1 파이썬\ndef solution(num1:int, num2:int) -&gt; int:\n    return num1 - num2\n\n\n1.2.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    num1 - num2\n}\n\nfn main() {\n    let num1 = 15;\n    let num2 = 5;\n    let result = solution(num1, num2);\n    println!(\"The result of {} - {} is {}\", num1, num2, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#두-수의-곱",
    "href": "posts/qmd/learn_coding_basic.html#두-수의-곱",
    "title": "코딩테스트 입문",
    "section": "1.3 두 수의 곱",
    "text": "1.3 두 수의 곱\n정수 num1, num2 가 매개변수 주어집니다. num1 과 num2 를 곱한 값을 return 하도록 solution 함수를 완성해주세요.\n\n1.3.1 파이썬\ndef solution(num1:int, num2:int)  -&gt; int:\n    return num1 * num2\n\n\n1.3.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    num1 * num2\n}\n\nfn main() {\n    let num1 = 6;\n    let num2 = 7;\n    let result = solution(num1, num2);\n    println!(\"The result of {} * {} is {}\", num1, num2, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#몫-구하기",
    "href": "posts/qmd/learn_coding_basic.html#몫-구하기",
    "title": "코딩테스트 입문",
    "section": "1.4 몫 구하기",
    "text": "1.4 몫 구하기\n정수 num1, num2 가 매개변수로 주어질 때, num1 을 num2 로 나눈 몫을 return 하도록 solution 함수를 완성해주세요.\n\n1.4.1 파이썬\ndef solution(num1:int , num2:int) -&gt; int:\n    return num1 // num2\n\n\n1.4.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    num1 / num2\n}\n\nfn main() {\n    let num1 = 20;\n    let num2 = 4;\n\n    // Ensure num2 is not zero to avoid division by zero error\n    if num2 != 0 {\n        let result = solution(num1, num2);\n        println!(\"The result of {} // {} is {}\", num1, num2, result);\n    } else {\n        println!(\"Error: Division by zero is not allowed.\");\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#두-수의-나눗셈",
    "href": "posts/qmd/learn_coding_basic.html#두-수의-나눗셈",
    "title": "코딩테스트 입문",
    "section": "2.1 두 수의 나눗셈",
    "text": "2.1 두 수의 나눗셈\n정수 num1 과 num2 가 매개변수로 주어질 때, num1 을 num2 로 나눈 값에 1,000 을 곱한 후 정수 부분을 return 하도록 soltuion 함수를 완성해주세요.\n\n2.1.1 파이썬\ndef solution(num1L int, num2:int) -&gt; int:\n    answer = num1 / num2 * 1000\n    return int(answer)\n\n\n2.1.2 러스트\nfn solution(num1: f64, num2: i32) -&gt; i32 {\n    let answer = num1 / num2 as f64 * 1000.0;\n    answer as i32\n}\n\nfn main() {\n    let num1 = 20.0; // Using f64 for floating-point division\n    let num2 = 4;\n\n    if num2 != 0 {\n        let result = solution(num1, num2);\n        println!(\"The result of ({} / {}) * 1000 is {}\", num1, num2, result);\n    } else {\n        println!(\"Error: Division by zero is not allowed.\");\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#숫자-비교하기",
    "href": "posts/qmd/learn_coding_basic.html#숫자-비교하기",
    "title": "코딩테스트 입문",
    "section": "2.2 숫자 비교하기",
    "text": "2.2 숫자 비교하기\n정수 num1 과 num2 가 매개변수로 주어집니다. 두 수가 같으면 1 다르면 -1 을 retrun 하도록 solution 함수를 완성해주세요.\n\n2.2.1 파이썬\ndef solution(num1:int, num2:int) -&gt; int:\n    if num1 == num2:\n        answer = 1\n        return answer\n    else:\n        answer = -1\n    return answer\n\n\n2.2.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    if num1 == num2 {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nfn main() {\n    let num1 = 10;\n    let num2 = 10;\n\n    let result = solution(num1, num2);\n    println!(\"The result of comparing {} and {} is {}\", num1, num2, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#분수의-덧셈",
    "href": "posts/qmd/learn_coding_basic.html#분수의-덧셈",
    "title": "코딩테스트 입문",
    "section": "2.3 분수의 덧셈",
    "text": "2.3 분수의 덧셈\n첫 번째 분수의 분자와 분모를 뜻하는 numer1, denom1, 두 번째 분수의 분자와 분모를 뜻하는 numer2, denom2 가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.\n\n2.3.1 파이썬\nfrom typing import List\n\ndef gcd(a: int, b: int) -&gt; int:\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solution(numer1: int, denom1: int, numer2: int, denom2: int) -&gt; List[int]:\n    # Fraction addition\n    numer = numer1 * denom2 + numer2 * denom1\n    denom = denom1 * denom2\n\n    # Reduce to simplest form\n    divisor = gcd(numer, denom)\n    numer //= divisor\n    denom //= divisor\n\n    return [numer, denom]\n\n\n2.3.2 러스트\nfn gcd(a: i32, b: i32) -&gt; i32 {\n    let mut a = a;\n    let mut b = b;\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn solution(numer1: i32, denom1: i32, numer2: i32, denom2: i32) -&gt; Vec&lt;i32&gt; {\n    // Fraction addition\n    let numer = numer1 * denom2 + numer2 * denom1;\n    let denom = denom1 * denom2;\n\n    // Reduce to simplest form\n    let divisor = gcd(numer, denom);\n    let reduced_numer = numer / divisor;\n    let reduced_denom = denom / divisor;\n\n    vec![reduced_numer, reduced_denom]\n}\n\nfn main() {\n    let numer1 = 1; // First numerator\n    let denom1 = 2; // First denominator\n    let numer2 = 1; // Second numerator\n    let denom2 = 3; // Second denominator\n\n    let result = solution(numer1, denom1, numer2, denom2);\n    println!(\"The result of adding fractions is {}/{}\", result[0], result[1]);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열-두-배-만들기",
    "href": "posts/qmd/learn_coding_basic.html#배열-두-배-만들기",
    "title": "코딩테스트 입문",
    "section": "2.4 배열 두 배 만들기",
    "text": "2.4 배열 두 배 만들기\n정수 배열 numbers 가 매개변수로 주어집니다. numbers 의 각 원소에 두배한 원소를 가진 배열을 return 하도록 solution 함수를 완성해주세요.\n\n2.4.1 파이썬\nfrom typing import List\n\ndef solution(numbers:int) -&gt; List[int]:\n    return [num * 2 for num in numbers]\n\n\n2.4.2 러스트\nfn solution(numbers: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    numbers.iter().map(|&num| num * 2).collect()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5]; // Example input\n    let doubled_numbers = solution(numbers);\n\n    println!(\"Doubled numbers: {:?}\", doubled_numbers);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#나머지-구하기",
    "href": "posts/qmd/learn_coding_basic.html#나머지-구하기",
    "title": "코딩테스트 입문",
    "section": "3.1 나머지 구하기",
    "text": "3.1 나머지 구하기\n정수 num1, num2 가 매개변수로 주어질 때, num1 를 num2 로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요.\n\n3.1.1 파이썬\ndef solution(num1: int, num2: int) -&gt; int:\n    answer = num1 % num2\n    return answer\n\n\n3.1.2 러스트\nfn solution(num1: i32, num2: i32) -&gt; i32 {\n    let answer = num1 % num2;\n    answer\n}\n\nfn main() {\n    let num1 = 10; // Example input\n    let num2 = 3;  // Example input\n\n    let result = solution(num1, num2);\n    println!(\"The remainder of {} % {} is {}\", num1, num2, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#중앙값-구하기",
    "href": "posts/qmd/learn_coding_basic.html#중앙값-구하기",
    "title": "코딩테스트 입문",
    "section": "3.2 중앙값 구하기",
    "text": "3.2 중앙값 구하기\n중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어 1, 2, 7, 10, 11 의 중앙값은 7 입니다. 정수 배열 array 가 매개변수로 주어질 때, 중앙값을 return 하도록 solution 함수를 완성해보세요.\n\n3.2.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int]) -&gt; int:\n    sorted_array = sorted(array)\n    middle_index = len(array) // 2\n    return sorted_array[middle_index]\n\n\n3.2.2 러스트\nfn solution(array: Vec&lt;i32&gt;) -&gt; i32 {\n    let mut sorted_array = array.clone(); // Clone the input array to sort it\n    sorted_array.sort(); // Sort the array\n\n    let middle_index = sorted_array.len() / 2; // Calculate the middle index\n    sorted_array[middle_index] // Return the middle element\n}\n\nfn main() {\n    let array = vec![3, 1, 4, 1, 5, 9, 2]; // Example input\n    let median = solution(array);\n\n    println!(\"The median is {}\", median);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#최빈값-구하기",
    "href": "posts/qmd/learn_coding_basic.html#최빈값-구하기",
    "title": "코딩테스트 입문",
    "section": "3.3 최빈값 구하기",
    "text": "3.3 최빈값 구하기\n최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array 가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1 을 return 합니다.\n\n3.3.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int]) -&gt; int:\n    count = {}\n    for num in array:\n        count[num] = count.get(num, 0) + 1\n\n    max_count = max(count.values())\n    mode = [num for num, freq in count.items() if freq == max_count]\n\n    return mode[0] if len(mode) == 1 else -1\n\n\n3.3.2 러스트\nuse std::collections::HashMap;\n\nfn solution(array: Vec&lt;i32&gt;) -&gt; i32 {\n    let mut count = HashMap::new();\n\n    // Count the frequency of each number\n    for &num in &array {\n        *count.entry(num).or_insert(0) += 1;\n    }\n\n    // Find the maximum frequency\n    let max_count = *count.values().max().unwrap_or(&0);\n\n    // Collect numbers that have the maximum frequency\n    let mode: Vec&lt;i32&gt; = count.iter()\n        .filter(|&(_, &freq)| freq == max_count)\n        .map(|(&num, _)| num)\n        .collect();\n\n    // Return the mode or -1 if there is no unique mode\n    if mode.len() == 1 {\n        mode[0]\n    } else {\n        -1\n    }\n}\n\nfn main() {\n    let array = vec![1, 2, 2, 3, 3, 4]; // Example input\n    let result = solution(array);\n\n    println!(\"The mode is {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#짝수는-싫어요",
    "href": "posts/qmd/learn_coding_basic.html#짝수는-싫어요",
    "title": "코딩테스트 입문",
    "section": "3.4 짝수는 싫어요",
    "text": "3.4 짝수는 싫어요\n정수 n 이 매개변수로 주어질 때, n 이하의 홀수가 오름차순으로 담긴 배열을 return 하도록 solution 함수를 완성해주세요.\n\n3.4.1 파이썬\nfrom typing import List\n\ndef solution(n: int) -&gt; List[int]:\n    return [i for i in range(1, n+1, 2)]\n\n\n3.4.2 러스트\nfn solution(n: i32) -&gt; Vec&lt;i32&gt; {\n    (1..=n).step_by(2).collect() // Generate odd numbers from 1 to n\n}\n\nfn main() {\n    let n = 10; // Example input\n    let odd_numbers = solution(n);\n\n    println!(\"Odd numbers from 1 to {}: {:?}\", n, odd_numbers);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-1",
    "href": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-1",
    "title": "코딩테스트 입문",
    "section": "4.1 피자 나눠 먹기 (1)",
    "text": "4.1 피자 나눠 먹기 (1)\n머쓱이네 피자가게는 피자를 일곱 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n 이 주어질 때, 모든 사람이 피자를 한 조각 이상 먹기 위해 필요한 피자의 수를 return 하는 solution 함수를 완성해보세요.\n\n4.1.1 파이썬\ndef solution(n: int) -&gt; int:\n    answer = (n + 6) // 7\n    return answer\n\n\n4.1.2 러스트\nfn solution(n: i32) -&gt; i32 {\n    (n + 6) / 7\n}\n\nfn main() {\n    // Example usage\n    let result = solution(15);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-2",
    "href": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-2",
    "title": "코딩테스트 입문",
    "section": "4.2 피자 나눠 먹기 (2)",
    "text": "4.2 피자 나눠 먹기 (2)\n머쓱이네 피자가게는 피자를 여섯 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n 이 매개변수로 주어질 때, n 명이 주문한 피자를 남기지 않고 모두 같은 수의 피자 조각을 먹어야 한다면 최소 몇 판을 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.\n\n4.2.1 파이썬\nimport math\n\ndef solution(n: int) -&gt; int:\n    slices_per_pizza = 6\n    lcm = (n*slices_per_pizza) // math.gcd(n, slices_per_pizza)\n    answer = lcm // slices_per_pizza\n    return answer\n\n\n4.2.2 러스트\nuse num::integer::lcm;\n\nfn solution(n: i32) -&gt; i32 {\n    let slices_per_pizza = 6;\n    let lcm_value = lcm(n, slices_per_pizza);\n    lcm_value / slices_per_pizza\n}\n\nfn main() {\n    // Example usage\n    let result = solution(10);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-3",
    "href": "posts/qmd/learn_coding_basic.html#피자-나눠-먹기-3",
    "title": "코딩테스트 입문",
    "section": "4.3 피자 나눠 먹기 (3)",
    "text": "4.3 피자 나눠 먹기 (3)\n머쓱이네 피자가게는 피자를 두 조각에서 열 조각까지 원하는 조각 수로 잘라줍니다. 피자 조각 수 slice 와 피자를 먹는 사람의 수 n 이 매개변수로 주어질 때, n 명의 사람이 최소 한 조각 이상 피자를 먹으려면 최소 몇 판의 피자를 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.\n\n4.3.1 파이썬\ndef solution(slice: int, n: int) -&gt; int:\n    # 피자 판 수는 n을 slice로 나누고 올림한 값\n    answer = (n + slice - 1) // slice\n    return answer\n\n\n4.3.2 러스트\nfn solution(slice: i32, n: i32) -&gt; i32 {\n    (n + slice - 1) / slice\n}\n\nfn main() {\n    // Example usage\n    let result = solution(7, 10);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열의-평균값",
    "href": "posts/qmd/learn_coding_basic.html#배열의-평균값",
    "title": "코딩테스트 입문",
    "section": "4.4 배열의 평균값",
    "text": "4.4 배열의 평균값\n정수 배열 numbers 가 매개변수로 주어집니다. numbers 의 원소의 평균값을 return 하도록 solution 함수를 완성해주세요.\n\n4.4.1 파이썬\nfrom typing import List\n\ndef solution(numbers: List[int]) -&gt; List[int]:\n    # numbers의 합계를 구하고, 이를 numbers의 길이로 나누어 평균을 구합니다.\n    answer = sum(numbers) / len(numbers)\n    return answer\n\n\n4.4.2 러스트\nfn solution(numbers: &[i32]) -&gt; f64 {\n    let sum: i32 = numbers.iter().sum();\n    let count = numbers.len() as f64;\n    sum as f64 / count\n}\n\nfn main() {\n    // Example usage\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = solution(&numbers);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#옷가게-할인-받기",
    "href": "posts/qmd/learn_coding_basic.html#옷가게-할인-받기",
    "title": "코딩테스트 입문",
    "section": "5.1 옷가게 할인 받기",
    "text": "5.1 옷가게 할인 받기\n머쓱이네 옷가게는 10 만 원 이상 사면 5%, 30 만 원 이상 사면 10%, 50 만 원 이상 사면 20% 를 할인해줍니다. 구매한 옷의 가격 price 가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요.\n\n5.1.1 파이썬\ndef solution(price: int) -&gt; int:\n    if price &gt;= 500000:\n        price *= 0.8\n    elif price &gt;= 300000:\n        price *= 0.9\n    elif price &gt;= 100000:\n        price *= 0.95\n    return int(price)\n\n\n5.1.2 러스트\nfn solution(price: i32) -&gt; i32 {\n    let discounted_price = if price &gt;= 500000 {\n        (price as f64 * 0.8) as i32\n    } else if price &gt;= 300000 {\n        (price as f64 * 0.9) as i32\n    } else if price &gt;= 100000 {\n        (price as f64 * 0.95) as i32\n    } else {\n        price\n    };\n\n    discounted_price\n}\n\nfn main() {\n    // Example usage\n    let result = solution(150000);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#아이스-아메리카노",
    "href": "posts/qmd/learn_coding_basic.html#아이스-아메리카노",
    "title": "코딩테스트 입문",
    "section": "5.2 아이스 아메리카노",
    "text": "5.2 아이스 아메리카노\n머쓱이는 추운 날에도 아이스 아메리카노만 마십니다. 아이스 아메리카노는 한잔에 5,500 원입니다. 머쓱이가 가지고 있는 돈 money 가 매개변수로 주어질 때, 머쓱이가 최대로 마실 수 있는 아메리카노의 잔 수와 남는 돈을 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.\n\n5.2.1 파이썬\nfrom typing import List\n\ndef solution(money: int) -&gt; List[int]:\n    price_per_americano: int = 5500\n    number_of_americanos: int = money // price_per_americano\n    remaining_money: int = money % price_per_americano\n    return [number_of_americanos, remaining_money]\n\n\n5.2.2 러스트\nfn solution(money: i32) -&gt; Vec&lt;i32&gt; {\n    let price_per_americano: i32 = 5500;\n    let number_of_americanos: i32 = money / price_per_americano;\n    let remaining_money: i32 = money % price_per_americano;\n    vec![number_of_americanos, remaining_money]\n}\n\nfn main() {\n    // Example usage\n    let result = solution(25000);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#나이-출력",
    "href": "posts/qmd/learn_coding_basic.html#나이-출력",
    "title": "코딩테스트 입문",
    "section": "5.3 나이 출력",
    "text": "5.3 나이 출력\n머쓱이는 선생님이 몇 년도에 태어났는지 궁금해졌습니다. 2022 년 기준 선생님의 나이 age 가 주어질 때, 선생님의 출생 연도를 return 하는 solution 함수를 완성해주세요\n\n5.3.1 파이썬\ndef solution(age: int) -&gt; int:\n    return 2022 - age + 1\n\n\n5.3.2 러스트\nfn solution(age: i32) -&gt; i32 {\n    2022 - age + 1\n}\n\nfn main() {\n    // Example usage\n    let result = solution(40);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열-뒤집기",
    "href": "posts/qmd/learn_coding_basic.html#배열-뒤집기",
    "title": "코딩테스트 입문",
    "section": "5.4 배열 뒤집기",
    "text": "5.4 배열 뒤집기\n정수가 들어 있는 배열 num_list 가 매개변수로 주어집니다. num_list 의 원소의 순서를 거꾸로 뒤집은 배열을 return 하도록 solution 함수를 완성해주세요\n\n5.4.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int]) -&gt; List[int]:\n    answer = num_list[::-1]\n    return answer\n\n\n5.4.2 러스트\nfn solution(num_list: &[i32]) -&gt; Vec&lt;i32&gt; {\n    num_list.iter().rev().cloned().collect()\n}\n\nfn main() {\n    // Example usage\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = solution(&numbers);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열-뒤집기",
    "href": "posts/qmd/learn_coding_basic.html#문자열-뒤집기",
    "title": "코딩테스트 입문",
    "section": "6.1 문자열 뒤집기",
    "text": "6.1 문자열 뒤집기\n문자열 my_string 이 매개변수로 주어집니다. my_string 을 거꾸로 뒤집은 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n6.1.1 파이썬\ndef solution(my_string: str) -&gt; str:\n    return my_string[::-1]\n\n\n6.1.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.chars().rev().collect()\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#직각삼각형-출력하기",
    "href": "posts/qmd/learn_coding_basic.html#직각삼각형-출력하기",
    "title": "코딩테스트 입문",
    "section": "6.2 직각삼각형 출력하기",
    "text": "6.2 직각삼각형 출력하기\n* 의 높이와 너비를 1 이라고 했을 때, * 을 이용해 직각 이등변 삼각형을 그리려고합니다. 정수 n 이 주어지면 높이와 너비가 n 인 직각 이등변 삼각형을 출력하도록 코드를 작성해보세요.\n\n6.2.1 파이썬\nn = int(input())\nprint(\"\\n\".join(\"*\" * i for i in range(1, n + 1)))\n\n\n6.2.2 러스트\nuse std::io::stdin;\n\nfn main() {\n    let mut input = String::new();\n\n    // Read input from the user\n    stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    // Parse input to an integer\n    let n: usize = input.trim().parse().expect(\"Please enter a valid number\");\n\n    // Generate and print the star pattern\n    for i in 1..=n {\n        println!(\"{}\", \"*\".repeat(i));\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#짝수-홀수-개수",
    "href": "posts/qmd/learn_coding_basic.html#짝수-홀수-개수",
    "title": "코딩테스트 입문",
    "section": "6.3 짝수 홀수 개수",
    "text": "6.3 짝수 홀수 개수\n정수가 담긴 리스트 num_list 가 주어질 때, num_list 의 원소 중 짝수와 홀수의 개수를 담은 배열을 return 하도록 solution 함수를 완성해보세요.\n\n6.3.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int]) -&gt; List[int]:\n    even_count = sum(1 for num in num_list if num % 2 == 0)\n    odd_count = len(num_list) - even_count\n    return [even_count, odd_count]\n\n\n6.3.2 러스트\nfn solution(num_list: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let even_count = num_list.iter().filter(|&num| num % 2 == 0).count() as i32;\n    let odd_count = num_list.len() as i32 - even_count;\n    vec![even_count, odd_count]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자-반복-출력하기",
    "href": "posts/qmd/learn_coding_basic.html#문자-반복-출력하기",
    "title": "코딩테스트 입문",
    "section": "6.4 문자 반복 출력하기",
    "text": "6.4 문자 반복 출력하기\n문자열 my_string 과 정수 n 이 매개변수로 주어질 때, my_string 에 들어있는 각 문자를 n 만큼 반복한 문자열을 return 하도록 solution 함수를 완성해보세요.\n\n6.4.1 파이썬\ndef solution(my_string: str, n: int) -&gt; str:\n    return ''.join([char * n for char in my_string])\n\n\n6.4.2 러스트\nfn solution(my_string: &str, n: usize) -&gt; String {\n    my_string.chars().map(|c| c.to_string().repeat(n)).collect()\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#특정-문자-제거하기",
    "href": "posts/qmd/learn_coding_basic.html#특정-문자-제거하기",
    "title": "코딩테스트 입문",
    "section": "7.1 특정 문자 제거하기",
    "text": "7.1 특정 문자 제거하기\n문자열 my_string 과 문자 letter 이 매개변수로 주어집니다. my_string 에서 letter 를 제거한 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n7.1.1 파이썬\ndef solution(my_string: str, letter: int) -&gt; str:\n    return my_string.replace(letter, \"\")\n\n\n7.1.2 러스트\nfn solution(my_string: &str, letter: char) -&gt; String{\n    my_string.replace(letter, \"\")\n}\n\nfn main() {\n    let result = solution(\"Hello, World!\", 'o');\n    println!(\"{}\", result); // \"Hell, Wrld!\" 출력\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#각도기",
    "href": "posts/qmd/learn_coding_basic.html#각도기",
    "title": "코딩테스트 입문",
    "section": "7.2 각도기",
    "text": "7.2 각도기\n각에서 0 도 초과 90 도 미만은 예각, 90 도는 직각, 90 도 초과 180 도 미만은 둔각 180 도는 평각으로 분류합니다. 각 angle 이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4 를 return 하도록 solution 함수를 완성해주세요.\n\n7.2.1 파이썬\ndef solution(angle: int) -&gt; int:\n    if angle == 90:\n        return 2  # 직각\n    elif angle == 180:\n        return 4  # 평각\n    elif 0 &lt; angle &lt; 90:\n        return 1  # 예각\n    elif 90 &lt; angle &lt; 180:\n        return 3  # 둔각\n\n\n7.2.2 러스트\nfn solution(angle: i32) -&gt; i32 {\n    if angle == 90 {\n        2\n    } else if angle == 180 {\n        4\n    } else if (0 &lt; angle) && (angle &lt; 90) {\n        1\n    } else if (90 &lt; angle) && (angle &lt; 180) {\n        3\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", solution(90));  // 2 출력\n    println!(\"{}\", solution(180)); // 4 출력\n    println!(\"{}\", solution(45));  // 1 출력\n    println!(\"{}\", solution(120)); // 3 출력\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#양꼬치",
    "href": "posts/qmd/learn_coding_basic.html#양꼬치",
    "title": "코딩테스트 입문",
    "section": "7.3 양꼬치",
    "text": "7.3 양꼬치\n머쓱이네 양꼬치 가게는 10 인분을 먹으면 음료수 하나를 서비스로 줍니다. 양꼬치는 1 인분에 12,000 원, 음료수는 2,000 원입니다. 정수 n 과 k 가 매개변수로 주어졌을 때, 양꼬치 n 인분과 음료수 k 개를 먹었다면 총얼마를 지불해야 하는지 return 하도록 solution 함수를 완성해보세요.\n\n7.3.1 파이썬\ndef solution(n: int, k:int) -&gt; int:\n    # 양꼬치 가격 계산\n    cost_of_kebabs = n * 12000\n    # 음료수 가격 계산\n    cost_of_drinks = (k - (n // 10)) * 2000\n    # 총 지불 금액 계산\n    total_cost = cost_of_kebabs + cost_of_drinks\n    return total_cost\n\n\n7.3.2 러스트\nfn solution(n: i32, k: i32) -&gt; i32 {\n    // 양꼬치 가격 계산\n    let cost_of_kebabs = n * 12000;\n    // 음료수 가격 계산\n    let cost_of_drinks = (k - (n / 10)) * 2000;\n    // 총 지불 금액 계산\n    let total_cost = cost_of_kebabs + cost_of_drinks;\n    total_cost\n}\n\nfn main() {\n    let result = solution(10, 3);\n    println!(\"총 지불 금액: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#짝수의-합",
    "href": "posts/qmd/learn_coding_basic.html#짝수의-합",
    "title": "코딩테스트 입문",
    "section": "7.4 짝수의 합",
    "text": "7.4 짝수의 합\n정수 n 이 주어질 때, n 이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요.\n\n7.4.1 파이썬\ndef solution(n: int) -&gt; int:\n    # 짝수의 합을 저장할 변수\n    total_sum = 0\n    # 2부터 n까지 짝수만 더함\n    for i in range(2, n + 1, 2):\n        total_sum += i\n    return total_sum\n\n\n7.4.2 러스트\nfn solution(n: i32) -&gt; i32 {\n    // 짝수의 합을 저장할 변수\n    let mut total_sum = 0;\n    // 2부터 n까지 짝수만 더함\n    for i in (2..=n).step_by(2) {\n        total_sum += i;\n    }\n    total_sum\n}\n\nfn main() {\n    let result = solution(10);\n    println!(\"1부터 10까지 짝수의 합: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열-자르기",
    "href": "posts/qmd/learn_coding_basic.html#배열-자르기",
    "title": "코딩테스트 입문",
    "section": "8.1 배열 자르기",
    "text": "8.1 배열 자르기\n정수 배열 numbers 와 정수 num1, num2 가 매개변수로 주어질 때, numbers 의 num1 번 째 인덱스부터 num2 번째 인덱스까지 자른 정수 배열을 return 하도록 solution 함수를 완성해보세요.\n\n8.1.1 파이썬\nfrom typing import List\n\ndef solution(numbers: int, num1: int, num2: int) -&gt; List[int]:\n    # 리스트 슬라이싱을 사용하여 num1번째 인덱스부터 num2번째 인덱스까지 추출\n    return numbers[num1:num2 + 1]\n\n\n8.1.2 러스트\nfn solution(numbers: &[i32], num1: usize, num2: usize) -&gt; Vec&lt;i32&gt; {\n    // num1 인덱스부터 num2+1 인덱스까지의 요소들을 새 벡터로 복사\n    numbers[num1..=num2].to_vec()\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = solution(&numbers, 1, 3);\n    println!(\"{:?}\", result); // 출력: [2, 3, 4]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#외계행성의-나이",
    "href": "posts/qmd/learn_coding_basic.html#외계행성의-나이",
    "title": "코딩테스트 입문",
    "section": "8.2 외계행성의 나이",
    "text": "8.2 외계행성의 나이\n우주여행을 하던 머쓱이는 엔진 고장으로 PROGRAMMERS-962 행성에 불시착하게 됐습니다. 입국심사에서 나이를 말해야 하는데, PROGRAMMERS-962 행성에서는 나이를 알파벳으로 말하고 있습니다. a 는 0, b 는 1, c 는 2, …, j 는 9 입니다. 예를 들어 23 살은 cd, 51 살은 fb 로 표현합니다. 나이 age 가 매개변수로 주어질 때 PROGRAMMER-962 식 나이를 return 하도록 solution 함수를 완성해주세요.\n\n8.2.1 파이썬\ndef solution(age: int) -&gt; str:\n    # 숫자를 알파벳으로 매핑하는 딕셔너리 생성\n    age_map = {str(i): chr(97 + i) for i in range(10)}\n\n    # age를 문자열로 변환하고 각 숫자를 해당하는 알파벳으로 변환\n    return ''.join(age_map[digit] for digit in str(age))\n\n\n8.2.2 러스트\nfn solution(age: u32) -&gt; String {\n    // 숫자를 알파벳으로 매핑하는 배열 생성\n    let age_map: [char; 10] = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];\n\n    // age를 문자열로 변환하고 각 숫자를 해당하는 알파벳으로 변환\n    age.to_string()\n        .chars()\n        .map(|c| age_map[c.to_digit(10).unwrap() as usize])\n        .collect()\n}\n\nfn main() {\n    let result = solution(23);\n    println!(\"{}\", result); // 출력: \"cd\"\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#진료-순서-정하기",
    "href": "posts/qmd/learn_coding_basic.html#진료-순서-정하기",
    "title": "코딩테스트 입문",
    "section": "8.3 진료 순서 정하기",
    "text": "8.3 진료 순서 정하기\n외과의사 머쓱이는 응급실에 온 환자의 응급도를 기준으로 진료 순서를 정하려고 합니다. 정수 배열 emergency 가 매개변수로 주어질 때 응급도가 높은 순서대로 진료 순서를 정한 배열을 return 하도록 solution 함수를 완성해주세요.\n\n8.3.1 파이썬\nfrom typing import List\n\ndef solution(emergency: List[int]) -&gt; List[int]:\n    # 응급도와 인덱스를 함께 저장한 리스트 생성\n    sorted_emergency = sorted([(e, i) for i, e in enumerate(emergency)], reverse=True)\n\n    # 결과 리스트 초기화\n    result = [0] * len(emergency)\n\n    # 정렬된 리스트를 순회하며 순서 할당\n    for rank, (_, index) in enumerate(sorted_emergency, 1):\n        result[index] = rank\n\n    return result\n\n\n8.3.2 러스트\nfn solution(emergency: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    // 응급도와 인덱스를 함께 저장한 벡터 생성\n    let mut sorted_emergency: Vec&lt;(i32, usize)&gt; = emergency\n        .iter()\n        .enumerate()\n        .map(|(i, &e)| (e, i))\n        .collect();\n\n    // 응급도를 기준으로 내림차순 정렬\n    sorted_emergency.sort_by(|a, b| b.cmp(&a));\n\n    // 결과 벡터 초기화\n    let mut result = vec![0; emergency.len()];\n\n    // 정렬된 벡터를 순회하며 순서 할당\n    for (rank, &(_, index)) in sorted_emergency.iter().enumerate() {\n        result[index] = (rank + 1) as i32;\n    }\n\n    result\n}\n\nfn main() {\n    let emergency = vec![3, 76, 24];\n    let result = solution(emergency);\n    println!(\"{:?}\", result); // 출력: [3, 1, 2]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#순서쌍의-개수",
    "href": "posts/qmd/learn_coding_basic.html#순서쌍의-개수",
    "title": "코딩테스트 입문",
    "section": "8.4 순서쌍의 개수",
    "text": "8.4 순서쌍의 개수\n순서쌍이란 두 개의 숫자를 순서를 정하여 짝지어 나타낸 쌍으로 (a, b) 로 표기합니다. 자연수 n 이 매개변수로 주어질 때 두 숫자의 곱이 n 인 자연수 순서쌍의 개수를 return 하도록 solution 함수를 완성해주세요.\n\n8.4.1 파이썬\ndef solution(n: int) -&gt; int:\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # (i, n//i)\n            if i != n // i:\n                count += 1  # (n//i, i) if i and n//i are different\n    return count\n\n\n8.4.2 러스트\nfn solution(n: u64) -&gt; u64 {\n    let mut count = 0;\n    let sqrt_n = (n as f64).sqrt() as u64;\n\n    for i in 1..=sqrt_n {\n        if n % i == 0 {\n            count += 1;  // (i, n/i)\n            if i != n / i {\n                count += 1;  // (n/i, i) if i and n/i are different\n            }\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let n = 20;\n    let result = solution(n);\n    println!(\"Number of factors of {}: {}\", n, result); // 출력: Number of factors of 20: 6\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#개미-군단",
    "href": "posts/qmd/learn_coding_basic.html#개미-군단",
    "title": "코딩테스트 입문",
    "section": "9.1 개미 군단",
    "text": "9.1 개미 군단\n개미 군단이 사냥을 나가려고 합니다. 개미군단은 사냥감의 체력에 딱 맞는 병력을 데리고 나가려고 합니다. 장군개미는 5 의 공격력을, 병정개미는 3 의 공격력을 일개미는 1 의 공격력을 가지고 있습니다. 예를 들어 체력 23 의 여치를 사냥하려고 할 때, 일개미 23 마리를 데리고 가도 되지만, 장군개미 네 마리와 병정개미 한 마리를 데리고 간다면 더 적은 병력으로 사냥할 수 있습니다. 사냥감의 체력 hp 가 매개변수로 주어질 때, 사냥감의 체력에 딱 맞게 최소한의 병력을 구성하려면 몇 마리의 개미가 필요한지를 return 하도록 solution 함수를 완성해주세요.\n\n9.1.1 파이썬\ndef solution(hp: int) -&gt; int:\n    # 장군개미의 수를 계산\n    general_ants = hp // 5\n    hp %= 5\n\n    # 병정개미의 수를 계산\n    soldier_ants = hp // 3\n    hp %= 3\n\n    # 일개미의 수를 계산\n    worker_ants = hp // 1\n\n    # 총 개미 수 반환\n    return general_ants + soldier_ants + worker_ants\n\n\n9.1.2 러스트\nfn solution(mut hp: i32) -&gt; i32 {\n    // 장군개미의 수를 계산\n    let general_ants = hp / 5;\n    hp %= 5;\n\n    // 병정개미의 수를 계산\n    let soldier_ants = hp / 3;\n    hp %= 3;\n\n    // 일개미의 수를 계산\n    let worker_ants = hp;\n\n    // 총 개미 수 반환\n    general_ants + soldier_ants + worker_ants\n}\n\nfn main() {\n    let hp = 23;\n    let result = solution(hp);\n    println!(\"Total number of ants needed for {} HP: {}\", hp, result);\n    // 출력: Total number of ants needed for 23 HP: 5\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#모스부호-1",
    "href": "posts/qmd/learn_coding_basic.html#모스부호-1",
    "title": "코딩테스트 입문",
    "section": "9.2 모스부호 (1)",
    "text": "9.2 모스부호 (1)\n머쓱이는 친구에게 모스부호를 이용한 편지를 받았습니다. 그냥은 읽을 수 없어 이를 해독하는 프로그램을 만들려고 합니다. 문자열 letter 가 매개변수로 주어질 때, letter 를 영어 소문자로 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요. 모스부호는 다음과 같습니다.\n\n9.2.1 파이썬\ndef solution(letter: int) -&gt; str:\n    morse = {\n        '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',\n        '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',\n        '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',\n        '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',\n        '-.--':'y','--..':'z'\n    }\n\n    # 공백을 기준으로 모스 부호를 분리\n    morse_codes = letter.split()\n\n    # 각 모스 부호를 해당하는 알파벳으로 변환\n    decoded = [morse[code] for code in morse_codes]\n\n    # 변환된 알파벳들을 하나의 문자열로 결합\n    return ''.join(decoded)\n\n\n9.2.2 러스트\nuse std::collections::HashMap;\n\nfn solution(letter: &str) -&gt; String {\n    let morse: HashMap&lt;&str, char&gt; = [\n        (\".-\", 'a'), (\"-...\", 'b'), (\"-.-.\", 'c'), (\"-..\", 'd'), (\".\", 'e'), (\"..-.\", 'f'),\n        (\"--.\", 'g'), (\"....\", 'h'), (\"..\", 'i'), (\".---\", 'j'), (\"-.-\", 'k'), (\".-..\", 'l'),\n        (\"--\", 'm'), (\"-.\", 'n'), (\"---\", 'o'), (\".--.\", 'p'), (\"--.-\", 'q'), (\".-.\", 'r'),\n        (\"...\", 's'), (\"-\", 't'), (\"..-\", 'u'), (\"...-\", 'v'), (\".--\", 'w'), (\"-..-\", 'x'),\n        (\"-.--\", 'y'), (\"--..\", 'z')\n    ].iter().cloned().collect();\n\n    letter\n        .split_whitespace()\n        .filter_map(|code| morse.get(code).copied())\n        .collect()\n}\n\nfn main() {\n    // 테스트 케이스들\n    let test_cases = vec![\n        \".... . .-.. .-.. ---\",\n        \".-- --- .-. .-.. -...\",\n        \".-. ..- ... -\",\n    ];\n\n    for (i, case) in test_cases.iter().enumerate() {\n        let result = solution(case);\n        println!(\"Test case {}: '{}' -&gt; '{}'\", i + 1, case, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#가위-바위-보",
    "href": "posts/qmd/learn_coding_basic.html#가위-바위-보",
    "title": "코딩테스트 입문",
    "section": "9.3 가위 바위 보",
    "text": "9.3 가위 바위 보\n가위는 2 바위는 0 보는 5 로 표현합니다. 가위 바위 보를 내는 순서대로 나타낸 문자열 rsp 가 매개변수로 주어질 때, rsp 에 저장된 가위 바위 보를 모두 이기는 경우를 순서대로 나타낸 문자열을 return 하도록 solution 함수를 완성해보세요.\n\n9.3.1 파이썬\ndef solution(rsp: int) -&gt; int:\n    # 가위(2)는 바위(0)에게 지고, 바위(0)는 보(5)에게 지고, 보(5)는 가위(2)에게 집니다.\n    win_map = {'2': '0', '0': '5', '5': '2'}\n\n    # 각 문자에 대해 이기는 경우를 매핑하여 새로운 문자열 생성\n    return ''.join(win_map[char] for char in rsp)\n\n\n9.3.2 러스트\nuse std::collections::HashMap;\n\nfn solution(rsp: &str) -&gt; String {\n    // 가위(2)는 바위(0)에게 지고, 바위(0)는 보(5)에게 지고, 보(5)는 가위(2)에게 집니다.\n    let win_map: HashMap&lt;char, char&gt; = [\n        ('2', '0'),\n        ('0', '5'),\n        ('5', '2'),\n    ].iter().cloned().collect();\n\n    // 각 문자에 대해 이기는 경우를 매핑하여 새로운 문자열 생성\n    rsp.chars()\n        .filter_map(|c| win_map.get(&c))\n        .collect()\n}\n\nfn main() {\n    // 테스트 케이스\n    let test_cases = vec![\"2\", \"205\"];\n\n    for (i, case) in test_cases.iter().enumerate() {\n        let result = solution(case);\n        println!(\"Test case {}: '{}' -&gt; '{}'\", i + 1, case, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#구슬을-나누는-경우의-수",
    "href": "posts/qmd/learn_coding_basic.html#구슬을-나누는-경우의-수",
    "title": "코딩테스트 입문",
    "section": "9.4 구슬을 나누는 경우의 수",
    "text": "9.4 구슬을 나누는 경우의 수\n머쓱이는 구슬을 친구들에게 나누어주려고 합니다. 구슬은 모두 다르게 생겼습니다. 머쓱이가 갖고 있는 구슬의 개수 balls 와 친구들에게 나누어 줄 구슬 개수 share 이 매개변수로 주어질 때, balls 개의 구슬 중 share 개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요.\n\n9.4.1 파이썬\nfrom typing import Union\n\ndef solution(balls: int, share: int) -&gt; Union[int, float]:\n    # 분자 계산\n    numerator: int = 1\n    for i in range(balls, balls - share, -1):\n        numerator *= i\n\n    # 분모 계산\n    denominator: int = 1\n    for i in range(1, share + 1):\n        denominator *= i\n\n    # 결과 반환\n    return numerator // denominator\n\n\n9.4.2 러스트\nfn solution(balls: u64, share: u64) -&gt; u64 {\n    // 분자 계산\n    let mut numerator: u64 = 1;\n    for i in (balls - share + 1..=balls).rev() {\n        numerator *= i;\n    }\n\n    // 분모 계산\n    let mut denominator: u64 = 1;\n    for i in 1..=share {\n        denominator *= i;\n    }\n\n    // 결과 반환\n    numerator / denominator\n}\n\nfn main() {\n    // 테스트\n    let test_cases = [(5, 3), (3, 2), (10, 5)];\n\n    for (balls, share) in test_cases.iter() {\n        let result = solution(*balls, *share);\n        println!(\"Balls: {}, Share: {} -&gt; Result: {}\", balls, share, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#점의-위치-구하기",
    "href": "posts/qmd/learn_coding_basic.html#점의-위치-구하기",
    "title": "코딩테스트 입문",
    "section": "10.1 점의 위치 구하기",
    "text": "10.1 점의 위치 구하기\n사분면은 한 평면을 x 축과 y 축을 기준으로 나눈 네 부분입니다. 사분면은 아래와 같이 1 부터 4 까지 번호를매깁니다. - x 좌표와 y 좌표가 모두 양수이면 제 1 사분면에 속합니다. - x 좌표가 음수, y 좌표가 양수이면 제 2 사분면에 속합니다. - x 좌표와 y 좌표가 모두 음수이면 제 3 사분면에 속합니다. - x 좌표가 양수, y 좌표가 음수이면 제 4 사분면에 속합니다.\nx 좌표 (x, y) 를 차례대로 담은 정수 배열 dot 이 매개변수로 주어집니다. 좌표 dot 이 사분면 중 어디에 속하는지 1, 2, 3, 4 중 하나를 return 하도록 solution 함수를 완성해주세요.\n\n10.1.1 파이썬\nfrom typing import List\n\ndef solution(dot: List[int]) -&gt; int:\n    x, y = dot\n\n    if x &gt; 0 and y &gt; 0:\n        return 1\n    elif x &lt; 0 and y &gt; 0:\n        return 2\n    elif x &lt; 0 and y &lt; 0:\n        return 3\n    else:\n        return 4\n\n\n10.1.2 러스트\nfn solution(dot: &[i32]) -&gt; i32 {\n    let (x, y) = (dot[0], dot[1]);\n\n    if x &gt; 0 && y &gt; 0 {\n        1\n    } else if x &lt; 0 && y &gt; 0 {\n        2\n    } else if x &lt; 0 && y &lt; 0 {\n        3\n    } else {\n        4\n    }\n}\n\nfn main() {\n    let dot = vec![3, 2];\n    println!(\"Result: {}\", solution(&dot));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#차원으로-만들기",
    "href": "posts/qmd/learn_coding_basic.html#차원으로-만들기",
    "title": "코딩테스트 입문",
    "section": "10.2 2 차원으로 만들기",
    "text": "10.2 2 차원으로 만들기\n정수 배열 num_list 와 정수 n 이 매개변수로 주어집니다. num_list 를 다음 설명과 같이 2 차원 배열로 바꿔 return 하도록 solution 함수를 완성해주세요.\nnum_list 가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8 이고 n 이 2 이므로 num_list 를 2 * 4 배열로 다음과 같이 변경합니다. 2 차원으로 바꿀 때에는 num_list 의 원소들을 앞에서부터 n 개씩 나눠 2 차원 배열로 변경합니다.\n\n10.2.1 파이썬\nfrom typing import List\n\ndef solution(num_list: List[int], n: int) -&gt; List[List[int]]:\n    return [num_list[i:i+n] for i in range(0, len(num_list), n)]\n\n\n10.2.2 러스트\nfn solution(num_list: &[i32], n: usize) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    num_list.chunks(n).map(|chunk| chunk.to_vec()).collect()\n}\n\nfn main() {\n    let num_list = vec![1, 2, 3, 4, 5, 6, 7, 8];\n    let n = 3;\n    let result = solution(&num_list, n);\n    println!(\"Result: {:?}\", result);\n}```\n\n## 공 던지기\n\n머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 친구들의 번호가 들어있는 정수 배열 `numbers`와 정수 `K`가 주어질 때, `k`번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요.\n### 파이썬\n```python\nfrom typing import List\n\ndef solution(numbers: List[int], k: int) -&gt; int:\n    return numbers[(2 * (k - 1)) % len(numbers)]\n\n\n10.2.3 러스트\nfn solution(numbers: &[i32], k: usize) -&gt; i32 {\n    numbers[(2 * (k - 1)) % numbers.len()]\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let k = 3;\n    let result = solution(&numbers, k);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열-회전시키기",
    "href": "posts/qmd/learn_coding_basic.html#배열-회전시키기",
    "title": "코딩테스트 입문",
    "section": "10.3 배열 회전시키기",
    "text": "10.3 배열 회전시키기\n정수가 담긴 배열 numbers 와 문자열 direction 가 매개변수로 주어집니다. 배열 numbers 의 원소를 direction 방향으로 한 칸씩 회전시킨 배열을 return 하도록 solution 함수를 완성해주세요.\n\n10.3.1 파이썬\nfrom typing import List, Literal\n\ndef solution(numbers: List[int], direction: Literal[\"right\", \"left\"]) -&gt; List[int]:\n    if direction == \"right\":\n        return [numbers[-1]] + numbers[:-1]\n    else:  # direction == \"left\"\n        return numbers[1:] + [numbers[0]]\n\n\n10.3.2 러스트\n#[derive(PartialEq)]\nenum Direction {\n    Right,\n    Left,\n}\n\nfn solution(numbers: &[i32], direction: Direction) -&gt; Vec&lt;i32&gt; {\n    let mut result = Vec::with_capacity(numbers.len());\n\n    match direction {\n        Direction::Right =&gt; {\n            if let Some(&last) = numbers.last() {\n                result.push(last);\n                result.extend_from_slice(&numbers[..numbers.len() - 1]);\n            }\n        },\n        Direction::Left =&gt; {\n            result.extend_from_slice(&numbers[1..]);\n            if let Some(&first) = numbers.first() {\n                result.push(first);\n            }\n        },\n    }\n\n    result\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3];\n    let right_result = solution(&numbers, Direction::Right);\n    let left_result = solution(&numbers, Direction::Left);\n\n    println!(\"Right rotation: {:?}\", right_result);\n    println!(\"Left rotation: {:?}\", left_result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#합성수-찾기",
    "href": "posts/qmd/learn_coding_basic.html#합성수-찾기",
    "title": "코딩테스트 입문",
    "section": "11.1 합성수 찾기",
    "text": "11.1 합성수 찾기\n약수의 개수가 세 개 이상인 수를 합성수라고 합니다. 자연수 n 이 매개변수로 주어질 때 n 이하의 합성수의 개수를 return 하도록 solution 함수를 완성해주세요.\n\n11.1.1 파이썬\ndef solution(n: int) -&gt; int:\n    count = 0\n    for num in range(4, n + 1):  # 4부터 n까지 순회\n        if is_composite(num):\n            count += 1\n    return count\n\ndef is_composite(num: int) -&gt; bool:\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\n\n11.1.2 러스트\nfn solution(n: u32) -&gt; u32 {\n    (4..=n).filter(|&num| is_composite(num)).count() as u32\n}\n\nfn is_composite(num: u32) -&gt; bool {\n    (2..=((num as f64).sqrt() as u32)).any(|i| num % i == 0)\n}\n\nfn main() {\n    let n = 10;\n    let result = solution(n);\n    println!(\"Number of composite numbers up to {}: {}\", n, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#최댓값-만들기-1",
    "href": "posts/qmd/learn_coding_basic.html#최댓값-만들기-1",
    "title": "코딩테스트 입문",
    "section": "11.2 최댓값 만들기 (1)",
    "text": "11.2 최댓값 만들기 (1)\n정수 배열 numbers 가 매개변수로 주어집니다. numbers 의 원소 중 두 개를 곱해 만들 수 있는 최댓값을 return 하도록 solution 함수를 완성해주세요.\n\n11.2.1 파이썬\nfrom typing import List\n\ndef solution(numbers: List[int]) -&gt; int:\n    numbers.sort(reverse=True)  # 리스트를 내림차순으로 정렬\n    return numbers[0] * numbers[1]  # 가장 큰 두 수를 곱함\n\n\n11.2.2 러스트\nfn solution(mut numbers: Vec&lt;i32&gt;) -&gt; i32 {\n    numbers.sort_unstable_by(|a, b| b.cmp(a));  // Sort in descending order\n    numbers[0] * numbers[1]  // Multiply the two largest numbers\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = solution(numbers);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#팩토리얼",
    "href": "posts/qmd/learn_coding_basic.html#팩토리얼",
    "title": "코딩테스트 입문",
    "section": "11.3 팩토리얼",
    "text": "11.3 팩토리얼\ni 팩토리얼 \\(i!\\) 은 1 부터 i 까지 정수의 곱을 의미합니다. 예를들어 \\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) 입니다. 정수 n 이 주어질 때 \\(i! ≤ n\\) 조건을 만족하는 가장 큰 정수 i 를 return 하도록 solution 함수를 완성해주세요.\n\n11.3.1 파이썬\ndef solution(n: int) -&gt; int:\n    factorial = 1\n    i = 1\n    while factorial &lt;= n:\n        i += 1\n        factorial *= i\n    return i - 1\n\n\n11.3.2 러스트\nfn solution(n: u64) -&gt; u64 {\n    let mut factorial: u64 = 1;\n    let mut i: u64 = 1;\n    while factorial &lt;= n {\n        i += 1;\n        factorial *= i;\n    }\n    i - 1\n}\n\nfn main() {\n    let n = 3628800;\n    let result = solution(n);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#모음-제거",
    "href": "posts/qmd/learn_coding_basic.html#모음-제거",
    "title": "코딩테스트 입문",
    "section": "12.1 모음 제거",
    "text": "12.1 모음 제거\n영어에선 a, e, i, o, u 다섯 가지 알파벳을 모음으로 분류합니다. 문자열 my_string 이 매개변수로 주어질 때 모음을 제거한 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n12.1.1 파이썬\ndef solution(my_string: str) -&gt; str:\n    vowels = 'aeiou'\n    return ''.join(char for char in my_string if char not in vowels)\n\n\n12.1.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    let vowels = \"aeiou\";\n    my_string\n        .chars()\n        .filter(|c| !vowels.contains(*c))\n        .collect()\n}\n\nfn main() {\n    let input = \"hello world\";\n    let result = solution(input);\n    println!(\"{}\", result); // Output: \"hll wrld\"\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열-정렬하기-1",
    "href": "posts/qmd/learn_coding_basic.html#문자열-정렬하기-1",
    "title": "코딩테스트 입문",
    "section": "12.2 문자열 정렬하기 (1)",
    "text": "12.2 문자열 정렬하기 (1)\n문자열 my_string 이 매개변수로 주어질 때, my_string 안에 있는 숫자만 골라 오름차순 정렬한 리스트를 return 하도록 solution 함수를 작성해보세요.\n\n12.2.1 파이썬\nfrom typing import List\n\ndef solution(my_string: str) -&gt; List[int]:\n    return sorted([int(char) for char in my_string if char.isdigit()])\n\n\n12.2.2 러스트\nfn solution(my_string: &str) -&gt; Vec&lt;i32&gt; {\n    let mut digits: Vec&lt;i32&gt; = my_string\n        .chars()\n        .filter_map(|c| c.to_digit(10).map(|d| d as i32))\n        .collect();\n\n    digits.sort();\n    digits\n}\n\nfn main() {\n    let input = \"a1b2c3\";\n    let result = solution(input);\n    println!(\"{:?}\", result); // Output: [1, 2, 3]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#숨어있는-숫자의-덧셈-1",
    "href": "posts/qmd/learn_coding_basic.html#숨어있는-숫자의-덧셈-1",
    "title": "코딩테스트 입문",
    "section": "12.3 숨어있는 숫자의 덧셈 (1)",
    "text": "12.3 숨어있는 숫자의 덧셈 (1)\n문자열 my_string 이 매개변수로 주어집니다. my_string 안의 모든 자연수들의 합을 return 하도록 solution 함수를 완성해주세요.\n\n12.3.1 파이썬\ndef solution(my_string: str) -&gt; int:\n    return sum(int(char) for char in my_string if char.isdigit())\n\n\n12.3.2 러스트\nfn solution(my_string: &str) -&gt; i32 {\n    my_string\n        .chars()\n        .filter_map(|c| c.to_digit(10).map(|d| d as i32)) // Convert characters to digits\n        .sum() // Sum the digits\n}\n\nfn main() {\n    let input = \"a1b2c3\";\n    let result = solution(input);\n    println!(\"{}\", result); // Output: 6\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#소인수분해",
    "href": "posts/qmd/learn_coding_basic.html#소인수분해",
    "title": "코딩테스트 입문",
    "section": "12.4 소인수분해",
    "text": "12.4 소인수분해\n소인수분해란 어떤 수를 소수들의 곱으로 표현하는 것입니다. 예를 들어 12 를 소인수 분해하면 2 * 2 * 3 으로 나타낼 수 있습니다. 따라서 12 의 소인수는 2 와 3 입니다. 자연수 n 이 매개변수로 주어질 때 n 의 소인수를 오름차순으로 담은 배열을 return 하도록 solution 함수를 완성해주세요.\n\n12.4.1 파이썬\nfrom typing import List\n\ndef solution(n: int) -&gt; List[int]:\n    factors = []\n    divisor = 2\n\n    while divisor * divisor &lt;= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n\n    if n &gt; 1:\n        factors.append(n)\n\n    return sorted(set(factors))\n\n\n12.4.2 러스트\nfn solution(n: i32) -&gt; Vec&lt;i32&gt; {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    let mut num = n; // Create a mutable copy of n\n\n    while divisor * divisor &lt;= num {\n        if num % divisor == 0 {\n            factors.push(divisor);\n            num /= divisor; // Use the mutable copy\n        } else {\n            divisor += 1;\n        }\n    }\n\n    if num &gt; 1 {\n        factors.push(num);\n    }\n\n    // Use a HashSet to remove duplicates, then collect and sort\n    let mut unique_factors: Vec&lt;i32&gt; = factors.into_iter().collect();\n    unique_factors.sort();\n    unique_factors.dedup(); // Remove duplicates\n\n    unique_factors\n}\n\nfn main() {\n    let input = 28;\n    let result = solution(input);\n    println!(\"{:?}\", result); // Output: [2, 7]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#컨트롤-제트",
    "href": "posts/qmd/learn_coding_basic.html#컨트롤-제트",
    "title": "코딩테스트 입문",
    "section": "13.1 컨트롤 제트",
    "text": "13.1 컨트롤 제트\n숫자와 “Z”가 공백으로 구분되어 담긴 문자열이 주어집니다. 문자열에 있는 숫자를 차례대로 더하려고 합니다. 이 때 “Z”가 나오면 바로 전에 더했던 숫자를 뺀다는 뜻입니다. 숫자와 “Z”로 이루어진 문자열 s 가 주어질 때, 머쓱이가 구한 값을 return 하도록 solution 함수를 완성해보세요.\n\n13.1.1 파이썬\ndef solution(s: str) -&gt; int:\n    stack: list[int] = []\n    for item in s.split():\n        if item == 'Z':\n            if stack:  # 스택이 비어있지 않은 경우에만 pop\n                stack.pop()\n        else:\n            stack.append(int(item))\n    return sum(stack)\n\n\n13.1.2 러스트\nfn solution(s: &str) -&gt; i32 {\n    let mut stack: Vec&lt;i32&gt; = Vec::new();\n\n    for item in s.split_whitespace() {\n        if item == \"Z\" {\n            if !stack.is_empty() {\n                stack.pop();\n            }\n        } else {\n            if let Ok(num) = item.parse::&lt;i32&gt;() {\n                stack.push(num);\n            }\n        }\n    }\n\n    stack.iter().sum()\n}\n\nfn main() {\n    let input = \"1 2 3 Z 4 5\";\n    let result = solution(input);\n    println!(\"Result: {}\", result); // Output: Result: 12\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열-원소의-길이",
    "href": "posts/qmd/learn_coding_basic.html#배열-원소의-길이",
    "title": "코딩테스트 입문",
    "section": "13.2 배열 원소의 길이",
    "text": "13.2 배열 원소의 길이\n문자열 배열 strlist 가 매개변수로 주어집니다. strlist 각 원소의 길이를 담은 배열을 return 하도록 solution 함수를 완성해주세요.\n\n13.2.1 파이썬\nfrom typing import List\n\ndef solution(strlist:int ) -&gt; List[int]:\n    return [len(s) for s in strlist]\n\n\n13.2.2 러스트\nfn solution(strlist: &[String]) -&gt; Vec&lt;usize&gt; {\n    strlist.iter().map(|s| s.len()).collect()\n}\n\nfn main() {\n    let input = vec![\n        String::from(\"We\"),\n        String::from(\"are\"),\n        String::from(\"the\"),\n        String::from(\"world!\")\n    ];\n    let result = solution(&input);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#중복된-문자-제거",
    "href": "posts/qmd/learn_coding_basic.html#중복된-문자-제거",
    "title": "코딩테스트 입문",
    "section": "13.3 중복된 문자 제거",
    "text": "13.3 중복된 문자 제거\n문자열 my_string 이 매개변수로 주어집니다. my_string 에서 중복된 문자를 제거하고 하나의 문자만 남긴 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n13.3.1 파이썬\ndef solution(my_string: str) -&gt; str:\n    seen: set[str] = set()\n    return ''.join(ch for ch in my_string if not (ch in seen or seen.add(ch)))\n\n\n13.3.2 러스트\n use std::collections::HashSet;\n\nfn solution(my_string: &str) -&gt; String {\n    let mut seen = HashSet::new();\n    my_string.chars()\n        .filter(|&ch| seen.insert(ch))\n        .collect()\n}\n\nfn main() {\n    let input = \"people\";\n    let result = solution(input);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#삼각형의-완성조건-1",
    "href": "posts/qmd/learn_coding_basic.html#삼각형의-완성조건-1",
    "title": "코딩테스트 입문",
    "section": "13.4 삼각형의 완성조건 (1)",
    "text": "13.4 삼각형의 완성조건 (1)\n선분 세 개로 삼각형을 만들기 위해서는 다음과 같은 조건을 만족해야 합니다. - 가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 합니다. 삼각형의 세 변의 길이가 담긴 배열 sides 이 매개변수로 주어집니다. 세 변으로 삼각형을 만들 수 있다면 1, 만들 수 없다면 2 를 return 하도록 solution 함수를 완성해주세요.\n\n13.4.1 파이썬\nfrom typing import List\n\ndef solution(sides: List[int]) -&gt; int:\n    sides.sort()  # 배열을 오름차순으로 정렬\n    return 1 if sides[0] + sides[1] &gt; sides[2] else 2\n\n\n13.4.2 러스트\nfn solution(mut sides: Vec&lt;i32&gt;) -&gt; i32 {\n    sides.sort();  // 배열을 오름차순으로 정렬\n    if sides[0] + sides[1] &gt; sides[2] { 1 } else { 2 }\n}\n\nfn main() {\n    let input = vec![1, 2, 3];\n    let result = solution(input);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#가까운-수",
    "href": "posts/qmd/learn_coding_basic.html#가까운-수",
    "title": "코딩테스트 입문",
    "section": "14.1 가까운 수",
    "text": "14.1 가까운 수\n정수 배열 array 와 정수 n 이 매개변수로 주어질 때, array 에 들어있는 정수 중 n 과 가장 가까운 수를 return 하도록 solution 함수를 완성해주세요.\n\n14.1.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int], n: int) -&gt; int:\n    array.sort()  # Sort the array in ascending order\n    closest: int = array[0]  # Initialize closest number with the first element\n    min_diff: int = abs(n - array[0])  # Initialize minimum difference\n\n    for num in array:\n        diff: int = abs(n - num)\n        if diff &lt; min_diff:\n            min_diff = diff\n            closest = num\n        elif diff == min_diff and num &lt; closest:\n            closest = num\n\n    return closest\n\n\n14.1.2 러스트\nfn solution(mut array: Vec&lt;i32&gt;, n: i32) -&gt; i32 {\n    array.sort_unstable();  // Sort the array in ascending order\n    let mut closest = array[0];  // Initialize closest number with the first element\n    let mut min_diff = (n - array[0]).abs();  // Initialize minimum difference\n\n    for &num in &array {\n        let diff = (n - num).abs();\n        if diff &lt; min_diff {\n            min_diff = diff;\n            closest = num;\n        } else if diff == min_diff && num &lt; closest {\n            closest = num;\n        }\n    }\n\n    closest\n}\n\nfn main() {\n    let array = vec![1, 2, 3, 4, 5];\n    let n = 3;\n    let result = solution(array, n);\n    println!(\"Closest number: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#게임",
    "href": "posts/qmd/learn_coding_basic.html#게임",
    "title": "코딩테스트 입문",
    "section": "14.2 369 게임",
    "text": "14.2 369 게임\n머쓱이는 친구들과 369 게임을 하고 있습니다. 369 게임은 1 부터 숫자를 하나씩 대며 3, 6, 9 가 들어가는 숫자는 숫자 대신 3, 6, 9 의 개수만큼 박수를 치는 게임입니다. 머쓱이가 말해야하는 숫자 order 가 매개변수로 주어질 때, 머쓱이가 쳐야할 박수 횟수를 return 하도록 solution 함수를 완성해보세요.\n\n14.2.1 파이썬\ndef solution(order: int) -&gt; int:\n    return str(order).count('3') + str(order).count('6') + str(order).count('9')\n\n\n14.2.2 러스트\nfn solution(order: u32) -&gt; u32 {\n    order\n        .to_string()\n        .chars()\n        .filter(|&c| c == '3' || c == '6' || c == '9')\n        .count() as u32\n}\n\nfn main() {\n    let order = 29423;\n    let result = solution(order);\n    println!(\"Number of 3, 6, 9 occurrences: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#암호해독",
    "href": "posts/qmd/learn_coding_basic.html#암호해독",
    "title": "코딩테스트 입문",
    "section": "14.3 암호해독",
    "text": "14.3 암호해독\n군 전략가 머쓱이는 전쟁 중 적군이 다음과 같은 암호 체계를 사용한다는 것을 알아냈습니다.\n\n암호화된 문자열 cipher 를 주고받습니다.\n그 문자열에서 code 의 배수 번째 글자만 진짜 암호입니다.\n\n문자열 cipher 와 정수 code 가 매개변수로 주어질 때 해독된 암호 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n14.3.1 파이썬\ndef solution(cipher: str, code: int) -&gt; str:\n    return cipher[code-1::code]\n\n\n14.3.2 러스트\nfn solution(cipher: &str, code: usize) -&gt; String {\n    cipher.chars()\n        .skip(code - 1)\n        .step_by(code)\n        .collect()\n}\n\nfn main() {\n    let cipher = \"dfjardstddetckdaccccdegk\";\n    let code = 4;\n    let result = solution(cipher, code);\n    println!(\"Decoded message: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#대문자와-소문자",
    "href": "posts/qmd/learn_coding_basic.html#대문자와-소문자",
    "title": "코딩테스트 입문",
    "section": "14.4 대문자와 소문자",
    "text": "14.4 대문자와 소문자\n문자열 my_string 이 매개변수로 주어질 때, 대문자는 소문자로 소문자는 대문자로 변환한 문자열을 return 하도록 solution 함수를 완성해주세요.\n\n14.4.1 파이썬\ndef solution(my_string: str) -&gt; str:\n    return my_string.swapcase()\n\n\n14.4.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    my_string.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n        } else if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n        } else {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n    let my_string = \"Hello World!\";\n    let result = solution(my_string);\n    println!(\"Swapped case: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#영어가-싫어요",
    "href": "posts/qmd/learn_coding_basic.html#영어가-싫어요",
    "title": "코딩테스트 입문",
    "section": "15.1 영어가 싫어요",
    "text": "15.1 영어가 싫어요\n영어가 싫은 머쓱이는 영어로 표기되어있는 숫자를 수로 바꾸려고 합니다. 문자열 numbers 가 매개변수로 주어질 때, numbers 를 정수로 바꿔 return 하도록 solution 함수를 완성해 주세요.\n\n15.1.1 파이썬\ndef solution(numbers: str) -&gt; int:\n    num_dict = {\n        'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',\n        'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9'\n    }\n\n    for word, digit in num_dict.items():\n        numbers = numbers.replace(word, digit)\n\n    return int(numbers)\n\n\n15.1.2 러스트\nuse std::collections::HashMap;\n\nfn solution(numbers: &str) -&gt; i32 {\n    let num_dict: HashMap&lt;&str, &str&gt; = [\n        (\"zero\", \"0\"), (\"one\", \"1\"), (\"two\", \"2\"), (\"three\", \"3\"), (\"four\", \"4\"),\n        (\"five\", \"5\"), (\"six\", \"6\"), (\"seven\", \"7\"), (\"eight\", \"8\"), (\"nine\", \"9\")\n    ].iter().cloned().collect();\n\n    let mut result = numbers.to_string();\n    for (word, digit) in num_dict.iter() {\n        result = result.replace(word, digit);\n    }\n\n    result.parse().unwrap()\n}\n\nfn main() {\n    let result = solution(\"onetwothree\");\n    println!(\"{}\", result); // This will print: 123\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#인덱스-바꾸기",
    "href": "posts/qmd/learn_coding_basic.html#인덱스-바꾸기",
    "title": "코딩테스트 입문",
    "section": "15.2 인덱스 바꾸기",
    "text": "15.2 인덱스 바꾸기\n문자열 my_string 과 정수 num1, num2 가 매개변수로 주어질 때, my_string 에서 인덱스 num1 과 인덱스 num2 에 해당하는 문자를 바꾼 문자열을 return 하도록 solution 함수를 완성해보세요.\n\n15.2.1 파이썬\ndef solution(my_string: str, num1: int, num2: int) -&gt; str:\n    string_list = list(my_string)\n    string_list[num1], string_list[num2] = string_list[num2], string_list[num1]\n    return ''.join(string_list)\n\n\n15.2.2 러스트\nfn solution(my_string: &str, num1: usize, num2: usize) -&gt; String {\n    let mut chars: Vec&lt;char&gt; = my_string.chars().collect();\n    chars.swap(num1, num2);\n    chars.into_iter().collect()\n}\nfn main() {\n    let result = solution(\"hello\", 1, 2);\n    println!(\"{}\", result); // This will print: \"hlelo\"\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#한-번만-등장한-문자",
    "href": "posts/qmd/learn_coding_basic.html#한-번만-등장한-문자",
    "title": "코딩테스트 입문",
    "section": "15.3 한 번만 등장한 문자",
    "text": "15.3 한 번만 등장한 문자\n문자열 s 가 매개변수로 주어집니다. s 에서 한 번만 등장하는 문자를 사전 순으로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요. 한 번만 등장하는 문자가 없을 경우 빈 문자열을 return 합니다.\n\n15.3.1 파이썬\nfrom collections import Counter\nfrom typing import List\n\ndef solution(s: str) -&gt; str:\n    # Count the occurrences of each character\n    char_counts: Counter[str] = Counter(s)\n\n    # Filter characters that appear only once and sort them\n    unique_chars: List[str] = sorted([char for char, count in char_counts.items() if count == 1])\n\n    # Join the characters into a string\n    return ''.join(unique_chars)\n\n\n15.3.2 러스트\nuse std::collections::HashMap;\n\nfn solution(s: &str) -&gt; String {\n    // Count the occurrences of each character\n    let mut char_counts = HashMap::new();\n    for c in s.chars() {\n        *char_counts.entry(c).or_insert(0) += 1;\n    }\n\n    // Filter characters that appear only once and sort them\n    let mut unique_chars: Vec&lt;char&gt; = char_counts\n        .into_iter()\n        .filter(|&(_, count)| count == 1)\n        .map(|(char, _)| char)\n        .collect();\n\n    // Sort the unique characters\n    unique_chars.sort_unstable();\n\n    // Join the characters into a string\n    unique_chars.into_iter().collect()\n}\n\nfn main() {\n    let result = solution(\"abcabcabc\");\n    println!(\"{}\", result); // This will print: \"\"\n\n    let result2 = solution(\"abcabcabcd\");\n    println!(\"{}\", result2); // This will print: \"d\"\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#악수-구하기",
    "href": "posts/qmd/learn_coding_basic.html#악수-구하기",
    "title": "코딩테스트 입문",
    "section": "15.4 악수 구하기",
    "text": "15.4 악수 구하기\n정수 n 이 매개변수로 주어질 때, n 의 약수를 오름차순으로 담은 배열을 return 하도록 solution 함수를 완성해주세요.\n\n15.4.1 파이썬\nfrom typing import List\n\ndef solution(n: int) -&gt; List[int]:\n    divisors: List[int] = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sorted(divisors)\n\n\n15.4.2 러스트\nfn solution(n: u64) -&gt; Vec&lt;u64&gt; {\n    let mut divisors = Vec::new();\n    let sqrt = (n as f64).sqrt() as u64;\n\n    for i in 1..=sqrt {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n    }\n\n    divisors.sort_unstable();\n    divisors\n}\nfn main() {\n    let result = solution(12);\n    println!(\"{:?}\", result); // This will print: [1, 2, 3, 4, 6, 12]\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#편지",
    "href": "posts/qmd/learn_coding_basic.html#편지",
    "title": "코딩테스트 입문",
    "section": "16.1 편지",
    "text": "16.1 편지\n머쓱이는 할머니께 생신 축하 편지를 쓰려고 합니다. 할머니가 보시기 편하도록 글자 한 자 한 자를 가로 2cm 크기로 적으려고 하며, 편지를 가로로만 적을 때, 축하 문구 message 를 적기 위해 필요한 편지지의 최소 가로길이를 return 하도록 solution 함수를 완성해주세요.\n\n16.1.1 파이썬\ndef solution(message: str) -&gt; int:\n    return len(message) * 2\n\n\n16.1.2 러스트\nfn solution(message: &str) -&gt; i32 {\n    (message.len() * 2) as i32\n}\nfn main() {\n    let result = \"hello\";\n    println!(\"{}\",solution(result));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#가장-큰-수-찾기",
    "href": "posts/qmd/learn_coding_basic.html#가장-큰-수-찾기",
    "title": "코딩테스트 입문",
    "section": "16.2 가장 큰 수 찾기",
    "text": "16.2 가장 큰 수 찾기\n정수 배열 array 가 매개변수로 주어질 때, 가장 큰 수와 그 수의 인덱스를 담은 배열을 return 하도록 solution 함수를 완성해보세요.\n\n16.2.1 파이썬\nfrom typing import List, Union\n\ndef solution(array: List[Union[int, float]]) -&gt; List[Union[int, float]]:\n    max_value = max(array)\n    max_index = array.index(max_value)\n    return [max_value, max_index]\n\n\n16.2.2 러스트\nfn solution(array: &[i32]) -&gt; (i32, usize) {\n    let max_value = *array.iter().max().unwrap();\n    let max_index = array.iter().position(|&x| x == max_value).unwrap();\n    (max_value, max_index)\n}\n\nfn main() {\n    // Test case\n    let array = vec![3, 1, 4, 1, 5, 9, 2, 6, 5];\n\n    // Call the solution function\n    let (max_value, max_index) = solution(&array);\n\n    // Print the results\n    println!(\"Maximum value: {}, Index: {}\", max_value, max_index);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열-계산하기",
    "href": "posts/qmd/learn_coding_basic.html#문자열-계산하기",
    "title": "코딩테스트 입문",
    "section": "16.3 문자열 계산하기",
    "text": "16.3 문자열 계산하기\nmy_string 은 \\(3 + 5\\) 처럼 문자열로 된 수식입니다. 문자열 my_string 이 매개변수로 주어질 때, 수식을 계산한 값을 return 하는 solution 함수를 완성해주세요.\n\n16.3.1 파이썬\ndef solution(my_string: str) -&gt; int:\n    elements = my_string.split()\n    result = int(elements[0])\n\n    for i in range(1, len(elements), 2):\n        operator = elements[i]\n        number = int(elements[i + 1])\n\n        if operator == '+':\n            result += number\n        elif operator == '-':\n            result -= number\n\n    return result\n\n\n16.3.2 러스트\nfn solution(my_string: &str) -&gt; i32 {\n    let elements: Vec&lt;&str&gt; = my_string.split_whitespace().collect();\n    let mut result: i32 = elements[0].parse().unwrap();\n\n    for i in (1..elements.len()).step_by(2) {\n        let operator = elements[i];\n        let number: i32 = elements[i + 1].parse().unwrap();\n\n        match operator {\n            \"+\" =&gt; result += number,\n            \"-\" =&gt; result -= number,\n            _ =&gt; panic!(\"Unsupported operator: {}\", operator),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    // Test case\n    let input = \"3 + 5 - 2 + 8\";\n\n    // Call the solution function\n    let result = solution(input);\n\n    // Print the result\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#배열의-유사도",
    "href": "posts/qmd/learn_coding_basic.html#배열의-유사도",
    "title": "코딩테스트 입문",
    "section": "16.4 배열의 유사도",
    "text": "16.4 배열의 유사도\n두 배열이 얼마나 유사한지 확인해보려고 합니다. 문자열 배열 s1 과 s2 가 주어질 때 같은 원소의 개수를 return 하도록 solution 함수를 완성해주세요.\n\n16.4.1 파이썬\nfrom typing import List\n\ndef solution(s1: List[str], s2: List[str]) -&gt; int:\n    count = 0\n    for item in s1:\n        if item in s2:\n            count += 1\n    return count\n\n\n16.4.2 러스트\nfn solution(s1: &[&str], s2: &[&str]) -&gt; usize {\n    let mut count = 0;\n\n    for &item in s1 {\n        if s2.contains(&item) {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n    // Test case\n    let s1 = vec![\"apple\", \"banana\", \"cherry\"];\n    let s2 = vec![\"banana\", \"kiwi\", \"apple\", \"grape\"];\n\n    // Call the solution function\n    let result = solution(&s1, &s2);\n\n    // Print the result\n    println!(\"Count of common elements: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#숫자-찾기",
    "href": "posts/qmd/learn_coding_basic.html#숫자-찾기",
    "title": "코딩테스트 입문",
    "section": "17.1 숫자 찾기",
    "text": "17.1 숫자 찾기\n정수 num 과 k 가 매개변수로 주어질 때, num 을 이루는 숫자 중에 k 가 있으면 num 의 그 숫자가 있는 자리 수를 return 하고 없으면 \\(-1\\) 을 return 하도록 solution 함수를 완성해보세요.\n\n17.1.1 파이썬\ndef solution(num: int, k: int) -&gt; int:\n    num_str = str(num)\n    k_str = str(k)\n    index = num_str.find(k_str)\n    if index != -1:\n        return index + 1\n    else:\n        return -1\n\n\n17.1.2 러스트\nfn solution(num: i32, k: i32) -&gt; i32 {\n    let num_str = num.to_string();\n    let k_str = k.to_string();\n\n    match num_str.find(&k_str) {\n        Some(index) =&gt; (index + 1) as i32,\n        None =&gt; -1,\n    }\n}\n\nfn main() {\n    let test_cases = vec![\n        (42, 2),\n        (123, 4),\n        (5678, 7)\n    ];\n\n    for (num, k) in test_cases {\n        let result = solution(num, k);\n        println!(\"Number: {}, Search Digit: {}, Result: {}\", num, k, result);\n    }\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#n-의-배수-고르기",
    "href": "posts/qmd/learn_coding_basic.html#n-의-배수-고르기",
    "title": "코딩테스트 입문",
    "section": "17.2 n 의 배수 고르기",
    "text": "17.2 n 의 배수 고르기\n정수 n 과 정수 배열 numlist 가 매개변수로 주어질 때, numlist 에서 n 의 배수가 아닌 수들을 제거한 배열을 return 하도록 solution 함수를 완성해주세요.\n\n17.2.1 파이썬\ndef solution(n: int, numlist: list[int]) -&gt; list[int]:\n    return [num for num in numlist if num % n == 0]\n\n\n17.2.2 러스트\nfn solution(n: i32, numlist: &[i32]) -&gt; Vec&lt;i32&gt; {\n    numlist.iter().cloned().filter(|&num| num % n == 0).collect()\n}\n\nfn main() {\n    let n = 3;\n    let numlist = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let result = solution(n, &numlist);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#자릿수-더하기",
    "href": "posts/qmd/learn_coding_basic.html#자릿수-더하기",
    "title": "코딩테스트 입문",
    "section": "17.3 자릿수 더하기",
    "text": "17.3 자릿수 더하기\n정수 n 이 매개변수로 주어질 때 n 의 각 자리 숫자의 합을 return 하도록 solution 함수를 완성해주세요\n\n17.3.1 파이썬\ndef solution(n: int) -&gt; int:\n    return sum(int(digit) for digit in str(n))\n\n\n17.3.2 러스트\nfn solution(n: i32) -&gt; i32 {\n    n.to_string()\n        .chars()\n        .map(|digit| digit.to_digit(10).unwrap() as i32)\n        .sum()\n}\n\nfn main() {\n    let n = 12345;\n    let result = solution(n);\n    println!(\"{}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#ox-퀴즈",
    "href": "posts/qmd/learn_coding_basic.html#ox-퀴즈",
    "title": "코딩테스트 입문",
    "section": "17.4 OX 퀴즈",
    "text": "17.4 OX 퀴즈\n덧셈, 뺄셈 수식들이 \\(X [연산자] Y = Z\\) 형태로 들어있는 문자열 배열 quiz 가 매개변수로 주어집니다. 수식이 옳다면 “O”를 틀리다면 “X”를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해주세요.\n\n17.4.1 파이썬\ndef solution(quiz: list[str]) -&gt; list[str]:\n    result = []\n    for equation in quiz:\n        left, right = equation.split('=')\n        left = left.strip()\n        right = right.strip()\n\n        if eval(left) == int(right):\n            result.append(\"O\")\n        else:\n            result.append(\"X\")\n\n    return result\n\n\n17.4.2 러스트\nfn solution(quiz: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    quiz.iter().map(|equation| {\n        let parts: Vec&lt;&str&gt; = equation.split('=').collect();\n        let left = parts[0].trim();\n        let right = parts[1].trim();\n\n        let left_result = evaluate_expression(left);\n        let right_result: i32 = right.parse().unwrap();\n\n        if left_result == right_result {\n            \"O\".to_string()\n        } else {\n            \"X\".to_string()\n        }\n    }).collect()\n}\n\nfn evaluate_expression(expr: &str) -&gt; i32 {\n    let tokens: Vec&lt;&str&gt; = expr.split_whitespace().collect();\n    let mut result = tokens[0].parse::&lt;i32&gt;().unwrap();\n\n    for i in (1..tokens.len()).step_by(2) {\n        let operator = tokens[i];\n        let operand = tokens[i+1].parse::&lt;i32&gt;().unwrap();\n\n        match operator {\n            \"+\" =&gt; result += operand,\n            \"-\" =&gt; result -= operand,\n            \"*\" =&gt; result *= operand,\n            \"/\" =&gt; result /= operand,\n            _ =&gt; panic!(\"Unknown operator\"),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let quiz = vec![\n        \"3 + 4 = 7\".to_string(),\n        \"5 * 6 = 30\".to_string(),\n        \"19 - 6 = 13\".to_string(),\n    ];\n\n    let result = solution(quiz);\n    println!(\"{:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열안에-문자열",
    "href": "posts/qmd/learn_coding_basic.html#문자열안에-문자열",
    "title": "코딩테스트 입문",
    "section": "18.1 문자열안에 문자열",
    "text": "18.1 문자열안에 문자열\n문자열 str1, str2 가 매개변수로 주어집니다. str1 안에 str2 가 있다면 1 을 없다면 2 를 return 하도록 solution 함수를 완성해주세요.\n\n18.1.1 파이썬\ndef solution(str1: str, str2: str) -&gt; int:\n    return 1 if str2 in str1 else 2\n\n\n18.1.2 러스트\nfn solution(str1: &str, str2: &str) -&gt; i32 {\n    if str1.contains(str2) {\n        1\n    } else {\n        2\n    }\n}\n\nfn main() {\n    let str1 = \"Hello, world!\";\n    let str2 = \"world\";\n    let result = solution(str1, str2);\n    println!(\"{}\", result); // Output: 1\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#제곱수-판별하기",
    "href": "posts/qmd/learn_coding_basic.html#제곱수-판별하기",
    "title": "코딩테스트 입문",
    "section": "18.2 제곱수 판별하기",
    "text": "18.2 제곱수 판별하기\n어떤 자연수를 제곱했을 때 나오는 정수를 제곱수라고 합니다. 정수 n 이 매개변수로 주어질 때, n 이 제곱수라면 1 을 아니라면 2 를 return 하도록 solution 함수를 완성해주세요.\n\n18.2.1 파이썬\nimport math\n\ndef solution(n: int) -&gt; int:\n    return 1 if math.isqrt(n) ** 2 == n else 2\n\n\n18.2.2 러스트\nfn solution(n: i64) -&gt; i32 {\n    if (n as f64).sqrt().powi(2) as i64 == n {\n        1\n    } else {\n        2\n    }\n}\n\nfn main() {\n    let test_cases = 16;\n    println!(\"{}\", solution(test_cases));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#세균증식",
    "href": "posts/qmd/learn_coding_basic.html#세균증식",
    "title": "코딩테스트 입문",
    "section": "18.3 세균증식",
    "text": "18.3 세균증식\n어떤 세균은 1 시간에 두배만큼 증식한다고 합니다. 처음 세균의 마리수 n 과 경과한 시간 t 가 매개변수로 주어질 때 t 시간 후 세균의 수를 return 하도록 solution 함수를 완성해주세요.\n\n18.3.1 파이썬\ndef solution(n: int, t: int) -&gt; int:\n    return n * (2 ** t)\n\n\n18.3.2 러스트\nfn solution(n: i32, t: i32) -&gt; i32 {\n    n * (2_i32.pow(t as u32))\n}\n\nfn main() {\n    let n = 3;\n    let t = 2;\n    let result = solution(n, t);\n\n    println!(\"Result for n = {}, t = {}: {}\", n, t, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열-정렬하기-2",
    "href": "posts/qmd/learn_coding_basic.html#문자열-정렬하기-2",
    "title": "코딩테스트 입문",
    "section": "18.4 문자열 정렬하기 (2)",
    "text": "18.4 문자열 정렬하기 (2)\n영어 대소문자로 이루어진 문자열 my_string 이 매개변수로 주어질 때, my_string 을 모두 소문자로 바꾸고 알파벳 순서대로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요.\n\n18.4.1 파이썬\ndef solution(my_string: str) -&gt; str:\n    return ''.join(sorted(my_string.lower()))\n\n\n18.4.2 러스트\nfn solution(my_string: &str) -&gt; String {\n    let mut chars: Vec&lt;char&gt; = my_string.to_lowercase().chars().collect();\n    chars.sort_unstable();\n    chars.into_iter().collect()\n}\n\nfn main() {\n    let result = solution(\"Bcad\");\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#의-배수",
    "href": "posts/qmd/learn_coding_basic.html#의-배수",
    "title": "코딩테스트 입문",
    "section": "19.1 7 의 배수",
    "text": "19.1 7 의 배수\n머쓱이는 행운의 숫자 7 을 가장 좋아합니다. 정수 배열 array 가 매개변수로 주어질 때, 7 이 총 몇 개 있는지 return 하도록 solution 함수를 완성해보세요.\n\n19.1.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int]) -&gt; int:\n    return str(array).count(\"7\")\n\n\n19.1.2 러스트\nfn solution(array: &[i32]) -&gt; usize {\n    array.iter()\n        .map(|&num| num.to_string())\n        .collect::&lt;String&gt;()\n        .matches('7')\n        .count()\n}\n\nfn main() {\n    let example_array = vec![7, 77, 17, 27, 70];\n    let result = solution(&example_array);\n\n    println!(\"Input array: {:?}\", example_array);\n    println!(\"Number of '7's: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#잘라서-배열로-저장하기",
    "href": "posts/qmd/learn_coding_basic.html#잘라서-배열로-저장하기",
    "title": "코딩테스트 입문",
    "section": "19.2 잘라서 배열로 저장하기",
    "text": "19.2 잘라서 배열로 저장하기\n문자열 my_str 과 n 이 매개변수로 주어질 때, my_str 을 길이 n 씩 잘라서 저장한 배열을 return 하도록 solution 함수를 완성해주세요.\n\n19.2.1 파이썬\nfrom typing import List\n\ndef solution(my_str: str, n: int) -&gt; List[str]:\n    answer: List[str] = []\n    for i in range(0, len(my_str), n):\n        answer.append(my_str[i:i+n])\n    return answer\n\n\n19.2.2 러스트\nfn solution(my_str: &str, n: usize) -&gt; Vec&lt;String&gt; {\n    let mut answer: Vec&lt;String&gt; = Vec::new();\n    for i in (0..my_str.len()).step_by(n) {\n        answer.push(my_str[i..std::cmp::min(i + n, my_str.len())].to_string());\n    }\n    answer\n}\n\nfn main() {\n    let result = solution(\"abcdefghij\", 3);\n    println!(\"Result: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#중복된-숫자-개수",
    "href": "posts/qmd/learn_coding_basic.html#중복된-숫자-개수",
    "title": "코딩테스트 입문",
    "section": "19.3 중복된 숫자 개수",
    "text": "19.3 중복된 숫자 개수\n정수가 담긴 배열 array 와 정수 n 이 매개변수로 주어질 때, array 에 n 이 몇 개 있는 지를 return 하도록 solution 함수를 완성해보세요.\n\n19.3.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int], n: int) -&gt; int:\n    return array.count(n)\n\n\n19.3.2 러스트\nfn solution(array: &[i32], n: i32) -&gt; usize {\n    array.iter().filter(|&&x| x == n).count()\n}\n\nfn main() {\n    let array = vec![1, 1, 2, 3, 4, 5, 1];\n    let n = 1;\n    let result = solution(&array, n);\n    println!(\"Number of occurrences of {} in {:?}: {}\", n, array, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#머쓱이보다-키-큰-사람",
    "href": "posts/qmd/learn_coding_basic.html#머쓱이보다-키-큰-사람",
    "title": "코딩테스트 입문",
    "section": "19.4 머쓱이보다 키 큰 사람",
    "text": "19.4 머쓱이보다 키 큰 사람\n머쓱이는 학교에서 키 순으로 줄을 설 때 몇 번째로 서야 하는지 궁금해졌습니다. 머쓱이네 반 친구들의 키가 담긴 정수 배열 array 와 머쓱이의 키 height 가 매개변수로 주어질 때, 머쓱이보다 키 큰 사람 수를 return 하도록 solution 함수를 완성해보세요.\n\n19.4.1 파이썬\nfrom typing import List\n\ndef solution(array: List[int], height: int) -&gt; int:\n    return sum(1 for person in array if person &gt; height)\n\n\n19.4.2 러스트\nfn solution(array: &[i32], height: i32) -&gt; usize {\n    array.iter().filter(|&&person| person &gt; height).count()\n}\n\nfn main() {\n    let array = vec![180, 170, 165, 175, 190, 160];\n    let height = 170;\n    let result = solution(&array, height);\n    println!(\"Number of people taller than {}: {}\", height, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#직사각형-넓이-구하기",
    "href": "posts/qmd/learn_coding_basic.html#직사각형-넓이-구하기",
    "title": "코딩테스트 입문",
    "section": "20.1 직사각형 넓이 구하기",
    "text": "20.1 직사각형 넓이 구하기\n2 차원 좌표 평면에 변이 축과 평행한 직사각형이 있습니다. 직사각형 네 꼭짓점의 좌표 \\([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]\\) 가 담겨있는 배열 dots 가 매개변수로 주어질 때, 직사각형의 넓이를 return 하도록 solution 함수를 완성해보세요.\n\n20.1.1 파이썬\nfrom typing import List, Tuple\n\ndef solution(dots: List[Tuple[int, int]]) -&gt; int:\n    x_coords = [dot[0] for dot in dots]\n    y_coords = [dot[1] for dot in dots]\n\n    width = max(x_coords) - min(x_coords)\n    height = max(y_coords) - min(y_coords)\n\n    return width * height\n\n\n20.1.2 러스트\nfn solution(dots: &Vec&lt;(i32, i32)&gt;) -&gt; i32 {\n    let x_coords: Vec&lt;i32&gt; = dots.iter().map(|&(x, _)| x).collect();\n    let y_coords: Vec&lt;i32&gt; = dots.iter().map(|&(_, y)| y).collect();\n\n    let width = x_coords.iter().max().unwrap() - x_coords.iter().min().unwrap();\n    let height = y_coords.iter().max().unwrap() - y_coords.iter().min().unwrap();\n\n    width * height\n}\n\nfn main() {\n    let dots = vec![(1, 1), (2, 2), (3, 3), (4, 4)];\n    let result = solution(&dots);\n    println!(\"Area: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#캐릭터의-좌표",
    "href": "posts/qmd/learn_coding_basic.html#캐릭터의-좌표",
    "title": "코딩테스트 입문",
    "section": "20.2 캐릭터의 좌표",
    "text": "20.2 캐릭터의 좌표\n머쓱이는 RPG 게임을 하고 있습니다. 게임에는 up, down, left, right 방향키가 있으며 각 키를 누르면 위, 아래, 왼쪽, 오른쪽으로 한 칸씩 이동합니다. 예를 들어 [0,0] 에서 up 을 누른다면 캐릭터의 좌표는 [0, 1], down 을 누른다면 [0, -1], left 를 누른다면 [-1, 0], right 를 누른다면 [1, 0] 입니다. 머쓱이가 입력한 방향키의 배열 keyinput 와 맵의 크기 board 이 매개변수로 주어집니다. 캐릭터는 항상 [0,0] 에서 시작할 때 키 입력이 모두 끝난 뒤에 캐릭터의 좌표 [x, y] 를 return 하도록 solution 함수를 완성해주세요.\n\n[0, 0] 은 board 의 정 중앙에 위치합니다. 예를 들어 board 의 가로 크기가 9 라면 캐릭터는 왼쪽으로 최대 [-4, 0] 까지 오른쪽으로 최대 [4, 0] 까지 이동할 수 있습니다.\n\n\n20.2.1 파이썬\nfrom typing import List\n\ndef solution(keyinput: List[str], board: List[int]) -&gt; List[int]:\n    x, y = 0, 0\n    max_x, max_y = board[0] // 2, board[1] // 2\n\n    for key in keyinput:\n        if key == \"left\" and x &gt; -max_x:\n            x -= 1\n        elif key == \"right\" and x &lt; max_x:\n            x += 1\n        elif key == \"up\" and y &lt; max_y:\n            y += 1\n        elif key == \"down\" and y &gt; -max_y:\n            y -= 1\n\n    return [x, y]\n\n\n20.2.2 러스트\nfn solution(keyinput: &[String], board: &[i32]) -&gt; Vec&lt;i32&gt; {\n    let mut x = 0;\n    let mut y = 0;\n    let max_x = board[0] / 2;\n    let max_y = board[1] / 2;\n\n    for key in keyinput {\n        match key.as_str() {\n            \"left\" if x &gt; -max_x =&gt; x -= 1,\n            \"right\" if x &lt; max_x =&gt; x += 1,\n            \"up\" if y &lt; max_y =&gt; y += 1,\n            \"down\" if y &gt; -max_y =&gt; y -= 1,\n            _ =&gt; {}\n        }\n    }\n\n    vec![x, y]\n}\n\nfn main() {\n    let keyinput = vec![\n        \"left\".to_string(),\n        \"right\".to_string(),\n        \"up\".to_string(),\n        \"right\".to_string(),\n    ];\n    let board = vec![11, 11];\n    let result = solution(&keyinput, &board);\n    println!(\"Final position: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#최댓값-만들기-2",
    "href": "posts/qmd/learn_coding_basic.html#최댓값-만들기-2",
    "title": "코딩테스트 입문",
    "section": "20.3 최댓값 만들기 (2)",
    "text": "20.3 최댓값 만들기 (2)\n정수 배열 numbers 가 매개변수로 주어집니다. numbers 의 원소 중 두 개를 곱해 만들 수 있는 최댓값을 return 하도록 solution 함수를 완성해주세요.\n\n20.3.1 파이썬\nfrom typing import List\n\ndef solution(numbers: List[int]) -&gt; int:\n    numbers.sort()  # 리스트를 오름차순으로 정렬\n    return max(numbers[0] * numbers[1], numbers[-1] * numbers[-2])\n\n\n20.3.2 러스트\nfn solution(mut numbers: Vec&lt;i32&gt;) -&gt; i32 {\n    numbers.sort();  // Sort the vector in ascending order\n    numbers[0] * numbers[1].max(numbers[numbers.len() - 1] * numbers[numbers.len() - 2])\n}\n\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = solution(numbers);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#다항식-더하기",
    "href": "posts/qmd/learn_coding_basic.html#다항식-더하기",
    "title": "코딩테스트 입문",
    "section": "20.4 다항식 더하기",
    "text": "20.4 다항식 더하기\n한 개 이상의 항의 합으로 이루어진 식을 다항식이라고 합니다. 다항식을 계산할 때는 동류항끼리 계산해 정리합니다. 덧셈으로 이루어진 다항식 polynomial 이 매개변수로 주어질 때, 동류항끼리 더한 결괏값을 문자열로 return 하도록 solution 함수를 완성해보세요. 같은 식이라면 가장 짧은 수식을 return 합니다.\n\n20.4.1 파이썬\ndef solution(polynomial: str) -&gt; str:\n    x_terms: int = 0\n    constant: int = 0\n\n    for term in polynomial.split(' + '):\n        if 'x' in term:\n            coef: str = term.replace('x', '') or '1'\n            x_terms += int(coef)\n        else:\n            constant += int(term)\n\n    result: list[str] = []\n    if x_terms:\n        result.append(f\"{x_terms if x_terms &gt; 1 else ''}x\")\n    if constant:\n        result.append(str(constant))\n\n    return ' + '.join(result) if result else '0'\n\n\n20.4.2 러스트\nfn solution(polynomial: &str) -&gt; String {\n    let mut x_terms = 0;\n    let mut constant = 0;\n\n    for term in polynomial.split(\" + \") {\n        if term.contains('x') {\n            let coef = term.replace('x', \"\");\n            x_terms += coef.parse::&lt;i32&gt;().unwrap_or(1);\n        } else {\n            constant += term.parse::&lt;i32&gt;().unwrap();\n        }\n    }\n\n    let mut result = Vec::new();\n    if x_terms != 0 {\n        result.push(if x_terms &gt; 1 {\n            format!(\"{}x\", x_terms)\n        } else {\n            \"x\".to_string()\n        });\n    }\n    if constant != 0 {\n        result.push(constant.to_string());\n    }\n\n    if result.is_empty() {\n        \"0\".to_string()\n    } else {\n        result.join(\" + \")\n    }\n}\n\nfn main() {\n    let polynomial = \"3x + 7 + x\";\n    let result = solution(polynomial);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#숨어있는-숫자의-덧셈-2",
    "href": "posts/qmd/learn_coding_basic.html#숨어있는-숫자의-덧셈-2",
    "title": "코딩테스트 입문",
    "section": "21.1 숨어있는 숫자의 덧셈 (2)",
    "text": "21.1 숨어있는 숫자의 덧셈 (2)\n문자열 my_string 이 매개변수로 주어집니다. my_string 은 소문자, 대문자, 자연수로만 구성되어있습니다. my_string 안의 자연수들의 합을 return 하도록 solution 함수를 완성해주세요.\n\n21.1.1 파이썬\nimport re\nfrom typing import List\n\ndef solution(my_string: str) -&gt; int:\n    numbers: List[str] = re.findall(r'\\d+', my_string)\n    return sum(map(int, numbers))\n\n\n21.1.2 러스트\nuse regex::Regex;\n\nfn solution(my_string: &str) -&gt; i32 {\n    let re = Regex::new(r\"\\d+\").unwrap();\n    re.find_iter(my_string)\n        .filter_map(|m| m.as_str().parse::&lt;i32&gt;().ok())\n        .sum()\n}\n\nfn main() {\n    let test_string = \"aAb1B2cC34oOp\";\n    let result = solution(test_string);\n    println!(\"Sum of numbers in '{}': {}\", test_string, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#안전지대",
    "href": "posts/qmd/learn_coding_basic.html#안전지대",
    "title": "코딩테스트 입문",
    "section": "21.2 안전지대",
    "text": "21.2 안전지대\n다음 처럼 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다.\nX | X  |  X\nX | O  |  X\nX | X  |  X\n지뢰는 2 차원 배열 board 에 1 로 표시되어 있고 board 에는 지뢰가 매설 된 지역 1 과, 지뢰가 없는 지역 0 만 존재합니다. 지뢰가 매설된 지역의 지도 board 가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return 하도록 solution 함수를 완성해주세요.\n\n21.2.1 파이썬\nfrom typing import List, Set, Tuple\n\ndef solution(board: List[List[int]]) -&gt; int:\n    n: int = len(board)\n    danger_zones: Set[Tuple[int, int]] = set()\n\n    def mark_danger_zone(i: int, j: int) -&gt; None:\n        for di in range(-1, 2):\n            for dj in range(-1, 2):\n                ni, nj = i + di, j + dj\n                if 0 &lt;= ni &lt; n and 0 &lt;= nj &lt; n:\n                    danger_zones.add((ni, nj))\n\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == 1:\n                mark_danger_zone(i, j)\n\n    return n * n - len(danger_zones)\n\n\n21.2.2 러스트\nfn solution(board: &Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let n = board.len();\n    let mut danger_zones = std::collections::HashSet::new();\n\n    fn mark_danger_zone(i: i32, j: i32, n: i32, danger_zones: &mut std::collections::HashSet&lt;(i32, i32)&gt;) {\n        for di in -1..=1 {\n            for dj in -1..=1 {\n                let ni = i + di;\n                let nj = j + dj;\n                if ni &gt;= 0 && ni &lt; n && nj &gt;= 0 && nj &lt; n {\n                    danger_zones.insert((ni, nj));\n                }\n            }\n        }\n    }\n\n    for (i, row) in board.iter().enumerate() {\n        for (j, &cell) in row.iter().enumerate() {\n            if cell == 1 {\n                mark_danger_zone(i as i32, j as i32, n as i32, &mut danger_zones);\n            }\n        }\n    }\n\n    (n * n - danger_zones.len()) as i32\n}\n\nfn main() {\n    let board = vec![\n        vec![0, 0, 0, 0, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![0, 0, 1, 0, 0],\n        vec![0, 0, 0, 0, 0]\n    ];\n\n    println!(\"Safe squares: {}\", solution(&board));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#삼각형의-완성조건-2",
    "href": "posts/qmd/learn_coding_basic.html#삼각형의-완성조건-2",
    "title": "코딩테스트 입문",
    "section": "21.3 삼각형의 완성조건 (2)",
    "text": "21.3 삼각형의 완성조건 (2)\n선분 세 개로 삼각형을 만들기 위해서는 다음과 같은 조건을 만족해야 합니다.\n\n가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 합니다.\n\n삼각형의 두 변의 길이가 담긴 배열 sides 이 매개변수로 주어집니다. 나머지 한 변이 될 수 있는 정수의 개수를 return 하도록 solution 함수를 완성해주세요.\n\n21.3.1 파이썬\nfrom typing import List\n\ndef solution(sides: List[int]) -&gt; int:\n    max_side: int = max(sides)\n    min_side: int = min(sides)\n\n    # Case 1: 주어진 두 변 중 긴 변이 가장 긴 경우\n    count1: int = max_side - (max_side - min_side)\n\n    # Case 2: 새로운 변이 가장 긴 경우\n    count2: int = (max_side + min_side) - max_side - 1\n\n    return count1 + count2\n\n\n21.3.2 러스트\nfn solution(sides: &[i32]) -&gt; i32 {\n    let max_side = *sides.iter().max().unwrap();\n    let min_side = *sides.iter().min().unwrap();\n\n    // Case 1: 주어진 두 변 중 긴 변이 가장 긴 경우\n    let count1 = max_side - (max_side - min_side);\n\n    // Case 2: 새로운 변이 가장 긴 경우\n    let count2 = (max_side + min_side) - max_side - 1;\n\n    count1 + count2\n}\n\nfn main() {\n    let sides = vec![1, 2];\n    println!(\"Result: {}\", solution(&sides));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#외계어-사전",
    "href": "posts/qmd/learn_coding_basic.html#외계어-사전",
    "title": "코딩테스트 입문",
    "section": "21.4 외계어 사전",
    "text": "21.4 외계어 사전\nPROGRAMMERS-962 행성에 불시착한 우주비행사 머쓱이는 외계행성의 언어를 공부하려고 합니다. 알파벳이 담긴 배열 spell 과 외계어 사전 dic 이 매개변수로 주어집니다. spell 에 담긴 알파벳을 한번씩만 모두 사용한 단어가 dic 에 존재한다면 1, 존재하지 않는다면 2 를 return 하도록 solution 함수를 완성해주세요.\n\n21.4.1 파이썬\nfrom typing import List, Set\n\ndef solution(spell: List[str], dic: List[str]) -&gt; int:\n    spell_set: Set[str] = set(spell)\n\n    for word in dic:\n        if set(word) == spell_set and len(word) == len(spell):\n            return 1\n\n    return 2\n\n\n21.4.2 러스트\nuse std::collections::HashSet;\n\nfn solution(spell: &[String], dic: &[String]) -&gt; i32 {\n    let spell_set: HashSet&lt;char&gt; = spell.iter().flat_map(|s| s.chars()).collect();\n\n    for word in dic {\n        let word_set: HashSet&lt;char&gt; = word.chars().collect();\n        if word_set == spell_set && word.len() == spell.len() {\n            return 1;\n        }\n    }\n\n    2\n}\n\nfn main() {\n    let spell = vec![\"p\".to_string(), \"o\".to_string(), \"s\".to_string()];\n    let dic = vec![\"sod\".to_string(), \"eocd\".to_string(), \"qixm\".to_string(), \"adio\".to_string(), \"soo\".to_string()];\n\n    println!(\"Result: {}\", solution(&spell, &dic));\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#저주의-숫자-3",
    "href": "posts/qmd/learn_coding_basic.html#저주의-숫자-3",
    "title": "코딩테스트 입문",
    "section": "22.1 저주의 숫자 3",
    "text": "22.1 저주의 숫자 3\n3x 마을 사람들은 3 을 저주의 숫자라고 생각하기 때문에 3 의 배수와 숫자 3 을 사용하지 않습니다. 3x 마을 사람들의 숫자는 다음과 같습니다.\n\n\n\n10 진법\n3x 마을에서 쓰는 숫자\n10 진법\n3x 마을에서 쓰는 숫자\n\n\n\n\n1\n1\n6\n8\n\n\n2\n2\n7\n10\n\n\n3\n4\n8\n11\n\n\n4\n5\n9\n14\n\n\n5\n7\n10\n16\n\n\n\n정수 n 이 매개변수로 주어질 때, n 을 3x 마을에서 사용하는 숫자로 바꿔 return 하도록 solution 함수를 완성해주세요.\n\n22.1.1 파이썬\ndef solution(n: int) -&gt; int:\n    answer: int = 0\n    for i in range(n):\n        answer += 1\n        while answer % 3 == 0 or '3' in str(answer):\n            answer += 1\n    return answer\n\n\n22.1.2 러스트\nfn solution(n: i32) -&gt; i32 {\n    let mut answer: i32 = 0;\n    for _ in 0..n {\n        answer += 1;\n        while answer % 3 == 0 || answer.to_string().contains('3') {\n            answer += 1;\n        }\n    }\n    answer\n}\n\nfn main() {\n    let n = 15;\n    let result = solution(n);\n    println!(\"solution({}) = {}\", n, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#평행",
    "href": "posts/qmd/learn_coding_basic.html#평행",
    "title": "코딩테스트 입문",
    "section": "22.2 평행",
    "text": "22.2 평행\n점 네 개의 좌표를 담은 이차원 배열 dots 가 다음과 같이 매개변수로 주어집니다. [[x1, y1], [x2, y2], [x3, y3], [x4, y4]] 주어진 네 개의 점을 두 개씩 이었을 때, 두 직선이 평행이 되는 경우가 있으면 1 을 없으면 0 을 return 하도록 solution 함수를 완성해보세요.\n\n22.2.1 파이썬\nfrom typing import List, Tuple\n\ndef gradient(arr1: Tuple[int, int], arr2: Tuple[int, int]) -&gt; float:\n    \"\"\"두 점 간의 기울기를 계산하는 함수\"\"\"\n    # 기울기 = (y2 - y1) / (x2 - x1)\n    return (arr2[1] - arr1[1]) / (arr2[0] - arr1[0])\n\ndef solution(dots: List[Tuple[int, int]]) -&gt; int:\n    \"\"\"주어진 네 개의 점이 이루는 두 직선이 평행한지 확인하는 함수\"\"\"\n    # 첫 번째와 두 번째 점, 세 번째와 네 번째 점을 이은 직선의 기울기를 비교\n    if gradient(dots[0], dots[1]) == gradient(dots[2], dots[3]):\n        return 1\n    # 첫 번째와 세 번째 점, 두 번째와 네 번째 점을 이은 직선의 기울기를 비교\n    elif gradient(dots[0], dots[2]) == gradient(dots[1], dots[3]):\n        return 1\n    # 첫 번째와 네 번째 점, 두 번째와 세 번째 점을 이은 직선의 기울기를 비교\n    elif gradient(dots[0], dots[3]) == gradient(dots[1], dots[2]):\n        return 1\n\n    # 어떤 경우에도 평행하지 않은 경우 0 반환\n    return 0\n\n\n22.2.2 러스트\ntype Point = (i32, i32);\n\nfn gradient(arr1: &Point, arr2: &Point) -&gt; f64 {\n    (arr2.1 - arr1.1) as f64 / (arr2.0 - arr1.0) as f64\n}\n\nfn solution(dots: &[Point]) -&gt; i32 {\n    if gradient(&dots[0], &dots[1]) == gradient(&dots[2], &dots[3]) {\n        1\n    } else if gradient(&dots[0], &dots[2]) == gradient(&dots[1], &dots[3]) {\n        1\n    } else if gradient(&dots[0], &dots[3]) == gradient(&dots[1], &dots[2]) {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let dots = [(1, 4), (9, 2), (3, 8), (11, 6)];\n    let result = solution(&dots);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#겹치는-선분의-길이",
    "href": "posts/qmd/learn_coding_basic.html#겹치는-선분의-길이",
    "title": "코딩테스트 입문",
    "section": "22.3 겹치는 선분의 길이",
    "text": "22.3 겹치는 선분의 길이\n선분 3 개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2 차원 배열 lines 가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요.\nlines 가 [[0, 2], [-3, -1], [-2, 1]] 일 때 선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1] 로 길이 2 만큼 겹쳐있습니다.\n\n22.3.1 파이썬\nfrom typing import List, Tuple\n\ndef solution(lines: List[Tuple[int, int]]) -&gt; int:\n    # 각 좌표에 대해 겹치는 선분의 수를 기록할 리스트 초기화\n    line_counts: List[int] = [0] * 201  # -100 to 100, total 201 positions\n\n    # 각 선분에 대해 시작점부터 끝점까지 겹치는 선분의 수를 증가\n    for start, end in lines:\n        for i in range(start + 100, end + 100):  # Shift by 100 to handle negative indices\n            line_counts[i] += 1\n\n    # 겹치는 선분의 수가 2 이상인 구간의 길이를 계산\n    overlap_length: int = sum(1 for count in line_counts if count &gt; 1)\n\n    return overlap_length\n\n\n22.3.2 러스트\nfn solution(lines: &[(i32, i32)]) -&gt; i32 {\n    let mut line_counts = [0; 201];  // -100 to 100, total 201 positions\n\n    for &(start, end) in lines {\n        for i in start + 100..end + 100 {\n            line_counts[i as usize] += 1;\n        }\n    }\n\n    line_counts.iter().filter(|&&count| count &gt; 1).count() as i32\n}\n\nfn main() {\n    let lines = vec![(-1, 1), (1, 3), (3, 9)];\n    let result = solution(&lines);\n    println!(\"Overlapping length: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#유한소수-판별하기",
    "href": "posts/qmd/learn_coding_basic.html#유한소수-판별하기",
    "title": "코딩테스트 입문",
    "section": "22.4 유한소수 판별하기",
    "text": "22.4 유한소수 판별하기\n소수점 아래 숫자가 계속되지 않고 유한개인 소수를 유한소수라고 합니다. 분수를 소수로 고칠 때 유한소수로 나타낼 수 있는 분수인지 판별하려고 합니다. 유한소수가 되기 위한 분수의 조건은 다음과 같습니다.\n\n기약분수로 나타내었을 때, 분모의 소인수가 2 와 5 만 존재해야 합니다.\n\n두 정수 a 와 b 가 매개변수로 주어질 때, a/b 가 유한소수이면 1 을, 무한소수라면 2 를 return 하도록 solution 함수를 완성해주세요.\n\n22.4.1 파이썬\ndef gcd(a: int, b: int) -&gt; int:\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solution(a: int, b: int) -&gt; int:\n    # 기약분수로 만들기\n    divisor: int = gcd(a, b)\n    b //= divisor\n\n    # 분모의 소인수 찾기\n    while b % 2 == 0:\n        b //= 2\n    while b % 5 == 0:\n        b //= 5\n\n    # 분모가 1이면 유한소수, 아니면 무한소수\n    return 1 if b == 1 else 2\n\n\n22.4.2 러스트\nfn gcd(mut a: i32, mut b: i32) -&gt; i32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn solution(mut a: i32, mut b: i32) -&gt; i32 {\n    // Simplify the fraction\n    let divisor = gcd(a, b);\n    b /= divisor;\n\n    // Find prime factors of the denominator\n    while b % 2 == 0 {\n        b /= 2;\n    }\n    while b % 5 == 0 {\n        b /= 5;\n    }\n\n    // If denominator is 1, it's a finite decimal, otherwise infinite\n    if b == 1 { 1 } else { 2 }\n}\n\nfn main() {\n    let a = 7;\n    let b = 20;\n    let result = solution(a, b);\n    println!(\"Result for {}/{}: {}\", a, b, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#특이한-정렬",
    "href": "posts/qmd/learn_coding_basic.html#특이한-정렬",
    "title": "코딩테스트 입문",
    "section": "23.1 특이한 정렬",
    "text": "23.1 특이한 정렬\n정수 n 을 기준으로 n 과 가까운 수부터 정렬하려고 합니다. 이때 n 으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치합니다. 정수가 담긴 배열 numlist 와 정수 n 이 주어질 때 numlist 의 원소를 n 으로부터 가까운 순서대로 정렬한 배열을 return 하도록 solution 함수를 완성해주세요.\n\n23.1.1 파이썬\nfrom typing import List\n\ndef solution(numlist: List[int], n: int) -&gt; List[int]:\n    return sorted(numlist, key=lambda x: (abs(x-n), -x))\n\n\n23.1.2 러스트\nfn solution(mut numlist: Vec&lt;i32&gt;, n: i32) -&gt; Vec&lt;i32&gt; {\n    numlist.sort_by(|a, b| {\n        let diff_a = (a - n).abs();\n        let diff_b = (b - n).abs();\n        diff_a.cmp(&diff_b).then(b.cmp(a))\n    });\n    numlist\n}\n\nfn main() {\n    let numlist = vec![1, 2, 3, 4, 5, 6];\n    let n = 4;\n    let result = solution(numlist, n);\n    println!(\"Sorted list: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#등수-매기기",
    "href": "posts/qmd/learn_coding_basic.html#등수-매기기",
    "title": "코딩테스트 입문",
    "section": "23.2 등수 매기기",
    "text": "23.2 등수 매기기\n영어 점수와 수학 점수의 평균 점수를 기준으로 학생들의 등수를 매기려고 합니다. 영어 점수와 수학 점수를 담은 2 차원 정수 배열 score 가 주어질 때, 영어 점수와 수학 점수의 평균을 기준으로 매긴 등수를 담은 배열을 return 하도록 solution 함수를 완성해주세요.\n\n23.2.1 파이썬\nfrom typing import List\n\ndef solution(score: List[List[int]]) -&gt; List[int]:\n    # 평균 점수 계산\n    averages: List[float] = [sum(s) / 2 for s in score]\n\n    # 평균 점수를 기준으로 내림차순 정렬한 리스트 생성\n    sorted_averages: List[float] = sorted(averages, reverse=True)\n\n    # 각 점수의 등수 계산\n    ranks: List[int] = [sorted_averages.index(avg) + 1 for avg in averages]\n\n    return ranks\n\n\n23.2.2 러스트\nfn solution(score: &Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    // 평균 점수 계산\n    let averages: Vec&lt;f64&gt; = score.iter()\n        .map(|s| s.iter().sum::&lt;i32&gt;() as f64 / 2.0)\n        .collect();\n\n    // Create a sorted list of averages in descending order\n    let mut sorted_averages = averages.clone();\n    sorted_averages.sort_by(|a, b| b.partial_cmp(a).unwrap());\n\n    // Calculate ranks for each score\n    averages.iter()\n        .map(|&avg| sorted_averages.iter().position(|&x| x == avg).unwrap() as i32 + 1)\n        .collect()\n}\n\nfn main() {\n    let score = vec![vec![80, 90], vec![70, 80], vec![90, 90]];\n    let result = solution(&score);\n    println!(\"Ranks: {:?}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#옹알이-1",
    "href": "posts/qmd/learn_coding_basic.html#옹알이-1",
    "title": "코딩테스트 입문",
    "section": "23.3 옹알이 (1)",
    "text": "23.3 옹알이 (1)\n머쓱이는 태어난 지 6 개월 된 조카를 돌보고 있습니다. 조카는 아직 “aya”, “ye”, “woo”, “ma” 네 가지 발음을 최대 한 번씩 사용해 조합한 (이어 붙인) 발음밖에 하지 못합니다. 문자열 배열 babbling 이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return 하도록 solution 함수를 완성해주세요.\n\n23.3.1 파이썬\nfrom typing import List\n\ndef solution(babbling: List[str]) -&gt; int:\n    possible: List[str] = [\"aya\", \"ye\", \"woo\", \"ma\"]\n    count: int = 0\n\n    for word in babbling:\n        temp: str = word\n        for sound in possible:\n            if sound in temp:\n                temp = temp.replace(sound, ' ', 1)\n        if temp.strip() == '':\n            count += 1\n\n    return count\n\n\n23.3.2 러스트\nfn solution(babbling: Vec&lt;String&gt;) -&gt; i32 {\n    let possible = vec![\"aya\", \"ye\", \"woo\", \"ma\"];\n    let mut count = 0;\n\n    for word in babbling {\n        let mut temp = word.clone();\n        for sound in &possible {\n            if temp.contains(sound) {\n                temp = temp.replacen(sound, \" \", 1);\n            }\n        }\n        if temp.trim().is_empty() {\n            count += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let babbling = vec![\n        \"aya\".to_string(),\n        \"yee\".to_string(),\n        \"u\".to_string(),\n        \"maa\".to_string(),\n    ];\n    let result = solution(babbling);\n    println!(\"Count of possible words: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#로그인-성공",
    "href": "posts/qmd/learn_coding_basic.html#로그인-성공",
    "title": "코딩테스트 입문",
    "section": "23.4 로그인 성공?",
    "text": "23.4 로그인 성공?\n머쓱이는 프로그래머스에 로그인하려고 합니다. 머쓱이가 입력한 아이디와 패스워드가 담긴 배열 id_pw 와 회원들의 정보가 담긴 2 차원 배열 db 가 주어질 때, 다음과 같이 로그인 성공, 실패에 따른 메시지를 return 하도록 solution 함수를 완성해주세요.\n\n아이디와 비밀번호가 모두 일치하는 회원정보가 있으면 “login”을 return 합니다.\n로그인이 실패했을 때 아이디가 일치하는 회원이 없다면 “fail”를, 아이디는 일치하지만 비밀번호가 일치하는 회원이 없다면 “wrong pw”를 return 합니다.\n\n\n23.4.1 파이썬\nfrom typing import List, Tuple\n\ndef solution(id_pw: Tuple[str, str], db: List[Tuple[str, str]]) -&gt; str:\n    id: str\n    pw: str\n    id, pw = id_pw\n    for db_id, db_pw in db:\n        if id == db_id:\n            if pw == db_pw:\n                return \"login\"\n            else:\n                return \"wrong pw\"\n    return \"fail\"\n\n\n23.4.2 러스트\nfn solution(id_pw: (String, String), db: Vec&lt;(String, String)&gt;) -&gt; String {\n    let (id, pw) = id_pw;\n    for (db_id, db_pw) in db {\n        if id == db_id {\n            if pw == db_pw {\n                return \"login\".to_string();\n            } else {\n                return \"wrong pw\".to_string();\n            }\n        }\n    }\n    \"fail\".to_string()\n}\n\nfn main() {\n    let id_pw = (\"programmer\".to_string(), \"111\".to_string());\n    let db = vec![\n        (\"programmer\".to_string(), \"111\".to_string()),\n        (\"coder\".to_string(), \"222\".to_string()),\n    ];\n    let result = solution(id_pw, db);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#치킨-쿠폰",
    "href": "posts/qmd/learn_coding_basic.html#치킨-쿠폰",
    "title": "코딩테스트 입문",
    "section": "24.1 치킨 쿠폰",
    "text": "24.1 치킨 쿠폰\n프로그래머스 치킨은 치킨을 시켜먹으면 한 마리당 쿠폰을 한 장 발급합니다. 쿠폰을 열 장 모으면 치킨을 한 마리 서비스로 받을 수 있고, 서비스 치킨에도 쿠폰이 발급됩니다. 시켜먹은 치킨의 수 chicken 이 매개변수로 주어질 때 받을 수 있는 최대 서비스 치킨의 수를 return 하도록 solution 함수를 완성해주세요.\n\n24.1.1 파이썬\ndef solution(chicken: int) -&gt; int:\n    service_chicken: int = 0\n    coupons: int = chicken\n\n    while coupons &gt;= 10:\n        new_chicken: int = coupons // 10\n        service_chicken += new_chicken\n        coupons = (coupons % 10) + new_chicken\n\n    return service_chicken\n\n\n24.1.2 러스트\nfn solution(chicken: i32) -&gt; i32 {\n    let mut service_chicken = 0;\n    let mut coupons = chicken;\n\n    while coupons &gt;= 10 {\n        let new_chicken = coupons / 10;\n        service_chicken += new_chicken;\n        coupons = (coupons % 10) + new_chicken;\n    }\n\n    service_chicken\n}\n\nfn main() {\n    let test_input = 1081;\n    let result = solution(test_input);\n    println!(\"Input: {}, Result: {}\", test_input, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#이진수-더하기",
    "href": "posts/qmd/learn_coding_basic.html#이진수-더하기",
    "title": "코딩테스트 입문",
    "section": "24.2 이진수 더하기",
    "text": "24.2 이진수 더하기\n이진수를 의미하는 두 개의 문자열 bin1 과 bin2 가 매개변수로 주어질 때, 두 이진수의 합을 return 하도록 solution 함수를 완성해주세요.\n\n24.2.1 파이썬\ndef solution(bin1: str, bin2: str) -&gt; str:\n    # 이진수 문자열을 10진수 정수로 변환\n    num1: int = int(bin1, 2)\n    num2: int = int(bin2, 2)\n\n    # 두 수를 더함\n    sum_num: int = num1 + num2\n\n    # 결과를 다시 이진수 문자열로 변환\n    return bin(sum_num)[2:]\n\n\n24.2.2 러스트\nfn solution(bin1: &str, bin2: &str) -&gt; String {\n    // 이진수 문자열을 10진수 정수로 변환\n    let num1 = u32::from_str_radix(bin1, 2).unwrap();\n    let num2 = u32::from_str_radix(bin2, 2).unwrap();\n\n    // 두 수를 더함\n    let sum_num = num1 + num2;\n\n    // 결과를 다시 이진수 문자열로 변환\n    format!(\"{:b}\", sum_num)\n}\n\nfn main() {\n    // Test case\n    let bin1 = \"1001\";\n    let bin2 = \"1111\";\n\n    let result = solution(bin1, bin2);\n\n    println!(\"Binary 1: {}\", bin1);\n    println!(\"Binary 2: {}\", bin2);\n    println!(\"Sum (binary): {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#a-로-b-만들기",
    "href": "posts/qmd/learn_coding_basic.html#a-로-b-만들기",
    "title": "코딩테스트 입문",
    "section": "24.3 A 로 B 만들기",
    "text": "24.3 A 로 B 만들기\n문자열 before 와 after 가 매개변수로 주어질 때, before 의 순서를 바꾸어 after 를 만들 수 있으면 1 을, 만들 수 없으면 0 을 return 하도록 solution 함수를 완성해보세요.\n\n24.3.1 파이썬\ndef solution(before: str, after: str) -&gt; int:\n    return 1 if sorted(before) == sorted(after) else 0\n\n\n24.3.2 러스트\nfn solution(bin1: &str, bin2: &str) -&gt; String {\n    // 이진수 문자열을 10진수 정수로 변환\n    let num1 = u32::from_str_radix(bin1, 2).unwrap();\n    let num2 = u32::from_str_radix(bin2, 2).unwrap();\n\n    // 두 수를 더함\n    let sum_num = num1 + num2;\n\n    // 결과를 다시 이진수 문자열로 변환\n    format!(\"{:b}\", sum_num)\n}\n\nfn main() {\n    // Test case\n    let bin1 = \"1001\";\n    let bin2 = \"1111\";\n\n    let result = solution(bin1, bin2);\n\n    println!(\"Binary 1: {}\", bin1);\n    println!(\"Binary 2: {}\", bin2);\n    println!(\"Sum (binary): {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#k-의-개수",
    "href": "posts/qmd/learn_coding_basic.html#k-의-개수",
    "title": "코딩테스트 입문",
    "section": "24.4 k 의 개수",
    "text": "24.4 k 의 개수\n1 부터 13 까지의 수에서, 1 은 1, 10, 11, 12, 13 이렇게 총 6 번 등장합니다. 정수 i, j, k 가 매개변수로 주어질 때, i 부터 j 까지 k 가 몇 번 등장하는지 return 하도록 solution 함수를 완성해주세요.\n\n24.4.1 파이썬\ndef solution(i: int, j: int, k: int) -&gt; int:\n    count = 0\n    for num in range(i, j + 1):\n        count += str(num).count(str(k))\n    return count\n\n\n24.4.2 러스트\nfn solution(i: i32, j: i32, k: i32) -&gt; i32 {\n    let mut count = 0;\n    for num in i..=j {\n        count += num.to_string().chars().filter(|&c| c == k.to_string().chars().next().unwrap()).count() as i32;\n    }\n    count\n}\n\nfn main() {\n    // Simple test\n    let result = solution(1, 13, 1);\n    println!(\"Result: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#문자열-밀기",
    "href": "posts/qmd/learn_coding_basic.html#문자열-밀기",
    "title": "코딩테스트 입문",
    "section": "25.1 문자열 밀기",
    "text": "25.1 문자열 밀기\n문자열 “hello”에서 각 문자를 오른쪽으로 한 칸씩 밀고 마지막 문자는 맨 앞으로 이동시키면 “ohell”이 됩니다. 이것을 문자열을 민다고 정의한다면 문자열 A 와 B 가 매개변수로 주어질 때, A 를 밀어서 B 가 될 수 있다면 밀어야 하는 최소 횟수를 return 하고 밀어서 B 가 될 수 없으면 -1 을 return 하도록 solution 함수를 완성해보세요.\n\n25.1.1 파이썬\ndef solution(A: str, B: str) -&gt; int:\n    if A == B:\n        return 0\n\n    for i in range(1, len(A)):\n        if A[-i:] + A[:-i] == B:\n            return i\n\n    return -1\n\n\n25.1.2 러스트\nfn solution(a: &str, b: &str) -&gt; i32 {\n    if a == b {\n        return 0;\n    }\n\n    for i in 1..a.len() {\n        if format!(\"{}{}\", &a[a.len()-i..], &a[..a.len()-i]) == b {\n            return i as i32;\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let result = solution(\"hello\", \"ollo\");\n    println!(\"solution = {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#종이-자르기",
    "href": "posts/qmd/learn_coding_basic.html#종이-자르기",
    "title": "코딩테스트 입문",
    "section": "25.2 종이 자르기",
    "text": "25.2 종이 자르기\n머쓱이는 큰 종이를 1 x 1 크기\b로 자르려고 합니다. 예를 들어 2 x 2 크기의 종이를 1 x 1 크기로 자르려면 최소 가위질 세 번이 필요합니다.\n\n25.2.1 파이썬\ndef solution(M: int, N: int) -&gt; int:\n    return M * N - 1 if M * N &gt; 0 else 0\n\n\n25.2.2 러스트\nfn solution(m: i32, n: i32) -&gt; i32 {\n    if m * n &gt; 0 {\n        m * n - 1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let result = solution(3, 4);\n    println!(\"solution = {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#연속된-수의-합",
    "href": "posts/qmd/learn_coding_basic.html#연속된-수의-합",
    "title": "코딩테스트 입문",
    "section": "25.3 연속된 수의 합",
    "text": "25.3 연속된 수의 합\n연속된 세 개의 정수를 더해 12 가 되는 경우는 3, 4, 5 입니다. 두 정수 num 과 total 이 주어집니다. 연속된 수 num 개를 더한 값이 total 이 될 때, 정수 배열을 오름차순으로 담아 return 하도록 solution 함수를 완성해보세요.\n\n25.3.1 파이썬\nfrom typing import List\n\ndef solution(num: int, total: int) -&gt; List[int]:\n    # 연속된 수의 시작값 계산\n    start = (total - sum(range(num))) // num\n\n    # 시작값부터 num개의 연속된 수 리스트 생성\n    return list(range(start, start + num))\n\n\n25.3.2 러스트\nfn solution(num: i32, total: i32) -&gt; Vec&lt;i32&gt; {\n    let start = (total - (0..num).sum::&lt;i32&gt;()) / num;\n    (start..start + num).collect()\n}\n\nfn main() {\n    let num = 3;\n    let total = 12;\n    let result = solution(num, total);\n    println!(\"solution({}, {}) = {:?}\", num, total, result);\n}"
  },
  {
    "objectID": "posts/qmd/learn_coding_basic.html#다음에-올-숫자",
    "href": "posts/qmd/learn_coding_basic.html#다음에-올-숫자",
    "title": "코딩테스트 입문",
    "section": "25.4 다음에 올 숫자",
    "text": "25.4 다음에 올 숫자\n등차수열 혹은 등비수열 common 이 매개변수로 주어질 때, 마지막 원소 다음으로 올 숫자를 return 하도록 solution 함수를 완성해보세요.\n\n25.4.1 파이썬\nfrom typing import List\n\ndef solution(common: List[int]) -&gt; int:\n    if common[1] - common[0] == common[2] - common[1]:\n        # 등차수열인 경우\n        diff = common[1] - common[0]\n        return common[-1] + diff\n    else:\n        # 등비수열인 경우\n        ratio = common[1] / common[0]\n        return int(common[-1] * ratio)\n\n\n25.4.2 러스트\nfn solution(common: Vec&lt;i32&gt;) -&gt; i32 {\n    if common[1] - common[0] == common[2] - common[1] {\n        // Arithmetic sequence\n        let diff = common[1] - common[0];\n        common[common.len() - 1] + diff\n    } else {\n        // Geometric sequence\n        let ratio = common[1] as f64 / common[0] as f64;\n        (common[common.len() - 1] as f64 * ratio).round() as i32\n    }\n}\n\nfn main() {\n    let sequence = vec![1, 2, 3, 4];\n    let result = solution(sequence);\n    println!(\"Next number in the sequence: {}\", result);\n}"
  },
  {
    "objectID": "posts/qmd/guide_start_doing.html",
    "href": "posts/qmd/guide_start_doing.html",
    "title": "미루기를 멈추기 위한 간단한 방법들",
    "section": "",
    "text": "미루는 습관을 완전히 없애려고 처음부터 너무 애쓰기보다는 새로운 습관에 익숙해지듯 차근차근 그 정도를 줄여나가는 것이 효과적입니다. 마치 단숨에 높은 벽을 넘을 수 없듯이 오랫동안 굳어진 습관을 바꾸는 데에도 섬세한 접근 방식이 필요합니다. 다음은 미루는 습관을 극복하고 행동력을 키우는 데 도움이 되는 방법들입니다.\n\n막연하고 포괄적인 목표 대신 관찰 가능하고 구체적인 행동 목표를 설정하세요.\n\n“나는 미루는 습관을 멈추고 싶다.” ❌\n“나는 9월 1일까지 차고를 정리하고 정돈하고 싶다.” ✅\n\n현실적인 목표를 설정하세요. 거창한 목표보다는 작은 목표를 생각하고, 이상적인 목표보다는 최소한으로 수용 가능한 목표를 선택하세요. 그리고 한 번에 하나의 목표에만 집중하세요!\n\n“나는 다시는 미루지 않을 거야!” ❌\n“나는 매일 수학 공부에 한 시간씩 투자할 거야.” ✅\n\n목표를 작고 구체적인 하위 목표로 나누세요. 각 하위 목표는 큰 목표보다 달성하기 쉽습니다.\n\n“나는 보고서를 쓸 거야.” ❌\n“오늘 밤에는 스프레드시트 계획을 세우는 데 30분을 쓸 거야. 내일은 데이터를 입력하는 데 30분을 쓰고, 그다음 날에는 그 데이터를 바탕으로 보고서를 쓰는 데 한 시간을 쓸 거야.” ✅\n\n시간에 대해 (희망적으로 생각하기보다는) 현실적으로 생각하세요. 스스로에게 물어보세요: 그 작업에 실제로 얼마나 많은 시간이 걸릴까? 내가 실제로 사용할 수 있는 시간은 얼마나 될까?\n\n“내일은 시간이 충분해.” ❌\n“언제 시작할 수 있는지 달력을 확인하는 게 좋겠어. 지난번에는 생각보다 오래 걸렸어.” ✅\n\n일단 시작하세요! 전체 프로젝트를 한 번에 끝내려고 하지 말고 “천 리 길도 한 걸음부터.”를 기억하세요.\n\n“한 번에 다 끝내야 해.” ❌\n“내가 취할 수 있는 첫 번째 작은 단계는 무엇일까?” ✅\n\n포모도로 기법을 활용하세요. 타이머를 25분 동안 맞춰놓고 작업에 집중하세요.\n\n“겨우 25분밖에 없는데, 뭘 해.” ❌\n“다음 25분 동안 이 작업의 어떤 부분을 할 수 있을까?” ✅\n\n장애물과 일정 지연을 예상하세요. 첫 번째 (또는 두 번째, 세 번째) 장애물에 부딪히자마자 포기하지 마세요. 장애물은 해결해야 할 문제일 뿐 당신의 가치나 능력에 대한 반영이 아닙니다.\n\n“교수님이 연구실에 안 계시니, 논문을 쓸 수 없어. 영화나 보러 가야겠다.” ❌\n“교수님이 안 계시더라도, 돌아오실 때까지 개요를 작성할 수 있어.” ✅\n\n가능하다면 그 작업을 위임하거나 하지마세요! 정말 당신만이 이 일을 할 수 있는 유일한 사람인지, 정말로 반드시 해야 할 일인지를 생각해보세요. 아무도 모든 것을 다 할 수는 없다는 것을 기억하세요.\n\n“이 일을 정확하게 할 수 있는 사람은 나밖에 없어.” ❌\n“더 중요한 프로젝트를 위해 이 작업을 맡길 적임자를 찾아볼 거야.” ✅\n\n당신의 시간을 보호하세요. 거절하는 법을 배우세요. 불필요하거나 추가적인 프로젝트를 맡지 마세요. 중요한 일에 집중하기 위해 “긴급한” 일에 응답하지 않도록 해야 합니다.\n\n“나를 필요로 하는 사람은 누구든 도와줘야 해.” ❌\n“일하는 동안에는 전화를 받을 필요가 없어. 메시지를 확인하고 나중에 일이 끝나면 다시 전화할게.” ✅\n\n당신의 변명을 미루는 이유로 사용하지 말고 신호로 사용하세요. 또는 어떤 업무를 완료한 것에 대한 보상으로 사용하세요.\n\n“피곤해 (우울해/배고파/바빠/혼란스러워 등등). 나중에 할 거야.” ❌\n“피곤하니까, 보고서 작업에 25분만 투자할 거야. 그러고 나서 낮잠을 자야겠다.” ✅\n\n결과보다는 노력에 집중하세요. 진행 상황에 따라 조금씩 보상하세요. 작은 진전이라도 진전된 것입니다!\n\n“다 끝낼 때까지 기분이 좋을 수 없어.” ❌\n“몇 단계를 거쳤고 열심히 일했어. 기분이 좋다. 이제 영화를 봐야겠다.” ✅\n\n당신의 미루는 행동을 신호로 활용하세요. 멈추고 스스로에게 물어보세요: “나의 미루는 행동은 나에게 어떤 메시지를 보내고 있는 걸까?”\n\n“또 미루고 있어. 내가 정말 싫어.” ❌\n“또 미루고 있네. 지금 어떤 기분이 들지? 이건 뭘 의미하는 걸까? 뭘 배울 수 있을까?” ✅\n\n\n다음을 기억하세요.\n\n당신에게는 선택권이 있습니다. 미룰 수도 있고, 행동할 수도 있습니다.\n과거의 잘못이 현재 당신을 통제할 필요는 없습니다.\n배우고 성장하고 스스로에게 도전하는 삶이 즐거움을 줍니다.\n완벽할 필요는 없습니다.\n\n출처\n\nJane B. Burka and Lenora M. Yuen, PROCRASTINATION, Why You Do It, What to Do About It Now, Da Capo Press, 2008"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html",
    "href": "posts/qmd/setup_pixi.html",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "",
    "text": "파이썬 의존성 문제는 프로젝트가 의존하는 패키지 간 충돌, 버전 관리의 어려움, 시스템 환경에 따른 호환성 문제 등으로 나타납니다. 다음과 같은 상황에서 의존성 지옥이 발생할 수 있습니다.\n의존성 지옥을 피하려면 파이썬 의존성 관리 도구를 활용하여 각 프로젝트의 의존성을 격리해서 관리해야 합니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#프로젝트-시작하기",
    "href": "posts/qmd/setup_pixi.html#프로젝트-시작하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "5.1 프로젝트 시작하기",
    "text": "5.1 프로젝트 시작하기\n새 프로젝트를 시작할 때는 다음 명령어를 사용합니다. --format pyproject 옵션을 생략하면 pyproject.toml 대신 pixi.toml 파일이 생성됩니다.\npixi init --format pyproject hello-world\ncd hello-world\n명령어를 실행하면 다음과 같은 파일 구조가 생성됩니다.\n.\n├── pyproject.toml\n└── src\n    └── hello_world\n        └── __init__.py\n\n3 directories, 2 files\npyproject.toml 파일에 의존성 정보가 저장되며, 내용은 다음과 같습니다.\n[project]\nauthors = [{name = \"NAME\", email = \"EMAIL\"}]\ndependencies = []\nname = \"hello-world\"\nrequires-python = \"&gt;= 3.11\"\nversion = \"0.1.0\"\n\n[build-system]\nbuild-backend = \"hatchling.build\"\nrequires = [\"hatchling\"]\n\n[tool.pixi.workspace]\nchannels = [\"conda-forge\"]\nplatforms = [\"osx-arm64\"]\n\n[tool.pixi.pypi-dependencies]\nhello_world = { path = \".\", editable = true }"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#의존성-추가",
    "href": "posts/qmd/setup_pixi.html#의존성-추가",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "5.2 의존성 추가",
    "text": "5.2 의존성 추가\n의존성을 추가할 때 가장 먼저 해야 할 작업은 파이썬 버전을 지정하는 것입니다. pixi는 자체적으로 Python 버전 설치를 지원합니다. 다음 pixi add 명령어를 사용하세요.\npixi add python==3.10\n위 명령어를 실행하면 숨겨진 폴더(.pixi)와 pixi.lock 파일이 생성됩니다. .pixi 폴더는 설치된 패키지들이 저장되는 곳이고, pixi.lock 파일은 현재 프로젝트의 종속성 및 버전을 정확하게 기록한 파일입니다.\n\n\n\n\n\n\nNote\n\n\n\npixi.lock 파일은 pixi add를 실행하거나 toml 파일을 수동으로 변경한 뒤 pixi install을 실행할 때 자동으로 생성됩니다.\n\n\n다른 원하는 패키지를 설치할 때도 pixi add 명령어를 사용할 수 있습니다. 항상 Prefix.dev에서 지원되는 패키지를 검색하고 명령어를 확인하세요.\n\n5.2.1 채널 추가하기\npixi는 기본적으로 conda-forge를 기본 패키지 채널로 사용합니다. conda-forge에 원하는 패키지가 없는 경우 다음과 같이 다른 채널을 추가할 수 있습니다.\npixi project channel add bioconda\nAdded bioconda (https://conda.anaconda.org/bioconda/)\n\npixi add anndata2ri\nAdded anndata2ri\n\n\n\n\n\n\nTip\n\n\n\n아직 패키지별로 채널을 선택하여 설치하는 명령어는 없는 것으로 보입니다. 따라서 당분간은 위의 명령어를 사용해야 합니다.\n\n\n\n\n5.2.2 PyPI 의존성 추가\nPrefix.dev에서 찾을 수 없는 파이썬 패키지의 경우 pixi add --pypi [패키지이름] 명령으로 설치할 수 있습니다.\n\n\n\n\n\n\nWarning\n\n\n\n현재 이 기능은 베타 버전입니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#패키지-설치하기",
    "href": "posts/qmd/setup_pixi.html#패키지-설치하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "5.3 패키지 설치하기",
    "text": "5.3 패키지 설치하기\npixi add 명령어는 기본적으로 pixi.toml 파일에 패키지 이름을 추가하는 역할을 하며, 동시에 pixi.lock 파일도 업데이트합니다. 만약 업데이트되지 않았다면 pixi install 명령어를 사용하여 업데이트와 설치를 동시에 진행할 수 있습니다. 습관적으로 사용하는 것을 권장합니다.\npixi install"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#패키지-삭제하기",
    "href": "posts/qmd/setup_pixi.html#패키지-삭제하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "5.4 패키지 삭제하기",
    "text": "5.4 패키지 삭제하기\n설치한 패키지를 삭제하는 방법은 두 가지입니다. 두 번째 방법이 작동하지 않으면 첫 번째 방법을 시도해 보세요.\n\npixi.toml 파일을 수정하고 pixi install 명령어를 입력합니다.\npixi remove [패키지] 명령어를 사용합니다.\n\n\n\n\n\n\n\nNote\n\n\n\nPyPI로 설치한 패키지는 pixi remove --pypi [패키지] 명령으로 삭제할 수 있습니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#실행하기",
    "href": "posts/qmd/setup_pixi.html#실행하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "5.5 실행하기",
    "text": "5.5 실행하기\n\n5.5.1 Shell 실행\npixi shell\n\n\n5.5.2 명령어 실행\npixi run [명령어] 형식으로 실행합니다.\npixi run python --version\nPython 3.10.0"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#toml-파일-저장하기",
    "href": "posts/qmd/setup_pixi.html#toml-파일-저장하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "6.1 toml 파일 저장하기",
    "text": "6.1 toml 파일 저장하기\npixi는 기본적으로 모든 의존성 정보를 toml 파일에 저장하므로, pixi install 명령어를 실행하면 자동으로 파일이 생성됩니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#yml-파일로-의존성-저장하기",
    "href": "posts/qmd/setup_pixi.html#yml-파일로-의존성-저장하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "6.2 yml 파일로 의존성 저장하기",
    "text": "6.2 yml 파일로 의존성 저장하기\n아직 명령어로 직접 지원하지 않지만, 다음과 같이 conda 명령어를 통해 우회할 수 있습니다.\npixi run conda env export -f env.yml"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#가상-환경-삭제",
    "href": "posts/qmd/setup_pixi.html#가상-환경-삭제",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "6.3 가상 환경 삭제",
    "text": "6.3 가상 환경 삭제\n아직 명령어로 직접 지원하지 않습니다. 프로젝트 폴더 전체를 삭제하거나 pixi 관련 파일을 삭제하는 방법으로 우회합니다.\nrm -rf .pixi\nrm pixi.toml\nrm pixi.lock"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#requirements.txt-파일에서-의존성-가져오기",
    "href": "posts/qmd/setup_pixi.html#requirements.txt-파일에서-의존성-가져오기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "8.1 requirements.txt 파일에서 의존성 가져오기",
    "text": "8.1 requirements.txt 파일에서 의존성 가져오기\npixi add --pypi $(cat requirements.txt)"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#yml-파일에서-의존성-불러오기",
    "href": "posts/qmd/setup_pixi.html#yml-파일에서-의존성-불러오기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "8.2 .yml 파일에서 의존성 불러오기",
    "text": "8.2 .yml 파일에서 의존성 불러오기\npixi init --import environment.yml\n위 명령어를 사용하면 종속성이 포함된 toml 파일이 생성됩니다. 다만 pip 패키지의 종속성 중 git+URL 형식은 지원하지 않으므로 직접 추가해야 합니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#cuda11과-cuda12-환경-구현하기",
    "href": "posts/qmd/setup_pixi.html#cuda11과-cuda12-환경-구현하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "9.1 Cuda11과 Cuda12 환경 구현하기",
    "text": "9.1 Cuda11과 Cuda12 환경 구현하기\nCLI 명령어보다는 직접 toml 파일을 수정하는 것이 더 쉽습니다. 아래 예시처럼 수정하세요.\n[project]\nauthors = [{name = \"NAME\", email = \"EMAIL\"}]\ndependencies = []\nname = \"hello-world\"\nrequires-python = \"&gt;= 3.11\"\nversion = \"0.1.0\"\n\n[build-system]\nbuild-backend = \"hatchling.build\"\nrequires = [\"hatchling\"]\n\n[tool.pixi.workspace]\nchannels = [\"conda-forge\"]\nplatforms = [\"osx-arm64\"]\n\n[tool.pixi.pypi-dependencies]\nhello_world = { path = \".\", editable = true }\n\n[tool.pixi.environments]\ncuda11 = [\"cuda11\"]\ncuda12 = [\"cuda12\"]\ndefault = [\"cuda11\"]\n\n[tool.pixi.feature.cuda11.system-requirements]\ncuda = \"11.0\"\n\n[tool.pixi.feature.cuda11.dependencies]\ncuda-version = \"~=11.8\"\n\n[tool.pixi.feature.cuda12.system-requirements]\ncuda = \"12.0\"\n\n[tool.pixi.feature.cuda12.dependencies]\ncuda-version = \"~=12.0\"\ndefault = [\"cuda11\"]로 지정했기 때문에 -e 옵션 없이 실행하면 cuda11 feature가 사용됩니다."
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#다중-환경에-의존성-추가하기",
    "href": "posts/qmd/setup_pixi.html#다중-환경에-의존성-추가하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "9.2 다중 환경에 의존성 추가하기",
    "text": "9.2 다중 환경에 의존성 추가하기\n특정 환경에만 의존성을 추가하려면 pixi add 명령어에 -f [feature 이름] 옵션을 추가해야 합니다. 그렇지 않으면 모든 환경에 의존성이 추가됩니다.\npixi add -f cuda12 pandas"
  },
  {
    "objectID": "posts/qmd/setup_pixi.html#다중-환경에서-실행하기",
    "href": "posts/qmd/setup_pixi.html#다중-환경에서-실행하기",
    "title": "의존성 지옥에 빠진 당신을 구하러 온 Pixi",
    "section": "9.3 다중 환경에서 실행하기",
    "text": "9.3 다중 환경에서 실행하기\n특정 환경을 실행하려면 pixi run 명령어에 -e [feature 이름] 옵션을 추가 사용해야 합니다.\npixi run -e cuda12 python"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html",
    "href": "posts/qmd/guide_Quarto_blog.html",
    "title": "쿼토로 시작하는 블로그",
    "section": "",
    "text": "블로그는 많은 이유로 훌륭한 글쓰기 도구입니다. 그리고 쿼토(Quarto)는 몇번의 클릭만으로 블로그를 만들 수 있습니다. 게다가 커스터마이징이 쉽기도 합니다. 이 글은 쿼토를 이용한 블로그 만들기 가이드로 여러분의 소중한 시간을 절약하고 멋진 블로그를 시작하는 데 도움을 주기 위해 작성되었습니다.1"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#당신이-블로그를-해야하는-이유",
    "href": "posts/qmd/guide_Quarto_blog.html#당신이-블로그를-해야하는-이유",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.1 당신이 블로그를 해야하는 이유",
    "text": "1.1 당신이 블로그를 해야하는 이유\n블로그를 시작하는 이유가 명확하지 않다면 몇 가지 예시를 제공하겠습니다.\n\n배우기: 글쓰기는 얕은 지식을 막아줍니다. 블로그 글을 작성하는 과정에서 종종 제가 틀렸다는 사실을 깨닫곤 합니다. 글쓰기가 효과적인 학습 도구인 이유가 바로 이 때문이죠.\n다른 사람에 도움주기: 자기가 아는 것을 공유하면서 비슷한 문제에 봉착한 다른 이들을 도와줄 수 있습니다. 전문가가 아니더라도 걱정하지는 마세요. 사실 사람들은 보통 전문가보다는 다른 학습자, 즉 자신보다 단계만 조금 앞선 사람에게서 배우는 것을 더 선호합니다. 왜냐하면 전문가들은 초심자들이 겪는 어려움을 간과하는 경향이 있기 때문이죠.\n포트폴리오 및 취업 기회: 인터넷에 콘텐츠를 게시하면 누구든지 볼 수 있습니다. 이는 자신의 기술을 과시하는 데 유용합니다. 또한 개인적인 경험을 이야기하자면 공개적으로 글을 쓰는 것은 새로운 직업 기회로 연결될 수도 있습니다. 누가 당신의 블로그를 읽고 함께 일하기를 원할 수도 있으니까요."
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#블로그-초기-설정하기",
    "href": "posts/qmd/guide_Quarto_blog.html#블로그-초기-설정하기",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.2 블로그 초기 설정하기",
    "text": "1.2 블로그 초기 설정하기\n쿼토를 로컬에 설치했다면 블로그를 만드는 것은 정말 간단합니다. 터미널에 다음 입력어를 입력합니다.\nquarto create-project myblog --type website:blog\n더 자세한 것은 Beatriz Milz가 작성한 10 단계로 쿼토 블로그를 시작하는 방법을 참고하세요."
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#간단한-설정하기",
    "href": "posts/qmd/guide_Quarto_blog.html#간단한-설정하기",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.3 간단한 설정하기",
    "text": "1.3 간단한 설정하기\n루트 폴더에 있는 _quarto.yml 파일에는 쿼토 블로그에 대한 여러가지 설정이 존재합니다. 아래 예시 파일을 참고하세요.\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  title: \"Quarto blog\" # 블로그 제목 설정\n  site-url: https://quarto-blog.com # 블로그 URL 설정 (나중에 RSS 피드에 중요)\n  description: \"This is personal Blog.\" # 블로그 설명\n  navbar: # 메뉴바 설정\n    right:\n      - text: Blog\n        href: index.qmd \n      - icon: github\n        href: https://github.com/[xxxx]\n      - icon: twitter\n        href: https://twitter.com/[xxx]\n      - icon: youtube\n        href: https://www.youtube.com/user/[xxx]\n\n# You can ignore this part in the first step\n      - icon: rss\n        href: blog.xml\n      - text: Ressources\n        menu: \n          - text: DataViz Portfolio\n            href: dataviz_portfolio.html\n          - text: YARDS\n            href: https://yards.albert-rapp.de/\n          - text: R Weekly\n            href: https://rweekly.org/\n          - text: R Bloggers\n            href: https://www.r-bloggers.com/\n      - text: Archive\n        href: archive.qmd\n  google-analytics: &lt;Insert your ID here&gt;\n  cookie-consent: true\n  twitter-card: \n    image: thumbnail_blog.png\n    card-style: summary_large_image\n    creator: \"@rappa753\"\n\nfilters:\n  - code-filename\n\n\nformat:\n  html:\n    theme: theme.scss"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#첫-번째-게시물-쓰기",
    "href": "posts/qmd/guide_Quarto_blog.html#첫-번째-게시물-쓰기",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.4 첫 번째 게시물 쓰기",
    "text": "1.4 첫 번째 게시물 쓰기\n블로그 게시물은 posts 디렉토리에 파일을 생성해서 만듭니다. 간단하게 qmd 파일을 만들어 시작해보세요.\n\n1.4.1 메타데이터\n게시물에 대한 설정에 대한 것은 posts/_metadata.yml 파일이 처리합니다. 제가 사용하는 설정은 아래 파일을 참고하세요.\n\n\nposts/_metadata.yml\n\n# Options specified here will apply to all posts in this folder\n\n# freeze computational output\nfreeze: true\n\n# Enable banner style title blocks\ntitle-block-banner: false\n\n# Author name of all blog posts\nauthor: 'Albert Rapp'\n\n# Table of content settings\ntoc: true\ntoc-depth: 3\n\npage-layout: article"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#목록-페이지-rss-피드-포함",
    "href": "posts/qmd/guide_Quarto_blog.html#목록-페이지-rss-피드-포함",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.5 목록 페이지 (RSS 피드 포함)",
    "text": "1.5 목록 페이지 (RSS 피드 포함)\n블로그 글에 대한 목록 페이지를 만들어보죠. blog.qmd 파일을 만들고 YAML 헤더에다음과 같이 작성합니다.\n\n\nblog.qmd\n\n---\nlisting:\n  contents: posts/**/*.qmd # posts 디렉토리 (및 하위 디렉토리) 에 있는 모든 .qmd 파일을 이 목록 페이지에 포함한다는 의미\n  sort: \"date desc\" # 날짜순으로 정렬 및 필터링 기능\n  type: default \n  categories: true\n  sort-ui: true\n  filter-ui: true\n  fields: [date, title, reading-time, description, categories] # 자세한 것은 쿼토 공식 페이지를 참조\n  feed: true # 이 목록 페이지가 RSS 페이지를 생성\npage-layout: full\ntitle-block-banner: false # 배너를 보여주지 않음\n---"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#아카이브-만들기",
    "href": "posts/qmd/guide_Quarto_blog.html#아카이브-만들기",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.6 아카이브 만들기",
    "text": "1.6 아카이브 만들기\n모든 글을 나열하는 아카이브 페이지도 만들어 보겠습니다. 루트 디렉토리에 새로운 파일 archive.qmd 를 만들고 다음과 같은 내용을 채웠습니다.\n\n\narchive.qmd\n\n---\ntitle: \"Archive\"\npage-layout: full # 좌우 여백을 제거\nlisting:\n  contents: posts/**/*.qmd\n  type: default\n  fields: [date, title]\n  sort: 'date desc'\n---"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#댓글-기능-추가하기",
    "href": "posts/qmd/guide_Quarto_blog.html#댓글-기능-추가하기",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.7 댓글 기능 추가하기",
    "text": "1.7 댓글 기능 추가하기\n이제 댓글 기능을 추가해 보겠습니다. 이 기능을 통해 독자들은 훌륭한 콘텐츠에 대한 댓글을 달 수 있습니다. 제가 주로 사용하는 도구는 utterances 입니다. 이 도구는 GitHub 를 통해 작동하기 때문에 GitHub 에서 별도의 공개 저장소를 만들어야 합니다. 이 저장소는 블로그의 댓글을 저장하는 공간이 될 것입니다. 하지만 먼저 새로 생성한 저장소에 utterances 를 설치해야 합니다. 설치 방법은 공식 페이지를 참고하세요.\n블로그 게시글 하단에만 댓글을 보여주기 위해 posts/_metadata.yml파일에 아래 내용을 추가합니다.\n\n\nposts/_metadata.yml\n\ncomments: \n  utterances: \n    repo:  [repo]/blogComments"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#뉴스레터",
    "href": "posts/qmd/guide_Quarto_blog.html#뉴스레터",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.8 뉴스레터",
    "text": "1.8 뉴스레터\n정기적으로 구독자에게 새로운 콘텐츠 알림을 주기 위해서 뉴스레터를 발송하기 위해 서비스 제공 업체들의 코드를 원하는 위치에 배치하세요.\n&lt;iframe id=\"beehiiv-form\" src=\"https://embeds.beehiiv.com/9232d2a2-6e85-4beb-b8ed-1de94e9e4f01?slim=true\" data-test-id=\"beehiiv-embed\" frameborder=\"0\" scrolling=\"no\" style=\"margin: 0; border-radius: 0px !important; background-color: transparent; height: 75px; width: 90%;\"&gt;&lt;/iframe&gt;\n블로그 목록 페이지 상단에 해당 코드를 추가하는 방법은 아래와 같습니다.\n\n\nblog.qmd\n\n---\nlisting:\n  contents: posts/**/*.qmd\n  sort: \"date desc\"\n  type: default\n  categories: true\n  sort-ui: true\n  filter-ui: true\n  fields: [date, title, reading-time, description, categories]\n  feed: true\npage-layout: full\ntitle-block-banner: false\n---\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n# Series\n##### [ggplot2-series](ggplot-series.html)\nThis series contains a great deal of tips, tricks and packages \nthat you can use to level up your ggplot game.\n:::\n\n::: {.column width=\"60%\"}\n# Subscribe\n&lt;iframe id=\"beehiiv-form\" src=\"https://embeds.beehiiv.com/9232d2a2-6e85-4beb-b8ed-1de94e9e4f01?slim=true\" data-test-id=\"beehiiv-embed\" frameborder=\"0\" scrolling=\"no\" style=\"margin: 0; border-radius: 0px !important; background-color: transparent; height: 75px; width: 90%;\"&gt;&lt;/iframe&gt;\n:::\n\n::::"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#바닥글-추가",
    "href": "posts/qmd/guide_Quarto_blog.html#바닥글-추가",
    "title": "쿼토로 시작하는 블로그",
    "section": "1.9 바닥글 추가",
    "text": "1.9 바닥글 추가\n\n\nposts/_metadata.yml\n\nformat:\n  html:\n    include-after-body: ../footer.html"
  },
  {
    "objectID": "posts/qmd/guide_Quarto_blog.html#footnotes",
    "href": "posts/qmd/guide_Quarto_blog.html#footnotes",
    "title": "쿼토로 시작하는 블로그",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://albert-rapp.de/posts/13_quarto_blog_writing_guide/13_quarto_blog_writing_guide.html#create-your-own-series↩︎"
  },
  {
    "objectID": "books/Bioinfo_algorithm.html",
    "href": "books/Bioinfo_algorithm.html",
    "title": "생명정보학 알고리즘",
    "section": "",
    "text": "파이썬으로 구현하는 생명정보학 알고리즘\n\n1 목차\n\n1장. 서문\n\n1.1 들어가며\n1.2 생명정보학이란?\n1.3 책의 구성\n\n2장. 파이썬 소개\n\n2.1 파이썬의 특징\n2.2 변수와 미리 정의된 함수\n2.3 파이썬 코드 작성하기\n2.4 파이썬 프로그램 개발\n2.5 객체지향 프로그래밍\n2.6 사전 정의된 클래스 및 메서드\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n3장. 세포 및 분자생물학의 기초\n\n3.1 세포: 생명의 기본 단위\n3.2 유전자 정보: 핵산\n3.3 유전자: 유전 정보의 이산 단위\n3.4 인간 유전체\n3.5 생물 자원 및 데이터베이스\n참고 문헌과 추가 자료\n연습 문제\n\n4장. 생물학적 서열의 기본적 처리\n\n4.1 생물학적 서열: 표현과 기본 알고리즘\n4.2 전사와 역상보\n4.3 번역\n4.4 가능성 있는 유전자 찾기: 오픈 리딩 프레임\n4.5 하나로 합체\n4.6 생물학 서열의 클래스\n4.7 바이오파이썬으로 서열 처리\n4.8 바이오파이썬의 서열 주석 객체\n연습 문제와 프로그래밍 프로젝트\n\n5장. 서열 데이터에서 패턴 찾기\n\n5.1 소개: 생명정보학에서 패턴 찾기의 중요성\n5.2 고정된 패턴을 찾는 단순한 알고리즘\n5.3 휴리스틱 알고리즘: 보이어-무어\n5.4 결정적 유한 오토마타\n5.5 정규표현식으로 유연한 패턴 찾기\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n6장. 쌍 서열 정렬\n\n6.1 소개: 서열 비교와 서열 정렬\n6.2 시각화 정렬: 점 도표\n6.3 서열 정렬의 최적화 문제\n6.4 전역 정렬을 위한 동적 프로그래밍 알고리즘\n6.5 지역 정렬을 위한 동적 프로그래밍 알고리즘\n6.6 서열 정렬의 특별한 경우\n6.7 바이오파이썬을 활용한 쌍 서열 정렬\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n7장. 데이터베이스에서 유사한 서열 찾기\n\n7.1 소개\n7.2 BLAST 알고리즘과 프로그램\n7.3 구현한 BLAST 이식\n7.4 바이오파이썬을 통한 BLAST 사용\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n8장. 다중 서열 정렬\n\n8.1 소개: 문제 정의와 복잡도\n8.2 다중 서열 정렬의 알고리즘 최적화 클래스\n8.3 점진적 정렬을 파이썬에서 구현\n8.4 바이오파이썬으로 정렬 다루기\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n9장. 계통학 분석\n\n9.1 소개: 문제 정의 및 연관성\n9.2 계통학적 분석을 위한 알고리즘 클래스\n9.3 파이썬으로 거리 기반 알고리즘 구현\n9.4 계통학 분석을 위한 바이오파이썬\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n10장. 모티프 발견 알고리즘\n\n10.1 소개: 문제 정의와 관련성\n10.2 브루트 포스 알고리즘: 완전 탐색\n10.3 분기 및 경계 알고리즘\n10.4 휴리스틱 알고리즘\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n11장. 확률적 모티프와 알고리즘\n\n11.1 확률 모티프 표현 및 검색\n11.2 확률 알고리즘: 기댓값 최대화\n11.3 모티프 발견을 위한 깁스 샘플링\n11.4 바이오파이썬의 확률 모티프\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n12장. 은닉 마르코프 모델\n\n12.1 소개: 은닉 마르코프 모델이란 무엇인가?\n12.2 파이썬으로 알고리즘 구현\n12.3 데이터베이스 검색을 위한 은닉 마르코프 모델\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n13장. 그래프: 개념과 알고리즘\n\n13.1 그래프: 정의와 표현\n13.2 파이썬 클래스 그래프\n13.3 인접 노드와 차수\n13.4 경로, 탐색, 거리\n13.5 사이클\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n14장. 그래프와 생물학적 네트워크\n\n14.1 소개\n14.2 네트워크를 그래프로 표현\n14.3 네트워크 위상 분석\n14.4 대사작용 가능성 평가\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n15장. 게놈으로 리드 어셈블리: 그래프 기반 알고리즘\n\n15.1 게놈 어셈블리 소개 및 관련한 도전들\n15.2 오버랩 그래프와 해밀턴 사이클\n15.3 드브루인 그래프와 오일러 경로\n15.4 실제 게놈 어셈블리\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n16장. 참조 유전자 서열에 리드 어셈블리\n\n16.1 소개: 서열 일치 문제의 정의와 응용법\n16.2 패턴 전처리: 트라이\n16.3 서열의 전처리: 접미사 트리\n16.4 버로우즈 휠러 변환\n참고 문헌과 추가 자료\n연습 문제와 프로그래밍 프로젝트\n\n17장. 더 읽을거리\n\n17.1 추천하는 생명정보학 서적\n17.2 논문 및 학회\n17.3 정규 교육 과정\n17.4 온라인 교육 자료"
  },
  {
    "objectID": "books/Bioinfo_python_2ed.html",
    "href": "books/Bioinfo_python_2ed.html",
    "title": "파이썬을 활용한 생명정보학 2/e",
    "section": "",
    "text": "원제 : Bioinformatics with Python Cookbook - Second Edition\n생명정보학 데이터를 파이썬 프로그래밍 기법과 프레임워크를 사용해 처리한다. 차세대 염기서열 분석, 유전체학, 메타지노믹스(metagenomics), 집단 유전학, 계통 발생학, 프로테오믹스(proteomics)의 내용을 다룬다. 다양한 파이썬 도구와 라이브러리로 데이터를 변환, 분석, 시각화하는 최신 프로그래밍 기법을 배운다. 차세대 염기서열 분석 데이터의 필터링(filtering) 기술과 병렬처리 프레임워크(framework)인 대스크(Dask)와 스파크(Spark)도 소개한다.\n\n1 목차\n\n1장. 파이썬과 주변 생태계\n\n소개\n아나콘다를 사용한 필요 소프트웨어 설치\n도커를 사용한 필요 소프트웨어 설치\nrpy2를 통해 R과 인터페이스 만들기\n주피터 노트북에서 R 매직 명령어 사용하기\n\n2장. 차세대 염기서열 분석\n\n소개\nNCBI와 진뱅크 데이터베이스 둘러보기\n염기서열 분석의 기초\n배우기\nFASTQ 파일 다루기\n정렬 데이터 다루기\nVCF 파일 데이터 분석하기\n게놈 접근성과 SNP 데이터 필터하기\nHTSeq로 NGS 데이터 처리하기\n\n3장. 게놈 데이터 다루기\n\n소개\n좋은 품질의 참조 게놈 다루기\n낮은 품질의 참조 게놈 다루기\n게놈 주석 살펴보기\n게놈 주석으로 원하는 유전자 추출하기\nEnsembl REST API로 오소로그검색\nEnsembl REST API로 유전자 온톨로지 정보 검색\n\n4장. 집단유전학\n\n소개\nPLINK 형식 데이터셋 관리하기\nGenepop 파일 형식 소개\nBio.PopGen으로 데이터셋 탐색하기\nF - 통계 계산하기\n주성분 분석하기\nADMIXTURE 프로그램으로 집단 구조 조사하기\n\n5장. 집단유전학 시뮬레이션\n\n소개\n순방향 시뮬레이터 소개\n선택 시뮬레이션\n섬 모델과 디딤돌 모델을 사용한 시뮬레이션\n복잡한 집단 통계 모델 만들기\n\n6장. 계통 발생학\n\n소개\n계통 발생학 분석을 위한 데이터셋 준비\n유전자와 게놈 데이터 정렬\n서열 데이터 비교하기\n계통수 그리기\n재귀적으로 계통수 다루기\n계통수 시각화하기\n\n7장. 단백질 데이터 뱅크 사용하기\n\n소개\n데이터베이스에서 단백질 정보 찾기\nBio.PDB 소개\nPDB 파일에서 더 많은 정보 추출하기\nPDB 파일에서 분자간 거리 계산\n기하학적 계산하기\nPyMOL로 애니메이션 만들기\nBiopython을 사용해 mmCIF 파일 파싱하기\n\n8장. 생명정보학 파이프라인\n\n소개\n갤럭시 서버 소개\nAPI를 사용해 갤럭시 사용하기\n갤럭시 도구 개발\n일반적인 파이프라인 사용법\nAirflow를 사용해 유전변이 분석 파이프라인 만들기\n\n9장. 파이썬으로 유전체 빅데이터 다루기\n\n소개\nHDF5 데이터 형식\n대스크 라이브러리로 병렬분산처리\n파케이 데이터 형식\n스파크 라이브러리로 병렬분산처리\n사이썬과 눔바로 코드 최적화\n\n10장. 생명정보학의 다른 주제들\n\n소개\nQIIME2로 메타지노믹스 분석하기\n생식세포계열로 공통 염색체 찾기\nREST API로 GBIF 데이터베이스 사용하기\nGBIF의 지리 참조 데이터 다루기\n사이토스케이프로 단백질 네트워크 시각화\n\n11장. 고급 차세대 염기서열 분석\n\n소개\n분석을 위한 데이터셋 준비하기\n멘델리언 오류로 데이터 품질 관리\n의사 결정 나무를 사용한 데이터 탐색\n표준 통계로 데이터 탐색\n주석 데이터로 생물학적 특성 찾기\n\n\n\n\n2 구입처\n\n알라딘\nYES24\n교보문고\n인터파크\n반디앤루니스"
  },
  {
    "objectID": "portfolio/korean_monospace_font.html",
    "href": "portfolio/korean_monospace_font.html",
    "title": "한국어 프로그래밍 폰트 만들기",
    "section": "",
    "text": "프로그래머가 고정폭(Monospaced) 폰트를 사용하는 이유는 코드의 가독성과 정렬을 유지하기 위함입니다. 일반적인 문서 작업에 쓰이는 가변폭(Proportional) 폰트와 달리, 고정폭 폰트는 모든 글자의 가로 길이가 동일하여 프로그래밍에 다음과 같은 장점을 제공합니다.\n\n\n좋은 프로그래밍 폰트는 단순히 고정폭이라는 점 외에도 몇 가지 중요한 특징을 가집니다.\n\n명확한 문자 구분: 0과 O, 1과 l 같은 글자들이 혼동되지 않도록 각 문자의 고유한 형태가 뚜렷해야 합니다.\n일관된 너비: 모든 글자의 너비가 정확하게 일치해야 합니다. 일부 폰트들은 한글과 영어를 같이 쓸 때 너비가 깨지는 경우가 있어, 여러 언어를 사용하는 환경에서는 특히 중요합니다.\n리거쳐(Ligature) 지원: -&gt;, ==, != 와 같은 여러 문자가 합쳐져 하나의 기호처럼 보이는 기능을 지원하는 폰트도 있습니다. 이는 코드를 더 깔끔하고 읽기 쉽게 만들어줍니다. 대표적인 예시로는 Fira Code, JetBrains Mono 등이 있습니다.\n\n\n\n\n많은 개발자들이 뛰어난 가독성을 제공하는 영문 프로그래밍 폰트를 선호합니다. 하지만 대부분의 영문 전용 폰트들은 한글을 지원하지 않아, 코드에 한글 주석이나 변수명이 섞여 있을 때 시각적 통일성이 깨지고 가독성이 떨어지는 문제가 발생합니다. 따라서 많이 사용되는 영문 프로그래밍 폰트에 네이버에서 개발한 D2Coding 폰트를 병합하는 프로젝트를 진행했습니다. 아래는 그 목록들이며 각각의 Repo에서 ttf파일을 다운로드 받을 수 있습니다. 하는 김에 Nerd font 버전도 만들어서 터미널에 사용할 버전도 같이 만들었습니다.\n\n\n\n\n\n\n\nMeD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nJBD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nFiraD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nMLD2 repository 에서 다운로드."
  },
  {
    "objectID": "portfolio/korean_monospace_font.html#좋은-프로그래밍-폰트의-특징",
    "href": "portfolio/korean_monospace_font.html#좋은-프로그래밍-폰트의-특징",
    "title": "한국어 프로그래밍 폰트 만들기",
    "section": "",
    "text": "좋은 프로그래밍 폰트는 단순히 고정폭이라는 점 외에도 몇 가지 중요한 특징을 가집니다.\n\n명확한 문자 구분: 0과 O, 1과 l 같은 글자들이 혼동되지 않도록 각 문자의 고유한 형태가 뚜렷해야 합니다.\n일관된 너비: 모든 글자의 너비가 정확하게 일치해야 합니다. 일부 폰트들은 한글과 영어를 같이 쓸 때 너비가 깨지는 경우가 있어, 여러 언어를 사용하는 환경에서는 특히 중요합니다.\n리거쳐(Ligature) 지원: -&gt;, ==, != 와 같은 여러 문자가 합쳐져 하나의 기호처럼 보이는 기능을 지원하는 폰트도 있습니다. 이는 코드를 더 깔끔하고 읽기 쉽게 만들어줍니다. 대표적인 예시로는 Fira Code, JetBrains Mono 등이 있습니다."
  },
  {
    "objectID": "portfolio/korean_monospace_font.html#왜-만들었는가",
    "href": "portfolio/korean_monospace_font.html#왜-만들었는가",
    "title": "한국어 프로그래밍 폰트 만들기",
    "section": "",
    "text": "많은 개발자들이 뛰어난 가독성을 제공하는 영문 프로그래밍 폰트를 선호합니다. 하지만 대부분의 영문 전용 폰트들은 한글을 지원하지 않아, 코드에 한글 주석이나 변수명이 섞여 있을 때 시각적 통일성이 깨지고 가독성이 떨어지는 문제가 발생합니다. 따라서 많이 사용되는 영문 프로그래밍 폰트에 네이버에서 개발한 D2Coding 폰트를 병합하는 프로젝트를 진행했습니다. 아래는 그 목록들이며 각각의 Repo에서 ttf파일을 다운로드 받을 수 있습니다. 하는 김에 Nerd font 버전도 만들어서 터미널에 사용할 버전도 같이 만들었습니다.\n\n\n\n\n\n\n\nMeD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nJBD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nFiraD2 repository 에서 다운로드.\n\n\n\n\n\n\n\n\n\nMLD2 repository 에서 다운로드."
  },
  {
    "objectID": "portfolio/project_a.html",
    "href": "portfolio/project_a.html",
    "title": "Project Idea",
    "section": "",
    "text": "Here are a few project ideas that you might find interesting, along with some guidance on how to approach them:"
  },
  {
    "objectID": "portfolio/project_a.html#dna-sequence-analysis-1",
    "href": "portfolio/project_a.html#dna-sequence-analysis-1",
    "title": "Project Idea",
    "section": "1. DNA Sequence Analysis:",
    "text": "1. DNA Sequence Analysis:\nOne classic project is to perform DNA sequence analysis. This involves analyzing DNA sequences to find patterns, mutations, or other significant features.\nObjective: Develop a tool to identify gene sequences within a larger DNA dataset. Tools and Technologies: Use Python or R for scripting, and libraries like Biopython or Bioconductor for handling biological data. Steps to Follow: Start by acquiring a DNA dataset from public databases like NCBI or Ensembl. Clean and preprocess the data for analysis. Implement algorithms to search for specific motifs or patterns, such as promoter regions or specific gene markers. Visualize the results using plotting libraries such as Matplotlib or ggplot2."
  },
  {
    "objectID": "portfolio/project_a.html#protein-structure-prediction-1",
    "href": "portfolio/project_a.html#protein-structure-prediction-1",
    "title": "Project Idea",
    "section": "2. Protein Structure Prediction:",
    "text": "2. Protein Structure Prediction:\nThis project involves predicting the three-dimensional structure of proteins from their amino acid sequences, a task crucial for understanding protein function.\nObjective: Use machine learning to predict protein structures. Tools and Technologies: Python, TensorFlow, or PyTorch for building machine learning models; use databases like the Protein Data Bank (PDB) for training data. Steps to Follow: Gather and preprocess protein sequence and structure data. Experiment with different machine learning models, such as Convolutional Neural Networks (CNNs) or Recurrent Neural Networks (RNNs), to predict structures. Validate your model’s predictions using known protein structures."
  },
  {
    "objectID": "portfolio/project_a.html#genome-wide-association-studies-gwas-1",
    "href": "portfolio/project_a.html#genome-wide-association-studies-gwas-1",
    "title": "Project Idea",
    "section": "3. Genome-Wide Association Studies (GWAS):",
    "text": "3. Genome-Wide Association Studies (GWAS):\nGWAS investigate the association between genetic variants and traits in a population.\nObjective: Identify genetic variants associated with a specific trait or disease. Tools and Technologies: Use R or Python, along with libraries like PLINK for statistical analysis. Steps to Follow: Collect genotype and phenotype data from a public source. Perform quality control to ensure data integrity. Use statistical methods to find associations between genetic markers and traits. Interpret results to understand the genetic basis of the trait."
  },
  {
    "objectID": "portfolio/project_a.html#rna-seq-data-analysis-1",
    "href": "portfolio/project_a.html#rna-seq-data-analysis-1",
    "title": "Project Idea",
    "section": "4. RNA-Seq Data Analysis:",
    "text": "4. RNA-Seq Data Analysis:\nRNA sequencing (RNA-Seq) is a powerful technique to study gene expression.\nObjective: Analyze RNA-Seq data to identify differentially expressed genes. Tools and Technologies: Use R with Bioconductor packages or Python with libraries like Pandas and SciPy. Steps to Follow: Obtain RNA-Seq data from sources like GEO or ENA. Preprocess the data for quality control and normalization. Use statistical tests to find genes with significant changes in expression. Visualize the results using heatmaps or volcano plots."
  },
  {
    "objectID": "portfolio/project_a.html#metagenomics-1",
    "href": "portfolio/project_a.html#metagenomics-1",
    "title": "Project Idea",
    "section": "5. Metagenomics:",
    "text": "5. Metagenomics:\nMetagenomics involves studying genetic material recovered directly from environmental samples.\nObjective: Analyze metagenomic data to understand microbial diversity in an environment. Tools and Technologies: Use QIIME or Mothur for sequence processing and analysis. Steps to Follow: Gather metagenomic sequences from databases like MG-RAST. Preprocess sequences to remove contaminants and ensure quality. Analyze community composition and diversity using bioinformatics tools. Visualize the microbial diversity through various plots and charts. When selecting a project, consider your interests, the resources available to you, and the skills you wish to develop. Each of these projects can be tailored to different levels of complexity, allowing you to learn more about bioinformatics while also honing your computational and analytical skills. Good luck with your bioinformatics journey!"
  },
  {
    "objectID": "portfolio/kimchi_gold.html#김치-프리미엄-계산식",
    "href": "portfolio/kimchi_gold.html#김치-프리미엄-계산식",
    "title": "Project kimchi-gold",
    "section": "김치 프리미엄 계산식",
    "text": "김치 프리미엄 계산식\nkimchi-gold 프로젝트에서는 국제 금 시세와 국내 금 시세 간의 괴리율을 다음과 같은 단계를 거쳐 계산합니다.\n\n국제 금 시세의 그램(g)당 가격 계산: 국제 금 시세는 일반적으로 트로이온스(troy ounce) 단위로 표시되므로, 이를 그램(g) 단위로 변환해야 합니다. 1 트로이온스는 약 31.1035 그램입니다. 따라서 국제 금 시세(달러/트로이온스)를 그램당 가격(달러/g)으로 변환하는 공식은 다음과 같습니다.\n\\[\\text{국제 금 시세 (달러/g)} = \\frac{\\text{국제 금 시세 (달러/트로이온스)}}{31.1035}\\]\n국제 금 시세의 원화(KRW) 환산: 계산된 국제 금 시세(달러/g)에 원/달러 환율을 곱하여 원화(KRW) 기준의 그램당 국제 금 가격을 얻습니다.\n\\[\\text{원화 환산 국제 금 시세 (원/g)} = \\text{국제 금 시세 (달러/g)} \\times \\text{원/달러 환율 (원/달러)}\\]\n괴리율 계산: 최종적으로 국내 금 시세와 원화로 환산된 국제 금 시세를 비교하여 김치 프리미엄 괴리율을 계산합니다.\n\\[\\text{김치 프리미엄(\\%)} = \\left( \\frac{\\text{국내 금 시세 (원/g)} - \\text{원화 환산 국제 금 시세 (원/g)}}{\\text{원화 환산 국제 금 시세 (원/g)}} \\right) \\times 100\\]\n\n여기서 각 변수는 다음과 같습니다.\n\n국내 금 시세: 국내 시장에서 거래되는 금 1g 가격 (원/g)\n국제 금 시세: 국제 시장에서 거래되는 금 가격 (달러/트로이온스)\n원/달러 환율: 원화 대비 달러화 환율 (원/달러)\n\n위 공식을 통해 산출된 괴리율은 국내 금 가격이 국제 금 가격 대비 얼마나 높은지를 백분율로 나타냅니다.\n\n양(+)의 값은 국내 금 가격이 더 높다는 것을 의미합니다."
  },
  {
    "objectID": "portfolio/kimchi_gold.html#프로젝트의-활용법",
    "href": "portfolio/kimchi_gold.html#프로젝트의-활용법",
    "title": "Project kimchi-gold",
    "section": "프로젝트의 활용법",
    "text": "프로젝트의 활용법\nkimchi-gold 프로젝트를 통해 다음과 같은 정보를 얻을 수 있습니다.\n\n김치 프리미엄 추이: 과거부터 현재까지의 김치 프리미엄 변동 그래프를 통해 추세를 파악할 수 있습니다.\n알림 기능: 특정 수준 이상의 김치 프리미엄 발생 시 자동으로 이슈를 만들어 알람 메일을 보내줘 적절한 투자 시점을 포착하는 데 활용할 수 있습니다.\n\nkimchi-gold 프로젝트는 단순한 정보 제공을 위해 수행하였으며 앞으로도 지속적인 데이터 업데이트와 분석 기능 강화를 통해 더욱 유용한 정보를 제공할 수 있도록 하겠습니다."
  }
]