<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Taeyoon Kim">
<meta name="dcterms.date" content="2025-06-15">

<title>Nature Methods 데이터 시각화 컬럼 모음 – tomorrow-lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../.././static/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-be4b5f0ceb91c6d256a52250e5d87e72.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-f6cd7e65faeccfabf5ef1eb7f9f79780.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-be4b5f0ceb91c6d256a52250e5d87e72.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f7a981a6d6a5d49226379a17328db006.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-9dff5c0ff9725297dc8911b52dbca2ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-f7a981a6d6a5d49226379a17328db006.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-31EWCYNR0V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-31EWCYNR0V', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="google-site-verification" content="z2S1Xqj9hfJiC31aNGCnOA1gYpL_8MoZpPI2avrWMvg">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Nature Methods 데이터 시각화 컬럼 모음 – tomorrow-lab">
<meta property="og:description" content="The future of scientific discovery lies at the convergence of computational power and biological complexity. Our mission is to provide a platform where enthusiasts, researchers, and professionals can learn about and contribute to the rapidly evolving fields of bioinformatics, computational biology, and systems biology.">
<meta property="og:image" content="https://tomorrow-lab.github.io/posts/qmd/learn_dataVisualization.png">
<meta property="og:site_name" content="tomorrow-lab">
<meta property="og:image:height" content="1200">
<meta property="og:image:width" content="1200">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././static/logo.png" alt="" class="navbar-logo light-content">
    <img src="../.././static/logo.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tomorrow-lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://partrita.github.io"> <i class="bi bi-exclamation-triangle" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/partrita"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<div style="margin-top: 30px; margin-bottom: 20px;">
    <a href="https://substack.com/@tomorrowlab">
        <img alt="Static Badge" src="https://img.shields.io/badge/EHOTTL%40substack_-FF6719?link=https%3A%2F%2Fsubstack.com%2F%40tomorrowlab">
    </a>
    <a href="https://pixi.sh">
        <img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json" alt="Pixi Badge">
    </a>
    <!-- <script async src="https://eocampaign1.com/form/2616a818-1ef8-11ef-b372-4587d096212f.js" data-form="2616a818-1ef8-11ef-b372-4587d096212f"></script> -->
</div>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#생물학-데이터-시각화는-필수-도구" id="toc-생물학-데이터-시각화는-필수-도구" class="nav-link active" data-scroll-target="#생물학-데이터-시각화는-필수-도구"><span class="header-section-number">1</span> 생물학 데이터 시각화는 필수 도구</a></li>
  <li><a href="#구성-및-레이아웃" id="toc-구성-및-레이아웃" class="nav-link" data-scroll-target="#구성-및-레이아웃"><span class="header-section-number">2</span> 구성 및 레이아웃</a>
  <ul class="collapse">
  <li><a href="#쉽고-명확한-정보-전달을-위한-디자인" id="toc-쉽고-명확한-정보-전달을-위한-디자인" class="nav-link" data-scroll-target="#쉽고-명확한-정보-전달을-위한-디자인"><span class="header-section-number">2.1</span> 쉽고 명확한 정보 전달을 위한 디자인</a></li>
  <li><a href="#레이아웃-정보-전달을-위한-시각적-정리의-기술" id="toc-레이아웃-정보-전달을-위한-시각적-정리의-기술" class="nav-link" data-scroll-target="#레이아웃-정보-전달을-위한-시각적-정리의-기술"><span class="header-section-number">2.2</span> 레이아웃: 정보 전달을 위한 시각적 정리의 기술</a></li>
  <li><a href="#게슈탈트-이론" id="toc-게슈탈트-이론" class="nav-link" data-scroll-target="#게슈탈트-이론"><span class="header-section-number">2.3</span> 게슈탈트 이론</a>
  <ul class="collapse">
  <li><a href="#유사성-원리" id="toc-유사성-원리" class="nav-link" data-scroll-target="#유사성-원리"><span class="header-section-number">2.3.1</span> 유사성 원리</a></li>
  <li><a href="#근접성-원리" id="toc-근접성-원리" class="nav-link" data-scroll-target="#근접성-원리"><span class="header-section-number">2.3.2</span> 근접성 원리</a></li>
  <li><a href="#연결성-및-폐쇄성-원리" id="toc-연결성-및-폐쇄성-원리" class="nav-link" data-scroll-target="#연결성-및-폐쇄성-원리"><span class="header-section-number">2.3.3</span> 연결성 및 폐쇄성 원리</a></li>
  <li><a href="#시각적-완성-원리" id="toc-시각적-완성-원리" class="nav-link" data-scroll-target="#시각적-완성-원리"><span class="header-section-number">2.3.4</span> 시각적 완성 원리</a></li>
  <li><a href="#연속성-원리" id="toc-연속성-원리" class="nav-link" data-scroll-target="#연속성-원리"><span class="header-section-number">2.3.5</span> 연속성 원리</a></li>
  </ul></li>
  <li><a href="#여백negative-space-디자인의-숨겨진-힘" id="toc-여백negative-space-디자인의-숨겨진-힘" class="nav-link" data-scroll-target="#여백negative-space-디자인의-숨겨진-힘"><span class="header-section-number">2.4</span> 여백(Negative Space): 디자인의 숨겨진 힘</a>
  <ul class="collapse">
  <li><a href="#여백의-중요성" id="toc-여백의-중요성" class="nav-link" data-scroll-target="#여백의-중요성"><span class="header-section-number">2.4.1</span> 여백의 중요성</a></li>
  <li><a href="#효과적인-여백-넣기" id="toc-효과적인-여백-넣기" class="nav-link" data-scroll-target="#효과적인-여백-넣기"><span class="header-section-number">2.4.2</span> 효과적인 여백 넣기</a></li>
  <li><a href="#여백으로-시선-집중시키기" id="toc-여백으로-시선-집중시키기" class="nav-link" data-scroll-target="#여백으로-시선-집중시키기"><span class="header-section-number">2.4.3</span> 여백으로 시선 집중시키기</a></li>
  </ul></li>
  <li><a href="#중요한-부분-강조하기" id="toc-중요한-부분-강조하기" class="nav-link" data-scroll-target="#중요한-부분-강조하기"><span class="header-section-number">2.5</span> 중요한 부분 강조하기</a>
  <ul class="collapse">
  <li><a href="#의도치-않은-두드러짐의-위험성" id="toc-의도치-않은-두드러짐의-위험성" class="nav-link" data-scroll-target="#의도치-않은-두드러짐의-위험성"><span class="header-section-number">2.5.1</span> 의도치 않은 두드러짐의 위험성</a></li>
  <li><a href="#효과적인-글쓰기-원칙을-그림-디자인에-적용하기" id="toc-효과적인-글쓰기-원칙을-그림-디자인에-적용하기" class="nav-link" data-scroll-target="#효과적인-글쓰기-원칙을-그림-디자인에-적용하기"><span class="header-section-number">2.5.2</span> 효과적인 글쓰기 원칙을 그림 디자인에 적용하기</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#데이터-시각화에서-색상" id="toc-데이터-시각화에서-색상" class="nav-link" data-scroll-target="#데이터-시각화에서-색상"><span class="header-section-number">3</span> 데이터 시각화에서 색상</a>
  <ul class="collapse">
  <li><a href="#색상의-선택" id="toc-색상의-선택" class="nav-link" data-scroll-target="#색상의-선택"><span class="header-section-number">3.1</span> 색상의 선택</a>
  <ul class="collapse">
  <li><a href="#색상의-올바른-사용법" id="toc-색상의-올바른-사용법" class="nav-link" data-scroll-target="#색상의-올바른-사용법"><span class="header-section-number">3.1.1</span> 색상의 올바른 사용법</a></li>
  <li><a href="#색상의-세-가지-속성과-활용법" id="toc-색상의-세-가지-속성과-활용법" class="nav-link" data-scroll-target="#색상의-세-가지-속성과-활용법"><span class="header-section-number">3.1.2</span> 색상의 세 가지 속성과 활용법</a></li>
  <li><a href="#색맹을-고려한-색상-사용" id="toc-색맹을-고려한-색상-사용" class="nav-link" data-scroll-target="#색맹을-고려한-색상-사용"><span class="header-section-number">3.1.3</span> 색맹을 고려한 색상 사용</a></li>
  </ul></li>
  <li><a href="#과한-색상-사용의-문제점" id="toc-과한-색상-사용의-문제점" class="nav-link" data-scroll-target="#과한-색상-사용의-문제점"><span class="header-section-number">3.2</span> 과한 색상 사용의 문제점</a></li>
  <li><a href="#정량적-데이터의-색상-고려사항" id="toc-정량적-데이터의-색상-고려사항" class="nav-link" data-scroll-target="#정량적-데이터의-색상-고려사항"><span class="header-section-number">3.3</span> 정량적 데이터의 색상 고려사항</a>
  <ul class="collapse">
  <li><a href="#색상맵-고려사항" id="toc-색상맵-고려사항" class="nav-link" data-scroll-target="#색상맵-고려사항"><span class="header-section-number">3.3.1</span> 색상맵 고려사항</a></li>
  <li><a href="#색상맵에-유용한-도구들" id="toc-색상맵에-유용한-도구들" class="nav-link" data-scroll-target="#색상맵에-유용한-도구들"><span class="header-section-number">3.3.2</span> 색상맵에 유용한 도구들</a></li>
  </ul></li>
  <li><a href="#타이포그래피" id="toc-타이포그래피" class="nav-link" data-scroll-target="#타이포그래피"><span class="header-section-number">4.1</span> 타이포그래피</a>
  <ul class="collapse">
  <li><a href="#서체와-글꼴의-이해" id="toc-서체와-글꼴의-이해" class="nav-link" data-scroll-target="#서체와-글꼴의-이해"><span class="header-section-number">4.1.1</span> 서체와 글꼴의 이해</a></li>
  <li><a href="#서체-선택의-원칙" id="toc-서체-선택의-원칙" class="nav-link" data-scroll-target="#서체-선택의-원칙"><span class="header-section-number">4.1.2</span> 서체 선택의 원칙</a></li>
  <li><a href="#간격-조정과-문서-구조화" id="toc-간격-조정과-문서-구조화" class="nav-link" data-scroll-target="#간격-조정과-문서-구조화"><span class="header-section-number">4.1.3</span> 간격 조정과 문서 구조화</a></li>
  <li><a href="#단순함과-통일성의-미덕" id="toc-단순함과-통일성의-미덕" class="nav-link" data-scroll-target="#단순함과-통일성의-미덕"><span class="header-section-number">4.1.4</span> 단순함과 통일성의 미덕</a></li>
  <li><a href="#축" id="toc-축" class="nav-link" data-scroll-target="#축"><span class="header-section-number">4.1.5</span> 축</a></li>
  <li><a href="#눈금" id="toc-눈금" class="nav-link" data-scroll-target="#눈금"><span class="header-section-number">4.1.6</span> 눈금</a></li>
  <li><a href="#그리드" id="toc-그리드" class="nav-link" data-scroll-target="#그리드"><span class="header-section-number">4.1.7</span> 그리드</a></li>
  <li><a href="#레이블" id="toc-레이블" class="nav-link" data-scroll-target="#레이블"><span class="header-section-number">4.1.8</span> 레이블</a></li>
  </ul></li>
  <li><a href="#심볼-명확하고-의미-있는-데이터-표현" id="toc-심볼-명확하고-의미-있는-데이터-표현" class="nav-link" data-scroll-target="#심볼-명확하고-의미-있는-데이터-표현"><span class="header-section-number">4.2</span> 심볼: 명확하고 의미 있는 데이터 표현</a>
  <ul class="collapse">
  <li><a href="#단일-데이터-범주에서의-심볼" id="toc-단일-데이터-범주에서의-심볼" class="nav-link" data-scroll-target="#단일-데이터-범주에서의-심볼"><span class="header-section-number">4.2.1</span> 단일 데이터 범주에서의 심볼</a></li>
  <li><a href="#다중-데이터-범주에서의-심볼" id="toc-다중-데이터-범주에서의-심볼" class="nav-link" data-scroll-target="#다중-데이터-범주에서의-심볼"><span class="header-section-number">4.2.2</span> 다중 데이터 범주에서의 심볼</a></li>
  <li><a href="#데이터-구조-반영" id="toc-데이터-구조-반영" class="nav-link" data-scroll-target="#데이터-구조-반영"><span class="header-section-number">4.2.3</span> 데이터 구조 반영</a></li>
  <li><a href="#심볼-수가-많을-때의-대처" id="toc-심볼-수가-많을-때의-대처" class="nav-link" data-scroll-target="#심볼-수가-많을-때의-대처"><span class="header-section-number">4.2.4</span> 심볼 수가 많을 때의 대처</a></li>
  </ul></li>
  <li><a href="#화살표" id="toc-화살표" class="nav-link" data-scroll-target="#화살표"><span class="header-section-number">4.3</span> 화살표</a>
  <ul class="collapse">
  <li><a href="#화살표-사용-주의점" id="toc-화살표-사용-주의점" class="nav-link" data-scroll-target="#화살표-사용-주의점"><span class="header-section-number">4.3.1</span> 화살표 사용 주의점</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#nature-methods-blog에-이어서" id="toc-nature-methods-blog에-이어서" class="nav-link" data-scroll-target="#nature-methods-blog에-이어서"><span class="header-section-number">5</span> Nature methods blog에 이어서</a></li>
  <li><a href="#차트-유형" id="toc-차트-유형" class="nav-link" data-scroll-target="#차트-유형"><span class="header-section-number">6</span> 차트 유형</a>
  <ul class="collapse">
  <li><a href="#막대-그래프와-상자-그림" id="toc-막대-그래프와-상자-그림" class="nav-link" data-scroll-target="#막대-그래프와-상자-그림"><span class="header-section-number">6.1</span> 막대 그래프와 상자 그림</a>
  <ul class="collapse">
  <li><a href="#막대-그래프-활용" id="toc-막대-그래프-활용" class="nav-link" data-scroll-target="#막대-그래프-활용"><span class="header-section-number">6.1.1</span> 막대 그래프 활용</a></li>
  <li><a href="#상자-그림" id="toc-상자-그림" class="nav-link" data-scroll-target="#상자-그림"><span class="header-section-number">6.1.2</span> 상자 그림</a></li>
  <li><a href="#막대-그래프와-상자-그림을-위한-권장-사항" id="toc-막대-그래프와-상자-그림을-위한-권장-사항" class="nav-link" data-scroll-target="#막대-그래프와-상자-그림을-위한-권장-사항"><span class="header-section-number">6.1.3</span> 막대 그래프와 상자 그림을 위한 권장 사항</a></li>
  </ul></li>
  <li><a href="#집합과-교집합" id="toc-집합과-교집합" class="nav-link" data-scroll-target="#집합과-교집합"><span class="header-section-number">6.2</span> 집합과 교집합</a>
  <ul class="collapse">
  <li><a href="#오일러-다이어그램과-벤-다이어그램" id="toc-오일러-다이어그램과-벤-다이어그램" class="nav-link" data-scroll-target="#오일러-다이어그램과-벤-다이어그램"><span class="header-section-number">6.2.1</span> 오일러 다이어그램과 벤 다이어그램</a></li>
  <li><a href="#다수-집합-교집합-시각화" id="toc-다수-집합-교집합-시각화" class="nav-link" data-scroll-target="#다수-집합-교집합-시각화"><span class="header-section-number">6.2.2</span> 다수 집합 교집합 시각화</a></li>
  </ul></li>
  <li><a href="#히트맵" id="toc-히트맵" class="nav-link" data-scroll-target="#히트맵"><span class="header-section-number">6.3</span> 히트맵</a>
  <ul class="collapse">
  <li><a href="#색상을-지정하는-문제와-해결책" id="toc-색상을-지정하는-문제와-해결책" class="nav-link" data-scroll-target="#색상을-지정하는-문제와-해결책"><span class="header-section-number">6.3.1</span> 색상을 지정하는 문제와 해결책</a></li>
  <li><a href="#클러스터링의-중요성과-히트맵의-한계" id="toc-클러스터링의-중요성과-히트맵의-한계" class="nav-link" data-scroll-target="#클러스터링의-중요성과-히트맵의-한계"><span class="header-section-number">6.3.2</span> 클러스터링의 중요성과 히트맵의 한계</a></li>
  </ul></li>
  <li><a href="#시계열-데이터" id="toc-시계열-데이터" class="nav-link" data-scroll-target="#시계열-데이터"><span class="header-section-number">6.4</span> 시계열 데이터</a></li>
  <li><a href="#서브플롯으로-복잡한-데이터-풀어내기" id="toc-서브플롯으로-복잡한-데이터-풀어내기" class="nav-link" data-scroll-target="#서브플롯으로-복잡한-데이터-풀어내기"><span class="header-section-number">6.5</span> 서브플롯으로 복잡한 데이터 풀어내기</a>
  <ul class="collapse">
  <li><a href="#최소값과-최대값이-다른-데이터-다루기" id="toc-최소값과-최대값이-다른-데이터-다루기" class="nav-link" data-scroll-target="#최소값과-최대값이-다른-데이터-다루기"><span class="header-section-number">6.5.1</span> 최소값과 최대값이 다른 데이터 다루기</a></li>
  </ul></li>
  <li><a href="#경로-다이어그램" id="toc-경로-다이어그램" class="nav-link" data-scroll-target="#경로-다이어그램"><span class="header-section-number">6.6</span> 경로 다이어그램</a>
  <ul class="collapse">
  <li><a href="#시각적-그룹핑과-정렬로-정보-흐름-강조" id="toc-시각적-그룹핑과-정렬로-정보-흐름-강조" class="nav-link" data-scroll-target="#시각적-그룹핑과-정렬로-정보-흐름-강조"><span class="header-section-number">6.6.1</span> 시각적 그룹핑과 정렬로 정보 흐름 강조</a></li>
  <li><a href="#연결성-및-포함으로-관계-표현" id="toc-연결성-및-포함으로-관계-표현" class="nav-link" data-scroll-target="#연결성-및-포함으로-관계-표현"><span class="header-section-number">6.6.2</span> 연결성 및 포함으로 관계 표현</a></li>
  <li><a href="#유사성-및-근접성으로-그룹핑-강화" id="toc-유사성-및-근접성으로-그룹핑-강화" class="nav-link" data-scroll-target="#유사성-및-근접성으로-그룹핑-강화"><span class="header-section-number">6.6.3</span> 유사성 및 근접성으로 그룹핑 강화</a></li>
  <li><a href="#노드-레이블링의-어려움과-해결책" id="toc-노드-레이블링의-어려움과-해결책" class="nav-link" data-scroll-target="#노드-레이블링의-어려움과-해결책"><span class="header-section-number">6.6.4</span> 노드 레이블링의 어려움과 해결책</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#명확한-데이터-시각화를-하는-방법" id="toc-명확한-데이터-시각화를-하는-방법" class="nav-link" data-scroll-target="#명확한-데이터-시각화를-하는-방법"><span class="header-section-number">7</span> 명확한 데이터 시각화를 하는 방법</a>
  <ul class="collapse">
  <li><a href="#단순화하기" id="toc-단순화하기" class="nav-link" data-scroll-target="#단순화하기"><span class="header-section-number">7.1</span> 단순화하기</a>
  <ul class="collapse">
  <li><a href="#요소-수-줄이기" id="toc-요소-수-줄이기" class="nav-link" data-scroll-target="#요소-수-줄이기"><span class="header-section-number">7.1.1</span> 요소 수 줄이기</a></li>
  <li><a href="#불필요한-요소-제거" id="toc-불필요한-요소-제거" class="nav-link" data-scroll-target="#불필요한-요소-제거"><span class="header-section-number">7.1.2</span> 불필요한 요소 제거</a></li>
  <li><a href="#질서정연하게-배치" id="toc-질서정연하게-배치" class="nav-link" data-scroll-target="#질서정연하게-배치"><span class="header-section-number">7.1.3</span> 질서정연하게 배치</a></li>
  </ul></li>
  <li><a href="#효과적인-시각화를-위한-데이터-시각화-원칙" id="toc-효과적인-시각화를-위한-데이터-시각화-원칙" class="nav-link" data-scroll-target="#효과적인-시각화를-위한-데이터-시각화-원칙"><span class="header-section-number">7.2</span> 효과적인 시각화를 위한 데이터 시각화 원칙</a>
  <ul class="collapse">
  <li><a href="#패턴과-추세-인지" id="toc-패턴과-추세-인지" class="nav-link" data-scroll-target="#패턴과-추세-인지"><span class="header-section-number">7.2.1</span> 패턴과 추세 인지</a></li>
  <li><a href="#그래프-유형별-시각적-평가와-효율성" id="toc-그래프-유형별-시각적-평가와-효율성" class="nav-link" data-scroll-target="#그래프-유형별-시각적-평가와-효율성"><span class="header-section-number">7.2.2</span> 그래프 유형별 시각적 평가와 효율성</a></li>
  </ul></li>
  <li><a href="#시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩" id="toc-시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩" class="nav-link" data-scroll-target="#시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩"><span class="header-section-number">7.3</span> 시각적 두드러짐(Salience): 그래프 가독성 향상과 정보 인코딩</a>
  <ul class="collapse">
  <li><a href="#정보가-즉시-인식되어야-하는-이유" id="toc-정보가-즉시-인식되어야-하는-이유" class="nav-link" data-scroll-target="#정보가-즉시-인식되어야-하는-이유"><span class="header-section-number">7.3.1</span> 정보가 즉시 인식되어야 하는 이유</a></li>
  <li><a href="#복잡한-디자인-문제" id="toc-복잡한-디자인-문제" class="nav-link" data-scroll-target="#복잡한-디자인-문제"><span class="header-section-number">7.3.2</span> 복잡한 디자인 문제</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#다차원-데이터-시각화" id="toc-다차원-데이터-시각화" class="nav-link" data-scroll-target="#다차원-데이터-시각화"><span class="header-section-number">8</span> 다차원 데이터 시각화</a>
  <ul class="collapse">
  <li><a href="#차원-시각화" id="toc-차원-시각화" class="nav-link" data-scroll-target="#차원-시각화"><span class="header-section-number">8.1</span> 3차원 시각화</a></li>
  <li><a href="#차원-시각화이-필요한-경우" id="toc-차원-시각화이-필요한-경우" class="nav-link" data-scroll-target="#차원-시각화이-필요한-경우"><span class="header-section-number">8.2</span> 3차원 시각화이 필요한 경우</a>
  <ul class="collapse">
  <li><a href="#차원-시각화의-단점" id="toc-차원-시각화의-단점" class="nav-link" data-scroll-target="#차원-시각화의-단점"><span class="header-section-number">8.2.1</span> 3차원 시각화의 단점</a></li>
  <li><a href="#차원과-3차원시각화를-선택하는-방법" id="toc-차원과-3차원시각화를-선택하는-방법" class="nav-link" data-scroll-target="#차원과-3차원시각화를-선택하는-방법"><span class="header-section-number">8.2.2</span> 2차원과 3차원시각화를 선택하는 방법</a></li>
  </ul></li>
  <li><a href="#차원-시각화로-다변량-데이터-시각화" id="toc-차원-시각화로-다변량-데이터-시각화" class="nav-link" data-scroll-target="#차원-시각화로-다변량-데이터-시각화"><span class="header-section-number">8.3</span> 2차원 시각화로 다변량 데이터 시각화</a>
  <ul class="collapse">
  <li><a href="#평행-좌표-플롯-parallel-coordinate-plots" id="toc-평행-좌표-플롯-parallel-coordinate-plots" class="nav-link" data-scroll-target="#평행-좌표-플롯-parallel-coordinate-plots"><span class="header-section-number">8.3.1</span> 평행 좌표 플롯 (Parallel Coordinate Plots)</a></li>
  <li><a href="#산점도-행렬-scatter-plot-matrices" id="toc-산점도-행렬-scatter-plot-matrices" class="nav-link" data-scroll-target="#산점도-행렬-scatter-plot-matrices"><span class="header-section-number">8.3.2</span> 산점도 행렬 (Scatter Plot Matrices)</a></li>
  <li><a href="#평행-좌표-플롯-vs.-산점도-행렬" id="toc-평행-좌표-플롯-vs.-산점도-행렬" class="nav-link" data-scroll-target="#평행-좌표-플롯-vs.-산점도-행렬"><span class="header-section-number">8.3.3</span> 평행 좌표 플롯 vs.&nbsp;산점도 행렬</a></li>
  <li><a href="#시각화-방법의-시너지-효과" id="toc-시각화-방법의-시너지-효과" class="nav-link" data-scroll-target="#시각화-방법의-시너지-효과"><span class="header-section-number">8.3.4</span> 시각화 방법의 시너지 효과</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#데이터-탐색하기" id="toc-데이터-탐색하기" class="nav-link" data-scroll-target="#데이터-탐색하기"><span class="header-section-number">9</span> 데이터 탐색하기</a>
  <ul class="collapse">
  <li><a href="#연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구" id="toc-연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구" class="nav-link" data-scroll-target="#연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구"><span class="header-section-number">9.1</span> 연필과 종이: 사고와 가설 생성에 도움이 되는 독특한 도구</a>
  <ul class="collapse">
  <li><a href="#시각적-표현의-구체성" id="toc-시각적-표현의-구체성" class="nav-link" data-scroll-target="#시각적-표현의-구체성"><span class="header-section-number">9.1.1</span> 시각적 표현의 구체성</a></li>
  <li><a href="#연필과-종이의-즉각성과-유연성" id="toc-연필과-종이의-즉각성과-유연성" class="nav-link" data-scroll-target="#연필과-종이의-즉각성과-유연성"><span class="header-section-number">9.1.2</span> 연필과 종이의 즉각성과 유연성</a></li>
  <li><a href="#그리기의-인지적-이점" id="toc-그리기의-인지적-이점" class="nav-link" data-scroll-target="#그리기의-인지적-이점"><span class="header-section-number">9.1.3</span> 그리기의 인지적 이점</a></li>
  </ul></li>
  <li><a href="#그래픽으로-데이터-보기의-중요성" id="toc-그래픽으로-데이터-보기의-중요성" class="nav-link" data-scroll-target="#그래픽으로-데이터-보기의-중요성"><span class="header-section-number">9.2</span> 그래픽으로 데이터 보기의 중요성</a></li>
  <li><a href="#스택-그래프-vs.-개별-플롯-패턴-발견의-차이" id="toc-스택-그래프-vs.-개별-플롯-패턴-발견의-차이" class="nav-link" data-scroll-target="#스택-그래프-vs.-개별-플롯-패턴-발견의-차이"><span class="header-section-number">9.3</span> 스택 그래프 vs.&nbsp;개별 플롯: 패턴 발견의 차이</a></li>
  <li><a href="#네트워크-탐색을-위한-그래프-기법" id="toc-네트워크-탐색을-위한-그래프-기법" class="nav-link" data-scroll-target="#네트워크-탐색을-위한-그래프-기법"><span class="header-section-number">9.4</span> 네트워크 탐색을 위한 그래프 기법</a>
  <ul class="collapse">
  <li><a href="#노드-링크-다이어그램" id="toc-노드-링크-다이어그램" class="nav-link" data-scroll-target="#노드-링크-다이어그램"><span class="header-section-number">9.4.1</span> 노드-링크 다이어그램</a></li>
  <li><a href="#인접-행렬" id="toc-인접-행렬" class="nav-link" data-scroll-target="#인접-행렬"><span class="header-section-number">9.4.2</span> 인접 행렬</a></li>
  <li><a href="#큰-규모-네트워크-시각화의-한계와-대안" id="toc-큰-규모-네트워크-시각화의-한계와-대안" class="nav-link" data-scroll-target="#큰-규모-네트워크-시각화의-한계와-대안"><span class="header-section-number">9.4.3</span> 큰 규모 네트워크 시각화의 한계와 대안</a></li>
  </ul></li>
  <li><a href="#데이터-통합-다양한-분석-작업을-위한-시각적-표현" id="toc-데이터-통합-다양한-분석-작업을-위한-시각적-표현" class="nav-link" data-scroll-target="#데이터-통합-다양한-분석-작업을-위한-시각적-표현"><span class="header-section-number">9.5</span> 데이터 통합: 다양한 분석 작업을 위한 시각적 표현</a>
  <ul class="collapse">
  <li><a href="#결합된-시각화-디자인" id="toc-결합된-시각화-디자인" class="nav-link" data-scroll-target="#결합된-시각화-디자인"><span class="header-section-number">9.5.1</span> 결합된 시각화 디자인</a></li>
  <li><a href="#다수-시간-지점-데이터-처리" id="toc-다수-시간-지점-데이터-처리" class="nav-link" data-scroll-target="#다수-시간-지점-데이터-처리"><span class="header-section-number">9.5.2</span> 다수 시간 지점 데이터 처리</a></li>
  <li><a href="#통합-도구의-중요성" id="toc-통합-도구의-중요성" class="nav-link" data-scroll-target="#통합-도구의-중요성"><span class="header-section-number">9.5.3</span> 통합 도구의 중요성</a></li>
  </ul></li>
  <li><a href="#게놈-데이터-시각화-선형-게놈의-시각적-표현-선택" id="toc-게놈-데이터-시각화-선형-게놈의-시각적-표현-선택" class="nav-link" data-scroll-target="#게놈-데이터-시각화-선형-게놈의-시각적-표현-선택"><span class="header-section-number">9.6</span> 게놈 데이터 시각화: 선형 게놈의 시각적 표현 선택</a>
  <ul class="collapse">
  <li><a href="#게놈-데이터-개요-생성-및-문제점" id="toc-게놈-데이터-개요-생성-및-문제점" class="nav-link" data-scroll-target="#게놈-데이터-개요-생성-및-문제점"><span class="header-section-number">9.6.1</span> 게놈 데이터 개요 생성 및 문제점</a></li>
  <li><a href="#의미-있는-개요를-위한-접근-방식" id="toc-의미-있는-개요를-위한-접근-방식" class="nav-link" data-scroll-target="#의미-있는-개요를-위한-접근-방식"><span class="header-section-number">9.6.2</span> 의미 있는 개요를 위한 접근 방식</a></li>
  <li><a href="#게놈의-3차원적-특징과-미래-시각화" id="toc-게놈의-3차원적-특징과-미래-시각화" class="nav-link" data-scroll-target="#게놈의-3차원적-특징과-미래-시각화"><span class="header-section-number">9.6.3</span> 게놈의 3차원적 특징과 미래 시각화</a></li>
  </ul></li>
  <li><a href="#게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리" id="toc-게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리" class="nav-link" data-scroll-target="#게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리"><span class="header-section-number">9.7</span> 게놈 브라우저를 통한 대량 데이터 관리: 증가하는 데이터 트랙 처리</a>
  <ul class="collapse">
  <li><a href="#시각적-복잡성-줄이는-전략-압축과-요약" id="toc-시각적-복잡성-줄이는-전략-압축과-요약" class="nav-link" data-scroll-target="#시각적-복잡성-줄이는-전략-압축과-요약"><span class="header-section-number">9.7.1</span> 시각적 복잡성 줄이는 전략: 압축과 요약</a></li>
  <li><a href="#요약의-장점과-과제" id="toc-요약의-장점과-과제" class="nav-link" data-scroll-target="#요약의-장점과-과제"><span class="header-section-number">9.7.2</span> 요약의 장점과 과제</a></li>
  </ul></li>
  <li><a href="#게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시" id="toc-게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시" class="nav-link" data-scroll-target="#게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시"><span class="header-section-number">9.8</span> 게놈 구조 변이 표현: 멀리 떨어진 게놈 위치 간 관계 표시</a>
  <ul class="collapse">
  <li><a href="#구조-변이-묘사를-위한-시각화-기법" id="toc-구조-변이-묘사를-위한-시각화-기법" class="nav-link" data-scroll-target="#구조-변이-묘사를-위한-시각화-기법"><span class="header-section-number">9.8.1</span> 구조 변이 묘사를 위한 시각화 기법</a></li>
  <li><a href="#게놈-좌표계에서-벗어나-기능적-결과에-초점" id="toc-게놈-좌표계에서-벗어나-기능적-결과에-초점" class="nav-link" data-scroll-target="#게놈-좌표계에서-벗어나-기능적-결과에-초점"><span class="header-section-number">9.8.2</span> 게놈 좌표계에서 벗어나 기능적 결과에 초점</a></li>
  </ul></li>
  <li><a href="#효과적인-데이터-시각화를-위한-검토-지점" id="toc-효과적인-데이터-시각화를-위한-검토-지점" class="nav-link" data-scroll-target="#효과적인-데이터-시각화를-위한-검토-지점"><span class="header-section-number">9.9</span> 효과적인 데이터 시각화를 위한 검토 지점</a>
  <ul class="collapse">
  <li><a href="#개념적-그림-명확한-구조화" id="toc-개념적-그림-명확한-구조화" class="nav-link" data-scroll-target="#개념적-그림-명확한-구조화"><span class="header-section-number">9.9.1</span> 개념적 그림: 명확한 구조화</a></li>
  <li><a href="#데이터-그래프-연결성-드러내기와-정확한-시각적-인코딩" id="toc-데이터-그래프-연결성-드러내기와-정확한-시각적-인코딩" class="nav-link" data-scroll-target="#데이터-그래프-연결성-드러내기와-정확한-시각적-인코딩"><span class="header-section-number">9.9.2</span> 데이터 그래프: 연결성 드러내기와 정확한 시각적 인코딩</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#이러한-검토-지점들이-효과적인-데이터-시각화를-위한-좋은-지침이-되기를-바랍니다." id="toc-이러한-검토-지점들이-효과적인-데이터-시각화를-위한-좋은-지침이-되기를-바랍니다." class="nav-link" data-scroll-target="#이러한-검토-지점들이-효과적인-데이터-시각화를-위한-좋은-지침이-되기를-바랍니다."><span class="header-section-number">10</span> 이러한 검토 지점들이 효과적인 데이터 시각화를 위한 좋은 지침이 되기를 바랍니다.</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Nature Methods 데이터 시각화 컬럼 모음</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Tip</div>
    <div class="quarto-category">Productivity</div>
    <div class="quarto-category">Visualization</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Taeyoon Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 15, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">November 1, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="learn_dataVisualization.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="learn_dataVisualization.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
<p>Bang Wong, Martin Krzywinski, Nils Gehlenborg, Cydney Nielsen, Noam Shoresh, Rikke Schmidt Kjaergaard, Erica Savig, Alberto Cairo이 Nature Methods에 데이터 시각화에 대한 컬럼을 35편 썼습니다. 이글은 이런 자료들을 더 쉽게 찾아볼 수 있도록 한곳에 모아 정리한 것으로 많은 분들이 데이터 시각화를 하는데 도움이 되길 바랍니다.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="생물학-데이터-시각화는-필수-도구" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 생물학 데이터 시각화는 필수 도구</h1>
<p>오늘날 생물학 연구에서는 방대한 양의 데이터가 쏟아져 나오고 있으며 데이터를 효과적으로 탐색하고 소통하기 위해 데이터 시각화가 필수적입니다. 데이터 시각화의 궁극적인 목표는 복잡한 데이터를 사람들이 쉽고 명확하게 이해하고 설명할 수 있도록 돕는 것입니다. 모든 생물학적 데이터에 시각화가 필요한 것은 아닙니다. 하지만 다음과 같은 경우 데이터 시각화는 강력한 이점을 갖습니다.</p>
<ul>
<li>패턴 탐색: 데이터의 규칙성을 아직 모를 때 시각화는 패턴을 찾아내는 데 효과적입니다.</li>
<li>알고리즘 보완: 자동화된 계산으로는 파악하기 어려운 데이터의 세부 사항(예: 유전체학의 구조적 변이)을 시각적으로 명확하게 이해할 수 있도록 돕습니다.</li>
</ul>
<p>결론적으로 잘 디자인된 데이터 시각화는 복잡한 인지적 평가를 직관적인 지각적 이해로 바꿔주기 때문에 데이터를 이해하는 데 강력한 도움이 됩니다. 특히 방대한 데이터가 생산되는 현대 생물학 연구에서 시각화는 매우 중요한 역할을 합니다.</p>
</section>
<section id="구성-및-레이아웃" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 구성 및 레이아웃</h1>
<section id="쉽고-명확한-정보-전달을-위한-디자인" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="쉽고-명확한-정보-전달을-위한-디자인"><span class="header-section-number">2.1</span> 쉽고 명확한 정보 전달을 위한 디자인</h2>
<p>디자인의 가장 중요한 원칙은 유용성과 기능입니다. 잘 만들어진 물건이 쓰기 쉬운 것처럼 여러분의 그래프와 포스터도 보고 이해하기 쉬워야 합니다. 훌륭한 디자인은 그 물건이 어떤 기능을 하는지 명확한 단서를 주는 것입니다. 예를 들어, 지하철 노선도는 도시의 한 곳에서 다른 곳으로 이동하는 방법을 찾는 데 매우 효율적인 도구입니다. 만약 기차 정보를 단순히 정류장과 연결 표로만 제공한다면, 두 지점 사이의 가장 빠른 길을 찾는 것은 훨씬 더 어려울 겁니다.</p>
<p>따라서 그래프를 디자인할 때는 정보를 표현하는 체계적인 방법을 사용 하는 것이 중요합니다. 다른 종류의 정보를 명확하게 구분해 독자들이 발표 내용을 쉽게 이해할 수 있게 해야합니다.</p>
<p>또한 탄탄한 디자인 아이디어 개념과 뛰어난 기술 실행 능력이 좋은 결과물을 만드는 데 필요합니다. 디자인은 탐색적인 과정이므로 머릿속의 아이디어를 현실로 만들고 필요에 따라 그래픽 요소를 다듬을 수 있는 능력이 필요합니다. 그러니 그래픽 소프트웨어를 능숙하게 다룰 수 있도록 시간을 투자하세요.</p>
</section>
<section id="레이아웃-정보-전달을-위한-시각적-정리의-기술" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="레이아웃-정보-전달을-위한-시각적-정리의-기술"><span class="header-section-number">2.2</span> 레이아웃: 정보 전달을 위한 시각적 정리의 기술</h2>
<p>레이아웃은 발표 자료를 명확하게 만들기 위해 글과 그림을 페이지에 보기 좋게 배치하는 작업입니다. 그래픽 디자인에서는 모든 시각적인 정보를 전달하는 데 레이아웃이 가장 기본이 됩니다. 내용을 잘 정리하면 복잡한 정보도 독자들이 쉽게 따라갈 수 있지만 자료가 뒤죽박죽이면 독자들을 헷갈리게 합니다.</p>
<p>많은 예술가들은 ’황금 비율’이라는 특별한 수학적 관계를 사용합니다. 황금 비율은 어떤 선을 두 부분으로 나눴을 때, 전체 길이와 긴 부분의 비율이 긴 부분과 짧은 부분의 비율과 같아지는 것을 말합니다(대략 13:8 비율). 또한 황금 비율과 관련이 있는 ’피보나치 수열’은 그래픽 디자인에 많은 영향을 줍니다.(예 1, 2, 3, 5, 8, 13 등). 피보나치 숫자는 사용해 글꼴 크기나 책 페이지 레이아웃을 결정에 자주 사용되기 때문이죠.</p>
<p>황금 비율을 실제로 활용하는 방법은 우리가 만드는 슬라이드와 포스터에 조화로운 비율을 적용하는 것입니다. 이는 단순히 예술적인 이유뿐만이 아닙니다. 페이지에 요소를 어디에 배치하느냐에 따라 의미를 전달할 수 있기 때문입니다. 황금 비율을 간단하게 적용한 것이 바로 ‘삼등분할 법칙’입니다. 이 법칙은 페이지를 가로세로로 3등분 하여 총 9개의 구획을 만들고, 이 선을 따라 또는 선이 교차하는 지점(이른바 ’파워 포인트’)에 중요한 요소를 배치하면 시각적으로 더 눈에 띄게 됩니다. 시선 추적 연구에 따르면 사람들은 이미지를 볼 때 이러한 선으로 표시된 영역에 시선이 더 오래 머무는 경향이 있다고 합니다.</p>
<p>’그리드’를 사용하여 레이아웃을 잡으면 내용의 크기나 배치를 대충 짐작하지 않아도 되므로 디자인 과정을 훨씬 쉽게 만들 수 있습니다. 작업을 시작하기 전에 파워포인트나 어도비 일러스트레이터 같은 프로그램에서 미리 안내선(가이드)을 전략적으로 배치해보세요. 그리드는 내용을 고정시켜 디자인 전체에 안정감을 주고, 슬라이드 간의 일관성을 만들어 독자들이 다음에 나올 내용이 어디쯤에 나타날지 예상할 수 있도록 돕습니다.</p>
<p>레이아웃은 단순히 그리드 선을 그리는 것이 아니라 독자의 시선이 어떤 경로로 움직이기를 원하는지 계획하는 과정입니다. 이는 내용의 중요도를 파악하여 무엇을 먼저 읽고 무엇을 나중에 읽을지 명확하게 보여주는 것입니다.</p>
<p>우리는 모든 자료에 똑같은 시각적 내용으로 가득 찬 슬라이드와 포스터를 종종 보게 됩니다. 이런 경우 어디서부터 읽어야 할지 알기 어렵습니다. 전설적인 그래픽 디자이너 폴 랜드는 “대비가 없으면 죽은 것이나 마찬가지다”라고 말했습니다. 이처럼 레이아웃은 그래픽 디자인의 기본이자 정보 이해에 큰 영향을 줍니다.</p>
</section>
<section id="게슈탈트-이론" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="게슈탈트-이론"><span class="header-section-number">2.3</span> 게슈탈트 이론</h2>
<p>게슈탈트 이론은 사람들이 시각 정보를 어떻게 인식하고 정리하는지를 설명하기 위해 1920년대에 제안된 심리학 이론입니다. 독일어로 ‘형태’ 또는 ’형식’을 뜻하는 ’게슈탈트’는 우리가 개별적인 시각적 요소들을 모아 하나의 ’통합된 전체’로 인식하는 방식을 설명합니다.</p>
<p>게슈탈트는 부분과 전체의 상호작용을 강조합니다. 게슈탈트 심리학의 창시자 중 한 명인 쿠르트 코프카는 “전체는 부분의 합과는 다르다”고 말했습니다. 단순히 각 부분의 합을 넘어서는 새로운 의미가 창출된다는 점입니다. 이 이론의 핵심 개념은 그룹화입니다. 우리는 비슷하게 보이거나, 가까이 배치되거나, 선으로 연결되거나, 공통된 공간 안에 둘러싸인 객체들을 함께 속한 것으로 인식하는 경향이 있습니다. 이는 정보에 대한 맥락을 구축하는 강력한 방법입니다.</p>
<section id="유사성-원리" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="유사성-원리"><span class="header-section-number">2.3.1</span> 유사성 원리</h3>
<p>유사성 원리는 우리가 시각적으로 비슷한 요소들을 한 그룹으로 묶어 인식하는 경향을 설명합니다. 즉, 색상, 크기, 모양 등이 비슷한 것들은 서로 관련이 있다고 생각하는 것이죠. 이 원리는 데이터 시각화에서 범주를 구분할 때 흔히 사용됩니다. 또한, 글꼴, 글꼴 크기, 방향, 여백과 같은 그래픽 처리 방식을 반복적으로 사용하여 문서 내의 요소들이 서로 더 관련 있어 보이도록 디자인할 수 있습니다.</p>
</section>
<section id="근접성-원리" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="근접성-원리"><span class="header-section-number">2.3.2</span> 근접성 원리</h3>
<p>근접성 원리는 서로 가까이 배치된 객체들을 한 그룹으로 인식하는 경향을 말합니다. 이 원리는 그림 패널을 배열할 때 유용하게 적용됩니다. 예를 들어, 여러 개의 패널이 균일하게 떨어져 있을 때는 무엇을 기준으로 분석해야 할지 모호할 수 있습니다. 하지만 비교해야 할 패널들을 가깝게 배치하여 그룹화하면, 독자는 자연스럽게 그 관계를 파악하게 됩니다. 반대로, 패널을 순서대로 읽도록 유도하고 싶다면 한 줄로 배열하는 것이 효과적입니다.</p>
</section>
<section id="연결성-및-폐쇄성-원리" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="연결성-및-폐쇄성-원리"><span class="header-section-number">2.3.3</span> 연결성 및 폐쇄성 원리</h3>
<p>연결성 원리는 선이나 다른 시각적 연결 고리로 이어진 객체들을 통합된 그룹으로 인식하는 경향입니다. 유사성이나 근접성으로 묶인 객체들이 느슨한 연합으로 보이는 반면, 선으로 연결하면 연결성 원리에 의해 객체들을 훨씬 더 강하게 연관되게 보입니다.</p>
<p>폐쇄성 원리는 공통된 영역 안에 요소들이 둘러싸여 있을 때 하나의 그룹으로 인식하는 경향을 말합니다. 이 원리는 유사성, 근접성, 심지어 연결성보다도 강력하게 객체들을 통합된 전체로 묶어줍니다.</p>
</section>
<section id="시각적-완성-원리" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="시각적-완성-원리"><span class="header-section-number">2.3.4</span> 시각적 완성 원리</h3>
<p>시각적 완성(Visual Completion), 또는 시각적 보간(interpolation)은 실제로 존재하지 않는 윤곽선을 보게 되는 흥미로운 착시 현상을 만듭니다. 우리는 가능한 보이는 것에서 패턴을 찾으려는 경향이 있습니다. 따라서 우리는 프레젠테이션을 어지럽히는 불필요한 선, 상자, 글머리 기호 및 기타 그래픽 요소를 생략하여 깔끔하고 효과적인 디자인을 해야합니다.</p>
</section>
<section id="연속성-원리" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="연속성-원리"><span class="header-section-number">2.3.5</span> 연속성 원리</h3>
<p>우리 눈은 작은 정렬 불일치에도 매우 민감합니다. 이것을 연속성(Continuity) 원리라고 합니다. 따라서 시각적 요소를 가이드에 맞춰 정렬하는 것이 보는 사람이 패턴을 식별하는 데 도움이 됩니다. 그래서 정렬 가이드를 사용하여 구성된 그림은 깔끔하고 전문적으로 보이게 됩니다.</p>
</section>
</section>
<section id="여백negative-space-디자인의-숨겨진-힘" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="여백negative-space-디자인의-숨겨진-힘"><span class="header-section-number">2.4</span> 여백(Negative Space): 디자인의 숨겨진 힘</h2>
<p>여백(Negative Space)은 페이지의 여백뿐만 아니라 텍스트 블록, 이미지 사이의 간격등을 의미 합니다. 여백은 제목, 글, 그림만큼이나 디자인에 중요한 부분으로 디자인 요소들에게 숨 쉴 공간을 줄 뿐만 아니라 시각적 매력과 효과를 극적으로 향상시킬 수 있습니다.</p>
<section id="여백의-중요성" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="여백의-중요성"><span class="header-section-number">2.4.1</span> 여백의 중요성</h3>
<p>과학자의 발표 자료는 대개 내용으로 빽빽하게 채워져 있습니다. 일부 사람은 여백이 불필요하다고 여기거나 심지어 페이지가 가득 채워지지 않는다고 불평하기도 합니다. 그러나 내용이 빽빽한 없는 슬라이드와 포스터는 여백이 불규칙하기 때문에 이해하기 어렵습니다.</p>
</section>
<section id="효과적인-여백-넣기" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="효과적인-여백-넣기"><span class="header-section-number">2.4.2</span> 효과적인 여백 넣기</h3>
<p>이미지와 텍스트를 글자 그대로 또는 시각적으로 추상화된 ‘상자’ 안에 넣어서 레이아웃을 만드세요. 그러면 양의 공간과 음의 공간의 분포가 명확해집니다. 일반적인 팁을 주자면 섹션을 구분할 때 더 넓은 간격을 사용하고 섹션 내의 항목을 분리 할때는 더 얇은 간격을 사용하는 것입니다. 그리고 텍스트의 경우 글자 사이의 간격, 줄의 길이, 줄 사이의 간격을 조절해 추상화된 상자에 맞춥니다. 이런 방식의 여백은 독자에게 콘텐츠의 계층과 구성을 전달할 수 있습니다.</p>
</section>
<section id="여백으로-시선-집중시키기" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="여백으로-시선-집중시키기"><span class="header-section-number">2.4.3</span> 여백으로 시선 집중시키기</h3>
<p>여백은 독자의 주의를 끄는 가장 효과적인 방법 중 하나입니다. 강조하고 싶은 콘텐츠를 상대적으로 더 많은 여백으로 둘러싸 보세요. 페이지의 해당 부분으로 시선을 이끌 것입니다.</p>
</section>
</section>
<section id="중요한-부분-강조하기" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="중요한-부분-강조하기"><span class="header-section-number">2.5</span> 중요한 부분 강조하기</h2>
<p>두드러짐(Salience)은 객체를 주변 환경과 차별화시키는 속성입니다. 특히 슬라이드 프레젠테이션과 같은 시각 자료에서는 두드러짐과 정보의 관련성(relevance)이 일치하는지 확인하는 것이 필수적입니다. 청중이 내용을 동시에 듣고 읽는 상황이므로 정보 전달의 효율성이 무엇보다 중요하기 때문이죠.</p>
<p>예를 들어, 표의 특정 행이나 열에 색깔을 입히면 선택된 자료에 시선이 집중될 것입니다. 표 형식의 정보는 일반적으로 균일하게 보이기 때문에, 가장 중요한 것이 무엇인지 명확히 하는 것이 도움이 됩니다. 그래프에도 데이터의 특정 부분을 강조 구분을 하면 청중이 발표 내용과 시각 자료를 더 잘 이해하도록 돕는 방법이 될 수 있습니다.</p>
<section id="의도치-않은-두드러짐의-위험성" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="의도치-않은-두드러짐의-위험성"><span class="header-section-number">2.5.1</span> 의도치 않은 두드러짐의 위험성</h3>
<p>반대로 부주의하게 두드러짐을 남용하면 오히려 독자에게 잘못된 메세지를 줄 수 있습니다. 예를 들어 움직이는 이미지(예: 회전하는 3차원 단백질 구조)을 넣을 때는 주의해야 합니다. 왜냐하면 움직이는 이미지가 독자의 주의를 전부 집중시켜 다른 콘텐츠를 보지 못하게 합니다. 따라서 파워포인트 애니메이션은 신중하게 사용해야 하며, 움직이는 요소는 반드시 슬라이드의 주요 메시지를 뒷받침하는 콘텐츠여야 합니다.</p>
<p>동일한 콘텐츠도 어떻게 제시되느냐에 따라 이해도에 극적인 영향을 줍니다. 항상 화면에서 잠시 물러서서 무엇이 가장 두드러지는지 파악하려고 하세요. 그리고 가장 시각적으로 두드러지는 정보는 당신의 핵심 메시지여야 합니다.</p>
</section>
<section id="효과적인-글쓰기-원칙을-그림-디자인에-적용하기" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="효과적인-글쓰기-원칙을-그림-디자인에-적용하기"><span class="header-section-number">2.5.2</span> 효과적인 글쓰기 원칙을 그림 디자인에 적용하기</h3>
<p>효과적인 글쓰기 원칙을 그림 디자인에 적용하면 어려움을 극복하고 체계적인 방식으로 시각 자료를 만들 수 있습니다. 마치 글의 단어 하나하나를 다듬듯이, 그림의 각 부분도 평가하고 최적화되야 합니다.</p>
<p>핵심 원칙:</p>
<ul>
<li><p>명확성과 간결성: 복잡하고 이해하기 어려운 문장처럼 혼란스럽고 과도하게 꾸며진 그림(‘차트 잡동사니’)은 피해야 합니다. 번쩍이는 질감, 그라데이션, 불필요한 형태의 증식은 데이터를 해석하기 어렵게 만들고, 특정 부분을 강조하는 것을 방해하며 빈약한 데이터를 결코 구제할 수 없습니다.</p></li>
<li><p>평행 구조와 시각적 강조: 관련 아이디어를 시각적으로 강화하려면 ’평행 구조’를 사용하세요. 즉, 유사한 아이디어를 비슷한 시각적 형태로 표현하여 정보 간의 관계를 명확히 보여주세요. 중첩, 범주 계층, 중요성을 직관적으로 나타내는 모양과 색상을 선택하는 것이 중요합니다.</p></li>
</ul>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
</section>
</section>
</section>
<section id="데이터-시각화에서-색상" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 데이터 시각화에서 색상</h1>
<section id="색상의-선택" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="색상의-선택"><span class="header-section-number">3.1</span> 색상의 선택</h2>
<p>색상은 명확성을 더할 수 있는 강력한 도구이지만 잘못 사용하면 오히려 혼란을 초래하거나 잘못된 정보를 전달할 수 있습니다.</p>
<section id="색상의-올바른-사용법" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="색상의-올바른-사용법"><span class="header-section-number">3.1.1</span> 색상의 올바른 사용법</h3>
<ul>
<li>무지개색을 정량적 데이터에 사용하지 마세요. 무지개 색상은 그 자체로 순서에 대한 모호성이 있어 혼란을 줄 수 있습니다. 또한 특정 색상이 시각적으로 더 길거나 짧게 느껴지는 착시를 유발할 수 있습니다.</li>
<li>무지개색은 범주형 데이터에 사용하세요. 반면에 무지개색은 범주형 데이터(예: 실험 조건 구분)를 나타내는 데 효과적입니다.</li>
<li>색상 편향에 주의하세요. 특정 범주에 강렬하거나 약한 색상을 사용하면 독자에게 편향을 줄 수 있습니다. 구분 가능하면서도 시각적 가시성이 비슷한 색상을 선택하세요.</li>
</ul>
</section>
<section id="색상의-세-가지-속성과-활용법" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="색상의-세-가지-속성과-활용법"><span class="header-section-number">3.1.2</span> 색상의 세 가지 속성과 활용법</h3>
<p>모든 색상은 색조(hue), 채도(saturation), 명도(lightness)의 세 가지 속성으로 설명됩니다.</p>
<ul>
<li>색조: 색상을 빨간색, 노란색 등으로 분류하는 속성입니다.</li>
<li>채도: 색상의 순수함, 예를 들면 흰색이 거의 없는 빨간색 물체는 채도가 매우 높다고 합니다.</li>
<li>명도: 색상의 밝기 또는 어둡기를 나타냅니다.</li>
</ul>
<p>색상 선택 팁:</p>
<ul>
<li>흑백으로 변환해도 구별 가능하도록 명도를 변화시키면서 색상환을 나선형으로 통과하는 색상을 선택하세요.</li>
<li>이러한 방식으로 6~8가지 색상 그룹을 정의하는 것이 이상적입니다. 그 이상은 독특한 색상을 선택하기 어려워집니다.</li>
<li>더 많은 범주를 표시해야 한다면 색상 외에 질감(texture)의 차이를 활용할 수 있습니다(예: 빨간색 십자가와 빨간색 원).</li>
<li>시각적 개체의 크기도 중요합니다. 개체가 작거나 선이 얇을수록 색조, 채도, 명도의 더 큰 변화가 필요합니다.</li>
</ul>
</section>
<section id="색맹을-고려한-색상-사용" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="색맹을-고려한-색상-사용"><span class="header-section-number">3.1.3</span> 색맹을 고려한 색상 사용</h3>
<p>적록 색맹(protanopia/deuteranopia)은 생각보다 많이 존재합니다. 따라서 색맹 독자에게도 적합한 색상을 선택하는 것이 좋습니다. 도구 활용: 소프트웨어를 사용하여 적록 색맹인 사람들에게 이미지가 어떻게 보일지 시뮬레이션해 볼 수 있습니다.</p>
<ul>
<li><a href="https://www.vischeck.com">Vischeck</a>: 웹 기반 도구라 간편합니다.</li>
<li>DanKam 앱 (iPhone/Android): 휴대폰 카메라로 들어오는 색상 스펙트럼을 색맹인 사람들이 볼 수 있는 범위 내로 이동시킵니다.</li>
<li><a href="www.colorhelper.com">eyePilot</a> 및 <a href="www.ryobi-sol.co.jp/visolve/en/deflector.html">Visolve Deflector</a>를 사용하여 화면의 모든 색상을 조작할 수 있도록 합니다.</li>
</ul>
</section>
</section>
<section id="과한-색상-사용의-문제점" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="과한-색상-사용의-문제점"><span class="header-section-number">3.2</span> 과한 색상 사용의 문제점</h2>
<p>때로는 색상을 사용하지 않는 것이 더 나은 선택일 수 있습니다.</p>
<ul>
<li>데이터 왜곡 및 편향: 색상이 잘못 사용되면 전혀 사용하지 않는 것보다 못할 수 있습니다. 색상이 잘못된 정보를 눈에 띄게 하거나, 의미 있는 정보를 보기 어렵게 만들 수 있기 때문입니다.</li>
<li>시각적 혼란: 과도한 색상 사용은 혼란을 야기해 수많은 요소들이 우리의 주의를 끌기 위해 경쟁하게 만듭니다.</li>
</ul>
</section>
<section id="정량적-데이터의-색상-고려사항" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="정량적-데이터의-색상-고려사항"><span class="header-section-number">3.3</span> 정량적 데이터의 색상 고려사항</h2>
<p>데이터를 시각화할 때 색상 사용은 매우 중요합니다. 특히 숫자 값을 가지는 정량적 데이터는 그 특성상 색상 매핑에 신중을 기해야 합니다. 데이터의 구조에 따라 색상 선택이 달라지며, 이는 전달하고자 하는 정보의 정확성과 명확성에 큰 영향을 미칩니다.</p>
<p>데이터를 시각화하기 위해 먼저 데이터에 내재적인 순서가 있는지 없는지를 구분해야 합니다. 예를 들어 박테리아 종 목록은 순서가 없는 ’범주형 데이터’입니다. 반면 유전자 발현 값은 낮은 값부터 높은 값까지 정렬할 수 있는 ’순서가 있는 데이터’로 분류됩니다. 이런 정량적 데이터에 적절한 색상 맵을 만드는 것이 중요합니다.</p>
<p>색상은 의료 영상부터 원형 차트에 이르기까지 데이터 표현에서 가장 중요한 시각적 요소 중 하나입니다. 색상의 세 가지 주요 구성 요소인 색조(hue), 채도(saturation), 명도(lightness)를 조절함으로써 색상은 레이블링, 수량 표시, 현실 표현 또는 시뮬레이션, 활성화 및 장식과 같은 다양한 기본적인 의사소통 요구를 충족시킬 수 있습니다.</p>
<p>정량적 데이터는 그 요소들이 수치적인 척도 위에 놓여 서로의 상대적인 위치와 크기를 나타낸다는 점에서 범주형 데이터와 다릅니다. 이러한 상호 관계 때문에 데이터의 범위와 크기 변화에 지각적으로 일관된 색상 맵을 설계하는 것이 중요합니다.</p>
<section id="색상맵-고려사항" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="색상맵-고려사항"><span class="header-section-number">3.3.1</span> 색상맵 고려사항</h3>
<p>색상맵을 설계하기 전에 데이터에서 강조하고자 하는 주요 영역이나 지점을 먼저 정의해야 합니다.</p>
<ul>
<li><p>양수 또는 음수 값만 있는 데이터: 데이터에 양수 값 또는 음수 값만 있는 경우, 순차적인 색상 맵을 사용하는 것이 직관적입니다. 이는 명도만 10%에서 90% 검정까지 변화시키는 방식입니다. 이러한 색상 진행은 전체 범위에 걸쳐 균일한 전환을 만듭니다. 색상 그라디언트의 끝을 0과 이론적 최대값에 매핑하거나 관찰된 최소값과 최대값에 매핑하는 두 가지 옵션이 있습니다. 후자의 접근 방식은 시각적 표현에서 더 높은 대비가 필요하고 0이 기준점으로 관련이 없을 때 유용합니다.</p></li>
<li><p>두 개 이상의 관심 영역을 포함하는 데이터: 데이터에 양수 및 음수 값이 모두 포함되어 분포의 하단과 상단 그리고 0을 구분해야 하는 경우, 분기형(diverging, 또는 양극성) 색상 스키마가 효과적입니다. 이 스키마는 색조와 채도를 모두 사용합니다. 색조는 양수와 음수 값을 구분하는 데 사용하고(예: 빨간색과 파란색), 채도는 상대적인 크기를 나타내는 데 사용하며, 채도가 높을수록 더 큰 크기의 값을 나타내고 채도가 없으면 0을 나타냅니다.</p></li>
</ul>
</section>
<section id="색상맵에-유용한-도구들" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="색상맵에-유용한-도구들"><span class="header-section-number">3.3.2</span> 색상맵에 유용한 도구들</h3>
<p>색상 전문 지식이 없는 사용자도 적절한 색상 맵을 선택하는 데 도움을 줍니다.</p>
<ul>
<li>펜실베이니아 주립대학교의 <a href="http://colorbrewer2.org">ColorBrewer</a></li>
<li>NASA의 <a href="http://colorusage.arc.nasa.gov/ColorTool.php#1">Color Tool</a></li>
<li><h1 id="데이터-그림의-요소" data-number="4"><span class="header-section-number">4</span> 데이터 그림의 요소</h1></li>
</ul>
</section>
</section>
<section id="타이포그래피" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="타이포그래피"><span class="header-section-number">4.1</span> 타이포그래피</h2>
<p>타이포그래피는 글자를 배열하는 기술이자 예술입니다.</p>
<section id="서체와-글꼴의-이해" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="서체와-글꼴의-이해"><span class="header-section-number">4.1.1</span> 서체와 글꼴의 이해</h3>
<p>서체(typeface)의 글자 형태는 세리프(serif)와 산세리프(sans serif)로 나뉩니다.</p>
<ul>
<li>세리프 서체: 대체로 얇고 더 격식 있으며 ‘serif’ 부분이 눈이 줄을 따라가는 데 도움이 되므로 여러 줄의 텍스트 블록에서 읽기 쉽습니다.</li>
<li>산세리프 서체: 글자 형태가 더 단순하고 긴 텍스트에서는 가독성이 떨어진다고 주장하므로 제목이나 레이블과 같은 짧은 텍스트에 적합합니다. 일반적으로 슬라이드에는 산세리프 글꼴이 잘 어울리고 포스터나 인쇄물에는 세리프 글꼴이 적합합니다.</li>
</ul>
</section>
<section id="서체-선택의-원칙" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="서체-선택의-원칙"><span class="header-section-number">4.1.2</span> 서체 선택의 원칙</h3>
<p>가장 흔한 네 가지 서체는 Baskerville, Helvetica, Palatino, Times New Roman입니다. 제일 간단한 조언은 컴퓨터에 이 네 가지 서체를 설치하고 문서를 작성하라는 것입니다. 그렇게 하면 통일성을 가질 수 있으며 다른 컴퓨터에서 일관성있게 보여질 수 있을 것입니다. 물론 다양한 서체를 조합해 사용할 수 있지만 이는 세심한 주의와 기술을 요합니다.</p>
</section>
<section id="간격-조정과-문서-구조화" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3" class="anchored" data-anchor-id="간격-조정과-문서-구조화"><span class="header-section-number">4.1.3</span> 간격 조정과 문서 구조화</h3>
<p>타이포그래피는 문서의 분위기를 드러내고 텍스트의 구조와 의미를 명확히 할 수 있습니다. 또한 단어, 구문, 문장 및 텍스트 블록은 그들의 근본적인 의미에 따라 간격을 두어야 합니다. 단락 사이의 간격은 줄 사이의 간격보다 커야 하며, 목록 항목은 서로 관련되어 보이지만 인접 텍스트와는 분리되도록 간격을 두어야 합니다. 게슈탈트 원리에 따라 정렬되거나 서로 가까이 배치된 개체는 함께 속하는 것으로 인식됩니다.</p>
<p>의미 있는 간격을 가진 텍스트를 만들려면 ‘단락 앞 간격’ 및 ‘단락 뒤 간격’ 설정을 사용하세요. 이 설정은 <code>글꼴 메뉴 &gt; 단락</code>(파워포인트) 또는 <code>서식 메뉴 &gt; 단락</code>(워드)에서 찾을 수 있습니다. 예를 들어 단락 텍스트는 뒤에 5포인트 간격이 설정되고, 글머리 기호 목록은 뒤에 3포인트 간격이 설정될 수 있습니다. 또한 왼쪽 정렬된 텍스트는 들쭉날쭉한 오른쪽 가장자리를 남기는데 <code>Shift + Enter</code>을 사용해 수동으로 줄을 끊으면 더 규칙적으로 만들 수 있습니다.</p>
</section>
<section id="단순함과-통일성의-미덕" class="level3" data-number="4.1.4">
<h3 data-number="4.1.4" class="anchored" data-anchor-id="단순함과-통일성의-미덕"><span class="header-section-number">4.1.4</span> 단순함과 통일성의 미덕</h3>
<p>대부분의 문서는 하나의 서체를 사용하고 최대 두세 가지 글자 크기로 볼드체와 이탤릭체를 적절히 사용하면 완벽하게 작성할 수 있습니다. 이렇게 글꼴과 글꼴 처리의 변화를 제한함으로써 슬라이드나 포스터에 제시될 시각 정보의 구성을 통일할 수 있습니다. 통일된 타이포그래피 요소들이 문서를 더 읽기 쉽게 만듭니다.</p>
</section>
<section id="축" class="level3" data-number="4.1.5">
<h3 data-number="4.1.5" class="anchored" data-anchor-id="축"><span class="header-section-number">4.1.5</span> 축</h3>
<p>데이터에 좌표 시스템이 있다면 그림의 축은 독자의 방향을 잡아주는 기반이자 핵심입니다.</p>
<ul>
<li>축의 두께: 축의 두께는 적당해야 합니다. 0.5pt면 충분하며 그림이 특별히 크지 않다면 사방을 축으로 둘러싸는 것을 피해야 합니다.</li>
<li>화살표 사용 지양: 축에 화살표를 배치하는 것을 자제하세요. 축의 방향은 거의 의심할 여지가 없습니다.</li>
<li>다중 패널 그림의 스케일: 다중 패널 그림은 가능한 한 고정된 스케일을 유지해 비교하기 쉬워야 합니다.</li>
</ul>
</section>
<section id="눈금" class="level3" data-number="4.1.6">
<h3 data-number="4.1.6" class="anchored" data-anchor-id="눈금"><span class="header-section-number">4.1.6</span> 눈금</h3>
<p>눈금이 너무 빽빽하게 있으면 가독성이 떨어집니다.</p>
</section>
<section id="그리드" class="level3" data-number="4.1.7">
<h3 data-number="4.1.7" class="anchored" data-anchor-id="그리드"><span class="header-section-number">4.1.7</span> 그리드</h3>
<p>그리드는 비율을 비교하고 위치를 축 눈금과 연관시키는 시선(sight lines)으로 사용됩니다. 궁극적으로는 잘못된 그리드보다 그리드가 없는 것이 나을 수도 있습니다. 그리드는 기본적으로 사용하기보다는 필요할 때만 사용하세요.</p>
</section>
<section id="레이블" class="level3" data-number="4.1.8">
<h3 data-number="4.1.8" class="anchored" data-anchor-id="레이블"><span class="header-section-number">4.1.8</span> 레이블</h3>
<p>그림의 레이블은 하나의 고정된 크기를 사용하고, 게슈탈트 원리에 따라 하나의 그룹으로 정렬되야 합니다. 또한 레이블의 내용은 간결하지만 명확해야 합니다.</p>
</section>
</section>
<section id="심볼-명확하고-의미-있는-데이터-표현" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="심볼-명확하고-의미-있는-데이터-표현"><span class="header-section-number">4.2</span> 심볼: 명확하고 의미 있는 데이터 표현</h2>
<p>데이터 포인트 심볼은 산점도(scatter plot)에서 시각적인 패턴과 변수 간의 관계를 파악하는 데 도움이 됩니다. 잘 선택된 심볼은 데이터 가려짐(occlusion)을 줄이고 다양한 데이터 범주의 시각적 독립성을 유지하는 데 도움이 됩니다.</p>
<section id="단일-데이터-범주에서의-심볼" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="단일-데이터-범주에서의-심볼"><span class="header-section-number">4.2.1</span> 단일 데이터 범주에서의 심볼</h3>
<p>단일 데이터 범주를 가진 플롯에서는 겹치는 심볼로 인해 발생하는 데이터 가려짐을 최소화하는 것이 가장 중요합니다. 이 경우 속이 빈 원이 최선의 선택입니다. 다른 일반적인 기하학적 모양(사각형, 삼각형, 마름모 등)과 달리, 원은 다른 원과 교차되도 새로운 원을 만들지 않습니다. 그리고 속이 빈 형태의 장점은 겹치는 부분이 페이지에 더 밀도 높은 잉크 영역을 만들어 실용적인 밀도 맵을 대체할 수 있습니다.</p>
</section>
<section id="다중-데이터-범주에서의-심볼" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="다중-데이터-범주에서의-심볼"><span class="header-section-number">4.2.2</span> 다중 데이터 범주에서의 심볼</h3>
<p>여러 데이터 범주는 강력한 시각적 경계를 형성하는 뚜렷한 심볼로 인코딩되어야 합니다. 모양이 유사한 심볼은 특히 심볼이 겹치는 영역에서 데이터를 식별하기 어려울 수 있습니다.</p>
<p>데이터 범주 간에 명확하고 간단한 구별하는 방법은 범주 이름의 첫 글자를 플로팅 심볼로 사용하는 것입니다. 이 방법은 글자가 시각적으로 뚜렷하다면(예: H, Q, X) 독자가 범례를 반복해 확인할 필요가 없어 해석을 더 쉽게 만듭니다.</p>
<p>사용 가능하다면 색상은 매우 효과적인 구분자입니다. 그러나 색조의 수가 증가함에 따라 그 중요성이 감소하므로 신중하게 사용해야 합니다. 데이터 범주에 대한 좋은 색상 선택은 정성적 <a href="http://colorbrewer2.org/">브루어 팔레트</a>에서 찾을 수 있습니다.</p>
</section>
<section id="데이터-구조-반영" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="데이터-구조-반영"><span class="header-section-number">4.2.3</span> 데이터 구조 반영</h3>
<p>종종 데이터 포인트들은 계층 구조를 가집니다. 예를 들어 유전자의 상태(‘끔’ 또는 ‘켬’)에 따라 분류된 데이터는 구별하고 부각시키기 위해 시각적 비중(채움 및/또는 색상)을 가진 심볼을 사용하여 중요성을 나타낼 수 있습니다. 특히 관련성이 낮은 데이터(예: 맥락을 위해 포함된 참조 데이터)에는 덜 눈에 띄는 심볼을 사용하는 것이 좋습니다.</p>
</section>
<section id="심볼-수가-많을-때의-대처" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="심볼-수가-많을-때의-대처"><span class="header-section-number">4.2.4</span> 심볼 수가 많을 때의 대처</h3>
<p>심볼의 수가 많으면 구별하기 어렵습니다. 플롯에 6-7개 이상의 범주가 있다면 스몰 멀티플(small multiples)을 사용해 여러 패널로 데이터를 제시하는 것을 고려하세요.</p>
</section>
</section>
<section id="화살표" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="화살표"><span class="header-section-number">4.3</span> 화살표</h2>
<p>화살표는 가장 흔히 사용되는 그래픽 요소 중 하나입니다. 화살표는 복잡한 정보를 안내하는 매우 효율적인 시각적 의사소통 도구로 사용됩니다. 분자 생물학에서 화살표 관련 관례가 몇가지 있습니다. 예를 들어, 직각 선분과 함께 있는 화살표는 전사 시작 지점 또는 프로모터, 선과 평행하게 배치된 짧은 화살표는 일반적으로 PCR 프라이머를 나타냅니다.</p>
<section id="화살표-사용-주의점" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="화살표-사용-주의점"><span class="header-section-number">4.3.1</span> 화살표 사용 주의점</h3>
<p>화살표는 요소 자체보다는 요소 간의 기능적 관계에 주의를 집중시키는 데 가장 효과적으로 사용됩니다. 따라서 방향이나 순서를 나타내는 데 화살표를 사용하고 시스템의 구조등의 공간적 상호 관계를 강조하려면 요소를 연결할때 화살표 대신 선을 사용해야 합니다. 한 가지 예외는 현미경 사진이나 기타 영상에서 두드러진 특징을 나타내는 데는 일반적으로 화살표를 사용합니다.</p>
</section>
</section>
</section>
<section id="nature-methods-blog에-이어서" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Nature methods blog에 이어서</h1>
</section>
<section id="차트-유형" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> 차트 유형</h1>
<p>데이터와 목적에 맞는 차트 유형을 선택하는 것이 중요합니다.</p>
<section id="막대-그래프와-상자-그림" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="막대-그래프와-상자-그림"><span class="header-section-number">6.1</span> 막대 그래프와 상자 그림</h2>
<p>막대 그래프(Bar charts)와 상자 그림(Box plots)은 과학 문헌에서 매우 흔하게 사용되는 방법입니다. 특히 막대 그래프는 개수를 나타내는 데 적합하며, 상자 그림은 분포의 특성을 나타내는 데 적합합니다.</p>
<section id="막대-그래프-활용" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="막대-그래프-활용"><span class="header-section-number">6.1.1</span> 막대 그래프 활용</h3>
<p>막대 그래프는 길이를 사용하여 양을 나타냅니다. 일반적으로 아래와 같은 몇 가지 옵션이 있습니다.</p>
<ul>
<li><p>누적 막대 그래프(Stacked bar charts): 전체 양을 비교하면서 각 범주가 전체에 기여하는 바를 보여주고 싶을 때 가장 좋습니다. 흔히 여러 속성에서 순위를 시각화하는 데 사용됩니다.</p></li>
<li><p>계층형 막대 그래프(Layered bar chart): 전체 양의 분포보다는 각 범주 내 값의 분포를 모든 항목에 걸쳐 비교하는 데 주로 관심이 있을 때 적합합니다. 각 범주에 공통 기준선을 제공하므로 누적 막대 그래프보다 범주 내 비교에 더 정확합니다.</p></li>
<li><p>그룹화된 막대 그래프(Grouped bar chart): 각 항목 내에서 범주 간 값 비교를 가능하게 하면서 항목 간 비교도 가능하게 하는 것이 주 목표입니다. 각 항목의 양이 동일한 총합을 이룬다면 그룹화된 막대 그래프가 값을 더 정확하게 읽고 비교할 수 있습니다.</p></li>
</ul>
</section>
<section id="상자-그림" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="상자-그림"><span class="header-section-number">6.1.2</span> 상자 그림</h3>
<p>우리의 목표가 분포를 나타내고 비교하는 것이라면 막대 그래프보다 상자 그림이 더 좋은 선택입니다.상자 그림(Box plots), 또는 상자-수염 그림(box-and-whiskers plots)은 분포의 다섯 가지 특성을 위치와 길이로 인코딩하여 데이터를 효과적으로 요약합니다.</p>
<ul>
<li>상자: 분포의 첫 번째 사분위수(Q1)부터 세 번째 사분위수(Q3)까지를 나타내며, 사분위 범위(IQR)를 표현합니다.</li>
<li>중앙선: 상자 내부의 선은 중앙값(median)을 나타냅니다.</li>
<li>수염(Whiskers): Q1과 Q3에서 뻗어 나오는 선으로 일반적으로 Q1 – 1.5 × IQR 및 Q3 + 1.5 × IQR 이내의 가장 극단적인 데이터 포인트를 끝점으로 정의합니다.</li>
<li>이상치(Outliers): 수염 바깥의 각 이상치는 개별적인 점으로 표시됩니다.</li>
</ul>
</section>
<section id="막대-그래프와-상자-그림을-위한-권장-사항" class="level3" data-number="6.1.3">
<h3 data-number="6.1.3" class="anchored" data-anchor-id="막대-그래프와-상자-그림을-위한-권장-사항"><span class="header-section-number">6.1.3</span> 막대 그래프와 상자 그림을 위한 권장 사항</h3>
<ul>
<li>정렬: 암묵적인 항목 순서가 없는 한 막대는 높이 순서로 상자 그림은 중앙값 순서로 정렬해 쉽게 읽을 수 있도록 하세요.</li>
<li>기준선: 막대 그래프의 시작점은 0으로 하세요. 특별한 이유가 없다면 말이죠.</li>
<li>눈금 및 격자선: 데이터 해석 및 비교를 용이하게 하려면 눈금(tick marks)을 추가하고, 필요한 경우 축보다 얇은 격자선(grid lines)을 추가하여 작은 차이를 강조하세요.</li>
<li>색상: 상자와 막대는 단색으로 채우고 윤곽선은 생략하세요. 그리고 일반적으로 독자가 구별할 수 있는 최대 색상 수는 8~12개 입니다.</li>
</ul>
</section>
</section>
<section id="집합과-교집합" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="집합과-교집합"><span class="header-section-number">6.2</span> 집합과 교집합</h2>
<p>집합(Sets)은 과학 데이터 분석에서 보편적인 개념입니다. 예를 들어 토양 샘플에서 발견된 박테리아 종, 생화학 경로에서 발견된 효소, 게놈에서 발견된 변이체, 질량 분석법으로 혈청 샘플에서 검출된 단백질, 또는 암 환자 코호트에서 돌연변이된 유전자 등 이 모든 것을 집합으로 다룰 수 있습니다. 일부 연구의 목표는 흔히 여러 집합의 공통점과 차이점을 교집합을 통해 분석하는 작업이 이루어집니다.</p>
<p>집합과 그 교집합은 3~4개 정도까지는 시각화하기 쉽습니다. 그러나 집합의 수가 늘러나면 쉽지 않습니다. 예를 들어 3개의 집합은 8가지 가능한 교집합을 갖는 반면, <span class="math inline">\(n\)</span>개의 집합에 대해 <span class="math inline">\(2^n\)</span>가지 가능한 교집합이 존재하므로 10개의 집합은 1,024가지 가능한 교집합을 갖기 때문입니다.</p>
<section id="오일러-다이어그램과-벤-다이어그램" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="오일러-다이어그램과-벤-다이어그램"><span class="header-section-number">6.2.1</span> 오일러 다이어그램과 벤 다이어그램</h3>
<p>집합의 교집합은 일반적으로 오일러 다이어그램(Euler diagrams) 또는 벤 다이어그램(Venn diagrams)을 사용해 시각화 합니다.</p>
<ul>
<li>오일러 다이어그램: 교집합을 겹치는 모양(일반적으로 원이나 타원)으로 나타냅니다. 이 모양들은 종종 면적이 나타내는 요소의 수에 비례하도록 그려집니다.</li>
<li>벤 다이어그램: 오일러 다이어그램과 동일하지만 모든 가능한 교집합(비어 있는 교집합 포함)을 보여준다는 점에서 차이가 있습니다. 오일러 다이어그램에서는 비어 있는 교집합을 그리지 않습니다.</li>
</ul>
<p>오일러 다이어그램은 2~3개의 교집합 크기를 나타내는 데 적합하며 만드는 도구는 <a href="http://www.eulerdiagrams.org/eulerAPE/">EulerAPE</a>를 추천합니다.</p>
</section>
<section id="다수-집합-교집합-시각화" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="다수-집합-교집합-시각화"><span class="header-section-number">6.2.2</span> 다수 집합 교집합 시각화</h3>
<p>3개 이상의 집합에 대한 교집합을 효과적으로 시각화하려면 다른 접근법이 필요합니다.</p>
<ul>
<li>이진 패턴 및 막대 사용: 모든 집합 교집합을 이진 패턴을 사용하여 행렬의 열에 인코딩하고 행렬 열 위에 막대를 렌더링하여 각 교집합의 요소 수를 나타내는 것입니다.
<ul>
<li>막대는 교집합 크기의 큰 변화를 수용하기 위해 로그 변환될 수 있으며 교집합 크기의 분포를 보여주기 위해 정렬될 수 있습니다.</li>
<li>목적에 따라 막대는 집합 조합별로 정렬하여 겹치는 집합의 수에 따라 교집합을 그룹화하거나 특정 집합의 모든 교집합을 서로 옆에 배치할 수도 있습니다.</li>
<li>많은 수의 집합을 그릴 때는 공간을 절약하기 위해 비어 있는 교집합을 제거할 수 있습니다. 이러한 시각화를 웹 브라우저에서 생성하는 도구에 <a href="http://vcg.github.io/upset/">upset</a>가 있습니다.</li>
</ul></li>
<li>클러스터링된 히트맵: 10개 이상의 집합의 모든 교집합을 클러스터링된 히트맵을 사용하여 모든 쌍별 교집합 크기를 그리는 것은 좋은 시각화 방법입니다.
<ul>
<li>집합 크기는 히트맵의 행이나 열을 따라 막대 그래프로 그려야 합니다.</li>
<li>다만 이 히트맵의 단점은 고차 교집합에 대한 정보가 숨겨진다는 것입니다.</li>
</ul></li>
</ul>
<p>교집합 수가 많아지는 경우 시각화할 때는 거의 항상 절충(trade-offs)이 필요합니다. 그러니 시각화에 따른 장단점을 이해하고 데이터 구조를 인식하는 것이 필수적입니다.</p>
</section>
</section>
<section id="히트맵" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="히트맵"><span class="header-section-number">6.3</span> 히트맵</h2>
<p>히트맵은 2차원 숫자 데이터를 색상의 음영으로 표현하는 시각화 기법입니다. 생물학 분야에서 유전자 발현과 같은 대량의 다변량 데이터를 밀도 높고 직관적으로 보여주는 데 널리 사용됩니다. 수백 개의 행과 열을 한 화면에 표시할 수 있다는 장점이 있습니다. 히트맵은 기본적으로 색상 인코딩과 행 및 열의 의미 있는 재정렬에 의존합니다. 이 두 가지 요소 중 하나라도 제대로 적용되지 않으면 시각화의 유용성이 크게 떨어질 수 있습니다.</p>
<section id="색상을-지정하는-문제와-해결책" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="색상을-지정하는-문제와-해결책"><span class="header-section-number">6.3.1</span> 색상을 지정하는 문제와 해결책</h3>
<p>숫자를 색상으로 나타내는 것은 오래된 아이디어이지만 색상은 상대적인 매체이므로 개별적인 값을 표현하는 데에는 신뢰성이 떨어질 수 있습니다. 같은 색상이라도 주변 셀의 색상에 따라 다르게 보일 수 있기 때문이죠. 따라서 우리가 ‘봐야 할 것’과 ’실제로 보는 것’ 사이의 불일치를 고려하여 효과적인 색상 맵을 설계해야 합니다.</p>
<p>히트맵은 일반적으로 다양한 값의 범위를 보여주므로, 해당 스펙트럼의 한쪽 또는 양쪽 끝을 강조하기 위한 적절한 색상 맵을 설계하는 것이 중요합니다.</p>
<ul>
<li>발산형(Divergent) 색상 그라디언트: 낮은 값과 높은 값을 모두 강조할 때 좋습니다. 세 가지 색조(예: 파란색-흰색-빨간색)로 정의된 그라디언트는 범위의 양 끝을 시각적으로 명확하게 구분합니다.</li>
<li>단일 색조의 명도 변화 그라디언트: 한쪽 극단(가장 높거나 낮은 값)을 강조할 때 효과적입니다. 예를 들어 10%에서 90% 검정까지의 회색조는 선형적인 색상 변화를 잘 보여줍니다.</li>
<li>피해야 할 색상 조합: 빨간색-초록색 조합은 피해야 합니다. 색맹인 사람들이 어려움을 겪을 수 있기 때문입니다.</li>
</ul>
</section>
<section id="클러스터링의-중요성과-히트맵의-한계" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="클러스터링의-중요성과-히트맵의-한계"><span class="header-section-number">6.3.2</span> 클러스터링의 중요성과 히트맵의 한계</h3>
<p>적절한 색상 스케일과 함께 사용될 때 클러스터링은 히트맵에서 데이터의 구조를 파악하는 능력을 극적으로 향상시킬 수 있습니다. 행과 열이 유사성에 따라 재배열되면 패턴이 명확해집니다. 하지만 계층적 클러스터링은 몇 가지 시각화 문제를 야기합니다.</p>
<ul>
<li>다양한 배열 가능성: <span class="math inline">\(n\)</span>개의 행 또는 열이 클러스터 트리에 의해 연결될 때 <span class="math inline">\(2^{n-1}\)</span>가지의 가능한 배열이 존재하므로 하나의 히트맵은 가능한 많은 결과 중 하나일 뿐입니다.</li>
<li>관계 정보의 가려짐: 클러스터링은 일반적으로 매트릭스 양쪽에 표시되는 클러스터 트리에서 유용한 관계 정보를 생성합니다. 하지만 선형 순서화는 클러스터 트리에 반영된 중요한 관계를 가릴 수 있습니다.</li>
</ul>
<p>행과 열이 모두 클러스터링된 히트맵은 유사한 색상의 셀 블록을 생성하여 패턴을 쉽게 발견하게 합니다. 그러나 열에 내재된 순서가 있는 데이터(예: 시계열 또는 용량-반응 연구)를 히트맵으로 시각화할 때는 행에만 클러스터링이 적용됩니다. 이런 데이터에서는 한 행에 걸친 색상 시퀀스의 변동이 시간이나 농도와 어떻게 관련되는지 이해하는 것이 필요합니다. 이런 경우 평행 좌표 플롯(parallel coordinate plot)이 효과적인 대안이 될 수 있습니다.</p>
<ul>
<li>정확한 값 읽기: 공간 인코딩에 의존하여 절대값을 더 정확하게 읽을 수 있습니다.</li>
<li>경향 이해 용이: 색상보다는 물결 모양의 프로파일 그래프로 복잡한 경향을 더 쉽게 이해할 수 있습니다.</li>
<li>불일치 강조: 샘플 간의 작은 불일치를 강조하는 데 특히 적합합니다.</li>
</ul>
<blockquote class="blockquote">
<p>주의할 점: 평행 좌표 플롯은 정보를 겹쳐서 보여주기 때문에 수십 개 이상의 프로파일을 그릴 경우 구별하기 어려울 수 있습니다.</p>
</blockquote>
</section>
</section>
<section id="시계열-데이터" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="시계열-데이터"><span class="header-section-number">6.4</span> 시계열 데이터</h2>
<p>시간은 연구에서 핵심적인 역할을 합니다. 왜냐하면 시간은 사건에 대한 자연스러운 순서를 제공하며 종종 주기적이고 반복적인 패턴을 보여주기 때문입니다. 일반적으로 시계열 데이터를 시각화하는 방법은 위치, 밝기 또는 채도, 그리고 애니메이션을 사용하는 것입니다.</p>
</section>
<section id="서브플롯으로-복잡한-데이터-풀어내기" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="서브플롯으로-복잡한-데이터-풀어내기"><span class="header-section-number">6.5</span> 서브플롯으로 복잡한 데이터 풀어내기</h2>
<p>서브플롯은 요인 실험(Factorial experiments)은 독립 변수(예: 용량, 균주, 온도 또는 성별)의 다양한 조합이 반응 변수에 미치는 영향을 조사하는 데 자주 사용됩니다. 서브 플롯은 데이터를 작은 다중 그래프(small multiples)로 구성하는 방법이며 각 그래프는 서로 다른 범위에 맞게 잘리고 조정되어 상대적인 변화를 강조하면서도 전체 데이터 범위의 맥락을 보존하여 절대적인 변화를 보여줍니다. 이런 전략은 비선형 스케일링(예: 로그, 프로빗, 로짓 또는 역수)과 함께 사용하여 동적 범위와 해상도를 높이고, 가우시안 및 S자형 데이터를 선형화할 수 있습니다.</p>
<section id="최소값과-최대값이-다른-데이터-다루기" class="level3" data-number="6.5.1">
<h3 data-number="6.5.1" class="anchored" data-anchor-id="최소값과-최대값이-다른-데이터-다루기"><span class="header-section-number">6.5.1</span> 최소값과 최대값이 다른 데이터 다루기</h3>
<p>데이터 범주가 최소값과 최대값 모두에서 다를 때 단일 플롯은 패턴을 모호하게 만들 수 있습니다. 서브 플롯은 관심 있는 패턴과 측정 지표를 강조하기 위해 다양한 방식으로 개별적으로 스케일링될 수 있습니다.</p>
<ul>
<li>종횡비의 중요성: 플롯의 종횡비(aspect ratio) 선택은 기울기가 어떻게 인지되고 비교되는지에 영향을 미칩니다. 평균 트레이스가 45도를 향하도록 종횡비를 선택하는 것이 유용합니다.</li>
<li>전체 및 잘린 범위 쌍: 전체 및 잘린 범위를 보여주는 작은 다중 그래프 쌍은 절대값의 차이를 강조하고, 각 범주의 범위에 걸친 패턴과 상관관계를 보여줍니다.</li>
</ul>
</section>
</section>
<section id="경로-다이어그램" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="경로-다이어그램"><span class="header-section-number">6.6</span> 경로 다이어그램</h2>
<p>경로 다이어그램은 생물학적 시스템에서 연결성과 정보의 흐름을 설명합니다. 세포 신호 전달 경로에서부터 전 지구적 생태계 네트워크에 이르기까지 놀랍도록 유사한 표현 방식으로 모든 것을 묘사할 수 있습니다.</p>
<section id="시각적-그룹핑과-정렬로-정보-흐름-강조" class="level3" data-number="6.6.1">
<h3 data-number="6.6.1" class="anchored" data-anchor-id="시각적-그룹핑과-정렬로-정보-흐름-강조"><span class="header-section-number">6.6.1</span> 시각적 그룹핑과 정렬로 정보 흐름 강조</h3>
<p>시각적 그룹핑을 사용하여 경로 레이아웃에서 정보 흐름의 계층 구조를 만들고 명확한 정렬을 통해 노드 관계를 강조할 수 있습니다.</p>
<ul>
<li>엣지 디자인: 엣지는 노드 모양의 고정된 수의 점에 연결되어야 합니다. 불필요한 스타일링이나 화살표의 늘림을 피하고, 기본적인 화살촉을 사용해야 합니다. 엣지 각도는 30° 또는 45°의 배수로 제한해야 하며, 곡선 엣지는 원형 가이드를 사용하여 쉽게 그릴 수 있습니다. 엣지에는 0.5pt 선을 사용하고, 변의 길이가 2.5pt인 정삼각형 화살촉을 사용하는 것이 좋습니다.</li>
<li>정보 흐름 방향: 일반적으로 정보는 왼쪽에서 오른쪽으로, 위에서 아래로 흐를 것으로 예상됩니다. 이 표준에서 벗어나거나 레이아웃에 비대칭을 도입하는 것은 차이점을 강조할 수 있지만, 독자의 이해를 돕는 경우에만 드물게 사용해야 합니다. 상류 노드로 되돌아가는 엣지는 시계 방향으로 흐르도록 해야 합니다.</li>
<li>그리드 정렬: 노드를 그리드에 배치하면 그림 전체에 걸쳐 시선의 움직임을 돕습니다. 노드의 수평 정렬은 경로를 통한 정보의 흐름을 강조하는 반면, 방사형 정렬은 원천 노드를 강조합니다. 엣지 교차나 화살촉 충돌을 피하기 위해 그리드 패턴에서 국소적인 벗어남이 필요할 수 있습니다.</li>
</ul>
</section>
<section id="연결성-및-포함으로-관계-표현" class="level3" data-number="6.6.2">
<h3 data-number="6.6.2" class="anchored" data-anchor-id="연결성-및-포함으로-관계-표현"><span class="header-section-number">6.6.2</span> 연결성 및 포함으로 관계 표현</h3>
<p>경로 구성 요소 간의 강한 관계는 연결(connection)과 포함(enclosure)을 사용하여 설명할 수 있습니다.</p>
<ul>
<li>연결: 엣지는 연결을 통해 노드를 그룹화하는 역할을 합니다.</li>
<li>포함: 핵과 같이 공유 구획 내에서 노드를 그룹화하는 데 사용할 수 있습니다.</li>
</ul>
</section>
<section id="유사성-및-근접성으로-그룹핑-강화" class="level3" data-number="6.6.3">
<h3 data-number="6.6.3" class="anchored" data-anchor-id="유사성-및-근접성으로-그룹핑-강화"><span class="header-section-number">6.6.3</span> 유사성 및 근접성으로 그룹핑 강화</h3>
<p>노드를 유사성(예: 색상 또는 모양)이나 근접성(proximity)을 통해 연결하면 연결 및 포함으로 생성된 그룹핑을 방해하지 않고 경로의 특정 부분을 강조할 수 있습니다.</p>
<ul>
<li>유사성 그룹: 효과적인 유사성 그룹을 만들려면 노드를 강조하는 데 사용되는 경우를 제외하고는 노드 색상이나 모양의 불필요한 변화를 피해야 합니다.</li>
<li>근접성 그룹: 네거티브 공간(negative space), 즉 그룹 주위의 그리드에 빈 행이나 열을 사용하여 시각적 강조를 추가함으로써 근접성 그룹핑을 달성할 수 있습니다.</li>
<li>차이점 식별: 특정 단백질 클래스와 관련된 레이블이나 모호하지 않은 모양으로 차이점을 식별할 수 있습니다. 예를 들어, GPCR의 7개 막 관통 도메인과 녹색 복합체로서 G 단백질을 보여줄 수 있습니다.</li>
</ul>
<p>경로 다이어그램에서 그룹핑을 사용하면 대체 시각적 진입점을 제공할 수 있습니다. 복잡한 경로에서는 가능한 모든 경로를 처음부터 끝까지 따라가기가 어려울 수 있습니다. 중요한 노드 하위 유형을 쉽게 식별할 수 있다면, 경로 다이어그램을 엄격하게 순차적으로가 아니라 여러 방향에서 탐색할 수 있습니다.</p>
</section>
<section id="노드-레이블링의-어려움과-해결책" class="level3" data-number="6.6.4">
<h3 data-number="6.6.4" class="anchored" data-anchor-id="노드-레이블링의-어려움과-해결책"><span class="header-section-number">6.6.4</span> 노드 레이블링의 어려움과 해결책</h3>
<p>노드에 레이블을 추가하는 것은 종종 어려운 일입니다. 유전자 및 단백질 복합체의 이름이 길 수 있지만, 레이블에 맞게 노드 모양을 변경하면 그룹핑 효과가 희석됩니다.</p>
<ul>
<li>레이블 길이 고려: 가장 긴 레이블을 수용할 수 있는 노드 모양을 선택하거나 이름을 약어로 사용하는 것이 좋습니다.</li>
<li>색상 및 스타일: 텍스트와의 대비 손실을 피하기 위해 노드 색상은 채도를 낮게 유지하고, 그라데이션이나 그림자와 같은 시각적 장식은 피해야 합니다.</li>
</ul>
</section>
</section>
</section>
<section id="명확한-데이터-시각화를-하는-방법" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> 명확한 데이터 시각화를 하는 방법</h1>
<section id="단순화하기" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="단순화하기"><span class="header-section-number">7.1</span> 단순화하기</h2>
<p>정보의 명확성을 높이는 핵심 전략입니다.</p>
<section id="요소-수-줄이기" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="요소-수-줄이기"><span class="header-section-number">7.1.1</span> 요소 수 줄이기</h3>
<blockquote class="blockquote">
<p>’표시’를 최소화하라</p>
</blockquote>
<p>단순화하는 가장 좋은 방법은 페이지의 요소 수를 줄이는 것입니다. 모든 그림과 텍스트 조각은 시각적 감각을 자극하고 프레젠테이션의 복잡성에 기여합니다. 목표는 세련됨을 희생하지 않으면서 메시지를 전달하기 위해 가능한 한 가장 적은 수의 ’표시(marks)’를 사용하는 것입니다. 우리의 일반적인 경향은 여백을 더 많은 정보로 채우는 것입니다. 따라서 재료를 신중하게 제거하는 것은 일반적으로 저작 과정의 자연스러운 부분이 아닙니다. 하지만 더 적게 포함함으로써 잃는 기회는 보여지는 것에 대한 더 큰 강조로 얻어집니다.</p>
<p>저는 그림이나 슬라이드의 주요 목표에 집중하는 것이 구성 요소를 줄이는 지침이 된다고 생각합니다. 이 기준에 따라 모든 구성 요소를 평가하여 정보의 계층 구조를 만들고, 불필요한 요소를 제거하며, 메시지를 지원하기 위해 나머지를 다듬습니다. 예를 들어, 두 개의 융합 유전자를 생성하는 역위 이벤트를 나타낼 때, 불필요하게 복잡한 초기 과정을 단순화할 수 있습니다. 과정의 처음 두 단계를 결합하고 이동을 나타내는 화살표 수를 줄임으로써 디자인을 단순화하고 전달력을 효과적으로 향상시킬 수 있습니다.</p>
<p>단순화함으로써 우리는 사람들이 정보를 보고 처리하는 방식을 활용하는 것입니다. 잘 정돈된 레이아웃과 깔끔한 선을 가진 단순화된 프레젠테이션은 읽는 데 더 매력적이고 더 잘 이해될 가능성이 높습니다.</p>
</section>
<section id="불필요한-요소-제거" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="불필요한-요소-제거"><span class="header-section-number">7.1.2</span> 불필요한 요소 제거</h3>
<blockquote class="blockquote">
<p>중복 피하기</p>
</blockquote>
<p>중복되는 요소를 제거하는 것은 프레젠테이션에서 추가적인 내용을 덜어내는 또 다른 방법입니다. 예를 들어, ‘반응 1’, ’반응 2’와 같이 시리즈를 나타내는 그림 레이블에서 반복을 흔히 볼 수 있습니다. 이런 경우, 레이블 간의 공통 단어를 추출하여 헤더로 사용하면 일반적으로 외관을 깔끔하게 정리할 수 있습니다. 또한, 저자들은 기본적인 다양성을 포착하기 위해 다양한 실험 구성 요소를 보여주는 경우가 있습니다. 그러나 필요 이상의 예시를 포함하면 오히려 독자를 혼란스럽게 할 수 있습니다.</p>
</section>
<section id="질서정연하게-배치" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="질서정연하게-배치"><span class="header-section-number">7.1.3</span> 질서정연하게 배치</h3>
<p>단순성은 남은 요소를 체계적으로 구성함으로써도 달성할 수 있습니다. 그룹화를 통해 많은 독립적인 부분으로 이루어진 시스템이 더 적은 수의 요소로 보이게 할 수 있습니다.</p>
<ul>
<li><p>구조 생성: 무엇을 무엇과 함께 배치할지 결정하는 것이 구조를 만드는 첫 단계입니다. 한 단계에서 다음 단계로의 동작이나 변형을 설명하는 레이블은 진행 화살표와 함께 배치되어야 합니다. 개체 설명은 이미지 옆에 배치되어야 합니다.</p></li>
<li><p>깔끔한 레이아웃: 또한, 깔끔하고 질서정연한 레이아웃은 더 단순하게 보입니다. 그룹화 외에도, 프레젠테이션에 적합한 몇 개의 가상의 수평선과 수직선에 요소를 정렬하고, 여백(negative space)에 주의를 기울여 그룹 간에 명확한 경계를 만드세요.</p></li>
</ul>
</section>
</section>
<section id="효과적인-시각화를-위한-데이터-시각화-원칙" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="효과적인-시각화를-위한-데이터-시각화-원칙"><span class="header-section-number">7.2</span> 효과적인 시각화를 위한 데이터 시각화 원칙</h2>
<p>1967년 프랑스 지도 제작자 자크 베르탕(Jacques Bertin)은 정보 시각화를 위한 광범위한 이론적 틀을 제공했습니다. 그의 분석은 양적 변화를 표시하기 위한 모양, 방향, 색상, 질감, 부피, 크기와 같은 그래픽 요소의 시각적 속성에 초점을 맞췄습니다. 그는 그래프에 저장된 정보를 추출하는 데 필요한 여러 시각적 작업을 정의했습니다.</p>
<section id="패턴과-추세-인지" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="패턴과-추세-인지"><span class="header-section-number">7.2.1</span> 패턴과 추세 인지</h3>
<blockquote class="blockquote">
<p>테이블과 그래프의 차이</p>
</blockquote>
<p>그래프는 독자가 패턴과 추세를 인지하도록 하는 것이 목표입니다. 이는 정확한 이름과 숫자를 보고하는 테이블을 통해 정보를 전달하는 것과는 다릅니다.</p>
</section>
<section id="그래프-유형별-시각적-평가와-효율성" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="그래프-유형별-시각적-평가와-효율성"><span class="header-section-number">7.2.2</span> 그래프 유형별 시각적 평가와 효율성</h3>
<p>다양한 그래프 유형은 기본 추세를 파악하기 위해 다른 시각적 평가에 의존합니다. 파이 차트는 전체의 부분을 보여주는 일반적인 방법입니다. 대부분의 독자는 파이 차트에서 정보를 추출할 때 각도를 판단할 가능성이 높지만, 조각의 면적과 호 길이를 비교할 수도 있습니다. 이러한 각 지각 작업은 효율성과 정확성 면에서 낮은 순위를 차지합니다. 동일한 데이터를 막대 차트로 그리면 상대적인 값을 효과적으로 보여줍니다.</p>
</section>
</section>
<section id="시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="시각적-두드러짐salience-그래프-가독성-향상과-정보-인코딩"><span class="header-section-number">7.3</span> 시각적 두드러짐(Salience): 그래프 가독성 향상과 정보 인코딩</h2>
<p>시각적 두드러짐은 객체를 주변 환경과 차별화시키는 시각적 특성입니다. 그 의도는 대비(contrast)를 만드는 것입니다. 예를 들면 서로 직각을 이루는 두 선은 쉽게 보이지만, 유사한 객체들 사이에서 단일 비스듬한 선을 찾는 데는 더 오랜 시간이 걸립니다.</p>
<section id="정보가-즉시-인식되어야-하는-이유" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1" class="anchored" data-anchor-id="정보가-즉시-인식되어야-하는-이유"><span class="header-section-number">7.3.1</span> 정보가 즉시 인식되어야 하는 이유</h3>
<p>정보를 즉시 인식할 수 있도록 제시해야 하는 몇 가지 이유가 있습니다.</p>
<ul>
<li>인지 부하 감소: 첫째, 청중이 관련 패턴과 추세를 파악하는 데 걸리는 시간을 줄임으로써 인지 부하를 낮춥니다. 이는 시각 및 청각 정보가 일반적으로 주의를 놓고 경쟁하는 슬라이드 및 포스터 기반 프레젠테이션에서 특히 유용합니다.</li>
<li>추가 시각 정보 처리: 둘째, 청중이 데이터의 특정 특징을 빠르게 볼 수 있도록 돕는 것은 시각 피질이 동시에 추가적인 시각 특징을 이해하도록 합니다.</li>
</ul>
<p>디자인 원칙은 상당히 간단합니다. 무언가를 쉽게 찾으려면, 그 객체의 주요 시각적 특징을 변화시켜 돋보이게 만드세요. 예를 들어, 객체에 페이지의 다른 객체와 크게 다른 색상, 크기 또는 방향을 부여하세요. 움직임(Motion)은 특히 강력한 차별화 요소입니다. 애니메이션 GIF나 튀어 오르는 아이콘이 우리의 주의를 사로잡는 능력을 생각해 보세요. 이러한 이유로, 애니메이션화되는 객체의 중요성에 비례하여 움직임 사용을 조절해야 합니다.</p>
</section>
<section id="복잡한-디자인-문제" class="level3" data-number="7.3.2">
<h3 data-number="7.3.2" class="anchored" data-anchor-id="복잡한-디자인-문제"><span class="header-section-number">7.3.2</span> 복잡한 디자인 문제</h3>
<blockquote class="blockquote">
<p>비경쟁적 시각적 특징 활용</p>
</blockquote>
<p>디자인 문제는 복잡합니다. 일반적으로 여러 매개변수를 동시에 쉽게 검색할 수 있기를 원합니다. 해결책은 경쟁하지 않는 시각적 특징을 사용하는 것입니다. 그러나 시각적 결합 검색(즉, 두 개 이상의 시각적 특징을 기반으로 대상을 찾는 것)은 집중력을 요구하며 패턴 구성을 위해 그러한 객체들을 기억 속에 유지하기 어려울 수 있으므로 얼마나 많은 특징을 서로 겹칠 수 있는지에는 한계가 있습니다.</p>
<p>시각적 두드러짐을 생성하는 것은 청중이 정보를 빠르게 처리하는 능력을 향상시킬 것입니다. 이는 강연이나 여러 통신 채널이 동시에 사용될 때 특히 유용합니다. 또한, 대비가 생성되는 다양한 방식을 아는 것은 의도치 않은 사용을 피하는 데 도움이 됩니다.</p>
</section>
</section>
</section>
<section id="다차원-데이터-시각화" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> 다차원 데이터 시각화</h1>
<section id="차원-시각화" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="차원-시각화"><span class="header-section-number">8.1</span> 3차원 시각화</h2>
<blockquote class="blockquote">
<p>공간 데이터에 효과적이지만, 다른 데이터 유형에는 거의 그렇지 않습니다.</p>
</blockquote>
<p>고차원 데이터를 다룰 때, 추가적인 데이터 차원을 사용할 수 있다는 이유로 2차원(2D) ‘평면’ 표현보다 3차원(3D) 공간 시각화를 선택하고 싶은 유혹을 느낄 수 있습니다. 그러나 정량적, 범주형 및 관계형 데이터는 종종 공간 관계를 나타내지 않으므로, 이를 3D 공간에 그리면 시각적 복잡성이 추가되어 데이터 이해를 더 어렵게 만드는 경우가 많습니다. 따라서 이러한 데이터를 2D 평면에 그리고 비공간적 그래픽 인코딩에 의존하여 추가 차원을 나타내는 것이 더 효과적일 수 있습니다.</p>
</section>
<section id="차원-시각화이-필요한-경우" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="차원-시각화이-필요한-경우"><span class="header-section-number">8.2</span> 3차원 시각화이 필요한 경우</h2>
<p>특정 유형의 데이터에는 3D 공간 시각화가 최선의 선택입니다. 예를 들어, X선 결정학 데이터는 분자 내 원자의 위치를 설명하므로 본질적으로 공간적인 것을 특징짓습니다. 이러한 원자의 3D 공간 구성을 시각화함으로써 분자 구조를 드러낼 수 있습니다. 공간 데이터는 측정값의 3D 위치 정보를 반영하는 시각적 표현에 적합합니다. 이는 종종 데이터 해석에 결정적인 역할을 합니다.</p>
<p>객체의 2차원 투영은 깊이를 나타내는 시각적 단서를 사용하여 3차원을 표현합니다. 깊이를 나타내는 가장 강력한 시각적 단서는 부분 가려짐(partial occlusion)으로 한 객체가 다른 객체의 일부를 가리는 것입니다. 또 다른 깊이 단서는 평행선이 수렴하여 만들어지는 원근감(perspective)으로 특정 시점에서 객체까지의 거리를 추정할 수 있게 합니다. 이러한 깊이 단서는 2D 디스플레이에서 3D 객체를 묘사하는 데 필수적입니다.</p>
<section id="차원-시각화의-단점" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="차원-시각화의-단점"><span class="header-section-number">8.2.1</span> 3차원 시각화의 단점</h3>
<p>예를 들어, 객체의 높이나 길이가 원근감에 의해 왜곡될 수 있어, 플롯 내 요소의 스케일을 판단하기 어렵게 만듭니다. 피할 수 없이, 전경의 데이터 객체는 시청자로부터 더 멀리 떨어진 요소의 가시성을 방해할 것입니다. 또한, 색상이 양을 나타내는 데 사용될 때, 컴퓨터 소프트웨어로 묘사되는 객체에 드리워지는 음영이나 그림자는 추가적인 모호성을 유발할 수 있습니다.</p>
</section>
<section id="차원과-3차원시각화를-선택하는-방법" class="level3" data-number="8.2.2">
<h3 data-number="8.2.2" class="anchored" data-anchor-id="차원과-3차원시각화를-선택하는-방법"><span class="header-section-number">8.2.2</span> 2차원과 3차원시각화를 선택하는 방법</h3>
<p>평면 표현과 공간 표현 사이의 선택은 시각적 인코딩과 깊이 단서 사이의 간섭이 시각화 목표를 고려할 때 허용 가능한 절충안을 구성하는지에 달려야 합니다. 유전자 발현 또는 생물학적 네트워크와 같이 추상적인 데이터는 일반적으로 3D 공간 표현으로부터 이점을 얻지 못하며, 깊이 단서를 필요로 하지 않는 기술을 사용하여 그릴 때 가장 유용합니다.</p>
<p>대부분의 경우, 고차원 데이터는 요소를 2D 평면에 배치하고 크기나 색상을 사용하여 데이터의 추가 차원을 인코딩하는 표현으로 안정적이고 효율적으로 시각화할 수 있습니다. 데이터 차원 중 하나가 범주형이고 범주가 몇 개에 불과하다면 모양을 사용하여 범주를 인코딩할 수 있습니다. 평면에 다차원 데이터를 효과적으로 표현할 수 있는 많은 일반적인 데이터 시각화 접근 방식이 있습니다. 예를 들어, 고차원 데이터 세트에서 변수의 쌍별 조합을 각각 보여주는 산점도 행렬은 상관 관계를 효과적으로 드러낼 수 있습니다. 유사하게, 히트맵과 평행 좌표 플롯은 평면에 다차원 데이터를 그리는 데 유용한 기술입니다. 일부 정보 손실이 허용된다면 주성분 분석 또는 다차원 척도화와 같은 차원 축소 방법을 사용하여 고차원 데이터 세트의 2D 표현을 얻을 수 있습니다.</p>
</section>
</section>
<section id="차원-시각화로-다변량-데이터-시각화" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="차원-시각화로-다변량-데이터-시각화"><span class="header-section-number">8.3</span> 2차원 시각화로 다변량 데이터 시각화</h2>
<p>고차원 데이터는 분석 및 표현에 있어 상당한 어려움을 제기합니다. 평행 좌표 플롯이나 산점도 행렬과 같은 데이터 시각화 방법은 고차원 데이터를 위한 매우 유용한 2D 시각화 기술입니다. 이들은 평면상의 위치를 사용하여 데이터를 나타내며 각각 데이터의 다른 측면을 강조하는 고유한 강점을 가집니다. 많은 데이터 분석 작업은 클러스터, 추세 및 이상치를 찾는 것을 포함하며 잘 선택되고 잘 설계된 2D 플롯은 데이터의 패턴을 드러내는 데 매우 유리할 수 있습니다.</p>
<section id="평행-좌표-플롯-parallel-coordinate-plots" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="평행-좌표-플롯-parallel-coordinate-plots"><span class="header-section-number">8.3.1</span> 평행 좌표 플롯 (Parallel Coordinate Plots)</h3>
<p>근본적인 2D 플로팅 기술 중 하나는 평행 좌표를 사용하는 것입니다. 이 플롯의 특징적인 외관은 고유한 좌표계에서 비롯됩니다. 좌표는 서로 직교하지 않고 평행합니다. 각 수직 축은 최소값과 최대값 사이에서 스케일링된 데이터 값을 가진 다른 차원을 나타냅니다. 동일한 행에 속하는 데이터 포인트는 선분으로 연결되어 개별 데이터 특징이 전체 데이터 세트의 맥락에서 보여지도록 합니다.</p>
<p>평행 좌표는 다양한 데이터 유형을 동시에 처리할 수 있습니다. 예를 들어, 유전자 발현 데이터 및 시간 또는 여러 조건에 걸친 다른 정량적 다변량 데이터는 종종 각 차원이 동일한 유형이고 모든 축이 동일한 범위로 스케일링되는 특수한 형태의 평행 좌표 플롯을 사용하여 시각화됩니다. 이 접근 방식은 차원 간의 정확한 비교를 가능하게 합니다. 또한, 이러한 유형의 플롯은 범주형, 순서형 또는 정량적 차원을 포함하는 데이터 세트도 나타낼 수 있습니다.</p>
<p>강력한 그래픽 인코딩에 의존함으로써 평행 좌표 플롯은 특정 데이터 관계를 명확하게 보여줍니다. 예를 들어, 한 쌍의 축 사이에 많은 교차선이 나타나는 것은 해당 차원 간의 역관계(inverse relationship)를 나타내는 반면, 평행(또는 거의 평행)한 선은 인접 축으로 표현된 변수 간의 상관관계(correlation)를 시사할 수 있습니다. 이러한 유형의 특징은 평행 좌표 플롯에서 쉽게 볼 수 있습니다. 그러나 이 플롯은 범주형 정보가 지배적인 데이터나 적은 수의 값만을 통과하는 데이터 범위에는 적합하지 않습니다. 데이터 가려짐이 문제가 될 수 있기 때문입니다.</p>
<p>평행 좌표를 사용할 때는 축 높이와 축 사이의 거리를 조정하여 모든 각도의 절대값 평균이 45도에 가깝도록 해야 합니다. 전체 플롯의 종횡비는 축 사이에 선분이 나타나는 각도에 영향을 미칩니다. 평행 좌표 플롯을 적절하게 형성하면 시청자의 축 방향 인식이 향상되고 선 교차를 더 쉽게 발견할 수 있어 개별 프로파일을 추적하는 데 유용합니다.</p>
</section>
<section id="산점도-행렬-scatter-plot-matrices" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2" class="anchored" data-anchor-id="산점도-행렬-scatter-plot-matrices"><span class="header-section-number">8.3.2</span> 산점도 행렬 (Scatter Plot Matrices)</h3>
<p>산점도 행렬은 다변량 데이터를 위한 또 다른 일반적인 평면 시각화 방법입니다. 이 플로팅 기술에서는 모든 쌍별 조합을 나타내는 산점도 그리드를 사용하여 데이터 세트의 모든 차원 간의 쌍별 관계를 쉽게 탐색할 수 있습니다.</p>
</section>
<section id="평행-좌표-플롯-vs.-산점도-행렬" class="level3" data-number="8.3.3">
<h3 data-number="8.3.3" class="anchored" data-anchor-id="평행-좌표-플롯-vs.-산점도-행렬"><span class="header-section-number">8.3.3</span> 평행 좌표 플롯 vs.&nbsp;산점도 행렬</h3>
<p>평행 좌표 플롯과 산점도 행렬 중 어떤 것을 선택할지는 지원할 분석 작업에 따라 달라집니다. 이 두 접근 방식의 근본적인 차이점은 여러 차원에 걸쳐 개별 데이터 특징을 표현하는 방식입니다.</p>
<ul>
<li>평행 좌표 플롯: 데이터 포인트가 단일 선 또는 프로파일로 묘사됩니다. 함께 나타나는 ’선 묶음’은 클러스터를 나타내고, 이상치도 명확하게 드러납니다.</li>
<li>산점도 행렬: 데이터 특징이 산점도 간에 연결되지 않은 일련의 점으로 표현되므로, 개별 데이터 특징에 대한 결론을 도출하기 어렵습니다. 그러나 산점도 행렬은 점 구름의 특징적인 모양을 기반으로 전체 데이터 세트의 모든 차원 간의 쌍별 상관관계 및 기타 관계를 효율적으로 식별하는 데 사용할 수 있습니다.</li>
</ul>
</section>
<section id="시각화-방법의-시너지-효과" class="level3" data-number="8.3.4">
<h3 data-number="8.3.4" class="anchored" data-anchor-id="시각화-방법의-시너지-효과"><span class="header-section-number">8.3.4</span> 시각화 방법의 시너지 효과</h3>
<p>이러한 방법들은 서로 상호 보완적이며 동일한 데이터 세트에 대한 여러 조정된 시각화를 사용할 수 있는 대화형 환경에서 가장 좋은 결과를 제공합니다. 히트맵 및 차원 축소 도구와 함께 기본적인 2D 시각화 방법은 다변량 데이터에 대한 강력한 접근 방식이 될 수 있습니다.</p>
</section>
</section>
</section>
<section id="데이터-탐색하기" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> 데이터 탐색하기</h1>
<section id="연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="연필과-종이-사고와-가설-생성에-도움이-되는-독특한-도구"><span class="header-section-number">9.1</span> 연필과 종이: 사고와 가설 생성에 도움이 되는 독특한 도구</h2>
<p>그림을 그리는 것은 과학적 사고에 필수적입니다. 시각화 과정에서 연필로 종이에 그리는 행위는 내면의 성찰과 외면의 표현에 없어서는 안 될 부분입니다. 이는 우리의 사고를 구체적이고 명시적으로 만드는 건설적인 활동입니다.</p>
<section id="시각적-표현의-구체성" class="level3" data-number="9.1.1">
<h3 data-number="9.1.1" class="anchored" data-anchor-id="시각적-표현의-구체성"><span class="header-section-number">9.1.1</span> 시각적 표현의 구체성</h3>
<blockquote class="blockquote">
<p>사고의 명확화</p>
</blockquote>
<p>단어는 그림에서는 허용되지 않는 모호성을 부여합니다. 예를 들어, 단백질을 세포 내에 있다고 일반적인 용어로 구두로 설명할 수 있지만, 세포 내 단백질 그림을 그리면 단백질이 존재하는 세포 구획에 대해 구체적으로 생각하게 됩니다. 세포를 가장 일반적인 형태로 묘사하더라도, 단백질의 위치를 나타내려면 단백질을 세포질에, 핵 안에, 또는 그 사이 어딘가에 배치해야 합니다. 세포 내 모든 위치가 ’세포 내’라는 원래 매개변수를 준수하더라도, 그림의 해석은 더 직접적입니다. 즉, 단백질은 세포질성, 핵성 또는 핵막과 관련되어 있는 것으로 이해될 것입니다.</p>
<p>시각적 묘사는 우리가 이해의 전제를 끊임없이 평가하도록 요구합니다. 정보를 합리화하는 방법으로 빠른 스케치나 낙서를 하는 것은 우리의 사고에서 간극을 드러내고 대안적인 결론과 새로운 아이디어로 이어질 수 있습니다. 탐구적인 그리기를 할 때는 시각적 정확성을 다소 포기하는 것이 유용합니다. 우리는 묘사하는 객체가 실제 객체처럼 보이기를 기대하는 경향이 있습니다. 이러한 기술적 숙련도에 대한 기대는 많은 성인들이 그림 그리기를 연습으로 포기하는 이유일 것입니다. 그림을 그릴 때는 많은 가능성을 탐색하기 위해 스케치를 빠르게 다듬는 것이 생산적입니다.</p>
</section>
<section id="연필과-종이의-즉각성과-유연성" class="level3" data-number="9.1.2">
<h3 data-number="9.1.2" class="anchored" data-anchor-id="연필과-종이의-즉각성과-유연성"><span class="header-section-number">9.1.2</span> 연필과 종이의 즉각성과 유연성</h3>
<p>연필과 종이는 타의 추종을 불허하는 즉각성을 제공합니다. 이 매체를 사용하면 손이 닿는 곳에 있는 모든 것을 활용할 수 있습니다. 예를 들어, 저널 뒷면, 포스트잇, 또는 점심 식사 후의 냅킨이 될 수 있습니다. 그래픽 생성용 소프트웨어와는 달리 연필과 종이에는 학습 곡선이 없습니다. 컴퓨터의 일반적인 입력 장치(키보드와 마우스)는 정신을 몰입시키는 데 필요한 표현력과 유동성을 지원하기에 심각하게 부적절합니다. 디지털 매체의 실용적인 측면은 종종 인지 과정을 방해하는데 이는 우리가 자주 멈춰서 ‘어떻게’ 해야 할지 생각해야 하기 때문입니다.</p>
</section>
<section id="그리기의-인지적-이점" class="level3" data-number="9.1.3">
<h3 data-number="9.1.3" class="anchored" data-anchor-id="그리기의-인지적-이점"><span class="header-section-number">9.1.3</span> 그리기의 인지적 이점</h3>
<blockquote class="blockquote">
<p>기억력 확장 및 통찰력 확보</p>
</blockquote>
<p>그림 그리기 과정은 사고 과정과 연결되어 있으며 정신 모델을 생성하는 것은 과학 데이터에 대한 통찰력을 얻는 데 도움이 됩니다. 예를 들어, 우리의 지식을 유형의 형태로 외현화함으로써 우리는 동료들과 해석을 교환하고 의미를 명확히 할 기회를 만듭니다. 교육 환경에서 그림 그리기는 학동들의 과학 개념 이해를 향상시키는 것으로 나타났습니다. 학생들이 수업 자료의 시각적 표현을 생성하고, 정당화하며, 다듬도록 유도된 후 현저히 더 나은 성과를 보였습니다.</p>
<p>그림 그리기 기능 중 하나는 우리의 단기 작업 기억(short working memory)을 확장하는 것입니다. 시각적 작업 기억은 특정 작업을 수행하기 위해 시각 정보를 유지하는 우리의 능력을 설명합니다(예: 지도를 읽는 것). 우리는 몇 초 이상 몇 개 이상의 객체 속성을 기억하기 어렵습니다. 노드(행과 열로 배열됨) 간의 연결이 채워진 셀로 표시된 간단한 네트워크를 설명하는 표를 통해 연결을 연속적으로 읽고 기억에 저장하여 기본 네트워크의 정신적 그림을 만드는 것은 쉽지 않습니다. 동일한 정보를 다이어그램으로 묘사함으로써, 우리는 작업 기억의 한계를 극복하고 어떤 노드 쌍 사이의 개입하는 노드 수와 같은 복잡한 관계를 쉽게 볼 수 있습니다.</p>
</section>
</section>
<section id="그래픽으로-데이터-보기의-중요성" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="그래픽으로-데이터-보기의-중요성"><span class="header-section-number">9.2</span> 그래픽으로 데이터 보기의 중요성</h2>
<p>그래픽으로 데이터를 보는 것은 계산된 지표에만 의존하는 것보다 훨씬 중요합니다. 앤스콤의 콰르텟은 동일한 요약 통계를 갖는 데이터 세트라도 시각화하면 크게 다름을 보여줍니다. 고차원 데이터에서 ’행동 클래스’를 찾기 위해 저차원 ’슬라이스’를 만들어 시각화하는 것이 유용하며 이때 플롯 간의 일관성 유지가 중요합니다.</p>
</section>
<section id="스택-그래프-vs.-개별-플롯-패턴-발견의-차이" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="스택-그래프-vs.-개별-플롯-패턴-발견의-차이"><span class="header-section-number">9.3</span> 스택 그래프 vs.&nbsp;개별 플롯: 패턴 발견의 차이</h2>
<p>스택 그래프는 전체 커뮤니티의 동적 변화를 보여주지만 각 구성 요소의 상세한 추세를 파악하기는 어렵습니다. 반면, 개별 플롯은 각 개체군의 행동을 명확하게 드러내 더 많은 패턴을 발견할 수 있게 합니다. 너무 많은 데이터를 한 번에 표시하는 것은 시각적 부담을 주므로, 데이터 일부를 제외하거나 샘플링하여 복잡성을 줄여야 합니다.</p>
</section>
<section id="네트워크-탐색을-위한-그래프-기법" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="네트워크-탐색을-위한-그래프-기법"><span class="header-section-number">9.4</span> 네트워크 탐색을 위한 그래프 기법</h2>
<p>복잡한 생물학적 상호작용은 네트워크로 표현될 때 유용하며, 목적에 맞는 시각화 기법을 선택하면 의미 있는 통찰력을 얻을 수 있습니다. 네트워크 시각화는 허브(연결이 많은 노드)와 클러스터(고도로 상호 연결된 노드 집합) 같은 특징을 부각시킵니다.</p>
<section id="노드-링크-다이어그램" class="level3" data-number="9.4.1">
<h3 data-number="9.4.1" class="anchored" data-anchor-id="노드-링크-다이어그램"><span class="header-section-number">9.4.1</span> 노드-링크 다이어그램</h3>
<p>노드-링크 다이어그램은 네트워크의 지역적 세부 사항을 잘 보여주며 노드와 연결을 시각화합니다. 다양한 레이아웃은 데이터 관계 인지에 큰 영향을 줄 수 있습니다. 하지만 이 다이어그램은 데이터 세트가 커질수록 복잡해져 확장성이 떨어집니다.</p>
</section>
<section id="인접-행렬" class="level3" data-number="9.4.2">
<h3 data-number="9.4.2" class="anchored" data-anchor-id="인접-행렬"><span class="header-section-number">9.4.2</span> 인접 행렬</h3>
<p>큰 무방향성 네트워크에는 인접 행렬이 효과적입니다. 노드를 행과 열로 표시하여 연결성을 보여주므로, 노드-링크 다이어그램의 문제점을 피할 수 있습니다. 노드 순서를 재정렬하면 클러스터와 허브를 더 쉽게 파악할 수 있지만, 직접 연결되지 않은 노드 간의 관계를 파악하기는 어렵습니다.</p>
</section>
<section id="큰-규모-네트워크-시각화의-한계와-대안" class="level3" data-number="9.4.3">
<h3 data-number="9.4.3" class="anchored" data-anchor-id="큰-규모-네트워크-시각화의-한계와-대안"><span class="header-section-number">9.4.3</span> 큰 규모 네트워크 시각화의 한계와 대안</h3>
<p>네트워크가 너무 크면 노드-링크 다이어그램이나 인접 행렬 모두 부적절할 수 있습니다. 이때는 부분 네트워크를 시각화하거나 클러스터링 계수 같은 통계 측정에 의존하는 것이 유용합니다.</p>
</section>
</section>
<section id="데이터-통합-다양한-분석-작업을-위한-시각적-표현" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="데이터-통합-다양한-분석-작업을-위한-시각적-표현"><span class="header-section-number">9.5</span> 데이터 통합: 다양한 분석 작업을 위한 시각적 표현</h2>
<p>다른 데이터 유형은 고유한 시각화 기법에 가장 적합합니다. 여러 데이터 유형을 결합한 시각화는 데이터 간의 상관관계, 공통 추세, 잠재적 인과 관계를 발견하는 데 도움이 됩니다.</p>
<section id="결합된-시각화-디자인" class="level3" data-number="9.5.1">
<h3 data-number="9.5.1" class="anchored" data-anchor-id="결합된-시각화-디자인"><span class="header-section-number">9.5.1</span> 결합된 시각화 디자인</h3>
<p>결합된 시각화 디자인은 분석 작업에 따라 달라집니다. 예를 들어, 유전자 발현 데이터와 상호작용 네트워크를 결합할 때 ’히트 스트립’을 사용하면 특정 발현 프로파일을 가진 노드를 빠르게 찾을 수 있습니다.</p>
</section>
<section id="다수-시간-지점-데이터-처리" class="level3" data-number="9.5.2">
<h3 data-number="9.5.2" class="anchored" data-anchor-id="다수-시간-지점-데이터-처리"><span class="header-section-number">9.5.2</span> 다수 시간 지점 데이터 처리</h3>
<p>많은 시간 지점 데이터를 다룰 때는 노드의 발현 수준을 색상으로 나타내고 대화형으로 진행하거나, 각 시간 지점을 나타내는 ’작은 다중 그래프’로 네트워크를 배열하여 복잡한 패턴을 한눈에 파악하도록 도울 수 있습니다.</p>
</section>
<section id="통합-도구의-중요성" class="level3" data-number="9.5.3">
<h3 data-number="9.5.3" class="anchored" data-anchor-id="통합-도구의-중요성"><span class="header-section-number">9.5.3</span> 통합 도구의 중요성</h3>
<p>다양한 그래프 기법을 통합하는 도구는 데이터 탐색에 매우 유용합니다. Cytoscape 플러그인인 Cerebral처럼 여러 시각화 뷰를 제공하는 도구는 데이터 해석을 심화시킵니다.</p>
</section>
</section>
<section id="게놈-데이터-시각화-선형-게놈의-시각적-표현-선택" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="게놈-데이터-시각화-선형-게놈의-시각적-표현-선택"><span class="header-section-number">9.6</span> 게놈 데이터 시각화: 선형 게놈의 시각적 표현 선택</h2>
<p>게놈 데이터는 게놈 좌표를 기반으로 표시되지만, 게놈의 거대한 크기는 시각화에 도전 과제를 제기합니다. 전통적인 선형 게놈 브라우저는 한계가 있어 다른 조직 프레임워크를 사용해야 합니다.</p>
<section id="게놈-데이터-개요-생성-및-문제점" class="level3" data-number="9.6.1">
<h3 data-number="9.6.1" class="anchored" data-anchor-id="게놈-데이터-개요-생성-및-문제점"><span class="header-section-number">9.6.1</span> 게놈 데이터 개요 생성 및 문제점</h3>
<p>게놈을 동일한 크기로 나누어 요약 값을 보고하는 방식은 특징이 작을 때 중요한 정보를 가릴 수 있습니다. 게놈 브라우저의 확대/축소 기능은 다양한 규모로 게놈을 검사할 수 있도록 하여 이 문제를 해결합니다.</p>
</section>
<section id="의미-있는-개요를-위한-접근-방식" class="level3" data-number="9.6.2">
<h3 data-number="9.6.2" class="anchored" data-anchor-id="의미-있는-개요를-위한-접근-방식"><span class="header-section-number">9.6.2</span> 의미 있는 개요를 위한 접근 방식</h3>
<p>관심 있는 특징만 분리하거나 게놈 중간 부분을 제거하여 관련 신호를 함께 모으는 것이 의미 있는 개요를 만드는 방법입니다. 공간 채움 곡선과 같이 게놈을 압축하여 표시하는 방법도 있지만, 왜곡이 발생할 수 있습니다. 경우에 따라 게놈 순서를 포기하고 전사 시작 부위와 같은 공통 참조 지점을 기준으로 데이터를 정렬하는 것이 더 유용할 수 있습니다.</p>
</section>
<section id="게놈의-3차원적-특징과-미래-시각화" class="level3" data-number="9.6.3">
<h3 data-number="9.6.3" class="anchored" data-anchor-id="게놈의-3차원적-특징과-미래-시각화"><span class="header-section-number">9.6.3</span> 게놈의 3차원적 특징과 미래 시각화</h3>
<p>게놈의 3차원적 접힘 구조를 이해하게 되면 게놈 데이터를 조직하고 접근하는 방식도 바뀔 것입니다. 이는 선형 좌표 대신 기능적 상태에 따라 데이터를 그룹화하는 시각화를 가능하게 할 것입니다.</p>
</section>
</section>
<section id="게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="게놈-브라우저를-통한-대량-데이터-관리-증가하는-데이터-트랙-처리"><span class="header-section-number">9.7</span> 게놈 브라우저를 통한 대량 데이터 관리: 증가하는 데이터 트랙 처리</h2>
<p>게놈 데이터는 종류와 양이 방대하며, 게놈 브라우저는 이를 효과적으로 시각화하는 데 중요합니다. 게놈 브라우저는 트랙을 수직으로 배열하여 비교를 용이하게 하지만, 트랙 수가 늘어나면 시각적 복잡성이 증가합니다.</p>
<section id="시각적-복잡성-줄이는-전략-압축과-요약" class="level3" data-number="9.7.1">
<h3 data-number="9.7.1" class="anchored" data-anchor-id="시각적-복잡성-줄이는-전략-압축과-요약"><span class="header-section-number">9.7.1</span> 시각적 복잡성 줄이는 전략: 압축과 요약</h3>
<p>시각적 복잡성을 줄이기 위해 압축과 요약 전략을 사용할 수 있습니다. 압축은 데이터를 간결하게 표현하여 화면 공간을 확보하고, 여러 트랙을 합치거나 히트맵으로 봉우리 높이를 표현할 수 있습니다. 요약은 데이터 세부 사항을 희생하여 더 높은 수준의 추론을 제공하며, 실험 전반의 지표를 계산하여 데이터의 새로운 표현을 만듭니다.</p>
</section>
<section id="요약의-장점과-과제" class="level3" data-number="9.7.2">
<h3 data-number="9.7.2" class="anchored" data-anchor-id="요약의-장점과-과제"><span class="header-section-number">9.7.2</span> 요약의 장점과 과제</h3>
<p>요약은 연구자들이 전역적인 추세에 집중하고 더 깊은 조사를 위한 지점을 우선순위화하는 데 도움을 줍니다. 하지만 추상화된 요약이 기본 데이터를 완전히 대체하지는 않으므로, 게놈 브라우저는 요약 트랙과 세부 트랙의 계층 구조를 지원해야 합니다.</p>
</section>
</section>
<section id="게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="게놈-구조-변이-표현-멀리-떨어진-게놈-위치-간-관계-표시"><span class="header-section-number">9.8</span> 게놈 구조 변이 표현: 멀리 떨어진 게놈 위치 간 관계 표시</h2>
<p>게놈 구조 변이는 전통적인 게놈 시각화에 새로운 도전을 제기합니다. 구조 변이의 시퀀스 경계는 넓은 범위에 걸쳐 있으며, 그 크기와 방향이 다양합니다.</p>
<section id="구조-변이-묘사를-위한-시각화-기법" class="level3" data-number="9.8.1">
<h3 data-number="9.8.1" class="anchored" data-anchor-id="구조-변이-묘사를-위한-시각화-기법"><span class="header-section-number">9.8.1</span> 구조 변이 묘사를 위한 시각화 기법</h3>
<p>구조 변이를 묘사하기 위해 브레이크포인트 사이에 호(arc)를 그리는 방식이 있으나, 많은 호를 표시하면 시각적 혼란이 발생합니다. 원형 레이아웃인 Circos 이데오그램은 호를 압축하지만, 중첩에 취약합니다. 도트 플롯은 두 게놈의 서열 순서와 방향을 직접 보여주지만, 한 번에 하나의 변이-참조 서열 쌍만 표현할 수 있습니다.</p>
</section>
<section id="게놈-좌표계에서-벗어나-기능적-결과에-초점" class="level3" data-number="9.8.2">
<h3 data-number="9.8.2" class="anchored" data-anchor-id="게놈-좌표계에서-벗어나-기능적-결과에-초점"><span class="header-section-number">9.8.2</span> 게놈 좌표계에서 벗어나 기능적 결과에 초점</h3>
<p>게놈 좌표계에 얽매이지 않고 기능적 결과에 초점을 맞추는 것이 더 의미 있을 수 있습니다. 예를 들어, 유전자 융합과 같이 생물학적으로 중요한 특징을 강조하기 위해 노드가 서열 세그먼트를 나타내고 화살표가 서열 순서를 나타내는 그래프를 사용할 수 있습니다.</p>
</section>
</section>
<section id="효과적인-데이터-시각화를-위한-검토-지점" class="level2" data-number="9.9">
<h2 data-number="9.9" class="anchored" data-anchor-id="효과적인-데이터-시각화를-위한-검토-지점"><span class="header-section-number">9.9</span> 효과적인 데이터 시각화를 위한 검토 지점</h2>
<p>효과적인 데이터 시각화는 시각적 단서를 활용하여 그림의 내재된 의미를 명확하게 표현해야 합니다.</p>
<section id="개념적-그림-명확한-구조화" class="level3" data-number="9.9.1">
<h3 data-number="9.9.1" class="anchored" data-anchor-id="개념적-그림-명확한-구조화"><span class="header-section-number">9.9.1</span> 개념적 그림: 명확한 구조화</h3>
<p>게슈탈트 원리를 활용하여 객체들을 근접성, 연결성, 포함 원리에 따라 그룹화하여 명확한 시각적 구조를 만듭니다. 네거티브 공간을 활용하고, 균일한 빈 공간을 만들어 콘텐츠를 조직화할 수 있습니다. 그림의 의도가 레이아웃을 안내하도록 하고, 시각적 완성 원리에 따라 요소를 정렬하여 순서를 명확히 합니다.</p>
</section>
<section id="데이터-그래프-연결성-드러내기와-정확한-시각적-인코딩" class="level3" data-number="9.9.2">
<h3 data-number="9.9.2" class="anchored" data-anchor-id="데이터-그래프-연결성-드러내기와-정확한-시각적-인코딩"><span class="header-section-number">9.9.2</span> 데이터 그래프: 연결성 드러내기와 정확한 시각적 인코딩</h3>
<p>그래프는 데이터 간의 연결성을 드러내는 것이 주된 목적입니다. 그래픽 인코딩은 이러한 감지 과정을 지원해야 합니다. 막대 차트는 범주 간의 상대적 차이를 파악하는 데 효과적이며, 원형 차트는 전체의 부분을 묘사하는 데 유용합니다.</p>
<p>여러 차원 데이터를 표시할 때는 다변량 산점도를 활용할 수 있으나, 너무 많은 시각적 변수는 구분을 어렵게 합니다. 색상 값과 크기 스케일을 제한하거나, 가장 중요한 매개변수만 그리는 것이 좋습니다. 색상은 정량적 정보 표현에 한계가 있으며, 특히 노란색이나 무지개 스펙트럼은 값 범위 표현에 비일관성을 야기할 수 있습니다. 일관된 시각적 스케일을 위해 흑백 그라데이션이 효과적입니다.</p>
</section>
</section>
</section>
<section id="이러한-검토-지점들이-효과적인-데이터-시각화를-위한-좋은-지침이-되기를-바랍니다." class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> 이러한 검토 지점들이 효과적인 데이터 시각화를 위한 좋은 지침이 되기를 바랍니다.</h1>
<hr>
<p><em>내용을 계속 추가하는 중입니다.</em> &gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of a877f96 (2025-06-21)</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>https://blogs.nature.com/methagora/2013/07/data-visualization-points-of-view.html<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script async="" src="https://subscribe-forms.beehiiv.com/embed.js"></script><iframe src="https://subscribe-forms.beehiiv.com/ed70a4de-a490-4092-aed7-af5face9bf37" class="beehiiv-embed" data-test-id="beehiiv-embed" frameborder="0" scrolling="no" style="width: 260px; height: 355px; margin: 0; border-radius: 0px 0px 0px 0px !important; background-color: transparent; box-shadow: 0 0 #0000; max-width: 100%;"></iframe>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomorrow-lab\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      if (authorPrefersDark) {
          [baseTheme, altTheme] = [altTheme, baseTheme];
      }
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "partrita/giscus";
    script.dataset.repoId = "R_kgDONvsa2g";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDONvsa2s4CmWd7";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Proudly served by <a href="https://pages.github.com/">github pages</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This blog is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>