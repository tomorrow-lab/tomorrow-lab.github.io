<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Taeyoon Kim">
<meta name="dcterms.date" content="2026-01-31">

<title>polars를 활용한 데이터 분석 – tomorrow-lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../.././static/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c403db109ef8a29fe7d42d2b539140cc.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-182c3cbb9d016e7ba0fc3f515cd4d4f6.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c403db109ef8a29fe7d42d2b539140cc.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f7a981a6d6a5d49226379a17328db006.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-9dff5c0ff9725297dc8911b52dbca2ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-f7a981a6d6a5d49226379a17328db006.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-31EWCYNR0V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-31EWCYNR0V', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="google-site-verification" content="z2S1Xqj9hfJiC31aNGCnOA1gYpL_8MoZpPI2avrWMvg">
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="polars를 활용한 데이터 분석 – tomorrow-lab">
<meta property="og:description" content="The future of scientific discovery lies at the convergence of computational power and biological complexity. Our mission is to provide a platform where enthusiasts, researchers, and professionals can learn about and contribute to the rapidly evolving fields of bioinformatics, computational biology, and systems biology.">
<meta property="og:image" content="https://tomorrow-lab.github.io/posts/ipynb/ds_tutorial_polars_files/figure-html/cell-24-output-1.png">
<meta property="og:site_name" content="tomorrow-lab">
<meta property="og:image:height" content="294">
<meta property="og:image:width" content="472">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././static/logo.png" alt="" class="navbar-logo light-content">
    <img src="../.././static/logo.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tomorrow-lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">projects.html</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://partrita.github.io"> <i class="bi bi-exclamation-triangle" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/partrita"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<div style="margin-top: 30px; margin-bottom: 20px;">
    <a href="https://substack.com/@tomorrowlab">
        <img alt="Static Badge" src="https://img.shields.io/badge/EHOTTL%40substack_-FF6719?link=https%3A%2F%2Fsubstack.com%2F%40tomorrowlab">
    </a>
    <a href="https://pixi.sh">
        <img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json" alt="Pixi Badge">
    </a>
    <!-- <script async src="https://eocampaign1.com/form/2616a818-1ef8-11ef-b372-4587d096212f.js" data-form="2616a818-1ef8-11ef-b372-4587d096212f"></script> -->
</div>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#데이터셋-설명" id="toc-데이터셋-설명" class="nav-link active" data-scroll-target="#데이터셋-설명"><span class="header-section-number">0.1</span> 데이터셋 설명</a></li>
  <li><a href="#데이터-불러오기" id="toc-데이터-불러오기" class="nav-link" data-scroll-target="#데이터-불러오기"><span class="header-section-number">0.2</span> 데이터 불러오기</a></li>
  <li><a href="#크기행열셀-수-확인" id="toc-크기행열셀-수-확인" class="nav-link" data-scroll-target="#크기행열셀-수-확인"><span class="header-section-number">0.3</span> 크기·행/열·셀 수 확인</a></li>
  <li><a href="#데이터셋-살펴보기" id="toc-데이터셋-살펴보기" class="nav-link" data-scroll-target="#데이터셋-살펴보기"><span class="header-section-number">0.4</span> 데이터셋 살펴보기</a></li>
  <li><a href="#결측치자료형-확인" id="toc-결측치자료형-확인" class="nav-link" data-scroll-target="#결측치자료형-확인"><span class="header-section-number">0.5</span> 결측치·자료형 확인</a></li>
  <li><a href="#데이터-정제" id="toc-데이터-정제" class="nav-link" data-scroll-target="#데이터-정제"><span class="header-section-number">1</span> 데이터 정제</a>
  <ul class="collapse">
  <li><a href="#컬럼-이름-정리하기" id="toc-컬럼-이름-정리하기" class="nav-link" data-scroll-target="#컬럼-이름-정리하기"><span class="header-section-number">1.1</span> 컬럼 이름 정리하기</a></li>
  <li><a href="#컬럼-삭제하기" id="toc-컬럼-삭제하기" class="nav-link" data-scroll-target="#컬럼-삭제하기"><span class="header-section-number">1.2</span> 컬럼 삭제하기</a></li>
  <li><a href="#컬럼-자료형-고치기" id="toc-컬럼-자료형-고치기" class="nav-link" data-scroll-target="#컬럼-자료형-고치기"><span class="header-section-number">1.3</span> 컬럼 자료형 고치기</a>
  <ul class="collapse">
  <li><a href="#날짜-컬럼-sale_date를-datetime으로-변환" id="toc-날짜-컬럼-sale_date를-datetime으로-변환" class="nav-link" data-scroll-target="#날짜-컬럼-sale_date를-datetime으로-변환"><span class="header-section-number">1.3.1</span> 날짜 컬럼 <code>sale_date</code>를 datetime으로 변환</a></li>
  </ul></li>
  <li><a href="#결측값-다루기" id="toc-결측값-다루기" class="nav-link" data-scroll-target="#결측값-다루기"><span class="header-section-number">1.4</span> 결측값 다루기</a></li>
  <li><a href="#데이터-부분-선택" id="toc-데이터-부분-선택" class="nav-link" data-scroll-target="#데이터-부분-선택"><span class="header-section-number">1.5</span> 데이터 부분 선택</a></li>
  <li><a href="#컬럼-값-다시-코딩하기" id="toc-컬럼-값-다시-코딩하기" class="nav-link" data-scroll-target="#컬럼-값-다시-코딩하기"><span class="header-section-number">1.6</span> 컬럼 값 다시 코딩하기</a></li>
  <li><a href="#컬럼-값-포매팅" id="toc-컬럼-값-포매팅" class="nav-link" data-scroll-target="#컬럼-값-포매팅"><span class="header-section-number">1.7</span> 컬럼 값 포매팅</a>
  <ul class="collapse">
  <li><a href="#neighborhood-컬럼-포매팅title-case" id="toc-neighborhood-컬럼-포매팅title-case" class="nav-link" data-scroll-target="#neighborhood-컬럼-포매팅title-case"><span class="header-section-number">1.7.1</span> neighborhood 컬럼 포매팅(TITLE CASE)</a></li>
  <li><a href="#building_class_category-포매팅" id="toc-building_class_category-포매팅" class="nav-link" data-scroll-target="#building_class_category-포매팅"><span class="header-section-number">1.7.2</span> building_class_category 포매팅</a></li>
  </ul></li>
  <li><a href="#데이터프레임-병합하기" id="toc-데이터프레임-병합하기" class="nav-link" data-scroll-target="#데이터프레임-병합하기"><span class="header-section-number">1.8</span> 데이터프레임 병합하기</a></li>
  <li><a href="#데이터프레임을-새로운-csv-파일로-저장하기" id="toc-데이터프레임을-새로운-csv-파일로-저장하기" class="nav-link" data-scroll-target="#데이터프레임을-새로운-csv-파일로-저장하기"><span class="header-section-number">1.9</span> 데이터프레임을 새로운 CSV 파일로 저장하기</a></li>
  </ul></li>
  <li><a href="#데이터-시각화" id="toc-데이터-시각화" class="nav-link" data-scroll-target="#데이터-시각화"><span class="header-section-number">2</span> 데이터 시각화</a>
  <ul class="collapse">
  <li><a href="#분포-그리기" id="toc-분포-그리기" class="nav-link" data-scroll-target="#분포-그리기"><span class="header-section-number">2.1</span> 분포 그리기</a>
  <ul class="collapse">
  <li><a href="#히스토그램" id="toc-히스토그램" class="nav-link" data-scroll-target="#히스토그램"><span class="header-section-number">2.1.1</span> 히스토그램</a></li>
  <li><a href="#커널-밀도-추정-플롯" id="toc-커널-밀도-추정-플롯" class="nav-link" data-scroll-target="#커널-밀도-추정-플롯"><span class="header-section-number">2.1.2</span> 커널 밀도 추정 플롯</a></li>
  <li><a href="#박스플롯boxplot" id="toc-박스플롯boxplot" class="nav-link" data-scroll-target="#박스플롯boxplot"><span class="header-section-number">2.1.3</span> 박스플롯(Boxplot)</a></li>
  <li><a href="#바이올린-플롯violin-plot" id="toc-바이올린-플롯violin-plot" class="nav-link" data-scroll-target="#바이올린-플롯violin-plot"><span class="header-section-number">2.1.4</span> 바이올린 플롯(Violin Plot)</a></li>
  </ul></li>
  <li><a href="#범주형-데이터-그리기-plotting-categorical-data" id="toc-범주형-데이터-그리기-plotting-categorical-data" class="nav-link" data-scroll-target="#범주형-데이터-그리기-plotting-categorical-data"><span class="header-section-number">2.2</span> 범주형 데이터 그리기 (Plotting Categorical Data)</a>
  <ul class="collapse">
  <li><a href="#카운트플롯countplot" id="toc-카운트플롯countplot" class="nav-link" data-scroll-target="#카운트플롯countplot"><span class="header-section-number">2.2.1</span> 카운트플롯(Countplot)</a></li>
  <li><a href="#수치형-데이터-그리기-plotting-numerical-data" id="toc-수치형-데이터-그리기-plotting-numerical-data" class="nav-link" data-scroll-target="#수치형-데이터-그리기-plotting-numerical-data"><span class="header-section-number">2.2.2</span> 수치형 데이터 그리기 (Plotting Numerical Data)</a></li>
  <li><a href="#시계열-데이터-그리기-plotting-time-series-data" id="toc-시계열-데이터-그리기-plotting-time-series-data" class="nav-link" data-scroll-target="#시계열-데이터-그리기-plotting-time-series-data"><span class="header-section-number">2.2.3</span> 시계열 데이터 그리기 (Plotting Time-series Data)</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#데이터-탐색-data-exploration" id="toc-데이터-탐색-data-exploration" class="nav-link" data-scroll-target="#데이터-탐색-data-exploration"><span class="header-section-number">3</span> 데이터 탐색 (Data Exploration)</a>
  <ul class="collapse">
  <li><a href="#기술통계descriptive-statistics" id="toc-기술통계descriptive-statistics" class="nav-link" data-scroll-target="#기술통계descriptive-statistics"><span class="header-section-number">3.1</span> 기술통계(Descriptive Statistics)</a>
  <ul class="collapse">
  <li><a href="#범주형-데이터-요약summarizing-categorical-data" id="toc-범주형-데이터-요약summarizing-categorical-data" class="nav-link" data-scroll-target="#범주형-데이터-요약summarizing-categorical-data"><span class="header-section-number">3.1.1</span> 범주형 데이터 요약(Summarizing Categorical Data)</a></li>
  </ul></li>
  <li><a href="#building-class-category" id="toc-building-class-category" class="nav-link" data-scroll-target="#building-class-category"><span class="header-section-number">3.2</span> Building Class Category</a></li>
  <li><a href="#수치형-데이터-요약" id="toc-수치형-데이터-요약" class="nav-link" data-scroll-target="#수치형-데이터-요약"><span class="header-section-number">3.3</span> 수치형 데이터 요약</a>
  <ul class="collapse">
  <li><a href="#분산spread-측정하기" id="toc-분산spread-측정하기" class="nav-link" data-scroll-target="#분산spread-측정하기"><span class="header-section-number">3.3.1</span> 분산(Spread) 측정하기</a></li>
  </ul></li>
  <li><a href="#범주별-수치형-데이터-분할-segmenting-numerical-data-by-category" id="toc-범주별-수치형-데이터-분할-segmenting-numerical-data-by-category" class="nav-link" data-scroll-target="#범주별-수치형-데이터-분할-segmenting-numerical-data-by-category"><span class="header-section-number">3.4</span> 범주별 수치형 데이터 분할 (Segmenting Numerical Data by Category)</a>
  <ul class="collapse">
  <li><a href="#구별-준공연도year-built-세분화" id="toc-구별-준공연도year-built-세분화" class="nav-link" data-scroll-target="#구별-준공연도year-built-세분화"><span class="header-section-number">3.4.1</span> 구별 준공연도(Year Built) 세분화</a></li>
  <li><a href="#datetime-데이터-다루기" id="toc-datetime-데이터-다루기" class="nav-link" data-scroll-target="#datetime-데이터-다루기"><span class="header-section-number">3.4.2</span> Datetime 데이터 다루기</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#마치며" id="toc-마치며" class="nav-link" data-scroll-target="#마치며"><span class="header-section-number">4</span> 마치며</a></li>
  <li><a href="#참조" id="toc-참조" class="nav-link" data-scroll-target="#참조"><span class="header-section-number">5</span> 참조</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">polars를 활용한 데이터 분석</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">Polars</div>
    <div class="quarto-category">Data science</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Taeyoon Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 31, 2026</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">February 7, 2026</p>
    </div>
  </div>
    
  </div>
  


</header>


<p><code>polars</code>는 <code>pandas</code> 대비 5~10배 빠른 병렬 처리와 낮은 메모리 사용(2~4배)이 강점입니다. 게다가 무엇보다도 문법이 직관적이라 기존 <code>pandas</code> 문법보다 기억하기 좋습니다.</p>
<blockquote class="blockquote">
<p>물론 가장 인상 깊었던 문법은 <code>R</code>언어의 <code>tidyverse</code> 경험입니다.</p>
</blockquote>
<section id="데이터셋-설명" class="level2" data-number="0.1">
<h2 data-number="0.1" class="anchored" data-anchor-id="데이터셋-설명"><span class="header-section-number">0.1</span> 데이터셋 설명</h2>
<p>예시로 살펴볼 데이터셋은 2016년 9월~2017년 9월 사이 뉴욕시 부동산 매매 내역 CSV 파일(nyc_real_estate.csv)입니다. 데이터셋의 한 행은 한 건의 매매를 의미하며 21개의 컬럼 BOROUGH, NEIGHBORHOOD, SALE PRICE, SALE DATE등등이 있습니다. 각각의 컬럼에는 부동산 위치·단위 수·면적·매매가·매매일 등의 정보를 담고 있습니다.</p>
</section>
<section id="데이터-불러오기" class="level2" data-number="0.2">
<h2 data-number="0.2" class="anchored" data-anchor-id="데이터-불러오기"><span class="header-section-number">0.2</span> 데이터 불러오기</h2>
<p>먼저 데이터를 불러오겠습니다.</p>
<div id="0edf8bb3" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># CSV 파일 읽기</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pl.read_csv(<span class="st">"../data/nyc_real_estate.csv"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 컬럼 이름 확인</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>df.columns</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>['BOROUGH',
 'NEIGHBORHOOD',
 'BUILDING CLASS CATEGORY',
 'TAX CLASS AT PRESENT',
 'BLOCK',
 'LOT',
 'EASE-MENT',
 'BUILDING CLASS AT PRESENT',
 'ADDRESS',
 'APARTMENT NUMBER',
 'ZIP CODE',
 'RESIDENTIAL UNITS',
 'COMMERCIAL UNITS',
 'TOTAL UNITS',
 'LAND SQUARE FEET',
 'GROSS SQUARE FEET',
 'YEAR BUILT',
 'TAX CLASS AT TIME OF SALE',
 'BUILDING CLASS AT TIME OF SALE',
 'SALE PRICE',
 'SALE DATE']</code></pre>
</div>
</div>
</section>
<section id="크기행열셀-수-확인" class="level2" data-number="0.3">
<h2 data-number="0.3" class="anchored" data-anchor-id="크기행열셀-수-확인"><span class="header-section-number">0.3</span> 크기·행/열·셀 수 확인</h2>
<p>우리가 어떤 데이터셋을 확인할 때 가장 먼저 알아야 하는 것은 데이터셋의 크기입니다. <code>polars</code> 에서는 pandas와 동일하게 <code>shape</code> 속성을 이용해 행과 열의 크기를 확인할 수 있습니다.</p>
<div id="dedac14d" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (행, 열) 형태</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.shape)  <span class="co"># (84548, 21)과 유사한 튜플 출력</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 행 수</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>n_rows <span class="op">=</span> df.shape[<span class="dv">0</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"행 수:"</span>, n_rows)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 열 수</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>n_cols <span class="op">=</span> df.shape</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"열 수:"</span>, n_cols)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 전체 셀 수</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> n_rows <span class="op">*</span> n_cols</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"전체 셀 수:"</span>, size)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>(84548, 21)
행 수: 84548
열 수: 21
전체 셀 수: 1775508</code></pre>
</div>
</div>
</section>
<section id="데이터셋-살펴보기" class="level2" data-number="0.4">
<h2 data-number="0.4" class="anchored" data-anchor-id="데이터셋-살펴보기"><span class="header-section-number">0.4</span> 데이터셋 살펴보기</h2>
<p>이제 데이터가 어떤 모습인지 감을 잡기 위해 살짝 들여다보겠습니다👀. 데이터를 살펴볼 때 사용할 수 있는 메서드는 3가지가 있습니다.</p>
<ul>
<li><code>.head()</code>: 처음 x개의 행을 보여줍니다.</li>
<li><code>.tail()</code>: 마지막 x개의 행을 보여줍니다.</li>
<li><code>.sample()</code>: 임의의 x개의 행을 보여줍니다.</li>
</ul>
<p>귀찮다면 단순히 <code>df</code>를 출력하면 데이터프레임의 처음 5행과 마지막 5행이 출력됩니다.</p>
<div id="4bd7e209" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 처음 5행 (기본)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>df.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (5, 21)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">BOROUGH</th>
<th data-quarto-table-cell-role="th">NEIGHBORHOOD</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS CATEGORY</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">BLOCK</th>
<th data-quarto-table-cell-role="th">LOT</th>
<th data-quarto-table-cell-role="th">EASE-MENT</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">ADDRESS</th>
<th data-quarto-table-cell-role="th">APARTMENT NUMBER</th>
<th data-quarto-table-cell-role="th">ZIP CODE</th>
<th data-quarto-table-cell-role="th">RESIDENTIAL UNITS</th>
<th data-quarto-table-cell-role="th">COMMERCIAL UNITS</th>
<th data-quarto-table-cell-role="th">TOTAL UNITS</th>
<th data-quarto-table-cell-role="th">LAND SQUARE FEET</th>
<th data-quarto-table-cell-role="th">GROSS SQUARE FEET</th>
<th data-quarto-table-cell-role="th">YEAR BUILT</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">SALE PRICE</th>
<th data-quarto-table-cell-role="th">SALE DATE</th>
</tr>
<tr class="even">
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2A"</td>
<td>392</td>
<td>6</td>
<td>" "</td>
<td>"C2"</td>
<td>"153 AVENUE B"</td>
<td>" "</td>
<td>10009</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>"1633"</td>
<td>"6440"</td>
<td>1900</td>
<td>2</td>
<td>"C2"</td>
<td>"6625000"</td>
<td>"2017-07-19 00:00:00"</td>
</tr>
<tr class="even">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2"</td>
<td>399</td>
<td>26</td>
<td>" "</td>
<td>"C7"</td>
<td>"234 EAST 4TH&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>28</td>
<td>3</td>
<td>31</td>
<td>"4616"</td>
<td>"18690"</td>
<td>1900</td>
<td>2</td>
<td>"C7"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2016-12-14 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2"</td>
<td>399</td>
<td>39</td>
<td>" "</td>
<td>"C7"</td>
<td>"197 EAST 3RD&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>16</td>
<td>1</td>
<td>17</td>
<td>"2212"</td>
<td>"7803"</td>
<td>1900</td>
<td>2</td>
<td>"C7"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2016-12-09 00:00:00"</td>
</tr>
<tr class="even">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2B"</td>
<td>402</td>
<td>21</td>
<td>" "</td>
<td>"C4"</td>
<td>"154 EAST 7TH STREET"</td>
<td>" "</td>
<td>10009</td>
<td>10</td>
<td>0</td>
<td>10</td>
<td>"2272"</td>
<td>"6794"</td>
<td>1913</td>
<td>2</td>
<td>"C4"</td>
<td>"3936272"</td>
<td>"2016-09-23 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2A"</td>
<td>404</td>
<td>55</td>
<td>" "</td>
<td>"C2"</td>
<td>"301 EAST 10TH&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>"2369"</td>
<td>"4615"</td>
<td>1900</td>
<td>2</td>
<td>"C2"</td>
<td>"8000000"</td>
<td>"2016-11-17 00:00:00"</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="5dd00424" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 마지막 n행</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df.tail(<span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (2, 21)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">BOROUGH</th>
<th data-quarto-table-cell-role="th">NEIGHBORHOOD</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS CATEGORY</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">BLOCK</th>
<th data-quarto-table-cell-role="th">LOT</th>
<th data-quarto-table-cell-role="th">EASE-MENT</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">ADDRESS</th>
<th data-quarto-table-cell-role="th">APARTMENT NUMBER</th>
<th data-quarto-table-cell-role="th">ZIP CODE</th>
<th data-quarto-table-cell-role="th">RESIDENTIAL UNITS</th>
<th data-quarto-table-cell-role="th">COMMERCIAL UNITS</th>
<th data-quarto-table-cell-role="th">TOTAL UNITS</th>
<th data-quarto-table-cell-role="th">LAND SQUARE FEET</th>
<th data-quarto-table-cell-role="th">GROSS SQUARE FEET</th>
<th data-quarto-table-cell-role="th">YEAR BUILT</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">SALE PRICE</th>
<th data-quarto-table-cell-role="th">SALE DATE</th>
</tr>
<tr class="even">
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>"WOODROW"</td>
<td>"22 STORE BUILDINGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…</td>
<td>"4"</td>
<td>7100</td>
<td>28</td>
<td>" "</td>
<td>"K6"</td>
<td>"2730 ARTHUR KILL ROAD"</td>
<td>" "</td>
<td>10309</td>
<td>0</td>
<td>7</td>
<td>7</td>
<td>"208033"</td>
<td>"64117"</td>
<td>2001</td>
<td>4</td>
<td>"K6"</td>
<td>"11693337"</td>
<td>"2016-12-21 00:00:00"</td>
</tr>
<tr class="even">
<td>5</td>
<td>"WOODROW"</td>
<td>"35 INDOOR PUBLIC AND CULTURAL …</td>
<td>"4"</td>
<td>7105</td>
<td>679</td>
<td>" "</td>
<td>"P9"</td>
<td>"155 CLAY PIT ROAD"</td>
<td>" "</td>
<td>10309</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>"10796"</td>
<td>"2400"</td>
<td>2006</td>
<td>4</td>
<td>"P9"</td>
<td>"69300"</td>
<td>"2016-10-27 00:00:00"</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="fda7f4d8" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 랜덤 샘플 n행</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df.sample(<span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (5, 21)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">BOROUGH</th>
<th data-quarto-table-cell-role="th">NEIGHBORHOOD</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS CATEGORY</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">BLOCK</th>
<th data-quarto-table-cell-role="th">LOT</th>
<th data-quarto-table-cell-role="th">EASE-MENT</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT PRESENT</th>
<th data-quarto-table-cell-role="th">ADDRESS</th>
<th data-quarto-table-cell-role="th">APARTMENT NUMBER</th>
<th data-quarto-table-cell-role="th">ZIP CODE</th>
<th data-quarto-table-cell-role="th">RESIDENTIAL UNITS</th>
<th data-quarto-table-cell-role="th">COMMERCIAL UNITS</th>
<th data-quarto-table-cell-role="th">TOTAL UNITS</th>
<th data-quarto-table-cell-role="th">LAND SQUARE FEET</th>
<th data-quarto-table-cell-role="th">GROSS SQUARE FEET</th>
<th data-quarto-table-cell-role="th">YEAR BUILT</th>
<th data-quarto-table-cell-role="th">TAX CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">BUILDING CLASS AT TIME OF SALE</th>
<th data-quarto-table-cell-role="th">SALE PRICE</th>
<th data-quarto-table-cell-role="th">SALE DATE</th>
</tr>
<tr class="even">
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>"ROCKAWAY PARK"</td>
<td>"03 THREE FAMILY DWELLINGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…</td>
<td>"1"</td>
<td>16218</td>
<td>27</td>
<td>" "</td>
<td>"C0"</td>
<td>"215 BEACH 122 STREET"</td>
<td>" "</td>
<td>11694</td>
<td>3</td>
<td>0</td>
<td>3</td>
<td>"8000"</td>
<td>"3100"</td>
<td>1984</td>
<td>1</td>
<td>"C0"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2017-01-20 00:00:00"</td>
</tr>
<tr class="even">
<td>4</td>
<td>"JACKSON HEIGHTS"</td>
<td>"13 CONDOS - ELEVATOR APARTMENT…</td>
<td>"2"</td>
<td>1263</td>
<td>1030</td>
<td>" "</td>
<td>"R4"</td>
<td>"76-15 35TH AVENUE"</td>
<td>"2-O"</td>
<td>11372</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>" -&nbsp;&nbsp;"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>0</td>
<td>2</td>
<td>"R4"</td>
<td>"545000"</td>
<td>"2016-11-30 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"GREENWICH VILLAGE-WEST"</td>
<td>"10 COOPS - ELEVATOR APARTMENTS…</td>
<td>"2"</td>
<td>640</td>
<td>12</td>
<td>" "</td>
<td>"D0"</td>
<td>"380 WEST 12TH&nbsp;&nbsp;&nbsp;STREET, 6B"</td>
<td>" "</td>
<td>10014</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>" -&nbsp;&nbsp;"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>1939</td>
<td>2</td>
<td>"D0"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2016-12-07 00:00:00"</td>
</tr>
<tr class="even">
<td>4</td>
<td>"GLENDALE"</td>
<td>"10 COOPS - ELEVATOR APARTMENTS…</td>
<td>"2"</td>
<td>3907</td>
<td>975</td>
<td>" "</td>
<td>"D4"</td>
<td>"83-85 WOODHAVEN BLVD, 2S"</td>
<td>" "</td>
<td>11421</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>" -&nbsp;&nbsp;"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>1954</td>
<td>2</td>
<td>"D4"</td>
<td>"190000"</td>
<td>"2017-01-26 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"HARLEM-CENTRAL"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2B"</td>
<td>1937</td>
<td>148</td>
<td>" "</td>
<td>"C5"</td>
<td>"242 WEST 132 STREET"</td>
<td>" "</td>
<td>10027</td>
<td>7</td>
<td>0</td>
<td>7</td>
<td>"1682"</td>
<td>"2561"</td>
<td>1910</td>
<td>2</td>
<td>"C5"</td>
<td>"530000"</td>
<td>"2017-03-23 00:00:00"</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
<section id="결측치자료형-확인" class="level2" data-number="0.5">
<h2 data-number="0.5" class="anchored" data-anchor-id="결측치자료형-확인"><span class="header-section-number">0.5</span> 결측치·자료형 확인</h2>
<p>주어진 데이터셋의 결측값을 확인하는 방법은 아래와 같습니다.</p>
<div id="ffb27098" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 컬럼별 결측치 개수</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>null_counts_df <span class="op">=</span> df.null_count()</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>null_counts <span class="op">=</span> null_counts_df.to_dicts()[<span class="dv">0</span>]  <span class="co"># 단일 행을 딕셔너리로 변환</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"각 컬럼별 결측치 개수:"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, cnt <span class="kw">in</span> null_counts.items():</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>cnt<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>각 컬럼별 결측치 개수:
BOROUGH: 0
NEIGHBORHOOD: 0
BUILDING CLASS CATEGORY: 0
TAX CLASS AT PRESENT: 0
BLOCK: 0
LOT: 0
EASE-MENT: 0
BUILDING CLASS AT PRESENT: 0
ADDRESS: 0
APARTMENT NUMBER: 0
ZIP CODE: 0
RESIDENTIAL UNITS: 0
COMMERCIAL UNITS: 0
TOTAL UNITS: 0
LAND SQUARE FEET: 0
GROSS SQUARE FEET: 0
YEAR BUILT: 0
TAX CLASS AT TIME OF SALE: 0
BUILDING CLASS AT TIME OF SALE: 0
SALE PRICE: 0
SALE DATE: 0</code></pre>
</div>
</div>
<p>결과를 통해 우리 데이터셋에는 결측값이 없다는 것을 알 수 있습니다👍.</p>
</section>
<section id="데이터-정제" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 데이터 정제</h1>
<p>데이터 정제는 데이터 과학 파이프라인에서 가장 중요한 동시에 가장 시간이 많이 드는 단계 중 하나입니다. 뉴욕 타임즈의 2014년도 기사에 의하면 데이터 과학자는 작업 시간의 80%를 데이터를 정리하는데 쓴다고 했습니다.</p>
<p>데이터 수집 방식이 발전하면서 이 비율은 기사 발행 당시보다는 조금 낮아졌을 가능성이 있습니다. 그럼에도 불구하고 데이터 정제는 데이터 분석을 진행하기 전에 반드시 처리해야 하는 매우 중요한 과정입니다.</p>
<p>왜냐하면 정제 되지 않은 데이터를 통해 분석한 결과는 오해의 소지가 있을 수 있기 때문입니다. 따라서 학습 모델을 만드는 데 많은 시간을 쓰고 미세 조정을 하기 전에 가장 길면서도 가장 중요한 <strong>데이터 정제</strong>를 시작해 봅시다🧹🗑️.</p>
<section id="컬럼-이름-정리하기" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="컬럼-이름-정리하기"><span class="header-section-number">1.1</span> 컬럼 이름 정리하기</h2>
<p>처음 NYC 부동산 데이터셋을 불러왔을 때 가장 먼저 눈에 띈 것 중 하나는 컬럼 이름이었습니다. 컬럼 이름은 모두 대문자이고 단어 사이에 공백이 있습니다. 이런 형식은 분석 시 컬럼 이름을 자주 호출해야 하기 때문에 대소문자와 공백을 매번 신경 써야 해서 그다지 좋은 이름이 아닙니다.</p>
<p>컬럼 이름에 대한 이상적인 형식은 다음과 같습니다. - 소문자(lowercase) - 스네이크케이스(snakecase, 공백을 <code>_</code> 밑줄로 대체한 형식)</p>
<p>데이터셋의 한 컬럼을 예로 들어 설명하자면 현재 컬럼 이름은 다음과 같이 되어 있습니다. <code>BUILDING CLASS CATEGORY</code> 🤮 이상적인 형식은 다음과 같을 것입니다. <code>building_class_category</code> 😇</p>
<p>이런 변환을 수행하는 함수를 하나 작성하겠습니다. 먼저 <code>BUILDING CLASS CATEGORY</code> 예시부터 시작해 봅시다.</p>
<div id="aba5ec98" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> <span class="st">"BUILDING CLASS CATEGORY"</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 컬럼 이름을 소문자로 만들고 공백을 밑줄로 바꾸는 함수</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clean_column_name(column: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> column.lower().replace(<span class="st">" "</span>, <span class="st">"_"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>clean_column_name(original)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 'building_class_category'</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>'building_class_category'</code></pre>
</div>
</div>
<p>이제 이 함수를 <strong>모든</strong> 컬럼 이름에 적용하려면, 각 컬럼 이름에 대해 <code>clean_column_name()</code>을 적용해 새로운 컬럼 이름 리스트를 만든 뒤 <code>with_columns</code> 또는 <code>rename</code>에 넘겨주면 됩니다.</p>
<div id="24907a95" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># df: pl.DataFrame</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 딕셔너리 버전 (원래 이름 -&gt; 새 이름)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>column_dict <span class="op">=</span> {c: clean_column_name(c) <span class="cf">for</span> c <span class="kw">in</span> df.columns}</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) rename 사용</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.rename(column_dict)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 또는 리스트로 한 번에 지정</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># new_cols = [clean_column_name(c) for c in df.columns]</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co"># df = df.with_columns(df.columns).rename({old: new for old, new in zip(df.columns, new_cols)})</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>df.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (5, 21)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">borough</th>
<th data-quarto-table-cell-role="th">neighborhood</th>
<th data-quarto-table-cell-role="th">building_class_category</th>
<th data-quarto-table-cell-role="th">tax_class_at_present</th>
<th data-quarto-table-cell-role="th">block</th>
<th data-quarto-table-cell-role="th">lot</th>
<th data-quarto-table-cell-role="th">ease-ment</th>
<th data-quarto-table-cell-role="th">building_class_at_present</th>
<th data-quarto-table-cell-role="th">address</th>
<th data-quarto-table-cell-role="th">apartment_number</th>
<th data-quarto-table-cell-role="th">zip_code</th>
<th data-quarto-table-cell-role="th">residential_units</th>
<th data-quarto-table-cell-role="th">commercial_units</th>
<th data-quarto-table-cell-role="th">total_units</th>
<th data-quarto-table-cell-role="th">land_square_feet</th>
<th data-quarto-table-cell-role="th">gross_square_feet</th>
<th data-quarto-table-cell-role="th">year_built</th>
<th data-quarto-table-cell-role="th">tax_class_at_time_of_sale</th>
<th data-quarto-table-cell-role="th">building_class_at_time_of_sale</th>
<th data-quarto-table-cell-role="th">sale_price</th>
<th data-quarto-table-cell-role="th">sale_date</th>
</tr>
<tr class="even">
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>i64</td>
<td>i64</td>
<td>str</td>
<td>str</td>
<td>str</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2A"</td>
<td>392</td>
<td>6</td>
<td>" "</td>
<td>"C2"</td>
<td>"153 AVENUE B"</td>
<td>" "</td>
<td>10009</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>"1633"</td>
<td>"6440"</td>
<td>1900</td>
<td>2</td>
<td>"C2"</td>
<td>"6625000"</td>
<td>"2017-07-19 00:00:00"</td>
</tr>
<tr class="even">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2"</td>
<td>399</td>
<td>26</td>
<td>" "</td>
<td>"C7"</td>
<td>"234 EAST 4TH&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>28</td>
<td>3</td>
<td>31</td>
<td>"4616"</td>
<td>"18690"</td>
<td>1900</td>
<td>2</td>
<td>"C7"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2016-12-14 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2"</td>
<td>399</td>
<td>39</td>
<td>" "</td>
<td>"C7"</td>
<td>"197 EAST 3RD&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>16</td>
<td>1</td>
<td>17</td>
<td>"2212"</td>
<td>"7803"</td>
<td>1900</td>
<td>2</td>
<td>"C7"</td>
<td>" -&nbsp;&nbsp;"</td>
<td>"2016-12-09 00:00:00"</td>
</tr>
<tr class="even">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2B"</td>
<td>402</td>
<td>21</td>
<td>" "</td>
<td>"C4"</td>
<td>"154 EAST 7TH STREET"</td>
<td>" "</td>
<td>10009</td>
<td>10</td>
<td>0</td>
<td>10</td>
<td>"2272"</td>
<td>"6794"</td>
<td>1913</td>
<td>2</td>
<td>"C4"</td>
<td>"3936272"</td>
<td>"2016-09-23 00:00:00"</td>
</tr>
<tr class="odd">
<td>1</td>
<td>"ALPHABET CITY"</td>
<td>"07 RENTALS - WALKUP APARTMENTS…</td>
<td>"2A"</td>
<td>404</td>
<td>55</td>
<td>" "</td>
<td>"C2"</td>
<td>"301 EAST 10TH&nbsp;&nbsp;&nbsp;STREET"</td>
<td>" "</td>
<td>10009</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>"2369"</td>
<td>"4615"</td>
<td>1900</td>
<td>2</td>
<td>"C2"</td>
<td>"8000000"</td>
<td>"2016-11-17 00:00:00"</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>위 코드는 원래 컬럼 이름(예: <code>BUILDING CLASS CATEGORY</code>)을 새 이름(예: <code>building_class_category</code>)으로 바꾸어 저장합니다. 컬럼들이 이제 정말 깔끔해 보이네요!🎉</p>
</section>
<section id="컬럼-삭제하기" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="컬럼-삭제하기"><span class="header-section-number">1.2</span> 컬럼 삭제하기</h2>
<p>우리 데이터셋에는 21개의 컬럼이 있지만 분석에 모두 사용할 필요는 없습니다. 예를 들어, 이번 분석에서 다음 컬럼들은 크게 중요하지 않습니다.</p>
<ul>
<li><code>ease-ment</code><br>
</li>
<li><code>lot</code><br>
</li>
<li><code>block</code><br>
</li>
<li><code>tax_class_at_time_of_sale</code><br>
</li>
<li><code>tax_class_at_present</code></li>
</ul>
<p>따라서 이 컬럼들은 데이터프레임에서 제거 하겠습니다. <code>polars</code> 에서는 <code>select</code> 또는 <code>drop</code>을 이용해 제거할 수 있는데 여기서는 이름으로 명시적으로 지우는 방식을 사용해 보겠습니다.</p>
<div id="5d324764" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 제거할 컬럼 목록</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>columns_to_remove <span class="op">=</span> [</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ease-ment"</span>,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"lot"</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"block"</span>,</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"tax_class_at_present"</span>,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"tax_class_at_time_of_sale"</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 방법 1: drop 사용</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.drop(columns_to_remove)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 방법 2: 필요한 컬럼만 선택 (참고용)</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"># df = df.select([c for c in df.columns if c not in columns_to_remove])</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 컬럼 수 확인</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.shape)  <span class="co"># (84548, 16) 과 유사한 결과 기대</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>(84548, 16)</code></pre>
</div>
</div>
<p>현재 컬럼 수 확인 결과를 보면 데이터프레임이 21개 컬럼에서 16개 컬럼으로 줄어든 것을 볼 수 있습니다.</p>
<blockquote class="blockquote">
<p>중요<br>
방법2 코드는 필요 없는 5개의 컬럼을 제거한 새 데이터프레임을 덮어쓰고 있습니다. 이미 컬럼을 삭제한 뒤에 이 코드를 다시 실행하면, 해당 컬럼들이 더 이상 존재하지 않기 때문에 에러가 발생합니다. 따라서 같은 컬럼을 두 번 이상 삭제하지 않도록 주의해야 합니다.</p>
</blockquote>
</section>
<section id="컬럼-자료형-고치기" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="컬럼-자료형-고치기"><span class="header-section-number">1.3</span> 컬럼 자료형 고치기</h2>
<p>데이터프레임을 처음 불러올 때 컬럼의 자료형이 제대로 로딩되지 않는 경우가 자주 있습니다. 예를 들어, 숫자형 컬럼이 정수나 실수 대신 문자열을 의미하는 <code>object</code> 로 로딩되거나, 날짜·시간 컬럼이 기본적으로 문자열(object)로 로딩되기 때문에, 적절한 자료형으로 직접 변환해 주어야 합니다.</p>
<p>자료형을 고치기 전에, 사용할 수 있는 대표적인 자료형들을 간단히 정리해 보겠습니다.</p>
<ul>
<li><code>int64</code>: 정수(소수점 없는 숫자) 자료형<br>
</li>
<li><code>float64</code>: 실수(소수점이 있는 숫자) 자료형<br>
</li>
<li><code>bool</code>: 참/거짓(boolean) 자료형<br>
</li>
<li><code>object</code>: 문자열이거나, 서로 다른 자료형이 섞여 있을 때 사용하는 포괄적인 자료형 (예: 문자열 + 정수 섞여 있는 경우)</li>
</ul>
<p>현재 데이터프레임의 자료형을 대략 확인해 보면 다음과 같습니다.</p>
<div id="08b3604e" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df.schema</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>Schema([('borough', Int64),
        ('neighborhood', String),
        ('building_class_category', String),
        ('building_class_at_present', String),
        ('address', String),
        ('apartment_number', String),
        ('zip_code', Int64),
        ('residential_units', Int64),
        ('commercial_units', Int64),
        ('total_units', Int64),
        ('land_square_feet', String),
        ('gross_square_feet', String),
        ('year_built', Int64),
        ('building_class_at_time_of_sale', String),
        ('sale_price', String),
        ('sale_date', String)])</code></pre>
</div>
</div>
<p>이 중에서 <code>"String"</code>로 표시되어 있지만 실제로는 정수나 실수가 될 수 있는 컬럼이 몇 개 보입니다.</p>
<ul>
<li><code>land_square_feet</code><br>
</li>
<li><code>gross_square_feet</code><br>
</li>
<li><code>sale_price</code></li>
</ul>
<p>보통 <code>polars</code> 가 자동으로 데이터형을 변환해주지만 이런 것은 오류가 있어서 수동으로 바꿔줘야 합니다. 예를 들어 <code>sale_price</code> 컬럼에 <code>' -  '</code> 같은 값이 섞여 있어서 float으로 바로 변환할 수 없습니다. 따라서 먼저 이런 특이한 문자열을 결측값을 의미하는 <code>None</code>으로 바꿔주는 처리가 필요합니다.</p>
<div id="9ef93dd4" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>cols_to_fix <span class="op">=</span> [<span class="st">"sale_price"</span>, <span class="st">"land_square_feet"</span>, <span class="st">"gross_square_feet"</span>]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_fix:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.with_columns(</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        pl.when(pl.col(col) <span class="op">==</span> <span class="st">" -  "</span>).then(<span class="va">None</span>).otherwise(pl.col(col)).alias(col)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    ).with_columns(pl.col(col).cast(pl.Float64))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>df.schema</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>Schema([('borough', Int64),
        ('neighborhood', String),
        ('building_class_category', String),
        ('building_class_at_present', String),
        ('address', String),
        ('apartment_number', String),
        ('zip_code', Int64),
        ('residential_units', Int64),
        ('commercial_units', Int64),
        ('total_units', Int64),
        ('land_square_feet', Float64),
        ('gross_square_feet', Float64),
        ('year_built', Int64),
        ('building_class_at_time_of_sale', String),
        ('sale_price', Float64),
        ('sale_date', String)])</code></pre>
</div>
</div>
<p>이렇게 <code>' -  '</code>라는 이상한 하이픈 문자열을 제거(결측값으로 치환)한 뒤에야 해당 컬럼들을 <code>float</code> 자료형으로 안전하게 변환된 것을 확인 할 수 있습니다.</p>
<section id="날짜-컬럼-sale_date를-datetime으로-변환" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="날짜-컬럼-sale_date를-datetime으로-변환"><span class="header-section-number">1.3.1</span> 날짜 컬럼 <code>sale_date</code>를 datetime으로 변환</h3>
<p><code>polars</code> 에서는 <code>pl.str.to_datetime()</code>를 사용해 문자열을 datetime으로 변환합니다.</p>
<div id="66a73723" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 형식이 'YYYY-MM-DD HH:MM:SS' 인 경우</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.with_columns(pl.col(<span class="st">"sale_date"</span>).<span class="bu">str</span>.to_datetime(<span class="bu">format</span><span class="op">=</span><span class="st">"%Y-%m-</span><span class="sc">%d</span><span class="st"> %H:%M:%S"</span>, strict<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">"sale_date"</span>].dtype)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Datetime(time_unit='us', time_zone=None)</code></pre>
</div>
</div>
<ul>
<li>포맷이 <code>2017-03-09 00:00:00</code>처럼 시간까지 포함된 형태라면 위와 같이 <code>%Y-%m-%d %H:%M:%S</code>를 사용합니다.</li>
<li>포맷이 <code>YYYY-MM-DD</code>만 있다면 <code>format="%Y-%m-%d"</code>로 바꿔 사용하면 됩니다.</li>
</ul>
<p>이 과정을 거치면 <code>sale_price</code>, <code>land_square_feet</code>, <code>gross_square_feet</code>는 실수형으로, <code>sale_date</code>는 datetime 자료형으로 올바르게 변환됩니다.</p>
</section>
</section>
<section id="결측값-다루기" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="결측값-다루기"><span class="header-section-number">1.4</span> 결측값 다루기</h2>
<p>앞서 데이터에 결측값이 없다고 생각했던 것 기억나나요? 이제 데이터를 정제하고 나니 상황이 달라졌습니다.다음 컬럼들에 결측값이 있다는 것을 알 수 있습니다.</p>
<ul>
<li><code>sale_price</code><br>
</li>
<li><code>land_square_feet</code><br>
</li>
<li><code>gross_square_feet</code></li>
</ul>
<p>이제 각 컬럼에 결측값이 얼마나 있는지 다시 살펴보겠습니다.</p>
<p>데이터프레임의 각 컬럼마다 결측값이 몇 개 있는지 알고 싶다면 다음과 같이 계산할 수 있습니다.</p>
<div id="13fdb3b2" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 컬럼별 결측치 개수</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>null_counts_df <span class="op">=</span> df.null_count()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>null_counts <span class="op">=</span> null_counts_df.to_dicts()[<span class="dv">0</span>]  <span class="co"># 단일 행을 딕셔너리로 변환</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>n_rows <span class="op">=</span> df.height  <span class="co"># 전체 행 수</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"각 컬럼별 결측치 개수 및 비율(%):"</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, cnt <span class="kw">in</span> null_counts.items():</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    pct <span class="op">=</span> (cnt <span class="op">/</span> n_rows) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>cnt<span class="sc">}</span><span class="ss">개 (</span><span class="sc">{</span>pct<span class="sc">:.2f}</span><span class="ss">%)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>각 컬럼별 결측치 개수 및 비율(%):
borough: 0개 (0.00%)
neighborhood: 0개 (0.00%)
building_class_category: 0개 (0.00%)
building_class_at_present: 0개 (0.00%)
address: 0개 (0.00%)
apartment_number: 0개 (0.00%)
zip_code: 0개 (0.00%)
residential_units: 0개 (0.00%)
commercial_units: 0개 (0.00%)
total_units: 0개 (0.00%)
land_square_feet: 26252개 (31.05%)
gross_square_feet: 27612개 (32.66%)
year_built: 0개 (0.00%)
building_class_at_time_of_sale: 0개 (0.00%)
sale_price: 14561개 (17.22%)
sale_date: 0개 (0.00%)</code></pre>
</div>
</div>
<p>우와! 면적(square footage) 관련 컬럼들이 <code>sale_price</code> 컬럼보다 훨씬 더 많은 결측값을 가지고 있는 것을 알 수 있습니다. 각 컬럼별로 전체 행 개수 대비 몇 퍼센트가 결측인지도 계산해 보니, 면적 정보(<code>land_square_feet</code>, <code>gross_square_feet</code>)는 30%가 넘는 부동산에서 빠져 있고, <code>sale_price</code>는 약 17%가 결측입니다.</p>
<p><code>sale_price</code>가 결측인 행은 분석 대상에서 제외하고 싶다면 다음과 같이 해당 행들을 제거할 수 있습니다.</p>
<div id="212c68f4" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 드롭 이전 shape</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>before_rows, before_cols <span class="op">=</span> df.shape</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"드롭 이전: </span><span class="sc">{</span>before_rows<span class="sc">}</span><span class="ss">행, </span><span class="sc">{</span>before_cols<span class="sc">}</span><span class="ss">열"</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co"># sale_price가 null이 아닌 행만 유지</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.<span class="bu">filter</span>(pl.col(<span class="st">"sale_price"</span>).is_not_null())</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 드롭 이후 shape</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>after_rows, after_cols <span class="op">=</span> df.shape</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"드롭 이후: </span><span class="sc">{</span>after_rows<span class="sc">}</span><span class="ss">행, </span><span class="sc">{</span>after_cols<span class="sc">}</span><span class="ss">열"</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"제거된 행 수: </span><span class="sc">{</span>before_rows <span class="op">-</span> after_rows<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>드롭 이전: 84548행, 16열
드롭 이후: 69987행, 16열
제거된 행 수: 14561</code></pre>
</div>
</div>
</section>
<section id="데이터-부분-선택" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="데이터-부분-선택"><span class="header-section-number">1.5</span> 데이터 부분 선택</h2>
<p>이제 컬럼 이름과 자료형을 알맞게 정리했으니, 각 데이터 값이 <strong>말이 되는지</strong> 확인하기 위해 데이터 탐색(EDA)을 시작할 수 있습니다.</p>
<p>만약 포함된 값이 비현실적이라면 합리적인 범위에 들어오는 값만 남기도록 데이터프레임을 부분 선택(서브셋)할 수 있는데, 이 과정을 데이터 서브셋팅이라고 부릅니다.</p>
<p>이 작업은 과학이라기보다는 예술에 가까운 면이 있어서, 무엇이 말이 되는 값인지 판단하려면 도메인 지식이 조금 필요합니다. 이제 이 데이터프레임에 그 방법을 적용해 보겠습니다.</p>
<p>여기서는 <code>year_built</code> 컬럼에 집중해 값들이 타당한지 확인해 보겠습니다.</p>
<ul>
<li>한 자료에 따르면 뉴욕에서 가장 오래된 건물은 1650년대에 지어졌다고 하므로, 그 이전 연도인 건물들은 잘못된 값일 가능성이 큽니다.(도메인 지식)</li>
<li>데이터셋에서 <code>year_built</code>의 최솟값을 구해 보면 다음과 같습니다.</li>
</ul>
<div id="aa4021b4" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># year_built의 최소값 확인</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>min_year <span class="op">=</span> df.select(pl.col(<span class="st">"year_built"</span>).<span class="bu">min</span>()).item()</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"최소 year_built:"</span>, min_year)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>최소 year_built: 0</code></pre>
</div>
</div>
<p>연도가 “0”이라니 전혀 말이 되지 않습니다. 이 값을 제거하기 위해, <code>year_built</code>가 1650보다 큰 행만 남기는 데이터 서브셋을 만들겠습니다. 불리언 비교 연산을 사용해 쉽게 할 수 있습니다.</p>
<div id="b3104200" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># year_built &gt; 1650인 행만 남긴 서브셋 생성</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df.<span class="bu">filter</span>(pl.col(<span class="st">"year_built"</span>) <span class="op">&gt;</span> <span class="dv">1650</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 필터링 후 행 수 확인</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>n_original <span class="op">=</span> df.height</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>n_filtered <span class="op">=</span> df_filtered.height</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"필터링 후 행 수: </span><span class="sc">{</span>n_filtered<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"제거된 행 수: </span><span class="sc">{</span>n_original <span class="op">-</span> n_filtered<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 필터링된 데이터에서 year_built 최소값 확인</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>new_min_year <span class="op">=</span> df_filtered.select(pl.col(<span class="st">"year_built"</span>).<span class="bu">min</span>()).item()</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"필터링 후 최소 year_built:"</span>, new_min_year)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>필터링 후 행 수: 64595
제거된 행 수: 5392
필터링 후 최소 year_built: 1800</code></pre>
</div>
</div>
<p>불리언을 사용하면 “이 부동산의 <code>year_built</code>가 1650보다 큰가?”라는 질문에 대해 크면 <code>True</code>, 아니면 <code>False</code>를 반환합니다. 이 조건을 데이터프레임에 적용하면 조건이 <code>True</code>인 행만 남는 새로운 데이터프레임 서브셋을 얻을 수 있습니다. 이 서브셋을 <code>df_filtered</code>라는 새 변수에 저장합니다. 그런다음 현재 행이 몇 개 남았는지는 <code>len()</code> 또는 <code>df_filtered.shape[0]</code>으로 확인할 수 있습니다.</p>
<p>제거된 행의 수는 원래 데이터프레임의 행 수에서 필터링된 데이터프레임의 행 수를 빼서 알 수 있습니다. 즉, <code>year_built</code>가 1650 미만인 부동산이 거의 7천 개 가까이 제거된 셈으로 꽤 큰 규모의 정제입니다. 필터링된 데이터프레임에서 새로운 <code>year_built</code>의 최솟값을 확인해 보면 1800으로 훨씬 더 말이 되는 값이라는 것을 알 수 있습니다.</p>
</section>
<section id="컬럼-값-다시-코딩하기" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="컬럼-값-다시-코딩하기"><span class="header-section-number">1.6</span> 컬럼 값 다시 코딩하기</h2>
<p>우리는 뉴욕시 부동산 데이터를 다루고 있으므로 각 부동산이 어느 구(borough)에 있는지를 나타내는 컬럼이 있는지 확인하는 것이 중요합니다. 이 <code>borough</code> 컬럼은 구에 따라 부동산 가격이 크게 달라지기 때문에 분석에서 매우 중요한 역할을 합니다. 예를 들어, 번화가인 맨해튼과 스태튼아일랜드의 중위 주택 가격은 매우 다릅니다.</p>
<p><code>df_filtered["borough"].unique()</code>를 보면 값이 <code>[1, 2, 3, 4, 5]</code>로 숫자 코드로 되어 있습니다. Kaggle 설명에 따르면 이 값들은 각각 다음을 의미합니다: 맨해튼(1), 브롱크스(2), 브루클린(3), 퀸즈(4), 스태튼아일랜드(5)입니다. 이 숫자 코드를 사람이 읽기 쉬운 문자열로 다시 코딩해 보겠습니다. 먼저 숫자와 구 이름을 매핑하는 딕셔너리를 만듭니다. 그런다음 <code>replace</code>를 이용해 매핑 작업을 할 수 있습니다.</p>
<div id="c1a754a9" class="cell" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>boroughs_dict <span class="op">=</span> {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"Manhattan"</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"Bronx"</span>,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"Brooklyn"</span>,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"Queens"</span>,</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"Staten Island"</span>,</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df_filtered.with_columns(</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"borough"</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    .cast(pl.Utf8)  <span class="co"># 1) 문자열로 형 변환</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    .replace(boroughs_dict)  <span class="co"># 2) 숫자→문자열 매핑</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    .alias(<span class="st">"borough"</span>)  <span class="co"># 3) 같은 이름으로 덮어쓰기</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 확인: 고유 값 출력</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_filtered.select(pl.col(<span class="st">"borough"</span>).unique()))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 1)
┌───────────────┐
│ borough       │
│ ---           │
│ str           │
╞═══════════════╡
│ Manhattan     │
│ Brooklyn      │
│ Staten Island │
│ Queens        │
│ Bronx         │
└───────────────┘</code></pre>
</div>
</div>
<p>이렇게 하면 <code>borough</code> 컬럼이 <code>[1, 2, 3, 4, 5]</code>에서 <code>["Manhattan", "Bronx", "Brooklyn", "Queens", "Staten Island"]</code>로 변환됩니다.</p>
</section>
<section id="컬럼-값-포매팅" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="컬럼-값-포매팅"><span class="header-section-number">1.7</span> 컬럼 값 포매팅</h2>
<p>꼭 필요한 단계는 아니지만 문자열 컬럼의 값들을 정리하고 다시 포매팅해 두면 좋습니다. 이런 작은 조정만으로도 나중에 데이터를 분석할 때 결과를 해석하기가 더 <strong>쉬워집니다</strong>. 이 섹션에서는 다음 두 컬럼을 정리하겠습니다.</p>
<ul>
<li><code>neighborhood</code></li>
<li><code>building_class_category</code></li>
</ul>
<section id="neighborhood-컬럼-포매팅title-case" class="level3" data-number="1.7.1">
<h3 data-number="1.7.1" class="anchored" data-anchor-id="neighborhood-컬럼-포매팅title-case"><span class="header-section-number">1.7.1</span> neighborhood 컬럼 포매팅(TITLE CASE)</h3>
<p>현재 <code>neighborhood</code> 컬럼은 모두 대문자입니다.각 단어의 첫 글자는 대문자, 나머지는 소문자가 되도록 바꾸고 싶습니다. 이를 위해 사용할 수 있는 함수 두 가지는 <code>title()</code>과 <code>capitalize()</code>입니다.</p>
<ul>
<li><code>title()</code>은 문자열의 <strong>모든</strong> 단어 첫 글자를 대문자로 만듭니다.</li>
<li><code>capitalize()</code>는 문자열 전체에서 첫 글자 <strong>하나만</strong> 대문자로 만듭니다.</li>
</ul>
<p>우리는 동네 이름을 다루고 있으므로 <code>title()</code>을 쓰는 것이 적절할 것 입니다. 이제 <code>apply()</code>를 이용해 데이터프레임 각 행에 <code>title()</code>을 적용합니다. 이때 이름이 없는 익명 함수(람다)를 사용하겠습니다.</p>
<blockquote class="blockquote">
<p>익명 함수는 이름 없이 한 줄로 정의하는 함수이며, <code>def</code> 대신 <code>lambda</code> 키워드를 사용합니다. 즉, 한 번만 쓰고 말 간단한 로직에 유용한 기능입니다.</p>
</blockquote>
<div id="4714da7b" class="cell" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 단어의 첫 글자만 대문자로: UPPER → Title Case</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df_filtered.with_columns(</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"neighborhood"</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">str</span>.to_lowercase()  <span class="co"># 전부 소문자</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">str</span>.to_titlecase()  <span class="co"># 각 단어 첫 글자 대문자</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    .alias(<span class="st">"neighborhood"</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_filtered.select(pl.col(<span class="st">"neighborhood"</span>).unique()))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (253, 1)
┌──────────────────────┐
│ neighborhood         │
│ ---                  │
│ str                  │
╞══════════════════════╡
│ Williamsburg-North   │
│ Javits Center        │
│ Midtown West         │
│ Brownsville          │
│ Morris Park/Van Nest │
│ …                    │
│ Midtown East         │
│ Jamaica Estates      │
│ Downtown-Fulton Mall │
│ Bayside              │
│ East New York        │
└──────────────────────┘</code></pre>
</div>
</div>
</section>
<section id="building_class_category-포매팅" class="level3" data-number="1.7.2">
<h3 data-number="1.7.2" class="anchored" data-anchor-id="building_class_category-포매팅"><span class="header-section-number">1.7.2</span> building_class_category 포매팅</h3>
<p>이제 좀 더 복잡한 <code>building_class_category</code> 컬럼을 포매팅해 보겠습니다. 이 컬럼에는 다음 두 가지 변환을 적용하려고 합니다.</p>
<ol type="1">
<li>문자열 맨 앞에 있는 숫자를 제거한다.<br>
</li>
<li>문자열을 대문자에서 ’문장형(capitalized)’으로 바꾼다.</li>
</ol>
<p>두 단계가 필요하므로 <code>neighborhood</code>에서와 달리, 별도의 일반 함수를 하나 만들겠습니다.</p>
<p>먼저 <code>building_class_category</code> 문자열을 리스트로 쪼갭니다. 그다음, 첫 번째 요소를 제외하고 다시 합쳐 하나의 문자열로 만들고, <code>capitalize()</code>로 문장형으로 바꿉니다.</p>
<p>마지막으로 이 로직을 함수 하나로 묶어서 정의합니다. 그 후 이 함수를 <code>building_class_category</code> 컬럼의 모든 값에 적용합니다. 적용 결과를 확인해 보면, 앞의 숫자는 제거되고 전체 문자열은 대문자 대신 문장형이며 끝에 남아 있던 공백도 제거된 것을 볼 수 있습니다.</p>
<div id="c4744d1a" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_building_class_category(text: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> text <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    parts <span class="op">=</span> text.split(<span class="st">" "</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 최소 2개 이상일 때만 앞 요소 제거</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    cleaned <span class="op">=</span> <span class="st">" "</span>.join(parts[<span class="dv">1</span>:]) <span class="cf">if</span> <span class="bu">len</span>(parts) <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> text</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    cleaned <span class="op">=</span> cleaned.capitalize()  <span class="co"># Rentals - walkup apartments</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cleaned.strip()  <span class="co"># 좌우 공백 제거</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>df_filtered <span class="op">=</span> df_filtered.with_columns(</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"building_class_category"</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    .map_elements(format_building_class_category, return_dtype<span class="op">=</span>pl.Utf8)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    .alias(<span class="st">"building_class_category"</span>)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_filtered.select(pl.col(<span class="st">"building_class_category"</span>).unique()))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (46, 1)
┌─────────────────────────────────┐
│ building_class_category         │
│ ---                             │
│ str                             │
╞═════════════════════════════════╡
│ Warehouses                      │
│ Factories                       │
│ Hospital and health facilities  │
│ Office buildings                │
│ Commercial vacant land          │
│ …                               │
│ Outdoor recreational facilitie… │
│ Selected governmental faciliti… │
│ Rentals - walkup apartments     │
│ Coops - elevator apartments     │
│ Theatres                        │
└─────────────────────────────────┘</code></pre>
</div>
</div>
</section>
</section>
<section id="데이터프레임-병합하기" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="데이터프레임-병합하기"><span class="header-section-number">1.8</span> 데이터프레임 병합하기</h2>
<p>두 데이터셋이 공통 컬럼을 가지고 있다면, 이를 기준으로 합쳐서 더 큰 데이터셋을 만들 수 있습니다. SQL에서는 JOIN 구문으로 이를 수행하고, `polars 에서는 .join() 함수로 같은 작업을 합니다. 조인은 “왼쪽 데이터프레임”의 값과 “오른쪽 데이터프레임”의 값을 공통 컬럼을 기준으로 매칭해 합치는 작업입니다.</p>
<blockquote class="blockquote">
<p>​두 데이터프레임 모두에 존재하는 공통 컬럼이 있어야 하며, 이 컬럼 값이 일치하는 행끼리 묶입니다. ​ ### 조인 종류</p>
</blockquote>
<ul>
<li>Inner join: 두 데이터프레임 모두에 매칭되는 행만 반환. ​* Left join: 왼쪽 데이터프레임의 모든 행을 유지하고, 오른쪽에 매칭이 없는 경우 오른쪽 컬럼이 NULL이 됨. ​* Right join: 오른쪽 데이터프레임 기준으로 모든 행을 유지. ​* Full outer join: 양쪽 데이터프레임의 모든 행을 유지하므로, 데이터가 매우 커질 수 있음. ​ &gt; 실무에서는 left join과 inner join을 가장 자주 사용하고, right join과 full outer join은 상대적으로 드뭅니다.</li>
</ul>
<div id="4d852138" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 예제 데이터 생성</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>df1 <span class="op">=</span> pl.DataFrame(</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Courses"</span>: [<span class="st">"Spark"</span>, <span class="st">"PySpark"</span>, <span class="st">"Python"</span>, <span class="st">"Pandas"</span>],</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Fees"</span>: [<span class="dv">20000</span>, <span class="dv">25000</span>, <span class="dv">22000</span>, <span class="dv">30000</span>],</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Duration"</span>: [<span class="st">"30days"</span>, <span class="st">"40days"</span>, <span class="st">"35days"</span>, <span class="st">"50days"</span>],</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> pl.DataFrame(</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"Courses"</span>: [<span class="st">"Spark"</span>, <span class="st">"Java"</span>, <span class="st">"Python"</span>, <span class="st">"C++"</span>], <span class="st">"Discount"</span>: [<span class="dv">2000</span>, <span class="dv">2300</span>, <span class="dv">1200</span>, <span class="dv">2000</span>]}</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Left Join: 왼쪽 DF 모든 행 유지, 매칭 안 되면 null</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>result_left <span class="op">=</span> df1.join(df2, on<span class="op">=</span><span class="st">"Courses"</span>, how<span class="op">=</span><span class="st">"left"</span>)</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Left Join:</span><span class="ch">\n</span><span class="st">"</span>, result_left)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Inner Join: 양쪽에 모두 매칭되는 행만 반환</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>result_inner <span class="op">=</span> df1.join(df2, on<span class="op">=</span><span class="st">"Courses"</span>, how<span class="op">=</span><span class="st">"inner"</span>)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Inner Join:</span><span class="ch">\n</span><span class="st">"</span>, result_inner)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Left Join:
 shape: (4, 4)
┌─────────┬───────┬──────────┬──────────┐
│ Courses ┆ Fees  ┆ Duration ┆ Discount │
│ ---     ┆ ---   ┆ ---      ┆ ---      │
│ str     ┆ i64   ┆ str      ┆ i64      │
╞═════════╪═══════╪══════════╪══════════╡
│ Spark   ┆ 20000 ┆ 30days   ┆ 2000     │
│ PySpark ┆ 25000 ┆ 40days   ┆ null     │
│ Python  ┆ 22000 ┆ 35days   ┆ 1200     │
│ Pandas  ┆ 30000 ┆ 50days   ┆ null     │
└─────────┴───────┴──────────┴──────────┘
Inner Join:
 shape: (2, 4)
┌─────────┬───────┬──────────┬──────────┐
│ Courses ┆ Fees  ┆ Duration ┆ Discount │
│ ---     ┆ ---   ┆ ---      ┆ ---      │
│ str     ┆ i64   ┆ str      ┆ i64      │
╞═════════╪═══════╪══════════╪══════════╡
│ Spark   ┆ 20000 ┆ 30days   ┆ 2000     │
│ Python  ┆ 22000 ┆ 35days   ┆ 1200     │
└─────────┴───────┴──────────┴──────────┘</code></pre>
</div>
</div>
</section>
<section id="데이터프레임을-새로운-csv-파일로-저장하기" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="데이터프레임을-새로운-csv-파일로-저장하기"><span class="header-section-number">1.9</span> 데이터프레임을 새로운 CSV 파일로 저장하기</h2>
<p>이제 정제된 데이터셋이 준비되었습니다. 이 정제된 데이터프레임을 나중에 다시 불러오려면 먼저 CSV 파일로 저장해야 합니다. 이를 위해 .write_csv()를 사용할 수 있으며 함수 안에서 파일을 어느 경로에 저장할지 지정해 주면 됩니다.</p>
<div id="50c2f56e" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>df_filtered.write_csv(<span class="st">"../data/nyc_real_estate_cleaned.csv"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
</section>
<section id="데이터-시각화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 데이터 시각화</h1>
<p>데이터 시각화는 데이터 탐색에서 매우 중요한 부분입니다. 파이썬 기반 데이터 시각화 라이브러리는 여러 가지가 있으며, 대표적으로 다음과 같은 것들이 있습니다. ​ * Matplotlib * Seaborn * Altair * Plotly</p>
<p>이 중 <code>Matplotlib</code>과 <code>seaborn</code>이 가장 많이 사용됩니다. <code>Matplotlib</code>은 가장 오래된, 전통적인 시각화 라이브러리이며 <code>seaborn</code>은 그 위에 구축된 래퍼(wrapper) 라이브러리입니다.​</p>
<p>이 장에서는 <code>seaborn</code>으로 플롯을 만들고, <code>Matplotlib</code>을 이용해 그것을 커스터마이징하는 방법에 집중해서 살펴보겠습니다.</p>
<div id="a8c65324" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pl.read_csv(<span class="st">"../data/nyc_real_estate_cleaned.csv"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="분포-그리기" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="분포-그리기"><span class="header-section-number">2.1</span> 분포 그리기</h2>
<p>데이터 분포를 살펴 보면 데이터가 양의 치우침(positive skew), 음의 치우침(negative skew)을 가지는지, 혹은 정규분포에 가까운지를 포함해 많은 유용한 정보를 알 수 있습니다.</p>
<p><code>seaborn</code>은 수치형 변수의 분포를 시각화하는 데 도움이 되는 여러 가지 플롯 함수를 제공합니다. <code>seaborn</code>으로 다음과 같은 분포 관련 플롯들을 만들어 보겠습니다.</p>
<ul>
<li>히스토그램 (Histogram)</li>
<li>커널 밀도 추정(KDE) 플롯 (Kernel density estimate plot)</li>
<li>박스플롯 (Boxplot)</li>
<li>바이올린 플롯 (Violinplot) ​</li>
</ul>
<section id="히스토그램" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="히스토그램"><span class="header-section-number">2.1.1</span> 히스토그램</h3>
<p><code>seaborn</code>의 histplot() 함수는 데이터에 대한 단순한 히스토그램 시각화를 제공합니다. 이 함수에서 지정해야 하는 주요 인자는 <code>x</code> 와 <code>data</code> 입니다.</p>
<div id="27791653" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>sns.histplot(x<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-24-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="ds_tutorial_polars_files/figure-html/cell-24-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="커널-밀도-추정-플롯" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="커널-밀도-추정-플롯"><span class="header-section-number">2.1.2</span> 커널 밀도 추정 플롯</h3>
<p>커널 밀도 추정(Kernel Density Estimate, KDE) 플롯은 히스토그램과 비슷하게 <code>kdeplot()</code> 함수를 사용해 데이터가 어디에서 가장 많이 또는 어디에서 가장 적게 분포하는지에 대한 상위 수준의 모습을 보여 줍니다.</p>
<div id="dbb0c138" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(x<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-25-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="ds_tutorial_polars_files/figure-html/cell-25-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="박스플롯boxplot" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="박스플롯boxplot"><span class="header-section-number">2.1.3</span> 박스플롯(Boxplot)</h3>
<p>연속형 변수의 <strong>중앙값(median)</strong>과 <strong>사분위 범위(interquartile range)</strong>를 이해하고 싶다면 <code>boxplot()</code> 함수가 좋은 선택입니다. 이 함수는 histplot과 kdeplot과 설정 방식이 같아서, x와 data 인자만 지정해 주면 됩니다.</p>
<div id="05741629" class="cell" data-execution_count="25">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>sns.boxplot(x<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-26-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="ds_tutorial_polars_files/figure-html/cell-26-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="바이올린-플롯violin-plot" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="바이올린-플롯violin-plot"><span class="header-section-number">2.1.4</span> 바이올린 플롯(Violin Plot)</h3>
<p>바이올린 플롯은 박스플롯(Boxplot)의 재미있는 변형입니다. 커널 밀도 추정(KDE)과 박스플롯 정보를 하나의 시각화 안에 결합해 보여 줍니다. 하얀 점은 중앙값(median)을, 검은 막대는 사분위 범위(interquartile range)를 나타냅니다. 바이올린 플롯의 외곽선은 커널 밀도 추정 곡선이며, 이를 통해 데이터의 전체적인 분포 형태를 파악할 수 있습니다.</p>
<blockquote class="blockquote">
<p>바이올린 플롯이 정말 바이올린처럼 보이시나요? 단정하긴 어렵지만, 확실히 흥미롭게 보이긴 합니다.</p>
</blockquote>
<div id="af27b2f7" class="cell" data-execution_count="26">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>sns.violinplot(x<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-27-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="ds_tutorial_polars_files/figure-html/cell-27-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>연속형 변수를 범주(카테고리)별로 나누어 보고 싶다면, x와 y 파라미터를 사용해서 각각 연속형 변수와 범주형 변수를 지정해 줄 수 있습니다.</p>
<div id="bfcb8298" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>sns.violinplot(x<span class="op">=</span><span class="st">"borough"</span>, y<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-28-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5"><img src="ds_tutorial_polars_files/figure-html/cell-28-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="범주형-데이터-그리기-plotting-categorical-data" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="범주형-데이터-그리기-plotting-categorical-data"><span class="header-section-number">2.2</span> 범주형 데이터 그리기 (Plotting Categorical Data)</h2>
<section id="카운트플롯countplot" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="카운트플롯countplot"><span class="header-section-number">2.2.1</span> 카운트플롯(Countplot)</h3>
<p>데이터의 개수를 시각화하는 방법 중 하나는 카운트플롯(countplot)입니다. 다음과 같이 손쉽게 만들 수 있습니다.</p>
<div id="14b13e88" class="cell" data-execution_count="28">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>sns.barplot(x<span class="op">=</span><span class="st">"borough"</span>, y<span class="op">=</span><span class="st">"sale_price"</span>, data<span class="op">=</span>df)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-29-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="ds_tutorial_polars_files/figure-html/cell-29-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="수치형-데이터-그리기-plotting-numerical-data" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="수치형-데이터-그리기-plotting-numerical-data"><span class="header-section-number">2.2.2</span> 수치형 데이터 그리기 (Plotting Numerical Data)</h3>
<p>두 개의 연속형 변수 사이의 관계를 시각화하고 싶다고 가정해 보겠습니다. 이럴 때는 산점도(scatterplot)를 사용할 수 있습니다. <code>scatterplot()</code> 함수는 x와 y 파라미터가 필요합니다. ​ 여기서는 연면적(gross_square_feet)과 판매 가격(sale_price)의 관계를 살펴보되, 판매 가격이 10억 달러 미만인 물건만 필터링해서 시각화해 보겠습니다.</p>
<div id="d79bf6ca" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">"gross_square_feet"</span>, y<span class="op">=</span><span class="st">"sale_price"</span>, data<span class="op">=</span>df.<span class="bu">filter</span>(pl.col(<span class="st">"sale_price"</span>) <span class="op">&lt;</span> <span class="dv">10</span><span class="op">**</span><span class="dv">9</span>))</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-30-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="ds_tutorial_polars_files/figure-html/cell-30-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="시계열-데이터-그리기-plotting-time-series-data" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="시계열-데이터-그리기-plotting-time-series-data"><span class="header-section-number">2.2.3</span> 시계열 데이터 그리기 (Plotting Time-series Data)</h3>
<p>그래프를 그리기 전에 데이터를 집계(aggregate) 해야 하는 상황이 종종 있습니다. 예를 들어, 판매 날짜별로 판매된 부동산 수를 플롯하고 싶다면 특정 날짜에 대해 부동산 개수를 쉽게 가져올 수 있도록 데이터를 변환해야 합니다. 이제 시간에 따른 판매 건수 변화를 그려 보겠습니다. 이를 위해 데이터를 <code>sale_date</code>로 그룹화해 하루에 한 행씩만 갖도록 만들겠습니다.</p>
<div id="518d36a5" class="cell" data-execution_count="30">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 날짜별 건수 집계</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>sale_date_count <span class="op">=</span> (</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    df.group_by(<span class="st">"sale_date"</span>)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    .<span class="bu">len</span>()  <span class="co"># 각 그룹 길이</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    .rename({<span class="st">"len"</span>: <span class="st">"count"</span>})  <span class="co"># count 컬럼명으로 변경</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) sale_date를 datetime으로 캐스팅 (이미 datetime이면 생략 가능)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>sale_date_count <span class="op">=</span> sale_date_count.with_columns(</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"sale_date"</span>).cast(pl.Datetime)  <span class="co"># 또는 pl.Date</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) 시각화</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"sale_date"</span>,</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"count"</span>,</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>sale_date_count,</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-31-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="ds_tutorial_polars_files/figure-html/cell-31-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="데이터-탐색-data-exploration" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 데이터 탐색 (Data Exploration)</h1>
<p>데이터로부터 의미 있는 인사이트를 얻으려면 먼저 해당 데이터와 그것이 무엇을 나타내는지 충분히 이해하고 있어야 합니다. 그래서 탐색적 데이터 분석(Exploratory Data Analysis, EDA)은 데이터 사이언스 파이프라인에서 매우 중요한 단계입니다.</p>
<p>또한 데이터에 대담한 질문을 던지고 초기 가설을 시험해 보면서 창의성과 호기심이 필요한 아주 재미있는 과정이기도 합니다.</p>
<p>탐색적 데이터 분석은 정해진 단계가 딱 정리된 형식적인 프로세스라기보다는 유연한 탐색 과정에 가깝습니다. 데이터를 탐색하다 보면 패턴을 발견하고, 이상치(outlier)를 감지하며, 처음 세웠던 가정이 여전히 유효한지 확인하게 됩니다.</p>
<p>이제 깨끗하게 정제된 데이터(CSV)와 데이터 시각화 도구(<code>seaborn</code>)을 갖추었으니, 본격적으로 데이터를 탐색해 봅시다! 🚀</p>
<div id="5d39b452" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pl.read_csv(<span class="st">"../data/nyc_real_estate_cleaned.csv"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="기술통계descriptive-statistics" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="기술통계descriptive-statistics"><span class="header-section-number">3.1</span> 기술통계(Descriptive Statistics)</h2>
<p>기술통계(descriptive statistics)는 통계적 방법을 사용해 데이터를 설명·요약하는 과정을 말합니다. 이를 통해 데이터의 분포가 어떤지, 그리고 이상치(outlier)가 존재하는지를 파악할 수 있습니다. EDA를 수행할 때는 데이터셋에 포함된 모든 변수들을 기술통계로 탐색해 보는 것이 좋습니다. ​ &gt; ❗참고: 여기서 말하는 “변수(variable)”는 데이터프레임의 한 컬럼을 의미합니다. ​ 기술통계를 어떻게 적용할지는 어떤 종류의 변수를 다루고 있는지에 따라 달라집니다. ​ ### 변수의 종류(Types of Variables)</p>
<p>변수는 크게 두 가지 유형으로 나눌 수 있습니다.</p>
<ol type="1">
<li>범주형(Categorical): 어떤 값이 몇 개의 범주(category) 중 하나로 저장될 수 있으면 범주형 변수입니다. 범주형 변수는 순서가 없는 명목형(nominal)과, 순서가 의미 있는 서열형(ordinal)으로 나눌 수 있습니다.
<ul>
<li>명목형(Nominal): 논리적인 순서가 없음 (예: NYC 구 borough) ​ * 서열형(Ordinal): 정렬 가능한 데이터 (예: 1~10점 건물 안전 등급)</li>
</ul></li>
<li>수치형(Numerical): 어떤 값이 측정값을 의미하면 수치형 변수입니다. 수치형 변수는 이산형(discrete)과 연속형(continuous)으로 나눌 수 있습니다.
<ul>
<li>이산형(Discrete): 개수를 셀 수 있는 값 (예: 임대 유닛 수) ​ * 연속형(Continuous): 이론적으로 무한한 값 범위를 가질 수 있음 (예: 건물 면적 square footage)</li>
</ul></li>
</ol>
<section id="범주형-데이터-요약summarizing-categorical-data" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="범주형-데이터-요약summarizing-categorical-data"><span class="header-section-number">3.1.1</span> 범주형 데이터 요약(Summarizing Categorical Data)</h3>
<p>NYC 데이터프레임에는 다음과 같이 여러 개의 범주형 변수가 있습니다. ​ * borough * neighborhood * building_class_category ​</p>
<section id="nyc-구nyc-boroughs" class="level4" data-number="3.1.1.1">
<h4 data-number="3.1.1.1" class="anchored" data-anchor-id="nyc-구nyc-boroughs"><span class="header-section-number">3.1.1.1</span> NYC 구(NYC Boroughs)</h4>
<p>먼저 <code>borough</code> 컬럼을 살펴보면서 각 구에서 몇 개의 부동산이 거래되었는지 세어 보겠습니다. 이 작업을 가장 쉽게 하는 방법은 <code>.value_counts()</code>를 사용하는 것으로, 이름 그대로 데이터에서 각 값이 몇 번 등장하는지를 세어 줍니다.</p>
<div id="cd41adac" class="cell" data-execution_count="32">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>borough_counts <span class="op">=</span> df.select(pl.col(<span class="st">"borough"</span>).value_counts())</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(borough_counts)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 1)
┌────────────────────────┐
│ borough                │
│ ---                    │
│ struct[2]              │
╞════════════════════════╡
│ {"Brooklyn",21864}     │
│ {"Bronx",6328}         │
│ {"Queens",17710}       │
│ {"Staten Island",5849} │
│ {"Manhattan",12844}    │
└────────────────────────┘</code></pre>
</div>
</div>
<p>value_counts()의 출력은 항상 가장 많이 등장한 값부터 적게 등장한 값 순서로 정렬됩니다. ​ 이를 통해 브루클린(Brooklyn)이 부동산 거래 건수가 가장 많고, 스태튼아일랜드(Staten Island)는 가장 적다는 것을 알 수 있습니다. ​ 흥미롭게도, 브루클린의 거래 건수는 스태튼아일랜드보다 거의 4배나 많습니다. 🤯 ​</p>
<p>또한 value_counts()에 normalize=True를 전달하면, 구별 부동산 거래 비율(%)도 구할 수 있습니다. ​ 이 옵션을 사용하면 단순 건수(count) 가 아니라, 합이 1이 되는 비율(proportion) 로 변환된 값을 돌려줍니다.</p>
<div id="0f5cbae4" class="cell" data-execution_count="33">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>borough_counts <span class="op">=</span> (</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    df.select(pl.col(<span class="st">"borough"</span>).value_counts().alias(<span class="st">"vc"</span>))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    .unnest(<span class="st">"vc"</span>)  <span class="co"># struct 컬럼 풀어서 borough, count 두 컬럼으로 만들기</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    .with_columns((pl.col(<span class="st">"count"</span>) <span class="op">/</span> pl.col(<span class="st">"count"</span>).<span class="bu">sum</span>()).alias(<span class="st">"proportion"</span>))</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(borough_counts)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 3)
┌───────────────┬───────┬────────────┐
│ borough       ┆ count ┆ proportion │
│ ---           ┆ ---   ┆ ---        │
│ str           ┆ u32   ┆ f64        │
╞═══════════════╪═══════╪════════════╡
│ Brooklyn      ┆ 21864 ┆ 0.338478   │
│ Queens        ┆ 17710 ┆ 0.27417    │
│ Bronx         ┆ 6328  ┆ 0.097964   │
│ Manhattan     ┆ 12844 ┆ 0.198839   │
│ Staten Island ┆ 5849  ┆ 0.090549   │
└───────────────┴───────┴────────────┘</code></pre>
</div>
</div>
<p>브루클린은 뉴욕시 전체 부동산 거래의 약 34%를 차지하고 그 다음이 퀸즈 27%, 맨해튼 20% 순입니다. 반면 브롱크스에서는 약 10%, 스태튼아일랜드에서는 약 9%만 거래가 발생했습니다.</p>
<p>구별 데이터를 해석하는 또 다른 방법은 <code>seaborn</code>의 카운터플랏을 사용해 시각화하는 것입니다.​</p>
<div id="005d2979" class="cell" data-execution_count="34">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>sns.countplot(x<span class="op">=</span><span class="st">"borough"</span>, data<span class="op">=</span>df)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-35-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9"><img src="ds_tutorial_polars_files/figure-html/cell-35-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="building-class-category" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="building-class-category"><span class="header-section-number">3.2</span> Building Class Category</h2>
<p>구(borough) 정보 외에도, 부동산의 건물 분류(building class category) 에 대한 데이터도 가지고 있습니다. 이 역시 충분히 탐색해 볼 만한 또 다른 범주형 변수입니다. ​ <code>borough</code> 에는 고유한 값이 5개뿐이지만 <code>building_class_category</code>는 값의 수가 훨씬 많습니다. 고유한 값의 개수는 <code>n_unique()</code> 함수를 사용해 셀 수 있습니다.</p>
<div id="6ea40307" class="cell" data-execution_count="35">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>n_unique_building_class <span class="op">=</span> df.select(pl.col(<span class="st">"building_class_category"</span>).n_unique())</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n_unique_building_class)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (1, 1)
┌─────────────────────────┐
│ building_class_category │
│ ---                     │
│ u32                     │
╞═════════════════════════╡
│ 46                      │
└─────────────────────────┘</code></pre>
</div>
</div>
<p>와, 건물 종류(building class)가 정말 많네요. 우리 데이터셋에 있는 뉴욕시 부동산들이 46개의 건물 분류에 고르게 분포되어 있을까요? 아니면 소수의 분류에 대부분 몰려 있을까요?</p>
<p>먼저, 가장 흔한 5개의 건물 분류를 한번 살펴봅시다.</p>
<div id="cff63fa1" class="cell" data-execution_count="36">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>top5_building_classes <span class="op">=</span> (</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    df.select(pl.col(<span class="st">"building_class_category"</span>).value_counts().alias(<span class="st">"vc"</span>))</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    .unnest(<span class="st">"vc"</span>)  <span class="co"># -&gt; columns: building_class_category, count</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    .with_columns((pl.col(<span class="st">"count"</span>) <span class="op">/</span> pl.col(<span class="st">"count"</span>).<span class="bu">sum</span>()).alias(<span class="st">"proportion"</span>))</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    .sort(<span class="st">"proportion"</span>, descending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    .head(<span class="dv">5</span>)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(top5_building_classes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 3)
┌──────────────────────────────┬───────┬────────────┐
│ building_class_category      ┆ count ┆ proportion │
│ ---                          ┆ ---   ┆ ---        │
│ str                          ┆ u32   ┆ f64        │
╞══════════════════════════════╪═══════╪════════════╡
│ One family dwellings         ┆ 14459 ┆ 0.223841   │
│ Two family dwellings         ┆ 13088 ┆ 0.202616   │
│ Coops - elevator apartments  ┆ 11853 ┆ 0.183497   │
│ Condos - elevator apartments ┆ 8351  ┆ 0.129282   │
│ Three family dwellings       ┆ 3658  ┆ 0.05663    │
└──────────────────────────────┴───────┴────────────┘</code></pre>
</div>
</div>
<p>결과를 통해 상당히 많은 비율의 부동산이 이 5개의 건물 분류 중 하나에 속하는 것처럼 보입니다. 위 결과에서 정확한 비율을 구해봅시다.</p>
<div id="83e4d84b" class="cell" data-execution_count="37">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># df: Polars DataFrame 가정</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>top5_prop <span class="op">=</span> (</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    df.select(</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"building_class_category"</span>)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        .value_counts()  <span class="co"># struct: {building_class_category, count}</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        .alias(<span class="st">"vc"</span>)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    .unnest(<span class="st">"vc"</span>)  <span class="co"># -&gt; columns: building_class_category, count</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    .with_columns((pl.col(<span class="st">"count"</span>) <span class="op">/</span> pl.col(<span class="st">"count"</span>).<span class="bu">sum</span>()).alias(<span class="st">"proportion"</span>))</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    .sort(<span class="st">"proportion"</span>, descending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    .head(<span class="dv">5</span>)</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    .select(pl.col(<span class="st">"proportion"</span>).<span class="bu">sum</span>().alias(<span class="st">"top5_proportion"</span>))</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(top5_prop)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (1, 1)
┌─────────────────┐
│ top5_proportion │
│ ---             │
│ f64             │
╞═════════════════╡
│ 0.795867        │
└─────────────────┘</code></pre>
</div>
</div>
<p>위 결과를 통해 대략 79.5%의 뉴욕시 부동산이 상위 5개 건물 분류에 속한다는 사실을 알 수 있습니다. 실제 건물 분류 이름을 보면 이 결과가 꽤 그럴듯하다는 것을 알 수 있습니다. ​ * One family dwellings = 단독주택 * Two, Three family dwellings = 각각 듀플렉스, 트리플렉스 건물 * Coops/Condos = 임대 아파트 및 콘도</p>
</section>
<section id="수치형-데이터-요약" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="수치형-데이터-요약"><span class="header-section-number">3.3</span> 수치형 데이터 요약</h2>
<p>수치형 데이터를 요약하는 방법에는 여러 가지가 있는데, 그중 대표적인 두 가지는 1) 중심 경향성을 측정하는 것과 2) 데이터의 산포도(퍼져 있는 정도) 를 측정하는 것입니다. ​ ### 중심 경향성 측정</p>
<p>데이터의 중심 경향성(혹은 “가운데 값”)은 보통 평균(mean)과 중앙값(median)을 사용해 구할 수 있습니다. 수치형 변수의 평균(mean, 평균값) 을 계산하려면 값들의 합을 관측치 개수로 나누면 됩니다.</p>
<blockquote class="blockquote">
<p>평균이 중앙값보다 크면, 데이터는 오른쪽으로 치우쳐(skewed to the right) 있습니다. 이는 값이 매우 큰 이상치(outlier)들이 평균 값을 위로 끌어올리고 있다는 뜻입니다. 반대로 중앙값이 평균보다 크면, 데이터는 왼쪽으로 치우쳐(skewed to the left) 있습니다. 이는 값이 매우 작은 이상치들이 평균 값을 아래로 끌어내리고 있다는 뜻입니다</p>
</blockquote>
<section id="분산spread-측정하기" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="분산spread-측정하기"><span class="header-section-number">3.3.1</span> 분산(Spread) 측정하기</h3>
<p>분산(spread, 또는 dispersion)은 수치형 변수를 요약할 때 사용할 수 있는 또 다른 유용한 척도입니다. 분산은 데이터셋에서 각 값들이 서로 얼마나 떨어져 있는지를 이해하는 데 도움을 줍니다. 표준편차(standard deviation)는 각 값이 평균으로부터 얼마나 떨어져 있는지를 나타내는 지표입니다. 데이터가 더 널리 퍼져 있을수록 표준편차는 더 커집니다.숫자 리스트의 표준편차는 <code>numpy</code>의 <code>std()</code> 메서드를 사용해서 계산할 수 있습니다.</p>
<div id="81ae5af5" class="cell" data-execution_count="38">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.select(pl.col(<span class="st">"sale_price"</span>)).std())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (1, 1)
┌────────────┐
│ sale_price │
│ ---        │
│ f64        │
╞════════════╡
│ 1.1661e7   │
└────────────┘</code></pre>
</div>
</div>
<p>표준편차는 0보다 작을 수 없습니다. 표준편차가 0에 가까우면 값들이 평균 근처에 몰려 있다는 뜻이고, 표준편차가 정확히 0이면 모든 값이 평균과 동일하다는 뜻입니다. ​ ### 퍼센타일(Percentiles)</p>
<p>데이터가 정규분포(평균 = 중앙값)를 따를 때는 표준편차가 분산을 측정하는 데 유용한 지표입니다. 하지만 데이터가 비대칭(skewed), 즉 정규분포가 아닐 경우에는 분위수(quantiles, percentiles)가 분산을 나타내는 더 좋은 척도입니다. ​ 예를 들어 시험을 매우 잘 봐서 99번째 퍼센타일에 들었다면, 다른 응시자의 99%가 자신과 같거나 더 낮은 점수를 받았다는 의미로, 상위 1% 성적이라는 뜻입니다. 사분위수(quartiles) 는 데이터를 네 부분으로 나누는, 분산 측정에 자주 쓰이는 퍼센타일의 한 종류입니다. ​ * 1사분위수(Q1, 25번째 퍼센타일): 전체 값의 25%는 Q1보다 작고, 75%는 Q1보다 큽니다. ​* 2사분위수(Q2, 50번째 퍼센타일): 전체 값의 50%는 Q2보다 작고, 50%는 Q2보다 큽니다 (중앙값과 동일). ​* 3사분위수(Q3, 75번째 퍼센타일): 전체 값의 75%는 Q3보다 작고, 25%는 Q3보다 큽니다. ​ 수치형 변수의 사분위수를 구할 때는 <code>quantile()</code> 메서드를 사용할 수 있습니다</p>
<div id="c656f9a0" class="cell" data-execution_count="39">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>q1 <span class="op">=</span> df.select(pl.col(<span class="st">"sale_price"</span>).quantile(<span class="fl">0.25</span>))</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(q1)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (1, 1)
┌────────────┐
│ sale_price │
│ ---        │
│ f64        │
╞════════════╡
│ 237000.0   │
└────────────┘</code></pre>
</div>
</div>
<p>다른 방법으로, 모든 사분위수를 요약하면서 동시에 평균, 표준편차, 최소값, 최대값까지 한 번에 보고 싶다면 <code>describe()</code> 함수를 사용할 수 있습니다.</p>
<div id="ca20a21d" class="cell" data-execution_count="40">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>df.describe()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (9, 17)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">statistic</th>
<th data-quarto-table-cell-role="th">borough</th>
<th data-quarto-table-cell-role="th">neighborhood</th>
<th data-quarto-table-cell-role="th">building_class_category</th>
<th data-quarto-table-cell-role="th">building_class_at_present</th>
<th data-quarto-table-cell-role="th">address</th>
<th data-quarto-table-cell-role="th">apartment_number</th>
<th data-quarto-table-cell-role="th">zip_code</th>
<th data-quarto-table-cell-role="th">residential_units</th>
<th data-quarto-table-cell-role="th">commercial_units</th>
<th data-quarto-table-cell-role="th">total_units</th>
<th data-quarto-table-cell-role="th">land_square_feet</th>
<th data-quarto-table-cell-role="th">gross_square_feet</th>
<th data-quarto-table-cell-role="th">year_built</th>
<th data-quarto-table-cell-role="th">building_class_at_time_of_sale</th>
<th data-quarto-table-cell-role="th">sale_price</th>
<th data-quarto-table-cell-role="th">sale_date</th>
</tr>
<tr class="even">
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>str</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>f64</td>
<td>str</td>
<td>f64</td>
<td>str</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>"count"</td>
<td>"64595"</td>
<td>"64595"</td>
<td>"64595"</td>
<td>"64595"</td>
<td>"64595"</td>
<td>"64595"</td>
<td>64595.0</td>
<td>64595.0</td>
<td>64595.0</td>
<td>64595.0</td>
<td>45495.0</td>
<td>45336.0</td>
<td>64595.0</td>
<td>"64595"</td>
<td>64595.0</td>
<td>"64595"</td>
</tr>
<tr class="even">
<td>"null_count"</td>
<td>"0"</td>
<td>"0"</td>
<td>"0"</td>
<td>"0"</td>
<td>"0"</td>
<td>"0"</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>19100.0</td>
<td>19259.0</td>
<td>0.0</td>
<td>"0"</td>
<td>0.0</td>
<td>"0"</td>
</tr>
<tr class="odd">
<td>"mean"</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>10862.459153</td>
<td>2.008019</td>
<td>0.186454</td>
<td>2.211023</td>
<td>3435.388021</td>
<td>3903.138609</td>
<td>1949.529747</td>
<td>null</td>
<td>1.2634e6</td>
<td>null</td>
</tr>
<tr class="even">
<td>"std"</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>618.491884</td>
<td>15.098476</td>
<td>9.496642</td>
<td>17.942758</td>
<td>32232.44255</td>
<td>30384.575194</td>
<td>34.543645</td>
<td>null</td>
<td>1.1661e7</td>
<td>null</td>
</tr>
<tr class="odd">
<td>"min"</td>
<td>"Bronx"</td>
<td>"Airport La Guardia"</td>
<td>"Asylums and homes"</td>
<td>" "</td>
<td>"1 12TH&nbsp;&nbsp;&nbsp;ST EXTENSION"</td>
<td>" "</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1800.0</td>
<td>"A0"</td>
<td>0.0</td>
<td>"2016-09-01T00:00:00.000000"</td>
</tr>
<tr class="even">
<td>"25%"</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>10309.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>1600.0</td>
<td>1090.0</td>
<td>1925.0</td>
<td>null</td>
<td>237000.0</td>
<td>null</td>
</tr>
<tr class="odd">
<td>"50%"</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>11210.0</td>
<td>1.0</td>
<td>0.0</td>
<td>1.0</td>
<td>2204.0</td>
<td>1720.0</td>
<td>1942.0</td>
<td>null</td>
<td>530000.0</td>
<td>null</td>
</tr>
<tr class="even">
<td>"75%"</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>11354.0</td>
<td>2.0</td>
<td>0.0</td>
<td>2.0</td>
<td>3150.0</td>
<td>2600.0</td>
<td>1970.0</td>
<td>null</td>
<td>936000.0</td>
<td>null</td>
</tr>
<tr class="odd">
<td>"max"</td>
<td>"Staten Island"</td>
<td>"Wyckoff Heights"</td>
<td>"Warehouses"</td>
<td>"Z9"</td>
<td>"WHITTIER STREET"</td>
<td>"`"</td>
<td>11694.0</td>
<td>1844.0</td>
<td>2261.0</td>
<td>2261.0</td>
<td>4.2283e6</td>
<td>3.750565e6</td>
<td>2017.0</td>
<td>"Z9"</td>
<td>2.2100e9</td>
<td>"2017-08-31T00:00:00.000000"</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
</section>
<section id="범주별-수치형-데이터-분할-segmenting-numerical-data-by-category" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="범주별-수치형-데이터-분할-segmenting-numerical-data-by-category"><span class="header-section-number">3.4</span> 범주별 수치형 데이터 분할 (Segmenting Numerical Data by Category)</h2>
<p>때때로 새로운 통찰을 얻기 위해 데이터를 여러 방식으로 분할(segmentation) 해서 보는 것이 유용합니다.</p>
<p>지금까지 알아본 NYC 부동산 거래 데이터에서 구(borough), 건물 연식(신축 vs 구축), 건물 유형(단층 주택 vs 다층 아파트) 등으로 나누어 보면 어떨까요? 이렇게 나누었을 때, 각 세그먼트별 중앙값 판매 가격(median sale price) 에서 흥미로운 패턴이 보일 수도 있습니다. ​ 전체 구를 통틀어 중앙값 판매 가격은 63만 달러였다는 것을 이미 보았습니다. 하지만 구마다 중앙값 판매 가격이 크게 다를 수도 있습니다. 그러니 이제 구별로 분할된 판매 가격을 분석하면서 세분화 연습을 해봅시다. 이런 세분화 작업에는 <code>groupby()</code> 함수가 매우 유용합니다.</p>
<div id="2af7de6e" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>sale_price_borough <span class="op">=</span> df.group_by(<span class="st">"borough"</span>).agg(</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"sale_price"</span>).median().alias(<span class="st">"median"</span>),</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"sale_price"</span>).mean().alias(<span class="st">"mean"</span>),</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sale_price_borough)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 3)
┌───────────────┬───────────┬───────────────┐
│ borough       ┆ median    ┆ mean          │
│ ---           ┆ ---       ┆ ---           │
│ str           ┆ f64       ┆ f64           │
╞═══════════════╪═══════════╪═══════════════╡
│ Manhattan     ┆ 1110360.5 ┆ 3.4012e6      │
│ Staten Island ┆ 466326.0  ┆ 503555.582322 │
│ Queens        ┆ 496860.0  ┆ 728357.050649 │
│ Bronx         ┆ 310625.0  ┆ 632252.524652 │
│ Brooklyn      ┆ 425000.0  ┆ 826772.151436 │
└───────────────┴───────────┴───────────────┘</code></pre>
</div>
</div>
<p>위 결과를 통해 구별로 중앙값 판매 가격(median sale price) 이 상당히 다르다는 것을 알 수 있습니다. 이제 중앙값 판매 가격이 가장 높은 구부터 낮은 구 순으로 데이터프레임의 순서를 다시 정렬해 봅시다. 이를 위해 <code>sort_values()</code> 함수를 사용합니다.</p>
<div id="e058f8f5" class="cell" data-execution_count="42">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>sale_price_borough_sorted <span class="op">=</span> sale_price_borough.sort(</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"median"</span>,  <span class="co"># by='median'</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    descending<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sale_price_borough_sorted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>shape: (5, 3)
┌───────────────┬───────────┬───────────────┐
│ borough       ┆ median    ┆ mean          │
│ ---           ┆ ---       ┆ ---           │
│ str           ┆ f64       ┆ f64           │
╞═══════════════╪═══════════╪═══════════════╡
│ Manhattan     ┆ 1110360.5 ┆ 3.4012e6      │
│ Queens        ┆ 496860.0  ┆ 728357.050649 │
│ Staten Island ┆ 466326.0  ┆ 503555.582322 │
│ Brooklyn      ┆ 425000.0  ┆ 826772.151436 │
│ Bronx         ┆ 310625.0  ┆ 632252.524652 │
└───────────────┴───────────┴───────────────┘</code></pre>
</div>
</div>
<p>위의 데이터프레임을 보면 맨해튼이 단연코 가장 높은 중앙값 판매 가격을 가지며 브롱크스가 가장 낮은 중앙값 판매 가격을 가진다는 것을 알 수 있습니다. 플랏을 그려 보죠.</p>
<div id="100d94f2" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>sns.barplot(x<span class="op">=</span><span class="st">"borough"</span>, y<span class="op">=</span><span class="st">"median"</span>, data<span class="op">=</span>sale_price_borough.sort(<span class="st">"median"</span>, descending<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Median Property Sales Price in NYC by Borough"</span>)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"median sales price"</span>)</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-44-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="ds_tutorial_polars_files/figure-html/cell-44-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>시각화를 하면 훨씬 보기 좋습니다! 특히나 정렬되어 있는 막대를 통해 어떤 구의 중앙값 판매 가격이 가장 높고 낮은지 훨씬 더 쉽게 파악할 수 있습니다.</p>
<p>새로 만든 데이터프레임에서는 구별로 중앙값과 평균 판매 가격을 계산했는데 이제 이 두 지표를 나란히 비교해서 차이가 있는지 확인해 봅시다.</p>
<div id="e8585e97" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>sns.barplot(</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"borough"</span>,</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"median"</span>,</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>sale_price_borough.sort(<span class="st">"median"</span>, descending<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axes[<span class="dv">0</span>],</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">"median sales price"</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">"Median"</span>)</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].tick_params(axis<span class="op">=</span><span class="st">"x"</span>, rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>sns.barplot(</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"borough"</span>,</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"mean"</span>,</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>sale_price_borough.sort(<span class="st">"mean"</span>, descending<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axes,</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>axes.set_ylabel(<span class="st">"mean sales price"</span>)</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>axes.set_title(<span class="st">"Mean"</span>)</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>axes.tick_params(axis<span class="op">=</span><span class="st">"x"</span>, rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-45-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="ds_tutorial_polars_files/figure-html/cell-45-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>위의 평균과 중앙값 막대 그래프를 보면, 맨해튼에는 아주 비싼 부동산 거래가 있어서 평균 판매 가격을 끌어올리고 있다는 것을 알 수 있습니다. 반면 브롱크스는 중앙값 판매 가격이 가장 낮지만, 실제로는 평균 판매 가격이 세 번째로 높습니다. ​ 이는 브롱크스에 값이 매우 싼 부동산이 많이 있는 동시에, 평균 집값을 그렇게 싸지만은 않게 만들어 버리는 큰 이상치(outlier)들이 존재한다는 뜻입니다.</p>
<section id="구별-준공연도year-built-세분화" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="구별-준공연도year-built-세분화"><span class="header-section-number">3.4.1</span> 구별 준공연도(Year Built) 세분화</h3>
<p>구 단위 세분화는 계속 활용하면서, 다른 부동산 특성도 함께 탐색해 볼 수 있습니다. 예를 들어, 구별 주택의 평균 연식을 살펴보는 것도 흥미로운 분석입니다. 브롱크스의 집들이 스태튼아일랜드보다 더 오래되었을까요? 이런 질문에 답하기 위해 구를 기준으로 데이터를 그룹화한 뒤 <code>year_built</code> 에 대한 기술통계를 계산합니다.</p>
<div id="2945c14d" class="cell" data-execution_count="45">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>df.group_by(<span class="st">"borough"</span>).agg(</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"year_built"</span>).mean().alias(<span class="st">"mean"</span>),</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"year_built"</span>).median().alias(<span class="st">"median"</span>),</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"year_built"</span>).<span class="bu">min</span>().alias(<span class="st">"min"</span>),</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"year_built"</span>).<span class="bu">max</span>().alias(<span class="st">"max"</span>),</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (5, 5)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">borough</th>
<th data-quarto-table-cell-role="th">mean</th>
<th data-quarto-table-cell-role="th">median</th>
<th data-quarto-table-cell-role="th">min</th>
<th data-quarto-table-cell-role="th">max</th>
</tr>
<tr class="even">
<td>str</td>
<td>f64</td>
<td>f64</td>
<td>i64</td>
<td>i64</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>"Bronx"</td>
<td>1944.618679</td>
<td>1940.0</td>
<td>1800</td>
<td>2017</td>
</tr>
<tr class="even">
<td>"Queens"</td>
<td>1949.380858</td>
<td>1948.0</td>
<td>1870</td>
<td>2017</td>
</tr>
<tr class="odd">
<td>"Staten Island"</td>
<td>1970.025474</td>
<td>1975.0</td>
<td>1800</td>
<td>2016</td>
</tr>
<tr class="even">
<td>"Manhattan"</td>
<td>1952.541187</td>
<td>1955.0</td>
<td>1800</td>
<td>2016</td>
</tr>
<tr class="odd">
<td>"Brooklyn"</td>
<td>1943.819704</td>
<td>1930.0</td>
<td>1800</td>
<td>2017</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>위 결과를 통해 브루클린의 주택 중간 연식이 스태튼아일랜드보다 더 오래되었다는 것을 알 수 있습니다. 이제 각 구별로 <code>year_built</code> 속성의 분포를 그려보겠습니다. 먼저 해야 할 일은 구들의 목록을 만들어, 각 구에 대해 개별 분포 플롯을 생성하는 반복문을 돌려야 합니다. 고유한 구의 이름은 <code>unique()</code> 함수를 사용해 얻을 수 있습니다.</p>
<div id="d67a5176" class="cell" data-execution_count="46">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>boroughs <span class="op">=</span> df.select(pl.col(<span class="st">"borough"</span>).unique())[<span class="st">"borough"</span>].to_list()</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>boroughs</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>['Queens', 'Staten Island', 'Brooklyn', 'Bronx', 'Manhattan']</code></pre>
</div>
</div>
<p>이제 순환문을 사용해 플랏을 그려봅니다.</p>
<div id="ee0f9d8b" class="cell" data-execution_count="47">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, borough <span class="kw">in</span> <span class="bu">enumerate</span>(boroughs):</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">3</span>, i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    sns.histplot(x<span class="op">=</span><span class="st">"year_built"</span>, data<span class="op">=</span>df.<span class="bu">filter</span>(pl.col(<span class="st">"borough"</span>) <span class="op">==</span> borough))</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"count"</span>)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"year built"</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    plt.title(borough)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    plt.xlim([<span class="dv">1850</span>, <span class="dv">2020</span>])</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-48-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12"><img src="ds_tutorial_polars_files/figure-html/cell-48-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
</section>
<section id="datetime-데이터-다루기" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="datetime-데이터-다루기"><span class="header-section-number">3.4.2</span> Datetime 데이터 다루기</h3>
<p>파이썬에는 시계열 데이터를 표현할 수 있는 내장 <code>datetime</code> 데이터 타입이 있습니다.<code>to_datetime()</code> 함수를 사용해 필요한 열의 데이터를 <code>datetime</code> 타입으로 변환할 수 있습니다. 먼저 데이터 변환을 한 뒤에 시계열 그래프를 그려보겠습니다.</p>
<div id="d054b40c" class="cell" data-execution_count="48">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 문자열 → Datetime 변환 (단 한 번만!)</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.with_columns(pl.col(<span class="st">"sale_date"</span>).<span class="bu">str</span>.strptime(pl.Datetime, strict<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) month / year / weekday 컬럼 생성</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.with_columns(</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"sale_date"</span>).dt.month().alias(<span class="st">"sale_month"</span>),</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"sale_date"</span>).dt.year().alias(<span class="st">"sale_year"</span>),</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">"sale_date"</span>).dt.weekday().alias(<span class="st">"sale_weekday"</span>),</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) 월별 건수 집계</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>agg_sale_month <span class="op">=</span> df.group_by(<span class="st">"sale_month"</span>).<span class="bu">len</span>().rename({<span class="st">"len"</span>: <span class="st">"count"</span>})</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) 시각화를 위해 Pandas로 변환 후 그리기</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>agg_sale_month_pd <span class="op">=</span> agg_sale_month.to_pandas()</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">4</span>))</span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span><span class="st">"sale_month"</span>, y<span class="op">=</span><span class="st">"count"</span>, data<span class="op">=</span>agg_sale_month_pd)</span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span><span class="st">"sale_month"</span>, y<span class="op">=</span><span class="st">"count"</span>, data<span class="op">=</span>agg_sale_month_pd, color<span class="op">=</span><span class="st">"red"</span>)</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">7000</span>])</span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-49-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13"><img src="ds_tutorial_polars_files/figure-html/cell-49-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>위 플랏을 통해 뉴욕시에서 부동산을 매매하기에 가장 인기 있는 달은 6월이고 가장 인기가 없는 달은 8월이라는 걸 손쉽게 알 수 있습니다. 이제 요일별로 나눠 본 부동산 거래 추세를 살펴보겠습니다. <code>group_by</code>를 사용해 다음과 같이 만들 수 있습니다.</p>
<div id="17174e1f" class="cell" data-execution_count="49">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>agg_sale_weekday <span class="op">=</span> df.group_by(<span class="st">"sale_weekday"</span>).<span class="bu">len</span>().rename({<span class="st">"len"</span>: <span class="st">"count"</span>})</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>agg_sale_weekday</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="49">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (7, 2)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">sale_weekday</th>
<th data-quarto-table-cell-role="th">count</th>
</tr>
<tr class="even">
<td>i8</td>
<td>u32</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>430</td>
</tr>
<tr class="even">
<td>5</td>
<td>12744</td>
</tr>
<tr class="odd">
<td>3</td>
<td>13121</td>
</tr>
<tr class="even">
<td>4</td>
<td>15282</td>
</tr>
<tr class="odd">
<td>2</td>
<td>12309</td>
</tr>
<tr class="even">
<td>1</td>
<td>10521</td>
</tr>
<tr class="odd">
<td>7</td>
<td>188</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="f37b2bbc" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>agg_sale_weekday <span class="op">=</span> df.group_by(<span class="st">"sale_weekday"</span>).<span class="bu">len</span>().rename({<span class="st">"len"</span>: <span class="st">"count"</span>})</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>weekday_values <span class="op">=</span> {</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"1"</span>: <span class="st">"Mon"</span>,</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"2"</span>: <span class="st">"Tues"</span>,</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"3"</span>: <span class="st">"Wed"</span>,</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"4"</span>: <span class="st">"Thurs"</span>,</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"5"</span>: <span class="st">"Fri"</span>,</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"6"</span>: <span class="st">"Sat"</span>,</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"7"</span>: <span class="st">"Sun"</span>,</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 컬럼 형변환 후 값을 교체합니다.</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>agg_sale_weekday <span class="op">=</span> agg_sale_weekday.with_columns(</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    pl.col(<span class="st">"sale_weekday"</span>).cast(pl.String).replace(weekday_values)</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>agg_sale_weekday</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<div><style>
.dataframe > thead > tr,
.dataframe > tbody > tr {
  text-align: right;
  white-space: pre-wrap;
}
</style>
<small>shape: (7, 2)</small>
<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">sale_weekday</th>
<th data-quarto-table-cell-role="th">count</th>
</tr>
<tr class="even">
<td>str</td>
<td>u32</td>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>"Mon"</td>
<td>10521</td>
</tr>
<tr class="even">
<td>"Tues"</td>
<td>12309</td>
</tr>
<tr class="odd">
<td>"Thurs"</td>
<td>15282</td>
</tr>
<tr class="even">
<td>"Fri"</td>
<td>12744</td>
</tr>
<tr class="odd">
<td>"Wed"</td>
<td>13121</td>
</tr>
<tr class="even">
<td>"Sat"</td>
<td>430</td>
</tr>
<tr class="odd">
<td>"Sun"</td>
<td>188</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p><code>sale_weekday</code> 열을 만들어보니 훨씬 보기 좋아졌습니다. 이제 바플랏을 그려서 시각화해봅니다.</p>
<div id="4426e307" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">4</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>sns.barplot(x<span class="op">=</span><span class="st">"sale_weekday"</span>, y<span class="op">=</span><span class="st">"count"</span>, data<span class="op">=</span>agg_sale_weekday)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"weekday"</span>)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"NYC Property Sales by Day of Week"</span>)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="ds_tutorial_polars_files/figure-html/cell-52-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14"><img src="ds_tutorial_polars_files/figure-html/cell-52-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>결과가 흥미롭습니다. 데이터에 의하면 목요일이 부동산을 판매하기에 가장 인기 있는 요일이라는 것을 알 수 있습니다. 그리고 주말인 토요일과 일요일에는 거래가 거의 이루어지지 않다는 것도 볼 수 있죠.</p>
</section>
</section>
</section>
<section id="마치며" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 마치며</h1>
<p>이번 글에서는 <code>polars</code>와 <code>seaborn</code>을 이용해 간단한 데이터 분석과 시각화를 체험해보았습니다. <code>polars</code>의 속도와 효율성, 그리고 <code>seaborn</code>의 직관적인 그래프 표현 덕분에 데이터 과학의 핵심 개념을 한눈에 살펴볼 수 있었죠. 앞으로는 더 복잡한 데이터셋을 다루거나, 머신러닝 모델과 결합해 분석을 확장해보는 것도 좋을 것 같습니다. 데이터 과학은 결국 ’데이터를 통해 통찰을 얻는 과정’이니까요. 오늘의 이 글이 여러분께 그 첫걸음이 되었길 바랍니다😊.</p>
</section>
<section id="참조" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> 참조</h1>
<ul>
<li>이 글에 사용된 원본 코드의 출처: https://www.practicalpythonfordatascience.com</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomorrow-lab\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      if (authorPrefersDark) {
          [baseTheme, altTheme] = [altTheme, baseTheme];
      }
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "partrita/giscus";
    script.dataset.repoId = "R_kgDONvsa2g";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDONvsa2s4CmWd7";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Proudly served by <a href="https://pages.github.com/">github pages</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This blog is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>