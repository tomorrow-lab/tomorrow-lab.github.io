<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Taeyoon Kim">
<meta name="dcterms.date" content="2024-05-30">

<title>어떻게 데이터 과학은 작동하는가? – tomorrow-lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-54a3bae54f78c194261bd58cdfbac44f.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-522971af95d0e085e01a2f9638043ec8.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-9677ae12f295ff20ac372f273d4f6fa4.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-380ce5cf48b80dcad6a036939cda27a2.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-31EWCYNR0V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-31EWCYNR0V', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="google-site-verification" content="z2S1Xqj9hfJiC31aNGCnOA1gYpL_8MoZpPI2avrWMvg">


<meta property="og:title" content="어떻게 데이터 과학은 작동하는가? – tomorrow-lab">
<meta property="og:description" content="The future of scientific discovery lies at the convergence of computational power and biological complexity. Our mission is to provide a platform where enthusiasts, researchers, and professionals can learn about and contribute to the rapidly evolving fields of bioinformatics, computational biology, and systems biology.">
<meta property="og:image" content="https://tomorrow-lab.github.io/posts/md/How_DS_works.png">
<meta property="og:site_name" content="tomorrow-lab">
<meta property="og:image:height" content="320">
<meta property="og:image:width" content="640">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tomorrow-lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../book.html"> 
<span class="menu-text">Book</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://partrita.github.io"> <i class="bi bi-sign-do-not-enter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/partrita"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/partrita"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<div style="padding-bottom: 30px;">
    <a href="https://substack.com/@tomorrowlab">
    <img alt="Static Badge" src="https://img.shields.io/badge/EHOTTL%40substack_-FF6719?link=https%3A%2F%2Fsubstack.com%2F%40tomorrowlab">
</a><a href="https://pixi.sh"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json" alt="Pixi Badge"></a>
    <script async="" src="https://eocampaign1.com/form/2616a818-1ef8-11ef-b372-4587d096212f.js" data-form="2616a818-1ef8-11ef-b372-4587d096212f"></script>
</div>
</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link active" data-scroll-target="#들어가며"><span class="header-section-number">1</span> 들어가며</a></li>
  <li><a href="#데이터-확보하기" id="toc-데이터-확보하기" class="nav-link" data-scroll-target="#데이터-확보하기"><span class="header-section-number">2</span> 데이터 확보하기</a></li>
  <li><a href="#날카로운-질문하기" id="toc-날카로운-질문하기" class="nav-link" data-scroll-target="#날카로운-질문하기"><span class="header-section-number">3</span> 날카로운 질문하기</a></li>
  <li><a href="#데이터를-테이블로-만들기" id="toc-데이터를-테이블로-만들기" class="nav-link" data-scroll-target="#데이터를-테이블로-만들기"><span class="header-section-number">4</span> 데이터를 테이블로 만들기</a></li>
  <li><a href="#데이터의-품질-확인하기" id="toc-데이터의-품질-확인하기" class="nav-link" data-scroll-target="#데이터의-품질-확인하기"><span class="header-section-number">5</span> 데이터의 품질 확인하기</a>
  <ul class="collapse">
  <li><a href="#데이터-검사하기" id="toc-데이터-검사하기" class="nav-link" data-scroll-target="#데이터-검사하기"><span class="header-section-number">5.1</span> 데이터 검사하기</a></li>
  <li><a href="#데이터-수정하기" id="toc-데이터-수정하기" class="nav-link" data-scroll-target="#데이터-수정하기"><span class="header-section-number">5.2</span> 데이터 수정하기</a></li>
  <li><a href="#결측치-다루기" id="toc-결측치-다루기" class="nav-link" data-scroll-target="#결측치-다루기"><span class="header-section-number">5.3</span> 결측치 다루기</a></li>
  </ul></li>
  <li><a href="#특성feature-변환하기" id="toc-특성feature-변환하기" class="nav-link" data-scroll-target="#특성feature-변환하기"><span class="header-section-number">6</span> 특성(Feature) 변환하기</a></li>
  <li><a href="#질문에-답하기" id="toc-질문에-답하기" class="nav-link" data-scroll-target="#질문에-답하기"><span class="header-section-number">7</span> 질문에 답하기</a></li>
  <li><a href="#분석-결과-공유하기" id="toc-분석-결과-공유하기" class="nav-link" data-scroll-target="#분석-결과-공유하기"><span class="header-section-number">8</span> 분석 결과 공유하기</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">어떻게 데이터 과학은 작동하는가?</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">Data science</div>
    <div class="quarto-category">Tip</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Taeyoon Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 30, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">January 21, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="How_DS_works.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<section id="들어가며" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 들어가며</h1>
<p>데이터 과학(Data science)은 데이터를 수집, 처리, 분석하여 유의미한 정보를 추출하고 의사결정을 지원하는 과정입니다. 데이터 과학자들은 통계학, 컴퓨터 과학, 기반 지식을 융합해 데이터를 활용한 문제 해결과 혁신을 가능하게 합니다. 이제 데이터를 어떻게 분석해야 하는지에 간략하게 알아보죠.</p>
<blockquote class="blockquote">
<p>이 글은 원본 글<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>과 관련 유튜브 영상<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>을 보고 번역과 많은 수정을 거쳤습니다.</p>
</blockquote>
</section>
<section id="데이터-확보하기" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 데이터 확보하기</h1>
<p>데이터 과학의 원시 자료는 숫자와 이름의 모음입니다. 측정값, 가격, 날짜, 시간, 제품, 제목, 행동 등 모든 것이 데이터 과학의 대상이 될 수 있습니다. 이미지, 텍스트, 오디오, 비디오 및 기타 복잡한 데이터도 숫자와 이름으로 축소할 수 있는 방법만 있다면 사용할 수 있습니다.</p>
<p>데이터를 가져오는 메커니즘은 매우 복잡합니다. 하지만 이 가이드는 전반적인 데이터 과학에 초점을 맞추고 있으므로 데이터를 가져오는 주제에 대해서는 다음 기회에 다루도록 하겠습니다.</p>
</section>
<section id="날카로운-질문하기" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 날카로운 질문하기</h1>
<p>데이터 과학은 이름과 숫자를 사용하여 질문에 답하는 과정입니다. 질문을 더 정확하게 할수록 더 만족스러운 답을 찾을 확률이 높아집니다. 예를 들어 ” 내 데이터를 통해 비즈니스에 대해 무엇을 알 수 있나요?” 또는 ” 어떻게 하면 수익을 높일 수 있나요?” 등은 잘못된 질문입니다. 반면에 “3 분기에 몬트리올에서 테슬라 Model S 를 몇 대 판매할 것인가?” 와 같은 질문은 명확한 답을 할 수 밖에 없으니 좋은 질문 입니다.</p>
<p>이제 질문이 생겼으니 데이터를 살펴보세요. 만약 ” 다음 주에 내 주식의 판매 가격은 얼마인가요?” 라는 질문이라면 데이터에 주식의 가격 이력이 포함되어 있는지 확인하세요. 만약 질문이 ” 모델 88 항공기 엔진이 고장날 때까지 몇 시간이 남았나요?” 라면 데이터에 여러 모델 88 엔진의 고장 시간이 포함되어 있는지 확인해야 합니다. 이것을 목표 데이터라고 합니다. 데이터에 목표 데이터가 없다면 질문에 답을 할 수 없습니다. 그런 경우 1단계로 돌아가서 추가로 데이터를 수집하세요.</p>
</section>
<section id="데이터를-테이블로-만들기" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 데이터를 테이블로 만들기</h1>
<p>대부분의 머신 러닝 알고리즘은 데이터가 테이블에 있다고 가정합니다. 따라서 만약 미식 축구를 설명하는 데이터 집합을 만든다면 각 열은 홈팀, 원정팀, 홈팀의 점수, 원정팀의 점수, 날짜, 시작 시간으로 하고 각 행은 각각의 경기를 나타낼 수 있습니다. 경기의 수만큼 행이 늘어나겠죠.</p>
</section>
<section id="데이터의-품질-확인하기" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> 데이터의 품질 확인하기</h1>
<section id="데이터-검사하기" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="데이터-검사하기"><span class="header-section-number">5.1</span> 데이터 검사하기</h2>
<p>다음 단계는 데이터를 깊게 살펴보는 것입니다. 여기에는 두 가지 목적이 있습니다. 첫 번째는 잘못된 데이터를 발견하여 수정하거나 제거하는 것입니다. 다른 하나는 각 행과 열에 익숙해지는 것입니다. 이 단계를 건너뛰고 데이터를 최대한 활용 할 수는 없습니다.</p>
<p>데이터의 한 열만 살펴보세요. 무엇에 레이블이 붙어 있나요? 값이 레이블에 맞는가요? 그 레이블이 여러분에게 어떤 의미가 있나요? 열의 의미에 대한 문서가 있나요? 어떻게 측정되었는지에 대한 문서가 있나요? 스스로에게 물어보세요.</p>
<p>각각의 열에 대한 히스토그램을 그려보고 분포가 기능에 대해 알고 있는 것과 일치하는지도 확인 해보세요. 혹시 비정상적인 수치가 있나요? 그런 이상값이 의미가 있나요? 어떤 식으로든 조금이라도 이상해 보인다면 그 이유를 찾아보세요.</p>
</section>
<section id="데이터-수정하기" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="데이터-수정하기"><span class="header-section-number">5.2</span> 데이터 수정하기</h2>
<p>각각의 열을 살펴보면서 혹시 이름과 설명이 오해의 소지가 있거나 잘못된 것을 발견할 수도 있습니다. 혹은 일부 값이 잘못되었다는 사실을 발견할 수도 있습니다. 이 경우 세 가지 선택지가 있습니다. 첫 번째, 수정이 분명해 보이는 경우 값을 수정한다 (예: 키 72 미터를 72 인치로 변환). 두 번째, 수정이 분명하지 않은 경우 값을 삭제하고 누락된 상태로 둘 수 있습니다. 세 번째, 값이 중요한 정보인 경우 전체 행 또는 열을 제거할 수 있습니다. 이렇게 하면 잘못된 데이터로 모델을 학습시키는 것을 방지할 수 있습니다. 잘못된 데이터는 누락된 데이터보다 훨씬 더 큰 피해를 줍니다.</p>
<p>가끔 바람직하지 않은 값이나 행을 제거하고 싶은 유혹이 있을 수 있습니다. 이러한 데이터는 여러분이 선호하는 이론을 뒷받침하지 않을 수 있습니다. 그러나 이렇게 하지는 마세요. 이것은 비윤리적이며 더 나쁜 것은 잘못된 답을 얻을 수 있다는 것입니다.</p>
</section>
<section id="결측치-다루기" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="결측치-다루기"><span class="header-section-number">5.3</span> 결측치 다루기</h2>
<p>거의 모든 데이터 집합에는 누락된 값이 있습니다. 이것은 때로 잘못된 것으로 판명되어 삭제된 것이기도 하고 보통 서로 다른 소스에서 가져온 데이터를 합치는 경우에 생겨다는 경우가 있습니다. 어쨌거나 머신러닝에 사용하기 위해서는 결측치를 수정해야 합니다. 결측치를 수정하는 방법에는 여러 가지가 있습니다. 먼저 샘플을 보고 싶으시다면 <a href="https://gallery.cortanaintelligence.com/Experiment/Methods-for-handling-missing-values-1?r=leg">Azure에서 결측치 다루기</a> 를 확인하세요. 결론적으로 결측치를 수정하는 최선의 방법은 데이터 마다 다르다는 것입니다.</p>
</section>
</section>
<section id="특성feature-변환하기" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> 특성(Feature) 변환하기</h1>
<p>머신 러닝 모델 학습을 하기 전에 아직 한 가지 단계가 남았습니다. 바로 피처 엔지니어링 (Feature engineering) 입니다. 현재 데이터셋에 있는 특성을 조합해 목표를 더 잘 예측할 수 있도록 하는 방법론이죠. 예를 들어 <a href="https://gallery.cortanaintelligence.com/Experiment/Create-useful-features-for-trains-1?r=legacy">특성 만들기 예제</a> 에서는 “기차 도착 시간” 에 “출발 시간”을 빼서 “환승 시간” 이라는 특성을 추가했습니다. 이 특성은 목표인 최고 속도를 예측하는 데 훨씬 더 유용합니다.</p>
<p>엄밀히 말하면 피처 엔지니어링은 데이터에 어떤 정보도 추가하지 않습니다. 단순히 존재하는 것을 새로운 방식으로 결합하는 것입니다. 그러나 두 개의 데이터 열을 결합하는 방법은 무한하고 대부분은 의미가 없거나 예측에 도움이 되지 않습니다.</p>
<p>피처 엔지니어링 프로세스는 데이터 과학에서 가장 자동화가 어려운 영역으로 시행착오와 직관, 경험이 필요한 과정입니다. 그래서 피처 엔지니어링에 사전 지식이 있으면 유리합니다. 피처 엔지니어링을 위한 간단한 팁으로 데이터의 모든 변수에 대한 관계를 시각화하는 것을 추천합니다. 이렇게 하면 변수 간의 관계를 드러내는 데 도움이 됩니다. 만약 플롯에서 패턴을 발견한다면 피쳐 엔지니어링을 해볼 기회일 수 있습니다. 즉, 두 변수를 개별적으로 사용하는 것보다 두 변수의 조합이 더 유용할 수 있다는 것을 시각화로 알 수 있죠.</p>
<p>때로는 어떤 변수나 변수 조합도 타깃을 예측하는 데 도움이 되지 않는 경우가 있습니다. 이는 아마도 다른 무언가를 측정해야 한다는 의미일 수 있습니다. 그렇다면 다시 1 단계로 돌아가서 더 많은 데이터 수집하세요.</p>
</section>
<section id="질문에-답하기" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> 질문에 답하기</h1>
<p>마지막으로 데이터 과학자들이 가장 좋아하는 부분입니다. 바로 머신 러닝입니다! 간단히 요약하면 질문이 어떤 문제에 속하는지 <a href="https://blogs.technet.microsoft.com/machinelearning/2015/08/27/what-types-of-questions-can-data-science-answer/">결정</a> 하고, 해당 문제에 사용할 알고리즘을 하나 이상 <a href="https://azure.microsoft.com/en-us/documentation/articles/machine-learning-algorithm-choice/">선택</a> 합니다. 그런다음 데이터를 분할(학습, 테스트, 검증 데이터 세트)하고 모델의 매개변수를 최적화하는 과정을 거칩니다.</p>
<p>만약 머신러닝으로 답을 얻을 수 없다면 아래의 방법들을 시도해볼 수 있습니다. 첫 번째, 단순히 데이터를 시각화 해봅니다. 거의 절반의 경우 이것만으로도 원하는 답을 얻을 수 있습니다. 예를 들어 “내년 7월 4일 보스턴의 최고 기온은?” 이라는 질문에 답을 하기 위해서는 지난 100년 동안의 7월 4일 보스턴의 최고 기온 히스토그램 그려보면 충분한 시각적 답을 얻을 수 있습니다.</p>
<p>두 번째는 기술적으로 좀 더 까다롭습니다. 데이터 세트가 너무 작아 결과가 만족스럽지 않다면 더 많은 가정을 세워서 데이터를 분석하는 것입니다. 예를 들어, 물체의 탄도 궤적을 예측 문제라면 뉴턴 역학을 사용해 위치와 속도를 포함하는 단일 데이터 포인트만으로도 미래의 물체의 위치와 속도를 예측할 수 있습니다. 이런 접근법의 장점은 훨씬 적은 데이터로 결과를 얻을 수 있다는 것입니다. 반면 단점은 세상에 완벽한 가정은 없다는 것입니다. 이런 방법 중 어느 것도 효과가 없다면 다시 1단계로 돌아가서 더 많은 데이터 수집해야 합니다.</p>
</section>
<section id="분석-결과-공유하기" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> 분석 결과 공유하기</h1>
<p>데이터를 활용해 질문에 대한 답을 찾았다고 해도 다른 사람이 사용하지 않는다면 아무런 의미가 없습니다. 따라서 분석 결과를 의사 결정을 위해 혹은 작업을 완료하기 위해 그리고 학습을 위한 형태의 자료로 만들어야 합니다. 자료를 만드는 방법에도 여러 가지가 있습니다. 웹 페이지에 결과를 게시하거나 PDF 파일로 만들어 배포하는 것들이 있죠.</p>
<p>“아무도 없는 숲에서는 나무가 쓰러져도 소리가 나지 않는다.” 라는 영어 속담이 있습니다. 그러니 가능한 많은 사람들에게 당신의 모델을 공유하세요.</p>


<!-- -->

</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><a href="https://e2eml.school/pocket_guide_data_science">A Pocket Guide to Data science (e2eml.school)</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://youtu.be/tKa0zDDDaQk?feature=shared">유튜브 영상</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/tomorrow-lab\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "어떻게 데이터 과학은 작동하는가?"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Taeyoon Kim"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [Data science, Tip]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> false</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2024-05-30"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="al">![](How_DS_works.png)</span>{width=100% fig-align="center"}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu"># 들어가며</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>데이터 과학(Data science)은 데이터를 수집, 처리, 분석하여 유의미한 정보를 추출하고 의사결정을 지원하는 과정입니다. 데이터 과학자들은 통계학, 컴퓨터 과학, 기반 지식을 융합해 데이터를 활용한 문제 해결과 혁신을 가능하게 합니다. 이제 데이터를 어떻게 분석해야 하는지에 간략하게 알아보죠.</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; 이 글은 원본 글</span><span class="ot">[^1]</span><span class="at">과 관련 유튜브 영상</span><span class="ot">[^2]</span><span class="at">을 보고 번역과 많은 수정을 거쳤습니다.</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu"># 데이터 확보하기</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>데이터 과학의 원시 자료는 숫자와 이름의 모음입니다. 측정값, 가격, 날짜, 시간, 제품, 제목, 행동 등 모든 것이 데이터 과학의 대상이 될 수 있습니다. 이미지, 텍스트, 오디오, 비디오 및 기타 복잡한 데이터도 숫자와 이름으로 축소할 수 있는 방법만 있다면 사용할 수 있습니다.</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>데이터를 가져오는 메커니즘은 매우 복잡합니다. 하지만 이 가이드는 전반적인 데이터 과학에 초점을 맞추고 있으므로 데이터를 가져오는 주제에 대해서는 다음 기회에 다루도록 하겠습니다.</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="fu"># 날카로운 질문하기</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>데이터 과학은 이름과 숫자를 사용하여 질문에 답하는 과정입니다. 질문을 더 정확하게 할수록 더 만족스러운 답을 찾을 확률이 높아집니다. 예를 들어 " 내 데이터를 통해 비즈니스에 대해 무엇을 알 수 있나요?" 또는 " 어떻게 하면 수익을 높일 수 있나요?" 등은 잘못된 질문입니다. 반면에 "3 분기에 몬트리올에서 테슬라 Model S 를 몇 대 판매할 것인가?" 와 같은 질문은 명확한 답을 할 수 밖에 없으니 좋은 질문 입니다.</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>이제 질문이 생겼으니 데이터를 살펴보세요. 만약 " 다음 주에 내 주식의 판매 가격은 얼마인가요?" 라는 질문이라면 데이터에 주식의 가격 이력이 포함되어 있는지 확인하세요. 만약 질문이 " 모델 88 항공기 엔진이 고장날 때까지 몇 시간이 남았나요?" 라면 데이터에 여러 모델 88 엔진의 고장 시간이 포함되어 있는지 확인해야 합니다. 이것을 목표 데이터라고 합니다. 데이터에 목표 데이터가 없다면 질문에 답을 할 수 없습니다. 그런 경우 1단계로 돌아가서 추가로 데이터를 수집하세요.</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="fu"># 데이터를 테이블로 만들기</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>대부분의 머신 러닝 알고리즘은 데이터가 테이블에 있다고 가정합니다. 따라서 만약 미식 축구를 설명하는 데이터 집합을 만든다면 각 열은 홈팀, 원정팀, 홈팀의 점수, 원정팀의 점수, 날짜, 시작 시간으로 하고 각 행은 각각의 경기를 나타낼 수 있습니다. 경기의 수만큼 행이 늘어나겠죠.</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="fu"># 데이터의 품질 확인하기</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## 데이터 검사하기</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>다음 단계는 데이터를 깊게 살펴보는 것입니다. 여기에는 두 가지 목적이 있습니다. 첫 번째는 잘못된 데이터를 발견하여 수정하거나 제거하는 것입니다. 다른 하나는 각 행과 열에 익숙해지는 것입니다. 이 단계를 건너뛰고 데이터를 최대한 활용 할 수는 없습니다.</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>데이터의 한 열만 살펴보세요. 무엇에 레이블이 붙어 있나요? 값이 레이블에 맞는가요? 그 레이블이 여러분에게 어떤 의미가 있나요? 열의 의미에 대한 문서가 있나요? 어떻게 측정되었는지에 대한 문서가 있나요? 스스로에게 물어보세요.</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>각각의 열에 대한 히스토그램을 그려보고 분포가 기능에 대해 알고 있는 것과 일치하는지도 확인 해보세요. 혹시 비정상적인 수치가 있나요? 그런 이상값이 의미가 있나요? 어떤 식으로든 조금이라도 이상해 보인다면 그 이유를 찾아보세요.</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="fu">## 데이터 수정하기</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>각각의 열을 살펴보면서 혹시 이름과 설명이 오해의 소지가 있거나 잘못된 것을 발견할 수도 있습니다. 혹은 일부 값이 잘못되었다는 사실을 발견할 수도 있습니다. 이 경우 세 가지 선택지가 있습니다. 첫 번째, 수정이 분명해 보이는 경우 값을 수정한다 (예: 키 72 미터를 72 인치로 변환). 두 번째, 수정이 분명하지 않은 경우 값을 삭제하고 누락된 상태로 둘 수 있습니다. 세 번째, 값이 중요한 정보인 경우 전체 행 또는 열을 제거할 수 있습니다. 이렇게 하면 잘못된 데이터로 모델을 학습시키는 것을 방지할 수 있습니다. 잘못된 데이터는 누락된 데이터보다 훨씬 더 큰 피해를 줍니다.</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>가끔 바람직하지 않은 값이나 행을 제거하고 싶은 유혹이 있을 수 있습니다. 이러한 데이터는 여러분이 선호하는 이론을 뒷받침하지 않을 수 있습니다. 그러나 이렇게 하지는 마세요. 이것은 비윤리적이며 더 나쁜 것은 잘못된 답을 얻을 수 있다는 것입니다.</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="fu">## 결측치 다루기</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>거의 모든 데이터 집합에는 누락된 값이 있습니다. 이것은 때로 잘못된 것으로 판명되어 삭제된 것이기도 하고 보통 서로 다른 소스에서 가져온 데이터를 합치는 경우에 생겨다는 경우가 있습니다. 어쨌거나 머신러닝에 사용하기 위해서는 결측치를 수정해야 합니다. 결측치를 수정하는 방법에는 여러 가지가 있습니다. 먼저 샘플을 보고 싶으시다면 <span class="co">[</span><span class="ot">Azure에서 결측치 다루기</span><span class="co">](https://gallery.cortanaintelligence.com/Experiment/Methods-for-handling-missing-values-1?r=leg)</span> 를 확인하세요. 결론적으로 결측치를 수정하는 최선의 방법은 데이터 마다 다르다는 것입니다.</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="fu"># 특성(Feature) 변환하기</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>머신 러닝 모델 학습을 하기 전에 아직 한 가지 단계가 남았습니다. 바로 피처 엔지니어링 (Feature engineering) 입니다. 현재 데이터셋에 있는 특성을 조합해 목표를 더 잘 예측할 수 있도록 하는 방법론이죠. 예를 들어 <span class="co">[</span><span class="ot">특성 만들기 예제</span><span class="co">](https://gallery.cortanaintelligence.com/Experiment/Create-useful-features-for-trains-1?r=legacy)</span> 에서는 "기차 도착 시간" 에 "출발 시간"을 빼서 "환승 시간" 이라는 특성을 추가했습니다. 이 특성은 목표인 최고 속도를 예측하는 데 훨씬 더 유용합니다.</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>엄밀히 말하면 피처 엔지니어링은 데이터에 어떤 정보도 추가하지 않습니다. 단순히 존재하는 것을 새로운 방식으로 결합하는 것입니다. 그러나 두 개의 데이터 열을 결합하는 방법은 무한하고 대부분은 의미가 없거나 예측에 도움이 되지 않습니다.</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>피처 엔지니어링 프로세스는 데이터 과학에서 가장 자동화가 어려운 영역으로 시행착오와 직관, 경험이 필요한 과정입니다. 그래서 피처 엔지니어링에 사전 지식이 있으면 유리합니다.</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>피처 엔지니어링을 위한 간단한 팁으로 데이터의 모든 변수에 대한 관계를 시각화하는 것을 추천합니다. 이렇게 하면 변수 간의 관계를 드러내는 데 도움이 됩니다. 만약 플롯에서 패턴을 발견한다면 피쳐 엔지니어링을 해볼 기회일 수 있습니다. 즉, 두 변수를 개별적으로 사용하는 것보다 두 변수의 조합이 더 유용할 수 있다는 것을 시각화로 알 수 있죠.</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>때로는 어떤 변수나 변수 조합도 타깃을 예측하는 데 도움이 되지 않는 경우가 있습니다. 이는 아마도 다른 무언가를 측정해야 한다는 의미일 수 있습니다. 그렇다면 다시 1 단계로 돌아가서 더 많은 데이터 수집하세요.</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="fu"># 질문에 답하기</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>마지막으로 데이터 과학자들이 가장 좋아하는 부분입니다. 바로 머신 러닝입니다! 간단히 요약하면 질문이 어떤 문제에 속하는지 <span class="co">[</span><span class="ot">결정</span><span class="co">](https://blogs.technet.microsoft.com/machinelearning/2015/08/27/what-types-of-questions-can-data-science-answer/)</span> 하고, 해당 문제에 사용할 알고리즘을 하나 이상 <span class="co">[</span><span class="ot">선택</span><span class="co">](https://azure.microsoft.com/en-us/documentation/articles/machine-learning-algorithm-choice/)</span> 합니다. 그런다음 데이터를 분할(학습, 테스트, 검증 데이터 세트)하고 모델의 매개변수를 최적화하는 과정을 거칩니다.</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>만약 머신러닝으로 답을 얻을 수 없다면 아래의 방법들을 시도해볼 수 있습니다. 첫 번째, 단순히 데이터를 시각화 해봅니다. 거의 절반의 경우 이것만으로도 원하는 답을 얻을 수 있습니다. 예를 들어 "내년 7월 4일 보스턴의 최고 기온은?" 이라는 질문에 답을 하기 위해서는 지난 100년 동안의 7월 4일 보스턴의 최고 기온 히스토그램 그려보면 충분한 시각적 답을 얻을 수 있습니다.</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>두 번째는 기술적으로 좀 더 까다롭습니다. 데이터 세트가 너무 작아 결과가 만족스럽지 않다면 더 많은 가정을 세워서 데이터를 분석하는 것입니다. 예를 들어, 물체의 탄도 궤적을 예측 문제라면 뉴턴 역학을 사용해 위치와 속도를 포함하는 단일 데이터 포인트만으로도 미래의 물체의 위치와 속도를 예측할 수 있습니다. 이런 접근법의 장점은 훨씬 적은 데이터로 결과를 얻을 수 있다는 것입니다. 반면 단점은 세상에 완벽한 가정은 없다는 것입니다. 이런 방법 중 어느 것도 효과가 없다면 다시 1단계로 돌아가서 더 많은 데이터 수집해야 합니다.</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="fu"># 분석 결과 공유하기</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>데이터를 활용해 질문에 대한 답을 찾았다고 해도 다른 사람이 사용하지 않는다면 아무런 의미가 없습니다. 따라서 분석 결과를 의사 결정을 위해 혹은 작업을 완료하기 위해 그리고 학습을 위한 형태의 자료로 만들어야 합니다. 자료를 만드는 방법에도 여러 가지가 있습니다. 웹 페이지에 결과를 게시하거나 PDF 파일로 만들어 배포하는 것들이 있죠.</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>"아무도 없는 숲에서는 나무가 쓰러져도 소리가 나지 않는다." 라는 영어 속담이 있습니다. 그러니 가능한 많은 사람들에게 당신의 모델을 공유하세요.</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="ot">[^1]: </span><span class="co">[</span><span class="ot">A Pocket Guide to Data science (e2eml.school)</span><span class="co">](https://e2eml.school/pocket_guide_data_science)</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="ot">[^2]: </span><span class="co">[</span><span class="ot">유튜브 영상</span><span class="co">](https://youtu.be/tKa0zDDDaQk?feature=shared)</span></span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Proudly served by <a href="https://pages.github.com/">github pages</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This blog is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>