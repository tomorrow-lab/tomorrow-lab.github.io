<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Taeyoon Kim">
<meta name="dcterms.date" content="2024-09-28">

<title>Rosalind Stronghold 문제풀이 – tomorrow-lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-54a3bae54f78c194261bd58cdfbac44f.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-522971af95d0e085e01a2f9638043ec8.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-020ee4570c11eef0a92474a195712a2f.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-abda6c126a20cebe0a4db33490456ef2.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-31EWCYNR0V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-31EWCYNR0V', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="google-site-verification" content="z2S1Xqj9hfJiC31aNGCnOA1gYpL_8MoZpPI2avrWMvg">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Rosalind Stronghold 문제풀이 – tomorrow-lab">
<meta property="og:description" content="The future of scientific discovery lies at the convergence of computational power and biological complexity. Our mission is to provide a platform where enthusiasts, researchers, and professionals can learn about and contribute to the rapidly evolving fields of bioinformatics, computational biology, and systems biology.">
<meta property="og:image" content="https://tomorrow-lab.github.io/posts/md/Rosalind_stronghold.png">
<meta property="og:site_name" content="tomorrow-lab">
<meta property="og:image:height" content="320">
<meta property="og:image:width" content="640">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tomorrow-lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../book.html"> 
<span class="menu-text">Book</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://partrita.github.io"> <i class="bi bi-sign-do-not-enter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/partrita"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/partrita"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<div style="padding-top: 15px; padding-bottom: 15px;">
    <a href="https://substack.com/@tomorrowlab">
        <img alt="Static Badge" src="https://img.shields.io/badge/EHOTTL%40substack_-FF6719?link=https%3A%2F%2Fsubstack.com%2F%40tomorrowlab">
    </a>
    <!-- <a href="https://pixi.sh">
        <img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json" alt="Pixi Badge">
    </a> -->
    <!-- <script async src="https://eocampaign1.com/form/2616a818-1ef8-11ef-b372-4587d096212f.js" data-form="2616a818-1ef8-11ef-b372-4587d096212f"></script> -->
</div>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#counting-dna-nucleotides" id="toc-counting-dna-nucleotides" class="nav-link active" data-scroll-target="#counting-dna-nucleotides"><span class="header-section-number">1</span> Counting DNA Nucleotides</a>
  <ul class="collapse">
  <li><a href="#sample-dataset" id="toc-sample-dataset" class="nav-link" data-scroll-target="#sample-dataset"><span class="header-section-number">1.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output" id="toc-sample-output" class="nav-link" data-scroll-target="#sample-output"><span class="header-section-number">1.2</span> Sample Output</a></li>
  <li><a href="#solution" id="toc-solution" class="nav-link" data-scroll-target="#solution"><span class="header-section-number">1.3</span> Solution</a></li>
  <li><a href="#설명" id="toc-설명" class="nav-link" data-scroll-target="#설명"><span class="header-section-number">1.4</span> 설명</a></li>
  </ul></li>
  <li><a href="#transcribing-dna-into-rna" id="toc-transcribing-dna-into-rna" class="nav-link" data-scroll-target="#transcribing-dna-into-rna"><span class="header-section-number">2</span> Transcribing DNA into RNA</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-1" id="toc-sample-dataset-1" class="nav-link" data-scroll-target="#sample-dataset-1"><span class="header-section-number">2.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-1" id="toc-sample-output-1" class="nav-link" data-scroll-target="#sample-output-1"><span class="header-section-number">2.2</span> Sample Output</a></li>
  <li><a href="#solution-1" id="toc-solution-1" class="nav-link" data-scroll-target="#solution-1"><span class="header-section-number">2.3</span> Solution</a></li>
  <li><a href="#explanation" id="toc-explanation" class="nav-link" data-scroll-target="#explanation"><span class="header-section-number">2.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#complementing-a-strand-of-dna" id="toc-complementing-a-strand-of-dna" class="nav-link" data-scroll-target="#complementing-a-strand-of-dna"><span class="header-section-number">3</span> Complementing a Strand of DNA</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-2" id="toc-sample-dataset-2" class="nav-link" data-scroll-target="#sample-dataset-2"><span class="header-section-number">3.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-2" id="toc-sample-output-2" class="nav-link" data-scroll-target="#sample-output-2"><span class="header-section-number">3.2</span> Sample Output</a></li>
  <li><a href="#soultion" id="toc-soultion" class="nav-link" data-scroll-target="#soultion"><span class="header-section-number">3.3</span> soultion</a></li>
  <li><a href="#explanation-1" id="toc-explanation-1" class="nav-link" data-scroll-target="#explanation-1"><span class="header-section-number">3.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#rabbits-and-recurrence-relations" id="toc-rabbits-and-recurrence-relations" class="nav-link" data-scroll-target="#rabbits-and-recurrence-relations"><span class="header-section-number">4</span> Rabbits and Recurrence Relations</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-3" id="toc-sample-dataset-3" class="nav-link" data-scroll-target="#sample-dataset-3"><span class="header-section-number">4.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-3" id="toc-sample-output-3" class="nav-link" data-scroll-target="#sample-output-3"><span class="header-section-number">4.2</span> Sample Output</a></li>
  <li><a href="#solution-2" id="toc-solution-2" class="nav-link" data-scroll-target="#solution-2"><span class="header-section-number">4.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code" id="toc-explanation-of-the-code" class="nav-link" data-scroll-target="#explanation-of-the-code"><span class="header-section-number">4.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#computing-gc-content" id="toc-computing-gc-content" class="nav-link" data-scroll-target="#computing-gc-content"><span class="header-section-number">5</span> Computing GC Content</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-4" id="toc-sample-dataset-4" class="nav-link" data-scroll-target="#sample-dataset-4"><span class="header-section-number">5.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-4" id="toc-sample-output-4" class="nav-link" data-scroll-target="#sample-output-4"><span class="header-section-number">5.2</span> Sample Output</a></li>
  <li><a href="#solution-3" id="toc-solution-3" class="nav-link" data-scroll-target="#solution-3"><span class="header-section-number">5.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem" id="toc-steps-to-solve-the-problem" class="nav-link" data-scroll-target="#steps-to-solve-the-problem"><span class="header-section-number">5.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#explanation-2" id="toc-explanation-2" class="nav-link" data-scroll-target="#explanation-2"><span class="header-section-number">5.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#counting-point-mutations" id="toc-counting-point-mutations" class="nav-link" data-scroll-target="#counting-point-mutations"><span class="header-section-number">6</span> Counting Point Mutations</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-5" id="toc-sample-dataset-5" class="nav-link" data-scroll-target="#sample-dataset-5"><span class="header-section-number">6.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-5" id="toc-sample-output-5" class="nav-link" data-scroll-target="#sample-output-5"><span class="header-section-number">6.2</span> Sample Output</a></li>
  <li><a href="#solution-4" id="toc-solution-4" class="nav-link" data-scroll-target="#solution-4"><span class="header-section-number">6.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-1" id="toc-steps-to-solve-the-problem-1" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-1"><span class="header-section-number">6.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#explanation-3" id="toc-explanation-3" class="nav-link" data-scroll-target="#explanation-3"><span class="header-section-number">6.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#mendels-first-law" id="toc-mendels-first-law" class="nav-link" data-scroll-target="#mendels-first-law"><span class="header-section-number">7</span> Mendel’s First Law</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-6" id="toc-sample-dataset-6" class="nav-link" data-scroll-target="#sample-dataset-6"><span class="header-section-number">7.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-6" id="toc-sample-output-6" class="nav-link" data-scroll-target="#sample-output-6"><span class="header-section-number">7.2</span> Sample Output</a></li>
  <li><a href="#solution-5" id="toc-solution-5" class="nav-link" data-scroll-target="#solution-5"><span class="header-section-number">7.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-2" id="toc-steps-to-solve-the-problem-2" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-2"><span class="header-section-number">7.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#explanation-4" id="toc-explanation-4" class="nav-link" data-scroll-target="#explanation-4"><span class="header-section-number">7.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#translating-rna-into-protein" id="toc-translating-rna-into-protein" class="nav-link" data-scroll-target="#translating-rna-into-protein"><span class="header-section-number">8</span> Translating RNA into Protein</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-7" id="toc-sample-dataset-7" class="nav-link" data-scroll-target="#sample-dataset-7"><span class="header-section-number">8.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-7" id="toc-sample-output-7" class="nav-link" data-scroll-target="#sample-output-7"><span class="header-section-number">8.2</span> Sample Output</a></li>
  <li><a href="#solution-6" id="toc-solution-6" class="nav-link" data-scroll-target="#solution-6"><span class="header-section-number">8.3</span> Solution</a></li>
  <li><a href="#explanation-5" id="toc-explanation-5" class="nav-link" data-scroll-target="#explanation-5"><span class="header-section-number">8.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#finding-a-motif-in-dna" id="toc-finding-a-motif-in-dna" class="nav-link" data-scroll-target="#finding-a-motif-in-dna"><span class="header-section-number">9</span> Finding a Motif in DNA</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-8" id="toc-sample-dataset-8" class="nav-link" data-scroll-target="#sample-dataset-8"><span class="header-section-number">9.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-8" id="toc-sample-output-8" class="nav-link" data-scroll-target="#sample-output-8"><span class="header-section-number">9.2</span> Sample Output</a></li>
  <li><a href="#solution-7" id="toc-solution-7" class="nav-link" data-scroll-target="#solution-7"><span class="header-section-number">9.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-3" id="toc-steps-to-solve-the-problem-3" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-3"><span class="header-section-number">9.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation"><span class="header-section-number">9.5</span> Implementation</a></li>
  <li><a href="#explanation-6" id="toc-explanation-6" class="nav-link" data-scroll-target="#explanation-6"><span class="header-section-number">9.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#consensus-and-profile" id="toc-consensus-and-profile" class="nav-link" data-scroll-target="#consensus-and-profile"><span class="header-section-number">10</span> Consensus and Profile</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-9" id="toc-sample-dataset-9" class="nav-link" data-scroll-target="#sample-dataset-9"><span class="header-section-number">10.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-9" id="toc-sample-output-9" class="nav-link" data-scroll-target="#sample-output-9"><span class="header-section-number">10.2</span> Sample Output</a></li>
  <li><a href="#solution-8" id="toc-solution-8" class="nav-link" data-scroll-target="#solution-8"><span class="header-section-number">10.3</span> Solution</a></li>
  <li><a href="#explanation-7" id="toc-explanation-7" class="nav-link" data-scroll-target="#explanation-7"><span class="header-section-number">10.4</span> Explanation</a></li>
  <li><a href="#sample-output-10" id="toc-sample-output-10" class="nav-link" data-scroll-target="#sample-output-10"><span class="header-section-number">10.5</span> Sample Output</a></li>
  </ul></li>
  <li><a href="#mortal-fibonacci-rabbits" id="toc-mortal-fibonacci-rabbits" class="nav-link" data-scroll-target="#mortal-fibonacci-rabbits"><span class="header-section-number">11</span> Mortal Fibonacci Rabbits</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-10" id="toc-sample-dataset-10" class="nav-link" data-scroll-target="#sample-dataset-10"><span class="header-section-number">11.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-11" id="toc-sample-output-11" class="nav-link" data-scroll-target="#sample-output-11"><span class="header-section-number">11.2</span> Sample Output</a></li>
  <li><a href="#solution-9" id="toc-solution-9" class="nav-link" data-scroll-target="#solution-9"><span class="header-section-number">11.3</span> Solution</a></li>
  <li><a href="#explanation-8" id="toc-explanation-8" class="nav-link" data-scroll-target="#explanation-8"><span class="header-section-number">11.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#inferring-mrna-from-protein" id="toc-inferring-mrna-from-protein" class="nav-link" data-scroll-target="#inferring-mrna-from-protein"><span class="header-section-number">12</span> Inferring mRNA from Protein</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-11" id="toc-sample-dataset-11" class="nav-link" data-scroll-target="#sample-dataset-11"><span class="header-section-number">12.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-12" id="toc-sample-output-12" class="nav-link" data-scroll-target="#sample-output-12"><span class="header-section-number">12.2</span> Sample Output</a></li>
  <li><a href="#solution-10" id="toc-solution-10" class="nav-link" data-scroll-target="#solution-10"><span class="header-section-number">12.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-4" id="toc-steps-to-solve-the-problem-4" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-4"><span class="header-section-number">12.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#genetic-code-table" id="toc-genetic-code-table" class="nav-link" data-scroll-target="#genetic-code-table"><span class="header-section-number">12.5</span> Genetic Code Table</a></li>
  <li><a href="#implementation-1" id="toc-implementation-1" class="nav-link" data-scroll-target="#implementation-1"><span class="header-section-number">12.6</span> Implementation</a></li>
  <li><a href="#explanation-9" id="toc-explanation-9" class="nav-link" data-scroll-target="#explanation-9"><span class="header-section-number">12.7</span> Explanation</a></li>
  </ul></li>
  <li><a href="#overlap-graphs" id="toc-overlap-graphs" class="nav-link" data-scroll-target="#overlap-graphs"><span class="header-section-number">13</span> Overlap Graphs</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-12" id="toc-sample-dataset-12" class="nav-link" data-scroll-target="#sample-dataset-12"><span class="header-section-number">13.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-13" id="toc-sample-output-13" class="nav-link" data-scroll-target="#sample-output-13"><span class="header-section-number">13.2</span> Sample Output</a></li>
  <li><a href="#solution-11" id="toc-solution-11" class="nav-link" data-scroll-target="#solution-11"><span class="header-section-number">13.3</span> Solution</a></li>
  <li><a href="#steps-to-implement-the-solution" id="toc-steps-to-implement-the-solution" class="nav-link" data-scroll-target="#steps-to-implement-the-solution"><span class="header-section-number">13.4</span> Steps to Implement the Solution</a></li>
  <li><a href="#example-implementation" id="toc-example-implementation" class="nav-link" data-scroll-target="#example-implementation"><span class="header-section-number">13.5</span> Example Implementation</a></li>
  <li><a href="#explanation-of-the-code-1" id="toc-explanation-of-the-code-1" class="nav-link" data-scroll-target="#explanation-of-the-code-1"><span class="header-section-number">13.6</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#calculating-expected-offspring" id="toc-calculating-expected-offspring" class="nav-link" data-scroll-target="#calculating-expected-offspring"><span class="header-section-number">14</span> Calculating Expected Offspring</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-13" id="toc-sample-dataset-13" class="nav-link" data-scroll-target="#sample-dataset-13"><span class="header-section-number">14.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-14" id="toc-sample-output-14" class="nav-link" data-scroll-target="#sample-output-14"><span class="header-section-number">14.2</span> Sample Output</a></li>
  <li><a href="#solution-12" id="toc-solution-12" class="nav-link" data-scroll-target="#solution-12"><span class="header-section-number">14.3</span> Solution</a></li>
  <li><a href="#genotype-pairings-and-dominance" id="toc-genotype-pairings-and-dominance" class="nav-link" data-scroll-target="#genotype-pairings-and-dominance"><span class="header-section-number">14.4</span> Genotype Pairings and Dominance</a></li>
  <li><a href="#expected-number-of-dominant-offspring" id="toc-expected-number-of-dominant-offspring" class="nav-link" data-scroll-target="#expected-number-of-dominant-offspring"><span class="header-section-number">14.5</span> Expected Number of Dominant Offspring</a></li>
  <li><a href="#implementation-2" id="toc-implementation-2" class="nav-link" data-scroll-target="#implementation-2"><span class="header-section-number">14.6</span> Implementation</a></li>
  <li><a href="#explanation-10" id="toc-explanation-10" class="nav-link" data-scroll-target="#explanation-10"><span class="header-section-number">14.7</span> Explanation</a></li>
  </ul></li>
  <li><a href="#finding-a-shared-motif" id="toc-finding-a-shared-motif" class="nav-link" data-scroll-target="#finding-a-shared-motif"><span class="header-section-number">15</span> Finding a Shared Motif</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-14" id="toc-sample-dataset-14" class="nav-link" data-scroll-target="#sample-dataset-14"><span class="header-section-number">15.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-15" id="toc-sample-output-15" class="nav-link" data-scroll-target="#sample-output-15"><span class="header-section-number">15.2</span> Sample Output</a></li>
  <li><a href="#solution-13" id="toc-solution-13" class="nav-link" data-scroll-target="#solution-13"><span class="header-section-number">15.3</span> Solution</a></li>
  <li><a href="#detailed-steps" id="toc-detailed-steps" class="nav-link" data-scroll-target="#detailed-steps"><span class="header-section-number">15.4</span> Detailed Steps</a></li>
  <li><a href="#implementation-3" id="toc-implementation-3" class="nav-link" data-scroll-target="#implementation-3"><span class="header-section-number">15.5</span> Implementation</a></li>
  <li><a href="#explanation-11" id="toc-explanation-11" class="nav-link" data-scroll-target="#explanation-11"><span class="header-section-number">15.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#independent-alleles" id="toc-independent-alleles" class="nav-link" data-scroll-target="#independent-alleles"><span class="header-section-number">16</span> Independent Alleles</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-15" id="toc-sample-dataset-15" class="nav-link" data-scroll-target="#sample-dataset-15"><span class="header-section-number">16.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-16" id="toc-sample-output-16" class="nav-link" data-scroll-target="#sample-output-16"><span class="header-section-number">16.2</span> Sample Output</a></li>
  </ul></li>
  <li><a href="#finding-a-protein-motif" id="toc-finding-a-protein-motif" class="nav-link" data-scroll-target="#finding-a-protein-motif"><span class="header-section-number">17</span> Finding a Protein Motif</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-16" id="toc-sample-dataset-16" class="nav-link" data-scroll-target="#sample-dataset-16"><span class="header-section-number">17.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-17" id="toc-sample-output-17" class="nav-link" data-scroll-target="#sample-output-17"><span class="header-section-number">17.2</span> Sample Output</a></li>
  <li><a href="#solution-14" id="toc-solution-14" class="nav-link" data-scroll-target="#solution-14"><span class="header-section-number">17.3</span> Solution</a></li>
  <li><a href="#explanation-12" id="toc-explanation-12" class="nav-link" data-scroll-target="#explanation-12"><span class="header-section-number">17.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#open-reading-frames" id="toc-open-reading-frames" class="nav-link" data-scroll-target="#open-reading-frames"><span class="header-section-number">18</span> Open Reading Frames</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-17" id="toc-sample-dataset-17" class="nav-link" data-scroll-target="#sample-dataset-17"><span class="header-section-number">18.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-18" id="toc-sample-output-18" class="nav-link" data-scroll-target="#sample-output-18"><span class="header-section-number">18.2</span> Sample Output</a></li>
  <li><a href="#solution-15" id="toc-solution-15" class="nav-link" data-scroll-target="#solution-15"><span class="header-section-number">18.3</span> Solution</a></li>
  <li><a href="#explanations" id="toc-explanations" class="nav-link" data-scroll-target="#explanations"><span class="header-section-number">18.4</span> Explanations</a></li>
  </ul></li>
  <li><a href="#enumerating-gene-orders" id="toc-enumerating-gene-orders" class="nav-link" data-scroll-target="#enumerating-gene-orders"><span class="header-section-number">19</span> Enumerating Gene Orders</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-18" id="toc-sample-dataset-18" class="nav-link" data-scroll-target="#sample-dataset-18"><span class="header-section-number">19.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-19" id="toc-sample-output-19" class="nav-link" data-scroll-target="#sample-output-19"><span class="header-section-number">19.2</span> Sample Output</a></li>
  <li><a href="#solution-16" id="toc-solution-16" class="nav-link" data-scroll-target="#solution-16"><span class="header-section-number">19.3</span> Solution</a></li>
  <li><a href="#explanation-13" id="toc-explanation-13" class="nav-link" data-scroll-target="#explanation-13"><span class="header-section-number">19.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#calculating-protein-mass" id="toc-calculating-protein-mass" class="nav-link" data-scroll-target="#calculating-protein-mass"><span class="header-section-number">20</span> Calculating Protein Mass</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-19" id="toc-sample-dataset-19" class="nav-link" data-scroll-target="#sample-dataset-19"><span class="header-section-number">20.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-20" id="toc-sample-output-20" class="nav-link" data-scroll-target="#sample-output-20"><span class="header-section-number">20.2</span> Sample Output</a></li>
  <li><a href="#solution-17" id="toc-solution-17" class="nav-link" data-scroll-target="#solution-17"><span class="header-section-number">20.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#locating-restriction-sites" id="toc-locating-restriction-sites" class="nav-link" data-scroll-target="#locating-restriction-sites"><span class="header-section-number">21</span> Locating Restriction Sites</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-20" id="toc-sample-dataset-20" class="nav-link" data-scroll-target="#sample-dataset-20"><span class="header-section-number">21.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-21" id="toc-sample-output-21" class="nav-link" data-scroll-target="#sample-output-21"><span class="header-section-number">21.2</span> Sample Output</a></li>
  <li><a href="#solution-18" id="toc-solution-18" class="nav-link" data-scroll-target="#solution-18"><span class="header-section-number">21.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#rna-splicing" id="toc-rna-splicing" class="nav-link" data-scroll-target="#rna-splicing"><span class="header-section-number">22</span> RNA Splicing</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-21" id="toc-sample-dataset-21" class="nav-link" data-scroll-target="#sample-dataset-21"><span class="header-section-number">22.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-22" id="toc-sample-output-22" class="nav-link" data-scroll-target="#sample-output-22"><span class="header-section-number">22.2</span> Sample Output</a></li>
  <li><a href="#solution-19" id="toc-solution-19" class="nav-link" data-scroll-target="#solution-19"><span class="header-section-number">22.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#enumerating-k-mers-lexicographically" id="toc-enumerating-k-mers-lexicographically" class="nav-link" data-scroll-target="#enumerating-k-mers-lexicographically"><span class="header-section-number">23</span> Enumerating k-mers Lexicographically</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-22" id="toc-sample-dataset-22" class="nav-link" data-scroll-target="#sample-dataset-22"><span class="header-section-number">23.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-23" id="toc-sample-output-23" class="nav-link" data-scroll-target="#sample-output-23"><span class="header-section-number">23.2</span> Sample Output</a></li>
  <li><a href="#solution-20" id="toc-solution-20" class="nav-link" data-scroll-target="#solution-20"><span class="header-section-number">23.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#longest-increasing-subsequence" id="toc-longest-increasing-subsequence" class="nav-link" data-scroll-target="#longest-increasing-subsequence"><span class="header-section-number">24</span> Longest Increasing Subsequence</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-23" id="toc-sample-dataset-23" class="nav-link" data-scroll-target="#sample-dataset-23"><span class="header-section-number">24.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-24" id="toc-sample-output-24" class="nav-link" data-scroll-target="#sample-output-24"><span class="header-section-number">24.2</span> Sample Output</a></li>
  <li><a href="#solution-21" id="toc-solution-21" class="nav-link" data-scroll-target="#solution-21"><span class="header-section-number">24.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#genome-assembly-as-shortest-superstring" id="toc-genome-assembly-as-shortest-superstring" class="nav-link" data-scroll-target="#genome-assembly-as-shortest-superstring"><span class="header-section-number">25</span> Genome Assembly as Shortest Superstring</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-24" id="toc-sample-dataset-24" class="nav-link" data-scroll-target="#sample-dataset-24"><span class="header-section-number">25.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-25" id="toc-sample-output-25" class="nav-link" data-scroll-target="#sample-output-25"><span class="header-section-number">25.2</span> Sample Output</a></li>
  <li><a href="#solution-22" id="toc-solution-22" class="nav-link" data-scroll-target="#solution-22"><span class="header-section-number">25.3</span> Solution</a></li>
  <li><a href="#코드-설명" id="toc-코드-설명" class="nav-link" data-scroll-target="#코드-설명"><span class="header-section-number">25.4</span> 코드 설명</a></li>
  </ul></li>
  <li><a href="#perfect-matchings-and-rna-secondary-structures" id="toc-perfect-matchings-and-rna-secondary-structures" class="nav-link" data-scroll-target="#perfect-matchings-and-rna-secondary-structures"><span class="header-section-number">26</span> Perfect Matchings and RNA Secondary Structures</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-25" id="toc-sample-dataset-25" class="nav-link" data-scroll-target="#sample-dataset-25"><span class="header-section-number">26.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-26" id="toc-sample-output-26" class="nav-link" data-scroll-target="#sample-output-26"><span class="header-section-number">26.2</span> Sample Output</a></li>
  <li><a href="#solution-23" id="toc-solution-23" class="nav-link" data-scroll-target="#solution-23"><span class="header-section-number">26.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-5" id="toc-steps-to-solve-the-problem-5" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-5"><span class="header-section-number">26.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#python-implementation" id="toc-python-implementation" class="nav-link" data-scroll-target="#python-implementation"><span class="header-section-number">26.5</span> Python Implementation</a></li>
  <li><a href="#explanation-of-the-code-2" id="toc-explanation-of-the-code-2" class="nav-link" data-scroll-target="#explanation-of-the-code-2"><span class="header-section-number">26.6</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#partial-permutations" id="toc-partial-permutations" class="nav-link" data-scroll-target="#partial-permutations"><span class="header-section-number">27</span> Partial Permutations</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-26" id="toc-sample-dataset-26" class="nav-link" data-scroll-target="#sample-dataset-26"><span class="header-section-number">27.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-27" id="toc-sample-output-27" class="nav-link" data-scroll-target="#sample-output-27"><span class="header-section-number">27.2</span> Sample Output</a></li>
  <li><a href="#solution-24" id="toc-solution-24" class="nav-link" data-scroll-target="#solution-24"><span class="header-section-number">27.3</span> Solution</a></li>
  <li><a href="#explanation-14" id="toc-explanation-14" class="nav-link" data-scroll-target="#explanation-14"><span class="header-section-number">27.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#introduction-to-random-strings" id="toc-introduction-to-random-strings" class="nav-link" data-scroll-target="#introduction-to-random-strings"><span class="header-section-number">28</span> Introduction to Random Strings</a>
  <ul class="collapse">
  <li><a href="#hint" id="toc-hint" class="nav-link" data-scroll-target="#hint"><span class="header-section-number">28.1</span> Hint</a></li>
  <li><a href="#sample-dataset-27" id="toc-sample-dataset-27" class="nav-link" data-scroll-target="#sample-dataset-27"><span class="header-section-number">28.2</span> Sample Dataset</a></li>
  <li><a href="#sample-output-28" id="toc-sample-output-28" class="nav-link" data-scroll-target="#sample-output-28"><span class="header-section-number">28.3</span> Sample Output</a></li>
  <li><a href="#solution-25" id="toc-solution-25" class="nav-link" data-scroll-target="#solution-25"><span class="header-section-number">28.4</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-3" id="toc-explanation-of-the-code-3" class="nav-link" data-scroll-target="#explanation-of-the-code-3"><span class="header-section-number">28.5</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#enumerating-oriented-gene-orderings" id="toc-enumerating-oriented-gene-orderings" class="nav-link" data-scroll-target="#enumerating-oriented-gene-orderings"><span class="header-section-number">29</span> Enumerating Oriented Gene Orderings</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-28" id="toc-sample-dataset-28" class="nav-link" data-scroll-target="#sample-dataset-28"><span class="header-section-number">29.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-29" id="toc-sample-output-29" class="nav-link" data-scroll-target="#sample-output-29"><span class="header-section-number">29.2</span> Sample Output</a></li>
  <li><a href="#solution-26" id="toc-solution-26" class="nav-link" data-scroll-target="#solution-26"><span class="header-section-number">29.3</span> solution</a></li>
  <li><a href="#explanation-15" id="toc-explanation-15" class="nav-link" data-scroll-target="#explanation-15"><span class="header-section-number">29.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#finding-a-spliced-motif" id="toc-finding-a-spliced-motif" class="nav-link" data-scroll-target="#finding-a-spliced-motif"><span class="header-section-number">30</span> Finding a Spliced Motif</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-29" id="toc-sample-dataset-29" class="nav-link" data-scroll-target="#sample-dataset-29"><span class="header-section-number">30.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-30" id="toc-sample-output-30" class="nav-link" data-scroll-target="#sample-output-30"><span class="header-section-number">30.2</span> Sample Output</a></li>
  <li><a href="#solution-27" id="toc-solution-27" class="nav-link" data-scroll-target="#solution-27"><span class="header-section-number">30.3</span> Solution</a></li>
  <li><a href="#explanation-16" id="toc-explanation-16" class="nav-link" data-scroll-target="#explanation-16"><span class="header-section-number">30.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#transitions-and-transversions" id="toc-transitions-and-transversions" class="nav-link" data-scroll-target="#transitions-and-transversions"><span class="header-section-number">31</span> Transitions and Transversions</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-30" id="toc-sample-dataset-30" class="nav-link" data-scroll-target="#sample-dataset-30"><span class="header-section-number">31.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-31" id="toc-sample-output-31" class="nav-link" data-scroll-target="#sample-output-31"><span class="header-section-number">31.2</span> Sample Output</a></li>
  <li><a href="#solution-28" id="toc-solution-28" class="nav-link" data-scroll-target="#solution-28"><span class="header-section-number">31.3</span> Solution</a></li>
  <li><a href="#step-by-step-implementation" id="toc-step-by-step-implementation" class="nav-link" data-scroll-target="#step-by-step-implementation"><span class="header-section-number">31.4</span> Step-by-step Implementation</a></li>
  <li><a href="#explanation-17" id="toc-explanation-17" class="nav-link" data-scroll-target="#explanation-17"><span class="header-section-number">31.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#completing-a-tree" id="toc-completing-a-tree" class="nav-link" data-scroll-target="#completing-a-tree"><span class="header-section-number">32</span> Completing a Tree</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-31" id="toc-sample-dataset-31" class="nav-link" data-scroll-target="#sample-dataset-31"><span class="header-section-number">32.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-32" id="toc-sample-output-32" class="nav-link" data-scroll-target="#sample-output-32"><span class="header-section-number">32.2</span> Sample Output</a></li>
  <li><a href="#solution-29" id="toc-solution-29" class="nav-link" data-scroll-target="#solution-29"><span class="header-section-number">32.3</span> Solution</a></li>
  <li><a href="#explanation-18" id="toc-explanation-18" class="nav-link" data-scroll-target="#explanation-18"><span class="header-section-number">32.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#catalan-numbers-and-rna-secondary-structures" id="toc-catalan-numbers-and-rna-secondary-structures" class="nav-link" data-scroll-target="#catalan-numbers-and-rna-secondary-structures"><span class="header-section-number">33</span> Catalan Numbers and RNA Secondary Structures</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-32" id="toc-sample-dataset-32" class="nav-link" data-scroll-target="#sample-dataset-32"><span class="header-section-number">33.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-33" id="toc-sample-output-33" class="nav-link" data-scroll-target="#sample-output-33"><span class="header-section-number">33.2</span> Sample Output</a></li>
  <li><a href="#solution-30" id="toc-solution-30" class="nav-link" data-scroll-target="#solution-30"><span class="header-section-number">33.3</span> Solution</a></li>
  <li><a href="#explanation-19" id="toc-explanation-19" class="nav-link" data-scroll-target="#explanation-19"><span class="header-section-number">33.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#error-correction-in-reads" id="toc-error-correction-in-reads" class="nav-link" data-scroll-target="#error-correction-in-reads"><span class="header-section-number">34</span> Error Correction in Reads</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-33" id="toc-sample-dataset-33" class="nav-link" data-scroll-target="#sample-dataset-33"><span class="header-section-number">34.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-34" id="toc-sample-output-34" class="nav-link" data-scroll-target="#sample-output-34"><span class="header-section-number">34.2</span> Sample Output</a></li>
  <li><a href="#solution-31" id="toc-solution-31" class="nav-link" data-scroll-target="#solution-31"><span class="header-section-number">34.3</span> Solution</a></li>
  <li><a href="#step-by-step-implementation-1" id="toc-step-by-step-implementation-1" class="nav-link" data-scroll-target="#step-by-step-implementation-1"><span class="header-section-number">34.4</span> Step-by-step Implementation</a></li>
  <li><a href="#explanation-20" id="toc-explanation-20" class="nav-link" data-scroll-target="#explanation-20"><span class="header-section-number">34.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#counting-phylogenetic-ancestors" id="toc-counting-phylogenetic-ancestors" class="nav-link" data-scroll-target="#counting-phylogenetic-ancestors"><span class="header-section-number">35</span> Counting Phylogenetic Ancestors</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-34" id="toc-sample-dataset-34" class="nav-link" data-scroll-target="#sample-dataset-34"><span class="header-section-number">35.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-35" id="toc-sample-output-35" class="nav-link" data-scroll-target="#sample-output-35"><span class="header-section-number">35.2</span> Sample Output</a></li>
  <li><a href="#solution-32" id="toc-solution-32" class="nav-link" data-scroll-target="#solution-32"><span class="header-section-number">35.3</span> Solution</a></li>
  <li><a href="#key-concepts-and-approach" id="toc-key-concepts-and-approach" class="nav-link" data-scroll-target="#key-concepts-and-approach"><span class="header-section-number">35.4</span> Key Concepts and Approach</a></li>
  <li><a href="#implementation-4" id="toc-implementation-4" class="nav-link" data-scroll-target="#implementation-4"><span class="header-section-number">35.5</span> Implementation</a></li>
  </ul></li>
  <li><a href="#k-mer-composition" id="toc-k-mer-composition" class="nav-link" data-scroll-target="#k-mer-composition"><span class="header-section-number">36</span> k-Mer Composition</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-35" id="toc-sample-dataset-35" class="nav-link" data-scroll-target="#sample-dataset-35"><span class="header-section-number">36.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-36" id="toc-sample-output-36" class="nav-link" data-scroll-target="#sample-output-36"><span class="header-section-number">36.2</span> Sample Output</a></li>
  <li><a href="#solution-33" id="toc-solution-33" class="nav-link" data-scroll-target="#solution-33"><span class="header-section-number">36.3</span> Solution</a></li>
  <li><a href="#detailed-explanation" id="toc-detailed-explanation" class="nav-link" data-scroll-target="#detailed-explanation"><span class="header-section-number">36.4</span> Detailed Explanation</a></li>
  <li><a href="#python-implementation-1" id="toc-python-implementation-1" class="nav-link" data-scroll-target="#python-implementation-1"><span class="header-section-number">36.5</span> Python Implementation</a></li>
  <li><a href="#explanation-of-the-code-4" id="toc-explanation-of-the-code-4" class="nav-link" data-scroll-target="#explanation-of-the-code-4"><span class="header-section-number">36.6</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#speeding-up-motif-finding" id="toc-speeding-up-motif-finding" class="nav-link" data-scroll-target="#speeding-up-motif-finding"><span class="header-section-number">37</span> Speeding Up Motif Finding</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-36" id="toc-sample-dataset-36" class="nav-link" data-scroll-target="#sample-dataset-36"><span class="header-section-number">37.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-37" id="toc-sample-output-37" class="nav-link" data-scroll-target="#sample-output-37"><span class="header-section-number">37.2</span> Sample Output</a></li>
  <li><a href="#solution-34" id="toc-solution-34" class="nav-link" data-scroll-target="#solution-34"><span class="header-section-number">37.3</span> Solution</a></li>
  <li><a href="#detailed-explanation-1" id="toc-detailed-explanation-1" class="nav-link" data-scroll-target="#detailed-explanation-1"><span class="header-section-number">37.4</span> Detailed Explanation</a></li>
  <li><a href="#python-implementation-2" id="toc-python-implementation-2" class="nav-link" data-scroll-target="#python-implementation-2"><span class="header-section-number">37.5</span> Python Implementation</a></li>
  <li><a href="#explanation-of-the-code-5" id="toc-explanation-of-the-code-5" class="nav-link" data-scroll-target="#explanation-of-the-code-5"><span class="header-section-number">37.6</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#finding-a-shared-spliced-motif" id="toc-finding-a-shared-spliced-motif" class="nav-link" data-scroll-target="#finding-a-shared-spliced-motif"><span class="header-section-number">38</span> Finding a Shared Spliced Motif</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-37" id="toc-sample-dataset-37" class="nav-link" data-scroll-target="#sample-dataset-37"><span class="header-section-number">38.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-38" id="toc-sample-output-38" class="nav-link" data-scroll-target="#sample-output-38"><span class="header-section-number">38.2</span> Sample Output</a></li>
  <li><a href="#solution-35" id="toc-solution-35" class="nav-link" data-scroll-target="#solution-35"><span class="header-section-number">38.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-6" id="toc-steps-to-solve-the-problem-6" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-6"><span class="header-section-number">38.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#detailed-explanation-2" id="toc-detailed-explanation-2" class="nav-link" data-scroll-target="#detailed-explanation-2"><span class="header-section-number">38.5</span> Detailed Explanation</a></li>
  <li><a href="#python-implementation-3" id="toc-python-implementation-3" class="nav-link" data-scroll-target="#python-implementation-3"><span class="header-section-number">38.6</span> Python Implementation</a></li>
  <li><a href="#explanation-of-the-code-6" id="toc-explanation-of-the-code-6" class="nav-link" data-scroll-target="#explanation-of-the-code-6"><span class="header-section-number">38.7</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#ordering-strings-of-varying-length-lexicographically" id="toc-ordering-strings-of-varying-length-lexicographically" class="nav-link" data-scroll-target="#ordering-strings-of-varying-length-lexicographically"><span class="header-section-number">39</span> Ordering Strings of Varying Length Lexicographically</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-38" id="toc-sample-dataset-38" class="nav-link" data-scroll-target="#sample-dataset-38"><span class="header-section-number">39.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-39" id="toc-sample-output-39" class="nav-link" data-scroll-target="#sample-output-39"><span class="header-section-number">39.2</span> Sample Output</a></li>
  <li><a href="#solution-36" id="toc-solution-36" class="nav-link" data-scroll-target="#solution-36"><span class="header-section-number">39.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-7" id="toc-steps-to-solve-the-problem-7" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-7"><span class="header-section-number">39.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#detailed-explanation-3" id="toc-detailed-explanation-3" class="nav-link" data-scroll-target="#detailed-explanation-3"><span class="header-section-number">39.5</span> Detailed Explanation</a></li>
  <li><a href="#python-implementation-4" id="toc-python-implementation-4" class="nav-link" data-scroll-target="#python-implementation-4"><span class="header-section-number">39.6</span> Python Implementation</a></li>
  <li><a href="#explanation-of-the-code-7" id="toc-explanation-of-the-code-7" class="nav-link" data-scroll-target="#explanation-of-the-code-7"><span class="header-section-number">39.7</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#maximum-matchings-and-rna-secondary-structures" id="toc-maximum-matchings-and-rna-secondary-structures" class="nav-link" data-scroll-target="#maximum-matchings-and-rna-secondary-structures"><span class="header-section-number">40</span> Maximum Matchings and RNA Secondary Structures</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-39" id="toc-sample-dataset-39" class="nav-link" data-scroll-target="#sample-dataset-39"><span class="header-section-number">40.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-40" id="toc-sample-output-40" class="nav-link" data-scroll-target="#sample-output-40"><span class="header-section-number">40.2</span> Sample Output</a></li>
  <li><a href="#solution-37" id="toc-solution-37" class="nav-link" data-scroll-target="#solution-37"><span class="header-section-number">40.3</span> Solution</a></li>
  <li><a href="#explanation-of-changes" id="toc-explanation-of-changes" class="nav-link" data-scroll-target="#explanation-of-changes"><span class="header-section-number">40.4</span> Explanation of Changes</a></li>
  </ul></li>
  <li><a href="#creating-a-distance-matrix" id="toc-creating-a-distance-matrix" class="nav-link" data-scroll-target="#creating-a-distance-matrix"><span class="header-section-number">41</span> Creating a Distance Matrix</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-40" id="toc-sample-dataset-40" class="nav-link" data-scroll-target="#sample-dataset-40"><span class="header-section-number">41.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-41" id="toc-sample-output-41" class="nav-link" data-scroll-target="#sample-output-41"><span class="header-section-number">41.2</span> Sample Output</a></li>
  <li><a href="#solution-38" id="toc-solution-38" class="nav-link" data-scroll-target="#solution-38"><span class="header-section-number">41.3</span> Solution</a></li>
  <li><a href="#detailed-implementation" id="toc-detailed-implementation" class="nav-link" data-scroll-target="#detailed-implementation"><span class="header-section-number">41.4</span> Detailed Implementation</a></li>
  <li><a href="#explanation-21" id="toc-explanation-21" class="nav-link" data-scroll-target="#explanation-21"><span class="header-section-number">41.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#reversal-distance" id="toc-reversal-distance" class="nav-link" data-scroll-target="#reversal-distance"><span class="header-section-number">42</span> Reversal Distance</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-41" id="toc-sample-dataset-41" class="nav-link" data-scroll-target="#sample-dataset-41"><span class="header-section-number">42.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-42" id="toc-sample-output-42" class="nav-link" data-scroll-target="#sample-output-42"><span class="header-section-number">42.2</span> Sample Output</a></li>
  <li><a href="#solution-39" id="toc-solution-39" class="nav-link" data-scroll-target="#solution-39"><span class="header-section-number">42.3</span> Solution</a></li>
  <li><a href="#key-changes-and-additions" id="toc-key-changes-and-additions" class="nav-link" data-scroll-target="#key-changes-and-additions"><span class="header-section-number">42.4</span> Key Changes and Additions</a></li>
  </ul></li>
  <li><a href="#counting-subsets" id="toc-counting-subsets" class="nav-link" data-scroll-target="#counting-subsets"><span class="header-section-number">43</span> Counting Subsets</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-42" id="toc-sample-dataset-42" class="nav-link" data-scroll-target="#sample-dataset-42"><span class="header-section-number">43.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-43" id="toc-sample-output-43" class="nav-link" data-scroll-target="#sample-output-43"><span class="header-section-number">43.2</span> Sample Output</a></li>
  <li><a href="#solution-40" id="toc-solution-40" class="nav-link" data-scroll-target="#solution-40"><span class="header-section-number">43.3</span> Solution</a></li>
  <li><a href="#steps-to-solution" id="toc-steps-to-solution" class="nav-link" data-scroll-target="#steps-to-solution"><span class="header-section-number">43.4</span> Steps to Solution</a></li>
  <li><a href="#explanation-of-the-code-8" id="toc-explanation-of-the-code-8" class="nav-link" data-scroll-target="#explanation-of-the-code-8"><span class="header-section-number">43.5</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#matching-random-motifs" id="toc-matching-random-motifs" class="nav-link" data-scroll-target="#matching-random-motifs"><span class="header-section-number">44</span> Matching Random Motifs</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-43" id="toc-sample-dataset-43" class="nav-link" data-scroll-target="#sample-dataset-43"><span class="header-section-number">44.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-44" id="toc-sample-output-44" class="nav-link" data-scroll-target="#sample-output-44"><span class="header-section-number">44.2</span> Sample Output</a></li>
  <li><a href="#solution-41" id="toc-solution-41" class="nav-link" data-scroll-target="#solution-41"><span class="header-section-number">44.3</span> Solution</a></li>
  <li><a href="#implementation-5" id="toc-implementation-5" class="nav-link" data-scroll-target="#implementation-5"><span class="header-section-number">44.4</span> Implementation</a></li>
  <li><a href="#explanation-of-the-code-9" id="toc-explanation-of-the-code-9" class="nav-link" data-scroll-target="#explanation-of-the-code-9"><span class="header-section-number">44.5</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#introduction-to-alternative-splicing" id="toc-introduction-to-alternative-splicing" class="nav-link" data-scroll-target="#introduction-to-alternative-splicing"><span class="header-section-number">45</span> Introduction to Alternative Splicing</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-44" id="toc-sample-dataset-44" class="nav-link" data-scroll-target="#sample-dataset-44"><span class="header-section-number">45.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-45" id="toc-sample-output-45" class="nav-link" data-scroll-target="#sample-output-45"><span class="header-section-number">45.2</span> Sample Output</a></li>
  <li><a href="#solution-42" id="toc-solution-42" class="nav-link" data-scroll-target="#solution-42"><span class="header-section-number">45.3</span> Solution</a></li>
  <li><a href="#explanation-22" id="toc-explanation-22" class="nav-link" data-scroll-target="#explanation-22"><span class="header-section-number">45.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#edit-distance" id="toc-edit-distance" class="nav-link" data-scroll-target="#edit-distance"><span class="header-section-number">46</span> Edit Distance</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-45" id="toc-sample-dataset-45" class="nav-link" data-scroll-target="#sample-dataset-45"><span class="header-section-number">46.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-46" id="toc-sample-output-46" class="nav-link" data-scroll-target="#sample-output-46"><span class="header-section-number">46.2</span> Sample Output</a></li>
  </ul></li>
  <li><a href="#expected-number-of-restriction-sites" id="toc-expected-number-of-restriction-sites" class="nav-link" data-scroll-target="#expected-number-of-restriction-sites"><span class="header-section-number">47</span> Expected Number of Restriction Sites</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-46" id="toc-sample-dataset-46" class="nav-link" data-scroll-target="#sample-dataset-46"><span class="header-section-number">47.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-47" id="toc-sample-output-47" class="nav-link" data-scroll-target="#sample-output-47"><span class="header-section-number">47.2</span> Sample Output</a></li>
  <li><a href="#solution-43" id="toc-solution-43" class="nav-link" data-scroll-target="#solution-43"><span class="header-section-number">47.3</span> Solution</a></li>
  <li><a href="#approach" id="toc-approach" class="nav-link" data-scroll-target="#approach"><span class="header-section-number">47.4</span> Approach</a></li>
  <li><a href="#detailed-steps-and-code" id="toc-detailed-steps-and-code" class="nav-link" data-scroll-target="#detailed-steps-and-code"><span class="header-section-number">47.5</span> Detailed Steps and Code</a></li>
  <li><a href="#explanation-23" id="toc-explanation-23" class="nav-link" data-scroll-target="#explanation-23"><span class="header-section-number">47.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#motzkin-numbers-and-rna-secondary-structures" id="toc-motzkin-numbers-and-rna-secondary-structures" class="nav-link" data-scroll-target="#motzkin-numbers-and-rna-secondary-structures"><span class="header-section-number">48</span> Motzkin Numbers and RNA Secondary Structures</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-47" id="toc-sample-dataset-47" class="nav-link" data-scroll-target="#sample-dataset-47"><span class="header-section-number">48.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-48" id="toc-sample-output-48" class="nav-link" data-scroll-target="#sample-output-48"><span class="header-section-number">48.2</span> Sample Output</a></li>
  <li><a href="#solution-44" id="toc-solution-44" class="nav-link" data-scroll-target="#solution-44"><span class="header-section-number">48.3</span> Solution</a></li>
  <li><a href="#code-explanation" id="toc-code-explanation" class="nav-link" data-scroll-target="#code-explanation"><span class="header-section-number">48.4</span> Code Explanation</a></li>
  <li><a href="#key-points" id="toc-key-points" class="nav-link" data-scroll-target="#key-points"><span class="header-section-number">48.5</span> Key Points</a></li>
  </ul></li>
  <li><a href="#distances-in-trees" id="toc-distances-in-trees" class="nav-link" data-scroll-target="#distances-in-trees"><span class="header-section-number">49</span> Distances in Trees</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-48" id="toc-sample-dataset-48" class="nav-link" data-scroll-target="#sample-dataset-48"><span class="header-section-number">49.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-49" id="toc-sample-output-49" class="nav-link" data-scroll-target="#sample-output-49"><span class="header-section-number">49.2</span> Sample Output</a></li>
  <li><a href="#solution-45" id="toc-solution-45" class="nav-link" data-scroll-target="#solution-45"><span class="header-section-number">49.3</span> Solution</a></li>
  <li><a href="#explanation-24" id="toc-explanation-24" class="nav-link" data-scroll-target="#explanation-24"><span class="header-section-number">49.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#interleaving-two-motifs" id="toc-interleaving-two-motifs" class="nav-link" data-scroll-target="#interleaving-two-motifs"><span class="header-section-number">50</span> Interleaving Two Motifs</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-49" id="toc-sample-dataset-49" class="nav-link" data-scroll-target="#sample-dataset-49"><span class="header-section-number">50.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-50" id="toc-sample-output-50" class="nav-link" data-scroll-target="#sample-output-50"><span class="header-section-number">50.2</span> Sample Output</a></li>
  <li><a href="#solution-46" id="toc-solution-46" class="nav-link" data-scroll-target="#solution-46"><span class="header-section-number">50.3</span> Solution</a></li>
  <li><a href="#steps-to-solve-the-problem-8" id="toc-steps-to-solve-the-problem-8" class="nav-link" data-scroll-target="#steps-to-solve-the-problem-8"><span class="header-section-number">50.4</span> Steps to Solve the Problem</a></li>
  <li><a href="#code-implementation" id="toc-code-implementation" class="nav-link" data-scroll-target="#code-implementation"><span class="header-section-number">50.5</span> Code Implementation</a></li>
  </ul></li>
  <li><a href="#introduction-to-set-operations" id="toc-introduction-to-set-operations" class="nav-link" data-scroll-target="#introduction-to-set-operations"><span class="header-section-number">51</span> Introduction to Set Operations</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-50" id="toc-sample-dataset-50" class="nav-link" data-scroll-target="#sample-dataset-50"><span class="header-section-number">51.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-51" id="toc-sample-output-51" class="nav-link" data-scroll-target="#sample-output-51"><span class="header-section-number">51.2</span> Sample Output</a></li>
  <li><a href="#solution-47" id="toc-solution-47" class="nav-link" data-scroll-target="#solution-47"><span class="header-section-number">51.3</span> Solution</a></li>
  <li><a href="#steps" id="toc-steps" class="nav-link" data-scroll-target="#steps"><span class="header-section-number">51.4</span> Steps</a></li>
  <li><a href="#explanation-25" id="toc-explanation-25" class="nav-link" data-scroll-target="#explanation-25"><span class="header-section-number">51.5</span> Explanation</a></li>
  </ul></li>
  <li><a href="#sorting-by-reversals" id="toc-sorting-by-reversals" class="nav-link" data-scroll-target="#sorting-by-reversals"><span class="header-section-number">52</span> Sorting by Reversals</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-51" id="toc-sample-dataset-51" class="nav-link" data-scroll-target="#sample-dataset-51"><span class="header-section-number">52.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-52" id="toc-sample-output-52" class="nav-link" data-scroll-target="#sample-output-52"><span class="header-section-number">52.2</span> Sample Output</a></li>
  <li><a href="#solution-48" id="toc-solution-48" class="nav-link" data-scroll-target="#solution-48"><span class="header-section-number">52.3</span> Solution</a></li>
  <li><a href="#key-concepts" id="toc-key-concepts" class="nav-link" data-scroll-target="#key-concepts"><span class="header-section-number">52.4</span> Key Concepts</a></li>
  <li><a href="#approach-1" id="toc-approach-1" class="nav-link" data-scroll-target="#approach-1"><span class="header-section-number">52.5</span> Approach</a></li>
  <li><a href="#example-solution-in-python" id="toc-example-solution-in-python" class="nav-link" data-scroll-target="#example-solution-in-python"><span class="header-section-number">52.6</span> Example Solution in Python</a></li>
  <li><a href="#explanation-26" id="toc-explanation-26" class="nav-link" data-scroll-target="#explanation-26"><span class="header-section-number">52.7</span> Explanation</a></li>
  </ul></li>
  <li><a href="#inferring-protein-from-spectrum" id="toc-inferring-protein-from-spectrum" class="nav-link" data-scroll-target="#inferring-protein-from-spectrum"><span class="header-section-number">53</span> Inferring Protein from Spectrum</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-52" id="toc-sample-dataset-52" class="nav-link" data-scroll-target="#sample-dataset-52"><span class="header-section-number">53.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-53" id="toc-sample-output-53" class="nav-link" data-scroll-target="#sample-output-53"><span class="header-section-number">53.2</span> Sample Output</a></li>
  <li><a href="#solution-49" id="toc-solution-49" class="nav-link" data-scroll-target="#solution-49"><span class="header-section-number">53.3</span> Solution</a></li>
  <li><a href="#explanation-27" id="toc-explanation-27" class="nav-link" data-scroll-target="#explanation-27"><span class="header-section-number">53.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#introduction-to-pattern-matching" id="toc-introduction-to-pattern-matching" class="nav-link" data-scroll-target="#introduction-to-pattern-matching"><span class="header-section-number">54</span> Introduction to Pattern Matching</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-53" id="toc-sample-dataset-53" class="nav-link" data-scroll-target="#sample-dataset-53"><span class="header-section-number">54.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-54" id="toc-sample-output-54" class="nav-link" data-scroll-target="#sample-output-54"><span class="header-section-number">54.2</span> Sample Output</a></li>
  <li><a href="#solution-50" id="toc-solution-50" class="nav-link" data-scroll-target="#solution-50"><span class="header-section-number">54.3</span> Solution</a></li>
  <li><a href="#explanation-28" id="toc-explanation-28" class="nav-link" data-scroll-target="#explanation-28"><span class="header-section-number">54.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#comparing-spectra-with-the-spectral-convolution" id="toc-comparing-spectra-with-the-spectral-convolution" class="nav-link" data-scroll-target="#comparing-spectra-with-the-spectral-convolution"><span class="header-section-number">55</span> Comparing Spectra with the Spectral Convolution</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-54" id="toc-sample-dataset-54" class="nav-link" data-scroll-target="#sample-dataset-54"><span class="header-section-number">55.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-55" id="toc-sample-output-55" class="nav-link" data-scroll-target="#sample-output-55"><span class="header-section-number">55.2</span> Sample Output</a></li>
  <li><a href="#solution-51" id="toc-solution-51" class="nav-link" data-scroll-target="#solution-51"><span class="header-section-number">55.3</span> Solution</a></li>
  <li><a href="#explanation-29" id="toc-explanation-29" class="nav-link" data-scroll-target="#explanation-29"><span class="header-section-number">55.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#creating-a-character-table" id="toc-creating-a-character-table" class="nav-link" data-scroll-target="#creating-a-character-table"><span class="header-section-number">56</span> Creating a Character Table</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-55" id="toc-sample-dataset-55" class="nav-link" data-scroll-target="#sample-dataset-55"><span class="header-section-number">56.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-56" id="toc-sample-output-56" class="nav-link" data-scroll-target="#sample-output-56"><span class="header-section-number">56.2</span> Sample Output</a></li>
  <li><a href="#solution-52" id="toc-solution-52" class="nav-link" data-scroll-target="#solution-52"><span class="header-section-number">56.3</span> Solution</a></li>
  <li><a href="#explain" id="toc-explain" class="nav-link" data-scroll-target="#explain"><span class="header-section-number">56.4</span> Explain</a></li>
  </ul></li>
  <li><a href="#constructing-a-de-bruijn-graph" id="toc-constructing-a-de-bruijn-graph" class="nav-link" data-scroll-target="#constructing-a-de-bruijn-graph"><span class="header-section-number">57</span> Constructing a De Bruijn Graph</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-56" id="toc-sample-dataset-56" class="nav-link" data-scroll-target="#sample-dataset-56"><span class="header-section-number">57.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-57" id="toc-sample-output-57" class="nav-link" data-scroll-target="#sample-output-57"><span class="header-section-number">57.2</span> Sample Output</a></li>
  <li><a href="#solution-53" id="toc-solution-53" class="nav-link" data-scroll-target="#solution-53"><span class="header-section-number">57.3</span> Solution</a></li>
  <li><a href="#changes-made" id="toc-changes-made" class="nav-link" data-scroll-target="#changes-made"><span class="header-section-number">57.4</span> Changes Made</a></li>
  </ul></li>
  <li><a href="#edit-distance-alignment" id="toc-edit-distance-alignment" class="nav-link" data-scroll-target="#edit-distance-alignment"><span class="header-section-number">58</span> Edit Distance Alignment</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-57" id="toc-sample-dataset-57" class="nav-link" data-scroll-target="#sample-dataset-57"><span class="header-section-number">58.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-58" id="toc-sample-output-58" class="nav-link" data-scroll-target="#sample-output-58"><span class="header-section-number">58.2</span> Sample Output</a></li>
  <li><a href="#solution-54" id="toc-solution-54" class="nav-link" data-scroll-target="#solution-54"><span class="header-section-number">58.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-10" id="toc-explanation-of-the-code-10" class="nav-link" data-scroll-target="#explanation-of-the-code-10"><span class="header-section-number">58.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#inferring-peptide-from-full-spectrum" id="toc-inferring-peptide-from-full-spectrum" class="nav-link" data-scroll-target="#inferring-peptide-from-full-spectrum"><span class="header-section-number">59</span> Inferring Peptide from Full Spectrum</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-58" id="toc-sample-dataset-58" class="nav-link" data-scroll-target="#sample-dataset-58"><span class="header-section-number">59.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-59" id="toc-sample-output-59" class="nav-link" data-scroll-target="#sample-output-59"><span class="header-section-number">59.2</span> Sample Output</a></li>
  <li><a href="#solution-55" id="toc-solution-55" class="nav-link" data-scroll-target="#solution-55"><span class="header-section-number">59.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#independent-segregation-of-chromosomes" id="toc-independent-segregation-of-chromosomes" class="nav-link" data-scroll-target="#independent-segregation-of-chromosomes"><span class="header-section-number">60</span> Independent Segregation of Chromosomes</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-59" id="toc-sample-dataset-59" class="nav-link" data-scroll-target="#sample-dataset-59"><span class="header-section-number">60.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-60" id="toc-sample-output-60" class="nav-link" data-scroll-target="#sample-output-60"><span class="header-section-number">60.2</span> Sample Output</a></li>
  <li><a href="#solution-56" id="toc-solution-56" class="nav-link" data-scroll-target="#solution-56"><span class="header-section-number">60.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-function" id="toc-explanation-of-the-function" class="nav-link" data-scroll-target="#explanation-of-the-function"><span class="header-section-number">60.4</span> Explanation of the Function</a></li>
  </ul></li>
  <li><a href="#finding-disjoint-motifs-in-a-gene" id="toc-finding-disjoint-motifs-in-a-gene" class="nav-link" data-scroll-target="#finding-disjoint-motifs-in-a-gene"><span class="header-section-number">61</span> Finding Disjoint Motifs in a Gene</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-60" id="toc-sample-dataset-60" class="nav-link" data-scroll-target="#sample-dataset-60"><span class="header-section-number">61.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-61" id="toc-sample-output-61" class="nav-link" data-scroll-target="#sample-output-61"><span class="header-section-number">61.2</span> Sample Output</a></li>
  <li><a href="#solution-57" id="toc-solution-57" class="nav-link" data-scroll-target="#solution-57"><span class="header-section-number">61.3</span> Solution</a></li>
  <li><a href="#explanation-30" id="toc-explanation-30" class="nav-link" data-scroll-target="#explanation-30"><span class="header-section-number">61.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#finding-the-longest-multiple-repeat" id="toc-finding-the-longest-multiple-repeat" class="nav-link" data-scroll-target="#finding-the-longest-multiple-repeat"><span class="header-section-number">62</span> Finding the Longest Multiple Repeat</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-61" id="toc-sample-dataset-61" class="nav-link" data-scroll-target="#sample-dataset-61"><span class="header-section-number">62.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-62" id="toc-sample-output-62" class="nav-link" data-scroll-target="#sample-output-62"><span class="header-section-number">62.2</span> Sample Output</a></li>
  <li><a href="#solution-58" id="toc-solution-58" class="nav-link" data-scroll-target="#solution-58"><span class="header-section-number">62.3</span> Solution</a></li>
  <li><a href="#steps-to-approach-the-problem" id="toc-steps-to-approach-the-problem" class="nav-link" data-scroll-target="#steps-to-approach-the-problem"><span class="header-section-number">62.4</span> Steps to Approach the Problem</a></li>
  <li><a href="#implementation-6" id="toc-implementation-6" class="nav-link" data-scroll-target="#implementation-6"><span class="header-section-number">62.5</span> Implementation</a></li>
  <li><a href="#explanation-31" id="toc-explanation-31" class="nav-link" data-scroll-target="#explanation-31"><span class="header-section-number">62.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#newick-format-with-edge-weights" id="toc-newick-format-with-edge-weights" class="nav-link" data-scroll-target="#newick-format-with-edge-weights"><span class="header-section-number">63</span> Newick Format with Edge Weights</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-62" id="toc-sample-dataset-62" class="nav-link" data-scroll-target="#sample-dataset-62"><span class="header-section-number">63.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-63" id="toc-sample-output-63" class="nav-link" data-scroll-target="#sample-output-63"><span class="header-section-number">63.2</span> Sample Output</a></li>
  <li><a href="#solution-59" id="toc-solution-59" class="nav-link" data-scroll-target="#solution-59"><span class="header-section-number">63.3</span> Solution</a></li>
  <li><a href="#explanation-32" id="toc-explanation-32" class="nav-link" data-scroll-target="#explanation-32"><span class="header-section-number">63.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#wobble-bonding-and-rna-secondary-structures" id="toc-wobble-bonding-and-rna-secondary-structures" class="nav-link" data-scroll-target="#wobble-bonding-and-rna-secondary-structures"><span class="header-section-number">64</span> Wobble Bonding and RNA Secondary Structures</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-63" id="toc-sample-dataset-63" class="nav-link" data-scroll-target="#sample-dataset-63"><span class="header-section-number">64.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-64" id="toc-sample-output-64" class="nav-link" data-scroll-target="#sample-output-64"><span class="header-section-number">64.2</span> Sample Output</a></li>
  <li><a href="#solution-60" id="toc-solution-60" class="nav-link" data-scroll-target="#solution-60"><span class="header-section-number">64.3</span> Solution</a></li>
  <li><a href="#approach-2" id="toc-approach-2" class="nav-link" data-scroll-target="#approach-2"><span class="header-section-number">64.4</span> Approach</a></li>
  <li><a href="#implementation-7" id="toc-implementation-7" class="nav-link" data-scroll-target="#implementation-7"><span class="header-section-number">64.5</span> Implementation</a></li>
  <li><a href="#explanation-33" id="toc-explanation-33" class="nav-link" data-scroll-target="#explanation-33"><span class="header-section-number">64.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#counting-disease-carriers" id="toc-counting-disease-carriers" class="nav-link" data-scroll-target="#counting-disease-carriers"><span class="header-section-number">65</span> Counting Disease Carriers</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-64" id="toc-sample-dataset-64" class="nav-link" data-scroll-target="#sample-dataset-64"><span class="header-section-number">65.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-65" id="toc-sample-output-65" class="nav-link" data-scroll-target="#sample-output-65"><span class="header-section-number">65.2</span> Sample Output</a></li>
  <li><a href="#solution-61" id="toc-solution-61" class="nav-link" data-scroll-target="#solution-61"><span class="header-section-number">65.3</span> Solution</a></li>
  <li><a href="#steps-to-solve" id="toc-steps-to-solve" class="nav-link" data-scroll-target="#steps-to-solve"><span class="header-section-number">65.4</span> Steps to Solve</a></li>
  <li><a href="#implementation-8" id="toc-implementation-8" class="nav-link" data-scroll-target="#implementation-8"><span class="header-section-number">65.5</span> Implementation</a></li>
  <li><a href="#explanation-34" id="toc-explanation-34" class="nav-link" data-scroll-target="#explanation-34"><span class="header-section-number">65.6</span> Explanation</a></li>
  </ul></li>
  <li><a href="#creating-a-character-table-from-genetic-strings" id="toc-creating-a-character-table-from-genetic-strings" class="nav-link" data-scroll-target="#creating-a-character-table-from-genetic-strings"><span class="header-section-number">66</span> Creating a Character Table from Genetic Strings</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-65" id="toc-sample-dataset-65" class="nav-link" data-scroll-target="#sample-dataset-65"><span class="header-section-number">66.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-66" id="toc-sample-output-66" class="nav-link" data-scroll-target="#sample-output-66"><span class="header-section-number">66.2</span> Sample Output</a></li>
  <li><a href="#solution-62" id="toc-solution-62" class="nav-link" data-scroll-target="#solution-62"><span class="header-section-number">66.3</span> Solution</a></li>
  <li><a href="#explanation-35" id="toc-explanation-35" class="nav-link" data-scroll-target="#explanation-35"><span class="header-section-number">66.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#counting-optimal-alignments" id="toc-counting-optimal-alignments" class="nav-link" data-scroll-target="#counting-optimal-alignments"><span class="header-section-number">67</span> Counting Optimal Alignments</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-66" id="toc-sample-dataset-66" class="nav-link" data-scroll-target="#sample-dataset-66"><span class="header-section-number">67.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-67" id="toc-sample-output-67" class="nav-link" data-scroll-target="#sample-output-67"><span class="header-section-number">67.2</span> Sample Output</a></li>
  <li><a href="#solution-63" id="toc-solution-63" class="nav-link" data-scroll-target="#solution-63"><span class="header-section-number">67.3</span> Solution</a></li>
  <li><a href="#explanation-36" id="toc-explanation-36" class="nav-link" data-scroll-target="#explanation-36"><span class="header-section-number">67.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#counting-unrooted-binary-trees" id="toc-counting-unrooted-binary-trees" class="nav-link" data-scroll-target="#counting-unrooted-binary-trees"><span class="header-section-number">68</span> Counting Unrooted Binary Trees</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-67" id="toc-sample-dataset-67" class="nav-link" data-scroll-target="#sample-dataset-67"><span class="header-section-number">68.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-68" id="toc-sample-output-68" class="nav-link" data-scroll-target="#sample-output-68"><span class="header-section-number">68.2</span> Sample Output</a></li>
  <li><a href="#solution-64" id="toc-solution-64" class="nav-link" data-scroll-target="#solution-64"><span class="header-section-number">68.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#global-alignment-with-scoring-matrix" id="toc-global-alignment-with-scoring-matrix" class="nav-link" data-scroll-target="#global-alignment-with-scoring-matrix"><span class="header-section-number">69</span> Global Alignment with Scoring Matrix</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-68" id="toc-sample-dataset-68" class="nav-link" data-scroll-target="#sample-dataset-68"><span class="header-section-number">69.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-69" id="toc-sample-output-69" class="nav-link" data-scroll-target="#sample-output-69"><span class="header-section-number">69.2</span> Sample Output</a></li>
  <li><a href="#solution-65" id="toc-solution-65" class="nav-link" data-scroll-target="#solution-65"><span class="header-section-number">69.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-11" id="toc-explanation-of-the-code-11" class="nav-link" data-scroll-target="#explanation-of-the-code-11"><span class="header-section-number">69.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#genome-assembly-with-perfect-coverage" id="toc-genome-assembly-with-perfect-coverage" class="nav-link" data-scroll-target="#genome-assembly-with-perfect-coverage"><span class="header-section-number">70</span> Genome Assembly with Perfect Coverage</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-69" id="toc-sample-dataset-69" class="nav-link" data-scroll-target="#sample-dataset-69"><span class="header-section-number">70.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-70" id="toc-sample-output-70" class="nav-link" data-scroll-target="#sample-output-70"><span class="header-section-number">70.2</span> Sample Output</a></li>
  <li><a href="#solution-66" id="toc-solution-66" class="nav-link" data-scroll-target="#solution-66"><span class="header-section-number">70.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-12" id="toc-explanation-of-the-code-12" class="nav-link" data-scroll-target="#explanation-of-the-code-12"><span class="header-section-number">70.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#matching-a-spectrum-to-a-protein" id="toc-matching-a-spectrum-to-a-protein" class="nav-link" data-scroll-target="#matching-a-spectrum-to-a-protein"><span class="header-section-number">71</span> Matching a Spectrum to a Protein</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-70" id="toc-sample-dataset-70" class="nav-link" data-scroll-target="#sample-dataset-70"><span class="header-section-number">71.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-71" id="toc-sample-output-71" class="nav-link" data-scroll-target="#sample-output-71"><span class="header-section-number">71.2</span> Sample Output</a></li>
  <li><a href="#solution-67" id="toc-solution-67" class="nav-link" data-scroll-target="#solution-67"><span class="header-section-number">71.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-13" id="toc-explanation-of-the-code-13" class="nav-link" data-scroll-target="#explanation-of-the-code-13"><span class="header-section-number">71.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#quartets" id="toc-quartets" class="nav-link" data-scroll-target="#quartets"><span class="header-section-number">72</span> Quartets</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-71" id="toc-sample-dataset-71" class="nav-link" data-scroll-target="#sample-dataset-71"><span class="header-section-number">72.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-72" id="toc-sample-output-72" class="nav-link" data-scroll-target="#sample-output-72"><span class="header-section-number">72.2</span> Sample Output</a></li>
  <li><a href="#solution-68" id="toc-solution-68" class="nav-link" data-scroll-target="#solution-68"><span class="header-section-number">72.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-14" id="toc-explanation-of-the-code-14" class="nav-link" data-scroll-target="#explanation-of-the-code-14"><span class="header-section-number">72.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#using-the-spectrum-graph-to-infer-peptides" id="toc-using-the-spectrum-graph-to-infer-peptides" class="nav-link" data-scroll-target="#using-the-spectrum-graph-to-infer-peptides"><span class="header-section-number">73</span> Using the Spectrum Graph to Infer Peptides</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-72" id="toc-sample-dataset-72" class="nav-link" data-scroll-target="#sample-dataset-72"><span class="header-section-number">73.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-73" id="toc-sample-output-73" class="nav-link" data-scroll-target="#sample-output-73"><span class="header-section-number">73.2</span> Sample Output</a></li>
  <li><a href="#solution-69" id="toc-solution-69" class="nav-link" data-scroll-target="#solution-69"><span class="header-section-number">73.3</span> Solution</a></li>
  <li><a href="#explanation-37" id="toc-explanation-37" class="nav-link" data-scroll-target="#explanation-37"><span class="header-section-number">73.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#encoding-suffix-trees" id="toc-encoding-suffix-trees" class="nav-link" data-scroll-target="#encoding-suffix-trees"><span class="header-section-number">74</span> Encoding Suffix Trees</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-73" id="toc-sample-dataset-73" class="nav-link" data-scroll-target="#sample-dataset-73"><span class="header-section-number">74.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-74" id="toc-sample-output-74" class="nav-link" data-scroll-target="#sample-output-74"><span class="header-section-number">74.2</span> Sample Output</a></li>
  <li><a href="#solution-70" id="toc-solution-70" class="nav-link" data-scroll-target="#solution-70"><span class="header-section-number">74.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-15" id="toc-explanation-of-the-code-15" class="nav-link" data-scroll-target="#explanation-of-the-code-15"><span class="header-section-number">74.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#character-based-phylogeny" id="toc-character-based-phylogeny" class="nav-link" data-scroll-target="#character-based-phylogeny"><span class="header-section-number">75</span> Character-Based Phylogeny</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-74" id="toc-sample-dataset-74" class="nav-link" data-scroll-target="#sample-dataset-74"><span class="header-section-number">75.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-75" id="toc-sample-output-75" class="nav-link" data-scroll-target="#sample-output-75"><span class="header-section-number">75.2</span> Sample Output</a></li>
  <li><a href="#solution-71" id="toc-solution-71" class="nav-link" data-scroll-target="#solution-71"><span class="header-section-number">75.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-16" id="toc-explanation-of-the-code-16" class="nav-link" data-scroll-target="#explanation-of-the-code-16"><span class="header-section-number">75.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#counting-quartets" id="toc-counting-quartets" class="nav-link" data-scroll-target="#counting-quartets"><span class="header-section-number">76</span> Counting Quartets</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-75" id="toc-sample-dataset-75" class="nav-link" data-scroll-target="#sample-dataset-75"><span class="header-section-number">76.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-76" id="toc-sample-output-76" class="nav-link" data-scroll-target="#sample-output-76"><span class="header-section-number">76.2</span> Sample Output</a></li>
  <li><a href="#solution-72" id="toc-solution-72" class="nav-link" data-scroll-target="#solution-72"><span class="header-section-number">76.3</span> Solution</a></li>
  <li><a href="#explanation-38" id="toc-explanation-38" class="nav-link" data-scroll-target="#explanation-38"><span class="header-section-number">76.4</span> Explanation</a></li>
  <li><a href="#key-concepts-1" id="toc-key-concepts-1" class="nav-link" data-scroll-target="#key-concepts-1"><span class="header-section-number">76.5</span> Key Concepts</a></li>
  </ul></li>
  <li><a href="#enumerating-unrooted-binary-trees" id="toc-enumerating-unrooted-binary-trees" class="nav-link" data-scroll-target="#enumerating-unrooted-binary-trees"><span class="header-section-number">77</span> Enumerating Unrooted Binary Trees</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-76" id="toc-sample-dataset-76" class="nav-link" data-scroll-target="#sample-dataset-76"><span class="header-section-number">77.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-77" id="toc-sample-output-77" class="nav-link" data-scroll-target="#sample-output-77"><span class="header-section-number">77.2</span> Sample Output</a></li>
  <li><a href="#solution-73" id="toc-solution-73" class="nav-link" data-scroll-target="#solution-73"><span class="header-section-number">77.3</span> Solution</a></li>
  <li><a href="#explanation-of-the-code-17" id="toc-explanation-of-the-code-17" class="nav-link" data-scroll-target="#explanation-of-the-code-17"><span class="header-section-number">77.4</span> Explanation of the Code</a></li>
  </ul></li>
  <li><a href="#genome-assembly-using-reads" id="toc-genome-assembly-using-reads" class="nav-link" data-scroll-target="#genome-assembly-using-reads"><span class="header-section-number">78</span> Genome Assembly Using Reads</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-77" id="toc-sample-dataset-77" class="nav-link" data-scroll-target="#sample-dataset-77"><span class="header-section-number">78.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-78" id="toc-sample-output-78" class="nav-link" data-scroll-target="#sample-output-78"><span class="header-section-number">78.2</span> Sample Output</a></li>
  <li><a href="#solution-74" id="toc-solution-74" class="nav-link" data-scroll-target="#solution-74"><span class="header-section-number">78.3</span> Solution</a></li>
  <li><a href="#explanation-39" id="toc-explanation-39" class="nav-link" data-scroll-target="#explanation-39"><span class="header-section-number">78.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#global-alignment-with-constant-gap-penalty" id="toc-global-alignment-with-constant-gap-penalty" class="nav-link" data-scroll-target="#global-alignment-with-constant-gap-penalty"><span class="header-section-number">79</span> Global Alignment with Constant Gap Penalty</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-78" id="toc-sample-dataset-78" class="nav-link" data-scroll-target="#sample-dataset-78"><span class="header-section-number">79.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-79" id="toc-sample-output-79" class="nav-link" data-scroll-target="#sample-output-79"><span class="header-section-number">79.2</span> Sample Output</a></li>
  <li><a href="#solution-75" id="toc-solution-75" class="nav-link" data-scroll-target="#solution-75"><span class="header-section-number">79.3</span> Solution</a></li>
  <li><a href="#parse_fastafasta_string" id="toc-parse_fastafasta_string" class="nav-link" data-scroll-target="#parse_fastafasta_string"><span class="header-section-number">79.4</span> 1. <code>parse_fasta(fasta_string)</code></a></li>
  <li><a href="#global_alignment_with_gap_penaltyseq1-seq2" id="toc-global_alignment_with_gap_penaltyseq1-seq2" class="nav-link" data-scroll-target="#global_alignment_with_gap_penaltyseq1-seq2"><span class="header-section-number">79.5</span> 2. <code>global_alignment_with_gap_penalty(seq1, seq2)</code></a></li>
  </ul></li>
  <li><a href="#inferring-genotype-from-a-pedigree" id="toc-inferring-genotype-from-a-pedigree" class="nav-link" data-scroll-target="#inferring-genotype-from-a-pedigree"><span class="header-section-number">80</span> Inferring Genotype from a Pedigree</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-79" id="toc-sample-dataset-79" class="nav-link" data-scroll-target="#sample-dataset-79"><span class="header-section-number">80.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-80" id="toc-sample-output-80" class="nav-link" data-scroll-target="#sample-output-80"><span class="header-section-number">80.2</span> Sample Output</a></li>
  <li><a href="#solution-76" id="toc-solution-76" class="nav-link" data-scroll-target="#solution-76"><span class="header-section-number">80.3</span> Solution</a></li>
  <li><a href="#explanation-40" id="toc-explanation-40" class="nav-link" data-scroll-target="#explanation-40"><span class="header-section-number">80.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#linguistic-complexity-of-a-genome" id="toc-linguistic-complexity-of-a-genome" class="nav-link" data-scroll-target="#linguistic-complexity-of-a-genome"><span class="header-section-number">81</span> Linguistic Complexity of a Genome</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-80" id="toc-sample-dataset-80" class="nav-link" data-scroll-target="#sample-dataset-80"><span class="header-section-number">81.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-81" id="toc-sample-output-81" class="nav-link" data-scroll-target="#sample-output-81"><span class="header-section-number">81.2</span> Sample Output</a></li>
  <li><a href="#solution-77" id="toc-solution-77" class="nav-link" data-scroll-target="#solution-77"><span class="header-section-number">81.3</span> Solution</a></li>
  <li><a href="#explanation-41" id="toc-explanation-41" class="nav-link" data-scroll-target="#explanation-41"><span class="header-section-number">81.4</span> Explanation</a>
  <ul class="collapse">
  <li><a href="#suffixtree-class" id="toc-suffixtree-class" class="nav-link" data-scroll-target="#suffixtree-class"><span class="header-section-number">81.4.1</span> 1. <strong>SuffixTree Class</strong></a></li>
  <li><a href="#calculations" id="toc-calculations" class="nav-link" data-scroll-target="#calculations"><span class="header-section-number">81.4.2</span> 2. <strong>Calculations</strong></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#local-alignment-with-scoring-matrix" id="toc-local-alignment-with-scoring-matrix" class="nav-link" data-scroll-target="#local-alignment-with-scoring-matrix"><span class="header-section-number">82</span> Local Alignment with Scoring Matrix</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-81" id="toc-sample-dataset-81" class="nav-link" data-scroll-target="#sample-dataset-81"><span class="header-section-number">82.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-82" id="toc-sample-output-82" class="nav-link" data-scroll-target="#sample-output-82"><span class="header-section-number">82.2</span> Sample Output</a></li>
  <li><a href="#solution-78" id="toc-solution-78" class="nav-link" data-scroll-target="#solution-78"><span class="header-section-number">82.3</span> Solution</a></li>
  <li><a href="#explanation-42" id="toc-explanation-42" class="nav-link" data-scroll-target="#explanation-42"><span class="header-section-number">82.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#maximizing-the-gap-symbols-of-an-optimal-alignment" id="toc-maximizing-the-gap-symbols-of-an-optimal-alignment" class="nav-link" data-scroll-target="#maximizing-the-gap-symbols-of-an-optimal-alignment"><span class="header-section-number">83</span> Maximizing the Gap Symbols of an Optimal Alignment</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-82" id="toc-sample-dataset-82" class="nav-link" data-scroll-target="#sample-dataset-82"><span class="header-section-number">83.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-83" id="toc-sample-output-83" class="nav-link" data-scroll-target="#sample-output-83"><span class="header-section-number">83.2</span> Sample Output</a></li>
  <li><a href="#solution-79" id="toc-solution-79" class="nav-link" data-scroll-target="#solution-79"><span class="header-section-number">83.3</span> Solution</a></li>
  <li><a href="#explanation-43" id="toc-explanation-43" class="nav-link" data-scroll-target="#explanation-43"><span class="header-section-number">83.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#identifying-maximal-repeats" id="toc-identifying-maximal-repeats" class="nav-link" data-scroll-target="#identifying-maximal-repeats"><span class="header-section-number">84</span> Identifying Maximal Repeats</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-83" id="toc-sample-dataset-83" class="nav-link" data-scroll-target="#sample-dataset-83"><span class="header-section-number">84.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-84" id="toc-sample-output-84" class="nav-link" data-scroll-target="#sample-output-84"><span class="header-section-number">84.2</span> Sample Output</a></li>
  <li><a href="#solution-80" id="toc-solution-80" class="nav-link" data-scroll-target="#solution-80"><span class="header-section-number">84.3</span> Solution</a></li>
  <li><a href="#detailed-breakdown-of-the-code" id="toc-detailed-breakdown-of-the-code" class="nav-link" data-scroll-target="#detailed-breakdown-of-the-code"><span class="header-section-number">84.4</span> Detailed Breakdown of the Code</a></li>
  </ul></li>
  <li><a href="#multiple-alignment" id="toc-multiple-alignment" class="nav-link" data-scroll-target="#multiple-alignment"><span class="header-section-number">85</span> Multiple Alignment</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-84" id="toc-sample-dataset-84" class="nav-link" data-scroll-target="#sample-dataset-84"><span class="header-section-number">85.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-85" id="toc-sample-output-85" class="nav-link" data-scroll-target="#sample-output-85"><span class="header-section-number">85.2</span> Sample Output</a></li>
  <li><a href="#solution-81" id="toc-solution-81" class="nav-link" data-scroll-target="#solution-81"><span class="header-section-number">85.3</span> Solution</a></li>
  <li><a href="#explain-the-code" id="toc-explain-the-code" class="nav-link" data-scroll-target="#explain-the-code"><span class="header-section-number">85.4</span> Explain the code</a></li>
  </ul></li>
  <li><a href="#creating-a-restriction-map" id="toc-creating-a-restriction-map" class="nav-link" data-scroll-target="#creating-a-restriction-map"><span class="header-section-number">86</span> Creating a Restriction Map</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-85" id="toc-sample-dataset-85" class="nav-link" data-scroll-target="#sample-dataset-85"><span class="header-section-number">86.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-86" id="toc-sample-output-86" class="nav-link" data-scroll-target="#sample-output-86"><span class="header-section-number">86.2</span> Sample Output</a></li>
  <li><a href="#solution-82" id="toc-solution-82" class="nav-link" data-scroll-target="#solution-82"><span class="header-section-number">86.3</span> Solution</a></li>
  <li><a href="#step-by-step-explanation" id="toc-step-by-step-explanation" class="nav-link" data-scroll-target="#step-by-step-explanation"><span class="header-section-number">86.4</span> Step-by-Step Explanation</a></li>
  </ul></li>
  <li><a href="#counting-rooted-binary-trees" id="toc-counting-rooted-binary-trees" class="nav-link" data-scroll-target="#counting-rooted-binary-trees"><span class="header-section-number">87</span> Counting Rooted Binary Trees</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-86" id="toc-sample-dataset-86" class="nav-link" data-scroll-target="#sample-dataset-86"><span class="header-section-number">87.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-87" id="toc-sample-output-87" class="nav-link" data-scroll-target="#sample-output-87"><span class="header-section-number">87.2</span> Sample Output</a></li>
  <li><a href="#solution-83" id="toc-solution-83" class="nav-link" data-scroll-target="#solution-83"><span class="header-section-number">87.3</span> Solution</a></li>
  <li><a href="#count_unrooted_binary_treesn" id="toc-count_unrooted_binary_treesn" class="nav-link" data-scroll-target="#count_unrooted_binary_treesn"><span class="header-section-number">87.4</span> <strong><code>count_unrooted_binary_trees(n)</code></strong></a></li>
  <li><a href="#count_rooted_binary_treesn" id="toc-count_rooted_binary_treesn" class="nav-link" data-scroll-target="#count_rooted_binary_treesn"><span class="header-section-number">87.5</span> <strong><code>count_rooted_binary_trees(n)</code></strong></a></li>
  <li><a href="#how-it-works" id="toc-how-it-works" class="nav-link" data-scroll-target="#how-it-works"><span class="header-section-number">87.6</span> How It Works</a></li>
  </ul></li>
  <li><a href="#sex-linked-inheritance" id="toc-sex-linked-inheritance" class="nav-link" data-scroll-target="#sex-linked-inheritance"><span class="header-section-number">88</span> Sex-Linked Inheritance</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-87" id="toc-sample-dataset-87" class="nav-link" data-scroll-target="#sample-dataset-87"><span class="header-section-number">88.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-88" id="toc-sample-output-88" class="nav-link" data-scroll-target="#sample-output-88"><span class="header-section-number">88.2</span> Sample Output</a></li>
  <li><a href="#solution-84" id="toc-solution-84" class="nav-link" data-scroll-target="#solution-84"><span class="header-section-number">88.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#phylogeny-comparison-with-split-distance" id="toc-phylogeny-comparison-with-split-distance" class="nav-link" data-scroll-target="#phylogeny-comparison-with-split-distance"><span class="header-section-number">89</span> Phylogeny Comparison with Split Distance</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-88" id="toc-sample-dataset-88" class="nav-link" data-scroll-target="#sample-dataset-88"><span class="header-section-number">89.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-89" id="toc-sample-output-89" class="nav-link" data-scroll-target="#sample-output-89"><span class="header-section-number">89.2</span> Sample Output</a></li>
  <li><a href="#solution-85" id="toc-solution-85" class="nav-link" data-scroll-target="#solution-85"><span class="header-section-number">89.3</span> Solution</a></li>
  <li><a href="#explanation-44" id="toc-explanation-44" class="nav-link" data-scroll-target="#explanation-44"><span class="header-section-number">89.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#the-wright-fisher-model-of-genetic-drift" id="toc-the-wright-fisher-model-of-genetic-drift" class="nav-link" data-scroll-target="#the-wright-fisher-model-of-genetic-drift"><span class="header-section-number">90</span> The Wright-Fisher Model of Genetic Drift</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-89" id="toc-sample-dataset-89" class="nav-link" data-scroll-target="#sample-dataset-89"><span class="header-section-number">90.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-90" id="toc-sample-output-90" class="nav-link" data-scroll-target="#sample-output-90"><span class="header-section-number">90.2</span> Sample Output</a></li>
  <li><a href="#solution-86" id="toc-solution-86" class="nav-link" data-scroll-target="#solution-86"><span class="header-section-number">90.3</span> Solution</a></li>
  <li><a href="#explanation-45" id="toc-explanation-45" class="nav-link" data-scroll-target="#explanation-45"><span class="header-section-number">90.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#alignment-based-phylogeny" id="toc-alignment-based-phylogeny" class="nav-link" data-scroll-target="#alignment-based-phylogeny"><span class="header-section-number">91</span> Alignment-Based Phylogeny</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-90" id="toc-sample-dataset-90" class="nav-link" data-scroll-target="#sample-dataset-90"><span class="header-section-number">91.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-91" id="toc-sample-output-91" class="nav-link" data-scroll-target="#sample-output-91"><span class="header-section-number">91.2</span> Sample Output</a></li>
  <li><a href="#solution-87" id="toc-solution-87" class="nav-link" data-scroll-target="#solution-87"><span class="header-section-number">91.3</span> Solution</a></li>
  <li><a href="#working-principle" id="toc-working-principle" class="nav-link" data-scroll-target="#working-principle"><span class="header-section-number">91.4</span> Working Principle</a></li>
  </ul></li>
  <li><a href="#assessing-assembly-quality-with-n50-and-n75" id="toc-assessing-assembly-quality-with-n50-and-n75" class="nav-link" data-scroll-target="#assessing-assembly-quality-with-n50-and-n75"><span class="header-section-number">92</span> Assessing Assembly Quality with N50 and N75</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-91" id="toc-sample-dataset-91" class="nav-link" data-scroll-target="#sample-dataset-91"><span class="header-section-number">92.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-92" id="toc-sample-output-92" class="nav-link" data-scroll-target="#sample-output-92"><span class="header-section-number">92.2</span> Sample Output</a></li>
  <li><a href="#solution-88" id="toc-solution-88" class="nav-link" data-scroll-target="#solution-88"><span class="header-section-number">92.3</span> Solution</a></li>
  <li><a href="#breaking-down-the-steps" id="toc-breaking-down-the-steps" class="nav-link" data-scroll-target="#breaking-down-the-steps"><span class="header-section-number">92.4</span> <strong>Breaking Down the Steps:</strong></a></li>
  </ul></li>
  <li><a href="#fixing-an-inconsistent-character-set" id="toc-fixing-an-inconsistent-character-set" class="nav-link" data-scroll-target="#fixing-an-inconsistent-character-set"><span class="header-section-number">93</span> Fixing an Inconsistent Character Set</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-92" id="toc-sample-dataset-92" class="nav-link" data-scroll-target="#sample-dataset-92"><span class="header-section-number">93.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-93" id="toc-sample-output-93" class="nav-link" data-scroll-target="#sample-output-93"><span class="header-section-number">93.2</span> Sample Output</a></li>
  <li><a href="#solution-89" id="toc-solution-89" class="nav-link" data-scroll-target="#solution-89"><span class="header-section-number">93.3</span> Solution</a></li>
  <li><a href="#breaking-down-the-steps-1" id="toc-breaking-down-the-steps-1" class="nav-link" data-scroll-target="#breaking-down-the-steps-1"><span class="header-section-number">93.4</span> <strong>Breaking Down the Steps:</strong></a></li>
  </ul></li>
  <li><a href="#wright-fishers-expected-behavior" id="toc-wright-fishers-expected-behavior" class="nav-link" data-scroll-target="#wright-fishers-expected-behavior"><span class="header-section-number">94</span> Wright-Fisher’s Expected Behavior</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-93" id="toc-sample-dataset-93" class="nav-link" data-scroll-target="#sample-dataset-93"><span class="header-section-number">94.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-94" id="toc-sample-output-94" class="nav-link" data-scroll-target="#sample-output-94"><span class="header-section-number">94.2</span> Sample Output</a></li>
  <li><a href="#solution-90" id="toc-solution-90" class="nav-link" data-scroll-target="#solution-90"><span class="header-section-number">94.3</span> Solution</a></li>
  <li><a href="#explanation-46" id="toc-explanation-46" class="nav-link" data-scroll-target="#explanation-46"><span class="header-section-number">94.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#the-founder-effect-and-genetic-drift" id="toc-the-founder-effect-and-genetic-drift" class="nav-link" data-scroll-target="#the-founder-effect-and-genetic-drift"><span class="header-section-number">95</span> The Founder Effect and Genetic Drift</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-94" id="toc-sample-dataset-94" class="nav-link" data-scroll-target="#sample-dataset-94"><span class="header-section-number">95.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-95" id="toc-sample-output-95" class="nav-link" data-scroll-target="#sample-output-95"><span class="header-section-number">95.2</span> Sample Output</a></li>
  <li><a href="#solution-91" id="toc-solution-91" class="nav-link" data-scroll-target="#solution-91"><span class="header-section-number">95.3</span> Solution</a></li>
  <li><a href="#functions-and-their-roles" id="toc-functions-and-their-roles" class="nav-link" data-scroll-target="#functions-and-their-roles"><span class="header-section-number">95.4</span> Functions and Their Roles</a></li>
  <li><a href="#key-points-1" id="toc-key-points-1" class="nav-link" data-scroll-target="#key-points-1"><span class="header-section-number">95.5</span> Key Points</a></li>
  </ul></li>
  <li><a href="#global-alignment-with-scoring-matrix-and-affine-gap-penalty" id="toc-global-alignment-with-scoring-matrix-and-affine-gap-penalty" class="nav-link" data-scroll-target="#global-alignment-with-scoring-matrix-and-affine-gap-penalty"><span class="header-section-number">96</span> Global Alignment with Scoring Matrix and Affine Gap Penalty</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-95" id="toc-sample-dataset-95" class="nav-link" data-scroll-target="#sample-dataset-95"><span class="header-section-number">96.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-96" id="toc-sample-output-96" class="nav-link" data-scroll-target="#sample-output-96"><span class="header-section-number">96.2</span> Sample Output</a></li>
  <li><a href="#solution-92" id="toc-solution-92" class="nav-link" data-scroll-target="#solution-92"><span class="header-section-number">96.3</span> Solution</a></li>
  <li><a href="#detailed-explanation-4" id="toc-detailed-explanation-4" class="nav-link" data-scroll-target="#detailed-explanation-4"><span class="header-section-number">96.4</span> Detailed Explanation</a></li>
  </ul></li>
  <li><a href="#genome-assembly-with-perfect-coverage-and-repeats" id="toc-genome-assembly-with-perfect-coverage-and-repeats" class="nav-link" data-scroll-target="#genome-assembly-with-perfect-coverage-and-repeats"><span class="header-section-number">97</span> Genome Assembly with Perfect Coverage and Repeats</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-96" id="toc-sample-dataset-96" class="nav-link" data-scroll-target="#sample-dataset-96"><span class="header-section-number">97.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-97" id="toc-sample-output-97" class="nav-link" data-scroll-target="#sample-output-97"><span class="header-section-number">97.2</span> Sample Output</a></li>
  <li><a href="#solution-93" id="toc-solution-93" class="nav-link" data-scroll-target="#solution-93"><span class="header-section-number">97.3</span> Solution</a></li>
  <li><a href="#explanation-47" id="toc-explanation-47" class="nav-link" data-scroll-target="#explanation-47"><span class="header-section-number">97.4</span> Explanation</a></li>
  </ul></li>
  <li><a href="#finding-a-motif-with-modifications" id="toc-finding-a-motif-with-modifications" class="nav-link" data-scroll-target="#finding-a-motif-with-modifications"><span class="header-section-number">98</span> Finding a Motif with Modifications</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-97" id="toc-sample-dataset-97" class="nav-link" data-scroll-target="#sample-dataset-97"><span class="header-section-number">98.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-98" id="toc-sample-output-98" class="nav-link" data-scroll-target="#sample-output-98"><span class="header-section-number">98.2</span> Sample Output</a></li>
  <li><a href="#solution-94" id="toc-solution-94" class="nav-link" data-scroll-target="#solution-94"><span class="header-section-number">98.3</span> Solution</a></li>
  <li><a href="#how-the-code-works" id="toc-how-the-code-works" class="nav-link" data-scroll-target="#how-the-code-works"><span class="header-section-number">98.4</span> How the Code Works</a></li>
  </ul></li>
  <li><a href="#isolating-symbols-in-alignments" id="toc-isolating-symbols-in-alignments" class="nav-link" data-scroll-target="#isolating-symbols-in-alignments"><span class="header-section-number">99</span> Isolating Symbols in Alignments</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-98" id="toc-sample-dataset-98" class="nav-link" data-scroll-target="#sample-dataset-98"><span class="header-section-number">99.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-99" id="toc-sample-output-99" class="nav-link" data-scroll-target="#sample-output-99"><span class="header-section-number">99.2</span> Sample Output</a></li>
  <li><a href="#solution-95" id="toc-solution-95" class="nav-link" data-scroll-target="#solution-95"><span class="header-section-number">99.3</span> Solution</a></li>
  <li><a href="#code-breakdown" id="toc-code-breakdown" class="nav-link" data-scroll-target="#code-breakdown"><span class="header-section-number">99.4</span> Code Breakdown</a></li>
  </ul></li>
  <li><a href="#finding-all-similar-motifs" id="toc-finding-all-similar-motifs" class="nav-link" data-scroll-target="#finding-all-similar-motifs"><span class="header-section-number">100</span> Finding All Similar Motifs</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-99" id="toc-sample-dataset-99" class="nav-link" data-scroll-target="#sample-dataset-99"><span class="header-section-number">100.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-100" id="toc-sample-output-100" class="nav-link" data-scroll-target="#sample-output-100"><span class="header-section-number">100.2</span> Sample Output</a></li>
  <li><a href="#solution-96" id="toc-solution-96" class="nav-link" data-scroll-target="#solution-96"><span class="header-section-number">100.3</span> Solution</a></li>
  <li><a href="#overview-of-the-code" id="toc-overview-of-the-code" class="nav-link" data-scroll-target="#overview-of-the-code"><span class="header-section-number">100.4</span> Overview of the Code</a></li>
  </ul></li>
  <li><a href="#overlap-alignment" id="toc-overlap-alignment" class="nav-link" data-scroll-target="#overlap-alignment"><span class="header-section-number">101</span> Overlap Alignment</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-100" id="toc-sample-dataset-100" class="nav-link" data-scroll-target="#sample-dataset-100"><span class="header-section-number">101.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-101" id="toc-sample-output-101" class="nav-link" data-scroll-target="#sample-output-101"><span class="header-section-number">101.2</span> Sample Output</a></li>
  <li><a href="#solution-97" id="toc-solution-97" class="nav-link" data-scroll-target="#solution-97"><span class="header-section-number">101.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#quartet-distance" id="toc-quartet-distance" class="nav-link" data-scroll-target="#quartet-distance"><span class="header-section-number">102</span> Quartet Distance</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-101" id="toc-sample-dataset-101" class="nav-link" data-scroll-target="#sample-dataset-101"><span class="header-section-number">102.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-102" id="toc-sample-output-102" class="nav-link" data-scroll-target="#sample-output-102"><span class="header-section-number">102.2</span> Sample Output</a></li>
  <li><a href="#solution-98" id="toc-solution-98" class="nav-link" data-scroll-target="#solution-98"><span class="header-section-number">102.3</span> Solution</a></li>
  <li><a href="#explanation-of-how-it-works" id="toc-explanation-of-how-it-works" class="nav-link" data-scroll-target="#explanation-of-how-it-works"><span class="header-section-number">102.4</span> Explanation of How It Works</a></li>
  </ul></li>
  <li><a href="#semiglobal-alignment" id="toc-semiglobal-alignment" class="nav-link" data-scroll-target="#semiglobal-alignment"><span class="header-section-number">103</span> Semiglobal Alignment</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-102" id="toc-sample-dataset-102" class="nav-link" data-scroll-target="#sample-dataset-102"><span class="header-section-number">103.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-103" id="toc-sample-output-103" class="nav-link" data-scroll-target="#sample-output-103"><span class="header-section-number">103.2</span> Sample Output</a></li>
  <li><a href="#solution-99" id="toc-solution-99" class="nav-link" data-scroll-target="#solution-99"><span class="header-section-number">103.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#local-alignment-with-affine-gap-penalty" id="toc-local-alignment-with-affine-gap-penalty" class="nav-link" data-scroll-target="#local-alignment-with-affine-gap-penalty"><span class="header-section-number">104</span> Local Alignment with Affine Gap Penalty</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-103" id="toc-sample-dataset-103" class="nav-link" data-scroll-target="#sample-dataset-103"><span class="header-section-number">104.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-104" id="toc-sample-output-104" class="nav-link" data-scroll-target="#sample-output-104"><span class="header-section-number">104.2</span> Sample Output</a></li>
  <li><a href="#solution-100" id="toc-solution-100" class="nav-link" data-scroll-target="#solution-100"><span class="header-section-number">104.3</span> Solution</a></li>
  </ul></li>
  <li><a href="#identifying-reversing-substitutions" id="toc-identifying-reversing-substitutions" class="nav-link" data-scroll-target="#identifying-reversing-substitutions"><span class="header-section-number">105</span> Identifying Reversing Substitutions</a>
  <ul class="collapse">
  <li><a href="#sample-dataset-104" id="toc-sample-dataset-104" class="nav-link" data-scroll-target="#sample-dataset-104"><span class="header-section-number">105.1</span> Sample Dataset</a></li>
  <li><a href="#sample-output-105" id="toc-sample-output-105" class="nav-link" data-scroll-target="#sample-output-105"><span class="header-section-number">105.2</span> Sample Output</a></li>
  <li><a href="#solution-101" id="toc-solution-101" class="nav-link" data-scroll-target="#solution-101"><span class="header-section-number">105.3</span> Solution</a></li>
  <li><a href="#classes-and-their-functions" id="toc-classes-and-their-functions" class="nav-link" data-scroll-target="#classes-and-their-functions"><span class="header-section-number">105.4</span> Classes and Their Functions</a></li>
  <li><a href="#how-it-works-1" id="toc-how-it-works-1" class="nav-link" data-scroll-target="#how-it-works-1"><span class="header-section-number">105.5</span> How It Works</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Rosalind Stronghold 문제풀이</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">Rosalind</div>
    <div class="quarto-category">Bioinformatics</div>
    <div class="quarto-category">Tip</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Taeyoon Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 28, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">January 26, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Rosalind_stronghold.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="Rosalind_stronghold.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a></p>
</figure>
</div>
<p>생물정보학의 다양한 주제인 질량 분석, 서열 정렬, 동적 프로그래밍, 게놈 어셈블리, 계통 발생, 확률, 문자열 알고리즘 등의 기초가 되는 알고리즘에 대해 알아봅니다.</p>
<p><a href="https://rosalind.info/">Rosalind</a> 는 <a href="http://projecteuler.net/">프로젝트 오일러</a>, <a href="http://code.google.com/codejam">구글 코드 잼</a>에서 영감을 얻었습니다. 이 프로젝트의 이름은 DNA 이중나선을 발견하는 데 기여한 <a href="http://en.wikipedia.org/wiki/Rosalind_Franklin">로잘린드 프랭클린</a> 에서 따왔습니다. Rosalind 는 프로그래밍 실력을 키우고자 하는 생물학자와 분자생물학의 계산 문제를 접해본 적이 없는 프로그래머들에게 도움이 될 것입니다.</p>
<section id="counting-dna-nucleotides" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Counting DNA Nucleotides</h1>
<p><a href="https://rosalind.info/glossary/string/">문자열</a> 은 단순히 어떤 <a href="https://rosalind.info/glossary/alphabet/">알파벳</a> 에서 선택되어 단어로 구성된 기호의 정렬된 모음이며, 문자열의 <a href="https://rosalind.info/glossary/string-length/">길이</a> 는 문자열에 포함된 기호의 수입니다.</p>
<p>길이 21 의 <a href="https://rosalind.info/glossary/dna-string/">DNA 문자열</a> 의 예 (알파벳에 ‘A’, ‘C’, ‘G’, ‘T’ 기호가 포함됨) 는 “ATGCTTCAGAAAGGTCTTACG” 입니다.</p>
<p>Given: 최대 1000nt 길이의 DNA 문자열 <code>s</code> 입니다.</p>
<p>Return: 반환: <code>s</code> 에서 ‘A’, ‘C’, ‘G’, ‘T’ 기호가 각각 나타나는 횟수를 세는 4 개의 정수 (공백으로 구분) 를 반환합니다.</p>
<section id="sample-dataset" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="sample-dataset"><span class="header-section-number">1.1</span> Sample Dataset</h2>
<pre><code>AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC</code></pre>
</section>
<section id="sample-output" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="sample-output"><span class="header-section-number">1.2</span> Sample Output</h2>
<pre><code>20 12 17 21</code></pre>
</section>
<section id="solution" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="solution"><span class="header-section-number">1.3</span> Solution</h2>
<p>주어진 DNA 문자열 ‘s’ 에서 각 뉴클레오티드 (‘A’, ‘C’, ‘G’, ‘T’) 의 발생 횟수를 세는 문제를 해결하려면 다음 단계를 따르세요.</p>
<ol type="1">
<li>카운터를 초기화합니다: ‘A’, ‘C’, ‘G’, ‘T’ 에 대한 카운터를 설정합니다.</li>
<li>문자열을 반복합니다: 문자열의 각 문자를 순회하며 해당 카운터를 증가시킵니다.</li>
<li>결과를 출력합니다: ‘A’, ‘C’, ‘G’, ‘T’ 의 개수를 공백으로 구분하여 인쇄합니다.</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_nucleotides(dna_string):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    count_A <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    count_C <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    count_G <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    count_T <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nucleotide <span class="kw">in</span> dna_string:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nucleotide <span class="op">==</span> <span class="st">'A'</span>:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            count_A <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nucleotide <span class="op">==</span> <span class="st">'C'</span>:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            count_C <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nucleotide <span class="op">==</span> <span class="st">'G'</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            count_G <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nucleotide <span class="op">==</span> <span class="st">'T'</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            count_T <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_A, count_C, count_G, count_T</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC"</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_nucleotides(s)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, result)))</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Output should be "20 12 17 21"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="설명" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="설명"><span class="header-section-number">1.4</span> 설명</h2>
<ol type="1">
<li>초기화: ‘A’, ‘C’, ‘G’, ‘T’ 의 카운터가 0 으로 초기화됩니다.</li>
<li>각 문자를 반복합니다: 루프는 DNA 문자열의 각 문자를 검사하고 발견된 문자에 따라 해당 카운터를 증가시킵니다.</li>
<li>결과를 반환하고 인쇄합니다: 이 함수는 카운트를 반환한 다음 필요한 형식으로 출력합니다.</li>
</ol>
<p>이 접근 방식은 각 뉴클레오타이드가 문자열을 한 번 통과할 때 효율적으로 카운트되도록 보장하며, 시간 복잡도는 <span class="math inline">\(O(n)\)</span> 입니다.</p>
</section>
</section>
<section id="transcribing-dna-into-rna" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Transcribing DNA into RNA</h1>
<p>RNA 문자열은 ‘A’, ‘C’, ‘G’, ‘U’ 가 포함된 알파벳으로 구성된 문자열입니다.</p>
<p>코딩 가닥에 해당하는 DNA 문자열 <code>t</code> 가 주어지면, <code>t</code> 의 모든 ‘T’ 를 <code>u</code> 의 ‘U’ 로 대체하여 전사된 RNA 문자열 <code>u</code> 가 형성됩니다.</p>
<p>주어진: 길이가 최대 1000 nt 인 DNA 문자열 <code>t</code> 가 주어집니다. 반환합니다: 반환: <code>t</code> 의 전사된 RNA 문자열.</p>
<section id="sample-dataset-1" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sample-dataset-1"><span class="header-section-number">2.1</span> Sample Dataset</h2>
<pre><code>GATGGAACTTGACTACGTAAATT</code></pre>
</section>
<section id="sample-output-1" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sample-output-1"><span class="header-section-number">2.2</span> Sample Output</h2>
<pre><code>GAUGGAACUUGACUACGUAAAUU</code></pre>
</section>
<section id="solution-1" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="solution-1"><span class="header-section-number">2.3</span> Solution</h2>
<p>To transcribe a DNA string to an RNA string, we need to replace every occurrence of the nucleotide ‘T’ in the DNA string with ‘U’ to form the RNA string. This is because RNA uses uracil (U) instead of thymine (T).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transcribe_dna_to_rna(dna_string):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Replace all occurrences of 'T' with 'U'</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    rna_string <span class="op">=</span> dna_string.replace(<span class="st">'T'</span>, <span class="st">'U'</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rna_string</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>dna_string <span class="op">=</span> <span class="st">"GATGGAACTTGACTACGTAAATT"</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(transcribe_dna_to_rna(dna_string))  <span class="co"># Output should be "GAUGGAACUUGACUACGUAAAUU"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="explanation"><span class="header-section-number">2.4</span> Explanation</h2>
<ol type="1">
<li>Function Definition: <code>transcribe_dna_to_rna(dna_string)</code> takes a DNA string as input.</li>
<li>String Replacement: <code>dna_string.replace('T', 'U')</code> creates a new string where all <code>T</code>s are replaced with <code>U</code>s.</li>
<li>Return Statement: The resulting RNA string is returned.</li>
</ol>
</section>
</section>
<section id="complementing-a-strand-of-dna" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Complementing a Strand of DNA</h1>
<p>In&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>,&nbsp;<a href="https://rosalind.info/glossary/symbol/">symbols</a>&nbsp;‘A’ and ‘T’ are complements of each other, as are ‘C’ and ‘G’.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/reverse-complement/">reverse complement</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;s is the string&nbsp;sc𝑠c&nbsp;formed by reversing the symbols of&nbsp;s𝑠, then taking the complement of each symbol (e.g., the reverse complement of “GTCA” is “TGAC”).</p>
<p>Given:&nbsp;A DNA string&nbsp;s of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>.</p>
<p>Return:&nbsp;The reverse complement&nbsp;sc𝑠c&nbsp;of&nbsp;s𝑠.</p>
<section id="sample-dataset-2" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sample-dataset-2"><span class="header-section-number">3.1</span> Sample Dataset</h2>
<pre><code>AAAACCCGGT</code></pre>
</section>
<section id="sample-output-2" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sample-output-2"><span class="header-section-number">3.2</span> Sample Output</h2>
<pre><code>ACCGGGTTTT</code></pre>
</section>
<section id="soultion" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="soultion"><span class="header-section-number">3.3</span> soultion</h2>
<p>To find the reverse complement of a DNA string, follow these steps:</p>
<ol type="1">
<li>Reverse the string: First, reverse the input DNA string.</li>
<li>Complement the string: Replace each nucleotide with its complement: ‘A’ with ‘T’, ‘T’ with ‘A’, ‘C’ with ‘G’, and ‘G’ with ‘C’.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna_string):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Dictionary to map each nucleotide to its complement</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    complement <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'T'</span>, <span class="st">'T'</span>: <span class="st">'A'</span>, <span class="st">'C'</span>: <span class="st">'G'</span>, <span class="st">'G'</span>: <span class="st">'C'</span>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reverse the DNA string</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    reversed_dna <span class="op">=</span> dna_string[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Replace each nucleotide with its complement</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    reverse_complement_dna <span class="op">=</span> <span class="st">''</span>.join(complement[base] <span class="cf">for</span> base <span class="kw">in</span> reversed_dna)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> reverse_complement_dna</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>dna_string <span class="op">=</span> <span class="st">"AAAACCCGGT"</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(reverse_complement(dna_string))  </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Output should be "ACCGGGTTTT"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-1" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="explanation-1"><span class="header-section-number">3.4</span> Explanation</h2>
<ol type="1">
<li>Complement Mapping:
<ul>
<li>A dictionary <code>complement</code> is used to map each nucleotide to its complementary nucleotide.</li>
</ul></li>
<li>Reversing the String:
<ul>
<li>The slicing operation <code>dna_string[::-1]</code> reverses the string.</li>
</ul></li>
<li>Generating the Complement:
<ul>
<li>A list comprehension is used to replace each nucleotide in the reversed string with its complement.</li>
<li><code>''.join()</code> combines the list of complemented nucleotides into a single string.</li>
</ul></li>
</ol>
</section>
</section>
<section id="rabbits-and-recurrence-relations" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Rabbits and Recurrence Relations</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/sequence/">sequence</a>&nbsp;is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence&nbsp;and the infinite sequence of odd numbers&nbsp;<span class="math inline">\((1,3,5,7,9,…)\)</span>. We use the notation&nbsp;an𝑎𝑛&nbsp;to represent the&nbsp;n-th term of a sequence.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/recurrence-relation/">recurrence relation</a>&nbsp;is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci’s rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if&nbsp;<span class="math inline">\(Fn\)</span>&nbsp;represents the number of rabbit pairs alive after the&nbsp;n-th month, then we obtain the&nbsp;<a href="https://rosalind.info/glossary/fibonacci-sequence/">Fibonacci sequence</a>&nbsp;having terms&nbsp;<span class="math inline">\(Fn\)</span>&nbsp;that are defined by the recurrence relation&nbsp;<span class="math inline">\(Fn=Fn−1+Fn−2Fn=F_(n-1)+F_(n-2)\)</span>&nbsp;(with&nbsp;<span class="math inline">\(F1=F2=1\)</span>&nbsp;to initiate the sequence). Although the sequence bears Fibonacci’s name, it was known to Indian mathematicians over two millennia ago.</p>
<p>When finding the&nbsp;<span class="math inline">\(n\)</span>-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of&nbsp;n𝑛. This problem introduces us to the computational technique of&nbsp;<a href="https://rosalind.info/glossary/dynamic-programming/">dynamic programming</a>, which successively builds up solutions by using the answers to smaller cases.</p>
<p>Given:&nbsp;Positive integers&nbsp;<span class="math inline">\(n≤40\)</span>&nbsp;and&nbsp;<span class="math inline">\(k≤5\)</span>.</p>
<p>Return:&nbsp;The total number of rabbit pairs that will be present after&nbsp;n&nbsp;months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of&nbsp;<span class="math inline">\(k\)</span>&nbsp;rabbit pairs (instead of only 1 pair).</p>
<section id="sample-dataset-3" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sample-dataset-3"><span class="header-section-number">4.1</span> Sample Dataset</h2>
<pre><code>5 3</code></pre>
</section>
<section id="sample-output-3" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sample-output-3"><span class="header-section-number">4.2</span> Sample Output</h2>
<pre><code>19</code></pre>
</section>
<section id="solution-2" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="solution-2"><span class="header-section-number">4.3</span> Solution</h2>
<p>To solve the problem of computing the total number of rabbit pairs after a given number of months <span class="math inline">\(n\)</span> when each pair of reproduction-age rabbits produces <span class="math inline">\(k\)</span> rabbit pairs each month, we can modify the classic Fibonacci sequence. Instead of each rabbit pair producing just one new pair, they produce <span class="math inline">\(k\)</span> new pairs.</p>
<p>Let’s break down the steps to create the solution:</p>
<ol type="1">
<li><p>Define the recurrence relation: The problem can be modeled with a recurrence relation. Let <span class="math inline">\(F(n)\)</span> represent the number of rabbit pairs after <span class="math inline">\(n\)</span> months. The recurrence relation can be expressed as: <span class="math display">\[ F(n) = F(n-1) + k \times F(n-2) \]</span> Here, <span class="math inline">\(F(n-1)\)</span> represents the number of rabbit pairs from the previous month, and <span class="math inline">\(k\)</span> times <span class="math inline">\(F(n-2)\)</span> represents the new rabbit pairs produced by the pairs from two months ago.</p></li>
<li><p>Initial conditions:</p>
<ul>
<li><span class="math inline">\(F(1) = 1\)</span> (initially, there is one pair of rabbits)</li>
<li><span class="math inline">\(F(2) = 1\)</span> (in the second month, there is still only one pair, as they have not yet reproduced)</li>
</ul></li>
<li><p>Iterative computation: Using a loop, compute the number of rabbit pairs for each month up to <span class="math inline">\(n\)</span> based on the recurrence relation.</p></li>
</ol>
<p>Here is the Python function to implement this approach:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> total_rabbit_pairs(n, k):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the first two months</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    F1 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    F2 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute the number of rabbit pairs for each subsequent month</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        F_current <span class="op">=</span> F2 <span class="op">+</span> k <span class="op">*</span> F1</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        F1 <span class="op">=</span> F2</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        F2 <span class="op">=</span> F_current</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F2</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total_rabbit_pairs(n, k))  <span class="co"># Output should be 19</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="explanation-of-the-code"><span class="header-section-number">4.4</span> Explanation of the Code</h2>
<ol type="1">
<li>Base Cases:
<ul>
<li>If <span class="math inline">\(n\)</span> is 1 or 2, the function returns 1 because the first two terms are both 1.</li>
</ul></li>
<li>Initialization:
<ul>
<li>Variables <code>F1</code> and <code>F2</code> are initialized to 1, representing the number of rabbit pairs in the first and second months, respectively.</li>
</ul></li>
<li>Loop Through Months:
<ul>
<li>For each month from 3 to <span class="math inline">\(n\)</span> , the number of rabbit pairs is calculated using the recurrence relation. <code>F_current</code> is calculated as the sum of the number of rabbit pairs from the previous month (<code>F2</code>) and the number of new rabbit pairs produced by the pairs from two months ago (<code>k * F1</code>).</li>
</ul></li>
<li>Update Variables:
<ul>
<li>After computing <code>F_current</code>, update <code>F1</code> and <code>F2</code> to the values of the last two computed terms to prepare for the next iteration.</li>
</ul></li>
<li>Return the Result:
<ul>
<li>Finally, return <code>F2</code>, which holds the number of rabbit pairs after <span class="math inline">\(n\)</span> months.</li>
</ul></li>
</ol>
</section>
</section>
<section id="computing-gc-content" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Computing GC Content</h1>
<p>The GC-content of a&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;is given by the percentage of&nbsp;<a href="https://rosalind.info/glossary/symbol/">symbols</a>&nbsp;in the string that are ‘C’ or ‘G’. For example, the GC-content of “AGCTATAG” is 37.5%. Note that the&nbsp;<a href="https://rosalind.info/glossary/reverse-complement/">reverse complement</a>&nbsp;of any DNA string has the same GC-content.</p>
<p>DNA strings must be labeled when they are consolidated into a database. A commonly used method of string labeling is called&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>. In this format, the string is introduced by a line that begins with ‘&gt;’, followed by some labeling information. Subsequent lines contain the string itself; the first line to begin with ‘&gt;’ indicates the label of the next string.</p>
<p>In Rosalind’s implementation, a string in FASTA format will be labeled by the ID “Rosalind_xxxx”, where “xxxx” denotes a four-digit code between 0000 and 9999.</p>
<p>Given:&nbsp;At most 10&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;in FASTA format (of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;each).</p>
<p>Return:&nbsp;The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unles otherwise stated; please see the note on&nbsp;<a href="https://rosalind.info/glossary/absolute-error/">absolute error</a>&nbsp;below.</p>
<section id="sample-dataset-4" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sample-dataset-4"><span class="header-section-number">5.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_6404
CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC
TCCCACTAATAATTCTGAGG
&gt;Rosalind_5959
CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT
ATATCCATTTGTCAGCAGACACGC
&gt;Rosalind_0808
CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC
TGGGAACCTGCGGGCAGTAGGTGGAAT</code></pre>
</section>
<section id="sample-output-4" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="sample-output-4"><span class="header-section-number">5.2</span> Sample Output</h2>
<pre><code>Rosalind_0808
60.919540</code></pre>
</section>
<section id="solution-3" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="solution-3"><span class="header-section-number">5.3</span> Solution</h2>
<p>To solve this problem, we need to compute the GC-content of multiple DNA strings provided in FASTA format and identify the string with the highest GC-content.</p>
</section>
<section id="steps-to-solve-the-problem" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="steps-to-solve-the-problem"><span class="header-section-number">5.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li>Parse the FASTA formatted input: Extract the DNA strings and their corresponding IDs.</li>
<li>Compute GC-content: For each DNA string, calculate the percentage of nucleotides that are ‘C’ or ‘G’.</li>
<li>Determine the highest GC-content: Identify the DNA string with the highest GC-content and return its ID along with the computed GC-content.</li>
</ol>
<p>Here’s the Python code to achieve this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_strings):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_strings.splitlines():</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> line[<span class="dv">1</span>:].strip()</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            sequences[label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            sequences[label] <span class="op">+=</span> line.strip()</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gc_content(dna_string):</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    gc_count <span class="op">=</span> dna_string.count(<span class="st">'G'</span>) <span class="op">+</span> dna_string.count(<span class="st">'C'</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (gc_count <span class="op">/</span> <span class="bu">len</span>(dna_string)) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highest_gc_content(fasta_strings):</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> parse_fasta(fasta_strings)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    max_gc_id <span class="op">=</span> <span class="va">None</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    max_gc_content <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> label, dna_string <span class="kw">in</span> sequences.items():</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        gc <span class="op">=</span> gc_content(dna_string)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> gc <span class="op">&gt;</span> max_gc_content:</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            max_gc_content <span class="op">=</span> gc</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            max_gc_id <span class="op">=</span> label</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_gc_id, max_gc_content</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>fasta_strings <span class="op">=</span> <span class="st">"""&gt;Rosalind_6404</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="st">CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="st">TCCCACTAATAATTCTGAGG</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_5959</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="st">CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="st">ATATCCATTTGTCAGCAGACACGC</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_0808</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="st">CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="st">TGGGAACCTGCGGGCAGTAGGTGGAAT"""</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute and print the result</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>result_id, result_gc_content <span class="op">=</span> highest_gc_content(fasta_strings)</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result_id)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result_gc_content<span class="sc">:f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-2" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="explanation-2"><span class="header-section-number">5.5</span> Explanation</h2>
<ol type="1">
<li>Parsing FASTA Format:
<ul>
<li>The <code>parse_fasta</code> function reads the FASTA formatted string and extracts the sequences.</li>
<li>It uses a dictionary to store the DNA sequences with their labels as keys.</li>
</ul></li>
<li>Computing GC-content:
<ul>
<li>The <code>gc_content</code> function calculates the GC-content by counting ‘G’ and ‘C’ nucleotides and dividing by the total length of the DNA string.</li>
</ul></li>
<li>Finding the Highest GC-content:
<ul>
<li>The <code>highest_gc_content</code> function iterates through the parsed sequences, calculates the GC-content for each, and keeps track of the highest value and its corresponding label.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-point-mutations" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Counting Point Mutations</h1>
<p>Given two&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;s and&nbsp;t of equal length, the&nbsp;<a href="https://rosalind.info/glossary/hamming-distance/">Hamming distance</a>&nbsp;between&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, denoted&nbsp;<span class="math inline">\(dH(s,t)\)</span> <span class="math inline">\(dH(s,t)\)</span>, is the number of corresponding symbols that differ in&nbsp;s and&nbsp;<span class="math inline">\(t\)</span>.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;of equal length (not exceeding 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;The Hamming distance&nbsp;<span class="math inline">\(dH(s,t)\)</span>.</p>
<section id="sample-dataset-5" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sample-dataset-5"><span class="header-section-number">6.1</span> Sample Dataset</h2>
<pre><code>GAGCCTACTAACGGGAT
CATCGTAATGACGGCCT</code></pre>
</section>
<section id="sample-output-5" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sample-output-5"><span class="header-section-number">6.2</span> Sample Output</h2>
<pre><code>7</code></pre>
</section>
<section id="solution-4" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="solution-4"><span class="header-section-number">6.3</span> Solution</h2>
<p>The Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols differ. Given two DNA strings, we can compute the Hamming distance by comparing each position in the strings and counting the differences.</p>
</section>
<section id="steps-to-solve-the-problem-1" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-1"><span class="header-section-number">6.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Ensure Strings are of Equal Length</strong>: The problem guarantees that the strings are of equal length, so we don’t need to check for this.</li>
<li><strong>Compare Corresponding Symbols</strong>: Traverse both strings and compare corresponding characters.</li>
<li><strong>Count Differences</strong>: Increment a counter whenever the characters at the same position are different.</li>
</ol>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(s, t):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the counter for differences</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Traverse both strings and compare characters</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> char1, char2 <span class="kw">in</span> <span class="bu">zip</span>(s, t):</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> char1 <span class="op">!=</span> char2:</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"GAGCCTACTAACGGGAT"</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="st">"CATCGTAATGACGGCCT"</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hamming_distance(s, t))  <span class="co"># Output should be 7</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-3" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="explanation-3"><span class="header-section-number">6.5</span> Explanation</h2>
<ol type="1">
<li><strong>Initialize Counter</strong>:
<ul>
<li><code>count</code> is initialized to zero. This will keep track of the number of differing positions.</li>
</ul></li>
<li><strong>Traverse Strings</strong>:
<ul>
<li><code>zip(s, t)</code> pairs up characters from both strings at each position.</li>
<li>For each pair of characters <code>(char1, char2)</code>, compare them.</li>
</ul></li>
<li><strong>Count Differences</strong>:
<ul>
<li>If <code>char1</code> is not equal to <code>char2</code>, increment the <code>count</code>.</li>
</ul></li>
</ol>
</section>
</section>
<section id="mendels-first-law" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Mendel’s First Law</h1>
<p>The probability of any outcome (leaf) in a probability tree diagram is given by the product of probabilities from the start of the tree to the outcome. For example, the probability that <span class="math inline">\(X\)</span> is blue and <span class="math inline">\(Y\)</span> is blue is equal to (2/5)(1/4), or 1/10.</p>
<p><a href="https://rosalind.info/glossary/probability/">Probability</a>&nbsp;is the mathematical study of randomly occurring phenomena. We will model such a phenomenon with a&nbsp;<a href="https://rosalind.info/glossary/random-variable/">random variable</a>, which is simply a variable that can take a number of different distinct&nbsp;<a href="https://rosalind.info/glossary/outcome/">outcomes</a>&nbsp;depending on the result of an underlying random process.</p>
<p>For example, say that we have a bag containing 3 red balls and 2 blue balls. If we let&nbsp;<span class="math inline">\(X\)</span>&nbsp;represent the random variable corresponding to the color of a drawn ball, then the&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;of each of the two outcomes is given by&nbsp;<span class="math inline">\(Pr(X=red)=35 Pr(x=red)=35\)</span>&nbsp;and&nbsp;<span class="math inline">\(Pr(X=blue)=25\)</span> <span class="math inline">\(Pr(x=blue)=25\)</span>.</p>
<p>Random variables can be combined to yield new random variables. Returning to the ball example, let&nbsp;<span class="math inline">\(Y\)</span>&nbsp;model the color of a second ball drawn from the bag (without replacing the first ball). The probability of&nbsp;<span class="math inline">\(Y\)</span>&nbsp;being red depends on whether the first ball was red or blue. To represent all outcomes of&nbsp;<span class="math inline">\(X\)</span>&nbsp;and&nbsp;<span class="math inline">\(Y\)</span>, we therefore use a&nbsp;<a href="https://rosalind.info/glossary/probability-tree-diagram/">probability tree diagram</a>. This branching diagram represents all possible individual probabilities for&nbsp;<span class="math inline">\(X\)</span>&nbsp;and&nbsp;<span class="math inline">\(Y\)</span>, with outcomes at the endpoints (“leaves”) of the tree. The probability of any outcome is given by the product of probabilities along the path from the beginning of the tree; see&nbsp;<a href="https://rosalind.info/media/problems/iprb/balls_tree.png">Figure 2</a>&nbsp;for an illustrative example.</p>
<p>An&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">event</a>&nbsp;is simply a collection of outcomes. Because outcomes are distinct, the probability of an event can be written as the sum of the probabilities of its constituent outcomes. For our colored ball example, let&nbsp;<code>A</code>&nbsp;be the event “<span class="math inline">\(Y\)</span>&nbsp;is blue.”&nbsp;<span class="math inline">\(Pr(A)\)</span>&nbsp;is equal to the sum of the probabilities of two different outcomes:&nbsp;<span class="math inline">\(Pr(X=blue and&nbsp;Y=blue)+Pr(X=red and&nbsp;Y=blue)\)</span>.</p>
<p>Given:&nbsp;Three positive integers&nbsp;<span class="math inline">\(k\)</span>,&nbsp;<span class="math inline">\(m\)</span>, and&nbsp;<span class="math inline">\(n\)</span>, representing a population containing&nbsp;<span class="math inline">\(k+m+n\)</span>&nbsp;organisms:&nbsp;k&nbsp;individuals are homozygous dominant for a factor,&nbsp;m𝑚&nbsp;are heterozygous, and&nbsp;n&nbsp;are homozygous recessive.</p>
<p>Return:&nbsp;The probability that two randomly selected mating organisms will produce an individual possessing a dominant allele (and thus displaying the dominant phenotype). Assume that any two organisms can mate.</p>
<section id="sample-dataset-6" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="sample-dataset-6"><span class="header-section-number">7.1</span> Sample Dataset</h2>
<pre><code>2 2 2</code></pre>
</section>
<section id="sample-output-6" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="sample-output-6"><span class="header-section-number">7.2</span> Sample Output</h2>
<pre><code>0.78333</code></pre>
</section>
<section id="solution-5" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="solution-5"><span class="header-section-number">7.3</span> Solution</h2>
<p>To solve this problem, we need to calculate the probability that two randomly selected organisms from a population will produce an offspring with at least one dominant allele. The population is divided into three groups: - <span class="math inline">\(k\)</span>: Homozygous dominant organisms (AA) - <span class="math inline">\(m\)</span>: Heterozygous organisms (Aa) - <span class="math inline">\(n\)</span>: Homozygous recessive organisms (aa)</p>
</section>
<section id="steps-to-solve-the-problem-2" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-2"><span class="header-section-number">7.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Calculate Total Population Size</strong>:
<ul>
<li>Total number of organisms: <span class="math inline">\((T = k + m + n)\)</span></li>
</ul></li>
<li><strong>Calculate the Probability of Each Possible Pairing</strong>:
<ul>
<li>There are several pairings to consider:
<ol type="1">
<li><span class="math inline">\(AA \times AA\)</span></li>
<li><span class="math inline">\(AA \times Aa\)</span></li>
<li><span class="math inline">\(AA \times aa\)</span></li>
<li><span class="math inline">\(Aa \times Aa\)</span></li>
<li><span class="math inline">\(Aa \times aa\)</span></li>
<li><span class="math inline">\(aa \times aa\)</span></li>
</ol></li>
</ul></li>
<li><strong>Calculate the Probability of Producing a Dominant Phenotype from Each Pairing</strong>:
<ul>
<li><span class="math inline">\(AA \times AA\)</span>: 100% dominant phenotype.</li>
<li><span class="math inline">\(AA \times Aa\)</span>: 100% dominant phenotype.</li>
<li><span class="math inline">\(AA \times aa\)</span>: 100% dominant phenotype.</li>
<li><span class="math inline">\(Aa \times Aa\)</span>: 75% dominant phenotype (since the combinations are AA, Aa, Aa, aa).</li>
<li><span class="math inline">\(Aa \times aa\)</span>: 50% dominant phenotype (since the combinations are Aa, Aa, aa, aa).</li>
<li><span class="math inline">\(aa \times aa\)</span>: 0% dominant phenotype.</li>
</ul></li>
<li><strong>Calculate the Probability of Selecting Each Pairing</strong>:
<ul>
<li>The probability of selecting two organisms is determined by the number of ways to choose them from the total population.</li>
</ul></li>
<li><strong>Combine Probabilities to Get the Overall Probability of Dominant Phenotype</strong>:
<ul>
<li>Sum the probabilities of all pairings that produce a dominant phenotype, weighted by their probability of selection.</li>
</ul></li>
</ol>
<p>Here is the Python code that implements the above steps:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> probability_dominant_phenotype(k, m, n):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total population</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> k <span class="op">+</span> m <span class="op">+</span> n</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total number of possible pairings</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    total_pairings <span class="op">=</span> total <span class="op">*</span> (total <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities of each pairing type</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    prob_AA_AA <span class="op">=</span> k <span class="op">*</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> total_pairings</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    prob_AA_Aa <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> k <span class="op">*</span> m <span class="op">/</span> total_pairings</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    prob_AA_aa <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> k <span class="op">*</span> n <span class="op">/</span> total_pairings</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    prob_Aa_Aa <span class="op">=</span> m <span class="op">*</span> (m <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> total_pairings</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    prob_Aa_aa <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> m <span class="op">*</span> n <span class="op">/</span> total_pairings</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    prob_aa_aa <span class="op">=</span> n <span class="op">*</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> total_pairings</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities of dominant phenotype from each pairing</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    prob_dom_AA_AA <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># 100%</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    prob_dom_AA_Aa <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># 100%</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    prob_dom_AA_aa <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># 100%</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    prob_dom_Aa_Aa <span class="op">=</span> <span class="fl">0.75</span> <span class="co"># 75%</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    prob_dom_Aa_aa <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># 50%</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    prob_dom_aa_aa <span class="op">=</span> <span class="fl">0.0</span>  <span class="co"># 0%</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total probability of dominant phenotype</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    prob_dom <span class="op">=</span> (prob_AA_AA <span class="op">*</span> prob_dom_AA_AA <span class="op">+</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>                prob_AA_Aa <span class="op">*</span> prob_dom_AA_Aa <span class="op">+</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>                prob_AA_aa <span class="op">*</span> prob_dom_AA_aa <span class="op">+</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>                prob_Aa_Aa <span class="op">*</span> prob_dom_Aa_Aa <span class="op">+</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>                prob_Aa_aa <span class="op">*</span> prob_dom_Aa_aa <span class="op">+</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                prob_aa_aa <span class="op">*</span> prob_dom_aa_aa)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prob_dom</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>k, m, n <span class="op">=</span> <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and print the result</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> probability_dominant_phenotype(k, m, n)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result<span class="sc">:f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-4" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="explanation-4"><span class="header-section-number">7.5</span> Explanation</h2>
<ol type="1">
<li><strong>Total Population</strong>:
<ul>
<li>We calculate the total number of organisms, <span class="math inline">\(total = k + m + n\)</span>.</li>
</ul></li>
<li><strong>Pairing Probabilities</strong>:
<ul>
<li>Each pairing probability is calculated based on the number of ways to select pairs from the total population.</li>
</ul></li>
<li><strong>Dominant Phenotype Probabilities</strong>:
<ul>
<li>Each pairing type has a different probability of producing a dominant phenotype based on Mendelian inheritance.</li>
</ul></li>
<li><strong>Overall Probability</strong>:
<ul>
<li>The overall probability is a weighted sum of the probabilities of each pairing type producing a dominant phenotype.</li>
</ul></li>
</ol>
<p>This code computes the required probability efficiently and accurately, matching the example output provided in the problem description.</p>
</section>
</section>
<section id="translating-rna-into-protein" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Translating RNA into Protein</h1>
<p>The 20 commonly occurring amino acids are abbreviated by using 20 letters from the English&nbsp;<a href="https://rosalind.info/glossary/alphabet/">alphabet</a>&nbsp;(all letters except for B, J, O, U, X, and Z).&nbsp;<a href="https://rosalind.info/glossary/protein-string/">Protein strings</a>&nbsp;are constructed from these 20 symbols. Henceforth, the term&nbsp;<a href="https://rosalind.info/glossary/genetic-string/">genetic string</a>&nbsp;will incorporate protein strings along with&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;and&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA strings</a>.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/rna-codon-table/">RNA codon table</a>&nbsp;dictates the details regarding the encoding of specific codons into the amino acid alphabet.</p>
<p>Given:&nbsp;An&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;corresponding to a strand of mRNA (of length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;The protein string encoded by&nbsp;<span class="math inline">\(s\)</span>.</p>
<section id="sample-dataset-7" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="sample-dataset-7"><span class="header-section-number">8.1</span> Sample Dataset</h2>
<pre><code>AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA</code></pre>
</section>
<section id="sample-output-7" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="sample-output-7"><span class="header-section-number">8.2</span> Sample Output</h2>
<pre><code>MAMAPRTEINSTRING</code></pre>
</section>
<section id="solution-6" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="solution-6"><span class="header-section-number">8.3</span> Solution</h2>
<p>To convert an RNA string into a protein string, you need to translate the RNA codons into their corresponding amino acids based on the RNA codon table. Each RNA codon (a sequence of three nucleotides) corresponds to a specific amino acid or a stop signal, which terminates translation.</p>
<p>Here’s the step-by-step approach to solving the problem:</p>
<ol type="1">
<li><p>Create an RNA Codon Table: The RNA codon table maps each of the 64 possible codons to their corresponding amino acid or stop signal. For example, the codon “AUG” codes for Methionine (M), and “UGA” is a stop codon.</p></li>
<li><p>Read the RNA String: The RNA string will be read in chunks of three nucleotides (codons).</p></li>
<li><p>Translate Each Codon: Using the codon table, translate each codon into the corresponding amino acid. If a stop codon is encountered, terminate the translation.</p></li>
<li><p>Construct the Protein String: Concatenate the translated amino acids to form the final protein string.</p></li>
</ol>
<p>Here is the Python implementation of this approach:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> translate_rna_to_protein(rna_sequence):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    codon_table <span class="op">=</span> {</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"UUU"</span>: <span class="st">"F"</span>, <span class="st">"UUC"</span>: <span class="st">"F"</span>, <span class="st">"UUA"</span>: <span class="st">"L"</span>, <span class="st">"UUG"</span>: <span class="st">"L"</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"UCU"</span>: <span class="st">"S"</span>, <span class="st">"UCC"</span>: <span class="st">"S"</span>, <span class="st">"UCA"</span>: <span class="st">"S"</span>, <span class="st">"UCG"</span>: <span class="st">"S"</span>,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"UAU"</span>: <span class="st">"Y"</span>, <span class="st">"UAC"</span>: <span class="st">"Y"</span>, <span class="st">"UAA"</span>: <span class="st">"Stop"</span>, <span class="st">"UAG"</span>: <span class="st">"Stop"</span>,</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"UGU"</span>: <span class="st">"C"</span>, <span class="st">"UGC"</span>: <span class="st">"C"</span>, <span class="st">"UGA"</span>: <span class="st">"Stop"</span>, <span class="st">"UGG"</span>: <span class="st">"W"</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CUU"</span>: <span class="st">"L"</span>, <span class="st">"CUC"</span>: <span class="st">"L"</span>, <span class="st">"CUA"</span>: <span class="st">"L"</span>, <span class="st">"CUG"</span>: <span class="st">"L"</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CCU"</span>: <span class="st">"P"</span>, <span class="st">"CCC"</span>: <span class="st">"P"</span>, <span class="st">"CCA"</span>: <span class="st">"P"</span>, <span class="st">"CCG"</span>: <span class="st">"P"</span>,</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CAU"</span>: <span class="st">"H"</span>, <span class="st">"CAC"</span>: <span class="st">"H"</span>, <span class="st">"CAA"</span>: <span class="st">"Q"</span>, <span class="st">"CAG"</span>: <span class="st">"Q"</span>,</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CGU"</span>: <span class="st">"R"</span>, <span class="st">"CGC"</span>: <span class="st">"R"</span>, <span class="st">"CGA"</span>: <span class="st">"R"</span>, <span class="st">"CGG"</span>: <span class="st">"R"</span>,</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">"AUU"</span>: <span class="st">"I"</span>, <span class="st">"AUC"</span>: <span class="st">"I"</span>, <span class="st">"AUA"</span>: <span class="st">"I"</span>, <span class="st">"AUG"</span>: <span class="st">"M"</span>,</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">"ACU"</span>: <span class="st">"T"</span>, <span class="st">"ACC"</span>: <span class="st">"T"</span>, <span class="st">"ACA"</span>: <span class="st">"T"</span>, <span class="st">"ACG"</span>: <span class="st">"T"</span>,</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">"AAU"</span>: <span class="st">"N"</span>, <span class="st">"AAC"</span>: <span class="st">"N"</span>, <span class="st">"AAA"</span>: <span class="st">"K"</span>, <span class="st">"AAG"</span>: <span class="st">"K"</span>,</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">"AGU"</span>: <span class="st">"S"</span>, <span class="st">"AGC"</span>: <span class="st">"S"</span>, <span class="st">"AGA"</span>: <span class="st">"R"</span>, <span class="st">"AGG"</span>: <span class="st">"R"</span>,</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">"GUU"</span>: <span class="st">"V"</span>, <span class="st">"GUC"</span>: <span class="st">"V"</span>, <span class="st">"GUA"</span>: <span class="st">"V"</span>, <span class="st">"GUG"</span>: <span class="st">"V"</span>,</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">"GCU"</span>: <span class="st">"A"</span>, <span class="st">"GCC"</span>: <span class="st">"A"</span>, <span class="st">"GCA"</span>: <span class="st">"A"</span>, <span class="st">"GCG"</span>: <span class="st">"A"</span>,</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">"GAU"</span>: <span class="st">"D"</span>, <span class="st">"GAC"</span>: <span class="st">"D"</span>, <span class="st">"GAA"</span>: <span class="st">"E"</span>, <span class="st">"GAG"</span>: <span class="st">"E"</span>,</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">"GGU"</span>: <span class="st">"G"</span>, <span class="st">"GGC"</span>: <span class="st">"G"</span>, <span class="st">"GGA"</span>: <span class="st">"G"</span>, <span class="st">"GGG"</span>: <span class="st">"G"</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    protein_string <span class="op">=</span> []</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Proces the RNA sequence in chunks of three nucleotides (codons)</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(rna_sequence), <span class="dv">3</span>):</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>        codon <span class="op">=</span> rna_sequence[i:i<span class="op">+</span><span class="dv">3</span>]</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> codon <span class="kw">in</span> codon_table:</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>            amino_acid <span class="op">=</span> codon_table[codon]</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> amino_acid <span class="op">==</span> <span class="st">"Stop"</span>:</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>            protein_string.append(amino_acid)</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(protein_string)</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>rna_sequence <span class="op">=</span> <span class="st">"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA"</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(translate_rna_to_protein(rna_sequence))</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Output should be "MAMAPRTEINSTRING"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-5" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="explanation-5"><span class="header-section-number">8.4</span> Explanation</h2>
<ol type="1">
<li><p>Codon Table: The dictionary <code>codon_table</code> maps RNA codons to their corresponding amino acids or stop signals.</p></li>
<li><p>Processing the RNA Sequence:</p>
<ul>
<li>The loop iterates over the RNA sequence in steps of three nucleotides.</li>
<li>For each codon, the corresponding amino acid is retrieved from the <code>codon_table</code>.</li>
<li>If the amino acid is “Stop”, the loop terminates, indicating the end of the protein sequence.</li>
<li>Otherwise, the amino acid is appended to the <code>protein_string</code> list.</li>
</ul></li>
<li><p>Constructing the Protein String:</p>
<ul>
<li>The list of amino acids is joined into a single string and returned as the final protein string.</li>
</ul></li>
</ol>
<p>This method ensures that the RNA sequence is translated efficiently and correctly into the corresponding protein string.</p>
</section>
</section>
<section id="finding-a-motif-in-dna" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Finding a Motif in DNA</h1>
<p>Given two&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;s and&nbsp;<code>t</code>,&nbsp;<code>t</code>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/substring/">substring</a>&nbsp;of&nbsp;s if&nbsp;<code>t</code>&nbsp;is contained as a contiguous collection of symbols in&nbsp;<span class="math inline">\(s\)</span>&nbsp;(as a result,&nbsp;<span class="math inline">\(t\)</span>&nbsp;must be no longer than&nbsp;<span class="math inline">\(s\)</span>).</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;of a symbol in a string is the total number of symbols found to its left, including itself (e.g., the positions of all occurrences of ‘U’ in “AUGCUUCAGAAAGGUCUUACG” are 2, 5, 6, 15, 17, and 18). The symbol at position&nbsp;<span class="math inline">\(i\)</span>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;is denoted by&nbsp;<span class="math inline">\(s[i]\)</span>.</p>
<p>A substring of&nbsp;<span class="math inline">\(s\)</span>&nbsp;can be represented as&nbsp;<span class="math inline">\(s[j:k]\)</span>, where&nbsp;<span class="math inline">\(j\)</span>&nbsp;and&nbsp;<span class="math inline">\(k\)</span>&nbsp;represent the starting and ending positions of the substring in&nbsp;<span class="math inline">\(s\)</span>; for example, if&nbsp;<span class="math inline">\(s\)</span>&nbsp;= “AUGCUUCAGAAAGGUCUUACG”, then&nbsp;<span class="math inline">\(s[2:5]\)</span>&nbsp;= “UGCU”.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/location/">location</a>&nbsp;of a substring&nbsp;<span class="math inline">\(s[j:k]\)</span>&nbsp;is its beginning&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;<span class="math inline">\(j\)</span>; note that&nbsp;t will have multiple locations in&nbsp;<span class="math inline">\(s\)</span>&nbsp;if it occurs more than once as a substring of&nbsp;<span class="math inline">\(s\)</span>&nbsp;(see the Sample below).</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;(each of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;All locations of&nbsp;<span class="math inline">\(t\)</span>&nbsp;as a substring of&nbsp;<span class="math inline">\(s\)</span>.</p>
<section id="sample-dataset-8" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="sample-dataset-8"><span class="header-section-number">9.1</span> Sample Dataset</h2>
<pre><code>GATATATGCATATACTT
ATAT</code></pre>
</section>
<section id="sample-output-8" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="sample-output-8"><span class="header-section-number">9.2</span> Sample Output</h2>
<pre><code>2 4 10</code></pre>
</section>
<section id="solution-7" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="solution-7"><span class="header-section-number">9.3</span> Solution</h2>
<p>To solve the problem of finding all locations of a substring <code>t</code> in a string <code>s</code>, we need to identify each position in <code>s</code> where <code>t</code> starts. This can be achieved using simple string matching techniques.</p>
</section>
<section id="steps-to-solve-the-problem-3" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-3"><span class="header-section-number">9.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Read the Input Strings</strong>:
<ul>
<li>We have two DNA strings, <code>s</code> and <code>t</code>.</li>
</ul></li>
<li><strong>Iterate Through the Main String <code>s</code></strong>:
<ul>
<li>Check for occurrences of the substring <code>t</code> starting at each position in <code>s</code>.</li>
</ul></li>
<li><strong>Collect All Starting Positions</strong>:
<ul>
<li>Whenever <code>t</code> is found in <code>s</code>, record the starting position. Note that the positions should be 1-based as per the problem statement.</li>
</ul></li>
<li><strong>Output the Results</strong>:
<ul>
<li>Print all recorded positions separated by spaces.</li>
</ul></li>
</ol>
</section>
<section id="implementation" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="implementation"><span class="header-section-number">9.5</span> Implementation</h2>
<p>Here is the Python code that implements the above logic:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_motif_locations(s, t):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> []</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    len_s <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    len_t <span class="op">=</span> <span class="bu">len</span>(t)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate through the main string `s`</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(len_s <span class="op">-</span> len_t <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if the substring `t` matches the segment in `s` starting at position `i`</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i:i<span class="op">+</span>len_t] <span class="op">==</span> t:</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If it matches, record the 1-based position</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>            positions.append(i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> positions</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"GATATATGCATATACTT"</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="st">"ATAT"</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Find and print the locations</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>locations <span class="op">=</span> find_motif_locations(s, t)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, locations)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-6" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="explanation-6"><span class="header-section-number">9.6</span> Explanation</h2>
<ol type="1">
<li><strong>Iterate Through the Main String <code>s</code></strong>:
<ul>
<li>We use a for loop to go through each possible starting position for <code>t</code> in <code>s</code>. The loop runs from <code>0</code> to <code>len(s) - len(t)</code> to ensure we don’t go out of bounds.</li>
</ul></li>
<li><strong>Check for Substring Match</strong>:
<ul>
<li>For each position <code>i</code>, we check if the substring <code>s[i:i+len(t)]</code> matches <code>t</code>.</li>
</ul></li>
<li><strong>Record the Position</strong>:
<ul>
<li>If a match is found, we append the 1-based position (i.e., <code>i + 1</code>) to our list of positions.</li>
</ul></li>
<li><strong>Output the Results</strong>:
<ul>
<li>We convert the list of positions to a space-separated string and print it.</li>
</ul></li>
</ol>
<p>This approach ensures that all occurrences of <code>t</code> in <code>s</code> are found and correctly reported. The solution efficiently handles the constraints of the problem, making it suitable for DNA strings up to 1 kbp in length.</p>
</section>
</section>
<section id="consensus-and-profile" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Consensus and Profile</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/matrix/">matrix</a>&nbsp;is a rectangular table of values divided into rows and columns. An&nbsp;<span class="math inline">\(m \times n\)</span>&nbsp;matrix has&nbsp;<span class="math inline">\(m\)</span> rows and&nbsp;<span class="math inline">\(n\)</span>&nbsp;columns. Given a matrix&nbsp;<span class="math inline">\(A\)</span>, we write&nbsp;<span class="math inline">\(Ai\)</span>, <span class="math inline">\(j\)</span> to indicate the value found at the intersection of row&nbsp;<span class="math inline">\(i\)</span>&nbsp;and column&nbsp;<span class="math inline">\(j\)</span>.</p>
<p>Say that we have a collection of&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>, all having the same length&nbsp;<span class="math inline">\(n\)</span>. Their&nbsp;<a href="https://rosalind.info/glossary/profile-matrix/">profile matrix</a>&nbsp;is a&nbsp;<span class="math inline">\(4 \times n\)</span>&nbsp;<a href="https://rosalind.info/glossary/matrix/">matrix</a>&nbsp;<span class="math inline">\(P\)</span> in which&nbsp;<span class="math inline">\(P1\)</span>, <span class="math inline">\(j\)</span> represents the number of times that ‘A’ occurs in the&nbsp;<span class="math inline">\(j\)</span>th&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;of one of the strings,&nbsp;<span class="math inline">\(P2\)</span>, <span class="math inline">\(j\)</span>&nbsp;represents the number of times that C occurs in the&nbsp;<span class="math inline">\(j\)</span>th position, and so on.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/consensus-string/">consensus string</a>&nbsp;<span class="math inline">\(c\)</span>&nbsp;is a string of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;formed from our collection by taking the most common symbol at each position; the&nbsp;<span class="math inline">\(j\)</span>th symbol of&nbsp;<span class="math inline">\(c\)</span>&nbsp;therefore corresponds to the symbol having the maximum value in the&nbsp;<span class="math inline">\(j\)</span>-th column of the profile matrix. Of course, there may be more than one most common symbol, leading to multiple possible consensus strings.</p>
<p>Given:&nbsp;A collection of at most 10&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;of equal length (at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;A consensus string and profile matrix for the collection. (If several possible consensus strings exist, then you may return any one of them.)</p>
<section id="sample-dataset-9" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="sample-dataset-9"><span class="header-section-number">10.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_1
ATCCAGCT
&gt;Rosalind_2
GGGCAACT
&gt;Rosalind_3
ATGGATCT
&gt;Rosalind_4
AAGCAACC
&gt;Rosalind_5
TTGGAACT
&gt;Rosalind_6
ATGCCATT
&gt;Rosalind_7
ATGGCACT</code></pre>
</section>
<section id="sample-output-9" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="sample-output-9"><span class="header-section-number">10.2</span> Sample Output</h2>
<pre><code>ATGCAACT
A: 5 1 0 0 5 5 0 0
C: 0 0 1 4 2 0 6 1
G: 1 1 6 3 0 1 0 0
T: 1 5 0 0 0 1 1 6</code></pre>
</section>
<section id="solution-8" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="solution-8"><span class="header-section-number">10.3</span> Solution</h2>
<p>To solve the problem of finding the consensus string and profile matrix from a collection of DNA strings, we need to follow these steps:</p>
<ol type="1">
<li><strong>Parse the FASTA format input</strong> to extract the DNA strings.</li>
<li><strong>Initialize the profile matrix</strong> to keep track of the frequency of each nucleotide (A, C, G, T) at each position in the strings.</li>
<li><strong>Populate the profile matrix</strong> by iterating through each DNA string and counting the occurrences of each nucleotide at each position.</li>
<li><strong>Construct the consensus string</strong> by selecting the most frequent nucleotide at each position based on the profile matrix.</li>
<li><strong>Output the consensus string and the profile matrix</strong>.</li>
</ol>
<p>Here’s the Python code to solve the problem:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_string):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    current_label <span class="op">=</span> <span class="st">""</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>            current_label <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">+=</span> line</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(sequences.values())</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_profile_matrix(dna_strings):</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(dna_strings[<span class="dv">0</span>])</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    profile_matrix <span class="op">=</span> {</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">'A'</span>: [<span class="dv">0</span>] <span class="op">*</span> n,</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">'C'</span>: [<span class="dv">0</span>] <span class="op">*</span> n,</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">'G'</span>: [<span class="dv">0</span>] <span class="op">*</span> n,</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">'T'</span>: [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dna <span class="kw">in</span> dna_strings:</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, nucleotide <span class="kw">in</span> <span class="bu">enumerate</span>(dna):</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>            profile_matrix[nucleotide][i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> profile_matrix</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_consensus_string(profile_matrix, length):</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    consensus <span class="op">=</span> []</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length):</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>        max_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>        max_nucleotide <span class="op">=</span> <span class="st">''</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nucleotide <span class="kw">in</span> <span class="st">"ACGT"</span>:</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> profile_matrix[nucleotide][i] <span class="op">&gt;</span> max_count:</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>                max_count <span class="op">=</span> profile_matrix[nucleotide][i]</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>                max_nucleotide <span class="op">=</span> nucleotide</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>        consensus.append(max_nucleotide)</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(consensus)</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> consensus_and_profile(fasta_string):</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>    dna_strings <span class="op">=</span> parse_fasta(fasta_string)</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    profile_matrix <span class="op">=</span> calculate_profile_matrix(dna_strings)</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    consensus_string <span class="op">=</span> calculate_consensus_string(profile_matrix, <span class="bu">len</span>(dna_strings[<span class="dv">0</span>]))</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> consensus_string, profile_matrix</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset as a single string</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>fasta_string <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_1</span></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a><span class="st">ATCCAGCT</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_2</span></span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a><span class="st">GGGCAACT</span></span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_3</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a><span class="st">ATGGATCT</span></span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_4</span></span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a><span class="st">AAGCAACC</span></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_5</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a><span class="st">TTGGAACT</span></span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_6</span></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a><span class="st">ATGCCATT</span></span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_7</span></span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a><span class="st">ATGGCACT</span></span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the result</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a>consensus_string, profile_matrix <span class="op">=</span> consensus_and_profile(fasta_string)</span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(consensus_string)</span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> nucleotide <span class="kw">in</span> <span class="st">"ACGT"</span>:</span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>nucleotide<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="st">' '</span><span class="sc">.</span>join(<span class="bu">map</span>(<span class="bu">str</span>, profile_matrix[nucleotide]))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-7" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="explanation-7"><span class="header-section-number">10.4</span> Explanation</h2>
<ol type="1">
<li><p><strong>Parsing FASTA Input</strong>:</p>
<ul>
<li>The <code>parse_fasta</code> function now processes a single string input and splits it into lines. It reads through each line, detecting labels (lines starting with ‘&gt;’) and corresponding DNA sequences, which are stored in a dictionary and then converted into a list of sequences.</li>
</ul></li>
<li><p><strong>Profile Matrix Calculation</strong>:</p>
<ul>
<li>The <code>calculate_profile_matrix</code> function initializes a dictionary with keys ‘A’, ‘C’, ‘G’, and ‘T’ and lists as values to store nucleotide counts at each position.</li>
</ul></li>
<li><p><strong>Consensus String Calculation</strong>:</p>
<ul>
<li>The <code>calculate_consensus_string</code> function builds the consensus string by selecting the nucleotide with the highest count at each position.</li>
</ul></li>
<li><p><strong>Main Function</strong>:</p>
<ul>
<li>The <code>consensus_and_profile</code> function orchestrates the entire process, returning the consensus string and the profile matrix.</li>
</ul></li>
</ol>
</section>
<section id="sample-output-10" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="sample-output-10"><span class="header-section-number">10.5</span> Sample Output</h2>
<p>Running the provided dataset through the code will produce the following output:</p>
<pre><code>ATGCAACT
A: 5 1 0 0 5 5 0 0
C: 0 0 1 4 2 0 6 1
G: 1 1 6 3 0 1 0 0
T: 1 5 0 0 0 1 1 6</code></pre>
<p>This output shows the consensus string and the profile matrix with counts of each nucleotide at each position, formatted as required by the problem statement.</p>
</section>
</section>
<section id="mortal-fibonacci-rabbits" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Mortal Fibonacci Rabbits</h1>
<p>Recall the definition of the&nbsp;<a href="https://rosalind.info/glossary/fibonacci-sequence/">Fibonacci numbers</a>&nbsp;from&nbsp;<a href="https://rosalind.info/problems/fib/">“Rabbits and Recurrence Relations”</a>, which followed the&nbsp;<a href="https://rosalind.info/glossary/recurrence-relation/">recurrence relation</a>&nbsp;<span class="math inline">\(Fn=Fn−1+Fn−2\)</span>&nbsp;and assumed that each pair of rabbits reaches maturity in one month and produces a single pair of offspring (one male, one female) each subsequent month.</p>
<p>Our aim is to somehow modify this recurrence relation to achieve a&nbsp;<a href="https://rosalind.info/glossary/dynamic-programming/">dynamic programming</a>&nbsp;solution in the case that all rabbits die out after a fixed number of months.(meaning that they reproduce only few times before dying).</p>
<p>Given:&nbsp;Positive integers&nbsp;n≤100&nbsp;and&nbsp;m≤20.</p>
<p>Return:&nbsp;The total number of pairs of rabbits that will remain after the&nbsp;<code>n</code>-th month if all rabbits live for&nbsp;<code>m</code>&nbsp;months.</p>
<section id="sample-dataset-10" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="sample-dataset-10"><span class="header-section-number">11.1</span> Sample Dataset</h2>
<pre><code>6 3</code></pre>
</section>
<section id="sample-output-11" class="level2" data-number="11.2">
<h2 data-number="11.2" class="anchored" data-anchor-id="sample-output-11"><span class="header-section-number">11.2</span> Sample Output</h2>
<pre><code>4</code></pre>
</section>
<section id="solution-9" class="level2" data-number="11.3">
<h2 data-number="11.3" class="anchored" data-anchor-id="solution-9"><span class="header-section-number">11.3</span> Solution</h2>
<p>To solve the problem of computing the number of rabbit pairs after a given number of months with a lifespan constraint, we need to adjust the classic Fibonacci sequence to consider the mortality of rabbits. Here’s how we can approach this using dynamic programming:</p>
<ol type="1">
<li><strong>Initialize the state</strong>:
<ul>
<li>We keep track of the number of rabbits of different ages using an array.</li>
<li><code>rabbits[i]</code> will represent the number of rabbit pairs of age <code>i</code>.</li>
</ul></li>
<li><strong>Simulate each month</strong>:
<ul>
<li>In each month, rabbits of age 0 produce new rabbits.</li>
<li>All rabbits get older by one month.</li>
<li>Rabbits older than <code>m</code> months die.</li>
</ul></li>
<li><strong>Update the state</strong>:
<ul>
<li>Shift all elements in the <code>rabbits</code> array to the right.</li>
<li>Update the number of new-born rabbits based on the rabbits of age 1 to m-1.</li>
</ul></li>
</ol>
<div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mortal_fibonacci_rabbits(n, m):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    rabbits <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> m</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    rabbits[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Initial pair of rabbits</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        new_born <span class="op">=</span> <span class="bu">sum</span>(rabbits[<span class="dv">1</span>:])  <span class="co"># All rabbits that are not in their first month</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shift all rabbits to the next month</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>            rabbits[i] <span class="op">=</span> rabbits[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        rabbits[<span class="dv">0</span>] <span class="op">=</span> new_born  <span class="co"># Update the new-born rabbits</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(rabbits)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the function with the sample dataset</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mortal_fibonacci_rabbits(<span class="dv">6</span>, <span class="dv">3</span>))  <span class="co"># Output should be 4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-8" class="level2" data-number="11.4">
<h2 data-number="11.4" class="anchored" data-anchor-id="explanation-8"><span class="header-section-number">11.4</span> Explanation</h2>
<ul>
<li><strong>Initialization</strong>:
<ul>
<li>We start with <code>rabbits = [1, 0, 0]</code>, which represents 1 pair of newborn rabbits and no other rabbits of other ages.</li>
</ul></li>
<li><strong>Monthly updates</strong>:
<ul>
<li>For each month, compute the number of new-born rabbits.</li>
<li>Shift the ages of rabbits, which involves moving each count in the <code>rabbits</code> array to the next index.</li>
<li>Rabbits older than <code>m-1</code> months (last index) die off automatically as they are not carried forward.</li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>The total number of rabbits is the sum of all entries in the <code>rabbits</code> array after the loop ends.</li>
</ul></li>
</ul>
<p>This approach ensures that we accurately track the age of each rabbit pair and account for their mortality, providing the correct number of rabbit pairs after <code>n</code> months.</p>
</section>
</section>
<section id="inferring-mrna-from-protein" class="level1" data-number="12">
<h1 data-number="12"><span class="header-section-number">12</span> Inferring mRNA from Protein</h1>
<p>For positive integers&nbsp;<span class="math inline">\(a\)</span>&nbsp;and&nbsp;<span class="math inline">\(n\)</span>,&nbsp;<span class="math inline">\(a\)</span>&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;<span class="math inline">\(n\)</span> (written&nbsp;<span class="math inline">\(amodn\)</span>&nbsp;in shorthand) is the remainder when&nbsp;a𝑎&nbsp;is divided by&nbsp;<span class="math inline">\(n\)</span>. For example,&nbsp;<span class="math inline">\(29 mod 11 = 7\)</span>&nbsp;because&nbsp;<span class="math inline">\(29=11 \times 2+7\)</span>.</p>
<p><a href="https://rosalind.info/glossary/modular-arithmetic/">Modular arithmetic</a>&nbsp;is the study of addition, subtraction, multiplication, and division with respect to the modulo operation. We say that&nbsp;<span class="math inline">\(a\)</span>&nbsp;and&nbsp;<span class="math inline">\(b\)</span>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">congruent</a>&nbsp;modulo&nbsp;<span class="math inline">\(n\)</span> if&nbsp;<span class="math inline">\(amodn=bmodn\)</span> ; in this case, we use the notation&nbsp;<span class="math inline">\(a≡bmodn\)</span>.</p>
<p>Two useful facts in modular arithmetic are that if&nbsp;<span class="math inline">\(a≡bmodn\)</span>&nbsp;and&nbsp;<span class="math inline">\(c≡dmodn\)</span>, then&nbsp;<span class="math inline">\(a+c≡b+dmodn\)</span>&nbsp;and&nbsp;<span class="math inline">\(a×c≡b×dmodn\)</span>. To check your understanding of these rules, you may wish to verify these relationships for&nbsp;<span class="math inline">\(a=29\)</span>,&nbsp;<span class="math inline">\(b=73\)</span>,&nbsp;<span class="math inline">\(c=10\)</span>,&nbsp;<span class="math inline">\(d=32\)</span>, and&nbsp;<span class="math inline">\(n=11\)</span>.</p>
<p>As you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein string</a>&nbsp;of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>.</p>
<p>Return:&nbsp;The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000. (Don’t neglect the importance of the&nbsp;<a href="https://rosalind.info/glossary/stop-codon/">stop codon</a>&nbsp;in protein translation.)</p>
<section id="sample-dataset-11" class="level2" data-number="12.1">
<h2 data-number="12.1" class="anchored" data-anchor-id="sample-dataset-11"><span class="header-section-number">12.1</span> Sample Dataset</h2>
<pre><code>MA</code></pre>
</section>
<section id="sample-output-12" class="level2" data-number="12.2">
<h2 data-number="12.2" class="anchored" data-anchor-id="sample-output-12"><span class="header-section-number">12.2</span> Sample Output</h2>
<pre><code>12</code></pre>
</section>
<section id="solution-10" class="level2" data-number="12.3">
<h2 data-number="12.3" class="anchored" data-anchor-id="solution-10"><span class="header-section-number">12.3</span> Solution</h2>
<p>To solve the problem of finding the total number of different RNA strings from which a given protein string could have been translated, we need to consider the redundancy in the genetic code. Each amino acid can be encoded by one or more codons, and this redundancy will influence the number of possible RNA sequences that can result in the same protein.</p>
</section>
<section id="steps-to-solve-the-problem-4" class="level2" data-number="12.4">
<h2 data-number="12.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-4"><span class="header-section-number">12.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Understand the Genetic Code</strong>:
<ul>
<li>Create a mapping of each amino acid to the number of possible codons that encode it.</li>
<li>Don’t forget to include the stop codons, which signal the end of translation.</li>
</ul></li>
<li><strong>Calculate Possible RNA Strings for Each Amino Acid</strong>:
<ul>
<li>For each amino acid in the given protein string, multiply the number of possible codons for that amino acid.</li>
<li>Include a factor for the stop codon at the end.</li>
</ul></li>
<li><strong>Use Modular Arithmetic</strong>:
<ul>
<li>Since the resulting number can be very large, use modulo <span class="math inline">\(1,000,000\)</span> to avoid overflow and ensure the result fits within standard integer sizes.</li>
</ul></li>
</ol>
</section>
<section id="genetic-code-table" class="level2" data-number="12.5">
<h2 data-number="12.5" class="anchored" data-anchor-id="genetic-code-table"><span class="header-section-number">12.5</span> Genetic Code Table</h2>
<p>Here is the mapping of amino acids to their respective number of codons: - ‘A’: 4, ‘C’: 2, ‘D’: 2, ‘E’: 2, ‘F’: 2, ‘G’: 4, ‘H’: 2, ‘I’: 3, ‘K’: 2, ‘L’: 6, - ‘M’: 1, ‘N’: 2, ‘P’: 4, ‘Q’: 2, ‘R’: 6, ‘S’: 6, ‘T’: 4, ‘V’: 4, ‘W’: 1, ‘Y’: 2, - Stop codon: 3</p>
</section>
<section id="implementation-1" class="level2" data-number="12.6">
<h2 data-number="12.6" class="anchored" data-anchor-id="implementation-1"><span class="header-section-number">12.6</span> Implementation</h2>
<p>Below is the Python code that implements the solution:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> infer_mrna_from_protein(protein):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Codon counts for each amino acid and stop codon</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    codon_count <span class="op">=</span> {</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'A'</span>: <span class="dv">4</span>, <span class="st">'C'</span>: <span class="dv">2</span>, <span class="st">'D'</span>: <span class="dv">2</span>, <span class="st">'E'</span>: <span class="dv">2</span>, <span class="st">'F'</span>: <span class="dv">2</span>, <span class="st">'G'</span>: <span class="dv">4</span>,</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'H'</span>: <span class="dv">2</span>, <span class="st">'I'</span>: <span class="dv">3</span>, <span class="st">'K'</span>: <span class="dv">2</span>, <span class="st">'L'</span>: <span class="dv">6</span>, <span class="st">'M'</span>: <span class="dv">1</span>, <span class="st">'N'</span>: <span class="dv">2</span>,</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'P'</span>: <span class="dv">4</span>, <span class="st">'Q'</span>: <span class="dv">2</span>, <span class="st">'R'</span>: <span class="dv">6</span>, <span class="st">'S'</span>: <span class="dv">6</span>, <span class="st">'T'</span>: <span class="dv">4</span>, <span class="st">'V'</span>: <span class="dv">4</span>,</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'W'</span>: <span class="dv">1</span>, <span class="st">'Y'</span>: <span class="dv">2</span>, <span class="st">'Stop'</span>: <span class="dv">3</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the number of possible RNA strings</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    possible_rna_strings <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the product of possible codons for each amino acid</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> aa <span class="kw">in</span> protein:</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>        possible_rna_strings <span class="op">*=</span> codon_count[aa]</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>        possible_rna_strings <span class="op">%=</span> <span class="dv">1000000</span>  <span class="co"># Take modulo 1,000,000 to keep the number manageable</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Multiply by the number of stop codons</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    possible_rna_strings <span class="op">*=</span> codon_count[<span class="st">'Stop'</span>]</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    possible_rna_strings <span class="op">%=</span> <span class="dv">1000000</span>  <span class="co"># Take modulo 1,000,000 again</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> possible_rna_strings</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>protein_string <span class="op">=</span> <span class="st">"MA"</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the result</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> infer_mrna_from_protein(protein_string)</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-9" class="level2" data-number="12.7">
<h2 data-number="12.7" class="anchored" data-anchor-id="explanation-9"><span class="header-section-number">12.7</span> Explanation</h2>
<ol type="1">
<li><strong>Codon Count Mapping</strong>:
<ul>
<li>The <code>codon_count</code> dictionary stores the number of codons that can encode each amino acid, along with the number of stop codons.</li>
</ul></li>
<li><strong>Product Calculation</strong>:
<ul>
<li>We initialize <code>possible_rna_strings</code> to 1.</li>
<li>For each amino acid in the protein string, multiply <code>possible_rna_strings</code> by the number of codons that can encode that amino acid.</li>
<li>Use modulo 1,000,000 after each multiplication to keep the number within manageable limits.</li>
</ul></li>
<li><strong>Stop Codon Factor</strong>:
<ul>
<li>Finally, multiply by the number of stop codons and take modulo 1,000,000 again.</li>
</ul></li>
</ol>
<p>This approach ensures that we efficiently compute the total number of possible RNA sequences modulo 1,000,000.</p>
</section>
</section>
<section id="overlap-graphs" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Overlap Graphs</h1>
<p>A graph whose nodes have all been labeled can be represented by an&nbsp;<a href="https://rosalind.info/glossary/adjacency-list/">adjacency list</a>, in which each row of the list contains the two node labels corresponding to a unique edge.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">directed graph</a>&nbsp;(or digraph) is a graph containing&nbsp;<a href="https://rosalind.info/glossary/directed-edge/">directed edges</a>, each of which has an orientation. That is, a directed edge is represented by an arrow instead of a line segment; the starting and ending nodes of an edge form its&nbsp;<a href="https://rosalind.info/glossary/tail/">tail</a>&nbsp;and&nbsp;<a href="https://rosalind.info/glossary/head/">head</a>, respectively. The directed edge with tail&nbsp;<span class="math inline">\(v\)</span>&nbsp;and head&nbsp;<span class="math inline">\(w\)</span>&nbsp;is represented by&nbsp;<span class="math inline">\((v,w)\)</span>&nbsp;(but&nbsp;<em>not</em>&nbsp;by&nbsp;<span class="math inline">\((w,v)\)</span>. A&nbsp;<a href="https://rosalind.info/glossary/directed-loop/">directed loop</a>&nbsp;is a directed edge of the form&nbsp;<span class="math inline">\((v,v)\)</span>.</p>
<p>For a collection of strings and a positive integer&nbsp;<span class="math inline">\(k\)</span>, the&nbsp;<a href="https://rosalind.info/glossary/overlap-graph/">overlap graph</a>&nbsp;for the strings is a directed graph&nbsp;<span class="math inline">\(O_k\)</span>&nbsp;in which each string is represented by a node, and string&nbsp;<span class="math inline">\(s\)</span>&nbsp;is connected to string&nbsp;<span class="math inline">\(t\)</span>&nbsp;with a directed edge when there is a length&nbsp;<span class="math inline">\(k\)</span>&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;that matches a length&nbsp;<span class="math inline">\(k\)</span>&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefix</a>&nbsp;of&nbsp;<span class="math inline">\(t\)</span>, as long as&nbsp;<span class="math inline">\(s≠t\)</span>; we demand&nbsp;<span class="math inline">\(s≠t\)</span>&nbsp;to prevent directed loops in the overlap graph (although directed cycles may be present).</p>
<p>Given:&nbsp;A collection of&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;having total length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;The adjacency list corresponding to&nbsp;<span class="math inline">\(O_3\)</span>. You may return edges in any order.</p>
<section id="sample-dataset-12" class="level2" data-number="13.1">
<h2 data-number="13.1" class="anchored" data-anchor-id="sample-dataset-12"><span class="header-section-number">13.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_0498
AAATAAA
&gt;Rosalind_2391
AAATTTT
&gt;Rosalind_2323
TTTTCCC
&gt;Rosalind_0442
AAATCCC
&gt;Rosalind_5013
GGGTGGG</code></pre>
</section>
<section id="sample-output-13" class="level2" data-number="13.2">
<h2 data-number="13.2" class="anchored" data-anchor-id="sample-output-13"><span class="header-section-number">13.2</span> Sample Output</h2>
<pre><code>Rosalind_0498 Rosalind_2391
Rosalind_0498 Rosalind_0442
Rosalind_2391 Rosalind_2323</code></pre>
</section>
<section id="solution-11" class="level2" data-number="13.3">
<h2 data-number="13.3" class="anchored" data-anchor-id="solution-11"><span class="header-section-number">13.3</span> Solution</h2>
<p>To solve the problem of constructing an overlap graph from a collection of DNA strings, we need to follow these steps:</p>
<ol type="1">
<li><strong>Parse the input data</strong>: Read the DNA strings in FASTA format.</li>
<li><strong>Construct the graph</strong>: Identify edges between nodes based on the overlap condition.</li>
<li><strong>Output the adjacency list</strong>: List all directed edges that satisfy the overlap condition.</li>
</ol>
</section>
<section id="steps-to-implement-the-solution" class="level2" data-number="13.4">
<h2 data-number="13.4" class="anchored" data-anchor-id="steps-to-implement-the-solution"><span class="header-section-number">13.4</span> Steps to Implement the Solution</h2>
<ol type="1">
<li><strong>Read the Input Data</strong>:
<ul>
<li>Use a parser to read the input DNA strings in FASTA format.</li>
<li>Store the strings in a dictionary with their labels as keys.</li>
</ul></li>
<li><strong>Check for Overlaps</strong>:
<ul>
<li>For each pair of strings, check if the suffix of length <code>k</code> of one string matches the prefix of length <code>k</code> of the other string.</li>
<li>If they match and the strings are different, record the directed edge from the first string to the second.</li>
</ul></li>
<li><strong>Output the Results</strong>:
<ul>
<li>Print each directed edge in the format “label1 label2”.</li>
</ul></li>
</ol>
</section>
<section id="example-implementation" class="level2" data-number="13.5">
<h2 data-number="13.5" class="anchored" data-anchor-id="example-implementation"><span class="header-section-number">13.5</span> Example Implementation</h2>
<p>Below is the Python code that performs these steps:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>            sequences[label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>            sequences[label] <span class="op">+=</span> line</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> overlap_graph(sequences, k):</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    adjacency_list <span class="op">=</span> []</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s1 <span class="kw">in</span> sequences:</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s2 <span class="kw">in</span> sequences:</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s1 <span class="op">!=</span> s2:</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> sequences[s1][<span class="op">-</span>k:] <span class="op">==</span> sequences[s2][:k]:</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>                    adjacency_list.append((s1, s2))</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> adjacency_list</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_adjacency_list(adjacency_list):</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> adjacency_list:</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>edge[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>edge[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_0498</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a><span class="st">AAATAAA</span></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_2391</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a><span class="st">AAATTTT</span></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_2323</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a><span class="st">TTTTCCC</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_0442</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a><span class="st">AAATCCC</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_5013</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a><span class="st">GGGTGGG</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(data)</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>adjacency_list <span class="op">=</span> overlap_graph(sequences, <span class="dv">3</span>)</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>print_adjacency_list(adjacency_list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-1" class="level2" data-number="13.6">
<h2 data-number="13.6" class="anchored" data-anchor-id="explanation-of-the-code-1"><span class="header-section-number">13.6</span> Explanation of the Code</h2>
<ol type="1">
<li><strong><code>parse_fasta</code> function</strong>:
<ul>
<li>Reads the FASTA formatted input.</li>
<li>Stores sequences in a dictionary where keys are the labels and values are the sequences.</li>
</ul></li>
<li><strong><code>overlap_graph</code> function</strong>:
<ul>
<li>Takes the sequences dictionary and the overlap length <code>k</code>.</li>
<li>Checks each pair of sequences to see if the suffix of length <code>k</code> of the first sequence matches the prefix of length <code>k</code> of the second sequence.</li>
<li>Records the directed edge if the condition is met.</li>
</ul></li>
<li><strong><code>print_adjacency_list</code> function</strong>:
<ul>
<li>Prints each edge in the required format.</li>
</ul></li>
</ol>
</section>
</section>
<section id="calculating-expected-offspring" class="level1" data-number="14">
<h1 data-number="14"><span class="header-section-number">14</span> Calculating Expected Offspring</h1>
<p>For a&nbsp;<a href="https://rosalind.info/glossary/random-variable/">random variable</a>&nbsp;<span class="math inline">\(X\)</span> taking integer values between 1 and&nbsp;n, the&nbsp;<a href="https://rosalind.info/glossary/expected-value/">expected value</a>&nbsp;of&nbsp;X&nbsp;is&nbsp;<span class="math inline">\(E(X)= \sum ^{n}\limits_{k=1}k×Pr(X=k)\)</span>. The expected value offers us a way of taking the long-term average of a random variable over a large number of trials.</p>
<p>As a motivating example, let&nbsp;<span class="math inline">\(X\)</span>&nbsp;be the number on a six-sided die. Over a large number of rolls, we should expect to obtain an average of 3.5 on the die (even though it’s not possible to roll a 3.5). The formula for expected value confirms that&nbsp;<span class="math inline">\(E(X)= \sum^{6}\limits_{k=1} k \times Pr(X=k)=3.5\)</span>.</p>
<p>More generally, a random variable for which every one of a number of equally spaced outcomes has the same probability is called a&nbsp;<a href="https://rosalind.info/glossary/uniform-random-variable/">uniform random variable</a>&nbsp;(in the die example, this “equal spacing” is equal to 1). We can generalize our die example to find that if&nbsp;<span class="math inline">\(X\)</span>&nbsp;is a uniform random variable with minimum possible value&nbsp;<span class="math inline">\(a\)</span>&nbsp;and maximum possible value&nbsp;<span class="math inline">\(b\)</span>, then&nbsp;<span class="math inline">\(E(X)= \frac{a+b}{2}\)</span>. You may also wish to verify that for the dice example, if&nbsp;<span class="math inline">\(Y\)</span>&nbsp;is the random variable associated with the outcome of a second die roll, then&nbsp;<span class="math inline">\(E(X+Y)=7E\)</span>.</p>
<p>Given:&nbsp;Six nonnegative integers, each of which does not exceed 20,000. The integers correspond to the number of couples in a population possessing each&nbsp;<a href="https://rosalind.info/glossary/genotype/">genotype</a>&nbsp;pairing for a given&nbsp;<a href="https://rosalind.info/glossary/factor/">factor</a>. In order, the six given integers represent the number of couples having the following genotypes:</p>
<ol type="1">
<li>AA-AA</li>
<li>AA-Aa</li>
<li>AA-aa</li>
<li>Aa-Aa</li>
<li>Aa-aa</li>
<li>aa-aa</li>
</ol>
<p>Return:&nbsp;The expected number of offspring displaying the dominant phenotype in the next generation, under the assumption that every couple has exactly two offspring.</p>
<section id="sample-dataset-13" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="sample-dataset-13"><span class="header-section-number">14.1</span> Sample Dataset</h2>
<pre><code>1 0 0 1 0 1</code></pre>
</section>
<section id="sample-output-14" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="sample-output-14"><span class="header-section-number">14.2</span> Sample Output</h2>
<pre><code>3.5</code></pre>
</section>
<section id="solution-12" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="solution-12"><span class="header-section-number">14.3</span> Solution</h2>
<p>To solve this problem, we need to calculate the expected number of offspring displaying the dominant phenotype given six nonnegative integers representing the number of couples with specific genotype pairings. Each couple has exactly two offspring.</p>
</section>
<section id="genotype-pairings-and-dominance" class="level2" data-number="14.4">
<h2 data-number="14.4" class="anchored" data-anchor-id="genotype-pairings-and-dominance"><span class="header-section-number">14.4</span> Genotype Pairings and Dominance</h2>
<p>The six genotype pairings are: 1. <strong>AA-AA</strong>: 100% dominant phenotype 2. <strong>AA-Aa</strong>: 100% dominant phenotype 3. <strong>AA-aa</strong>: 100% dominant phenotype 4. <strong>Aa-Aa</strong>: 75% dominant phenotype 5. <strong>Aa-aa</strong>: 50% dominant phenotype 6. <strong>aa-aa</strong>: 0% dominant phenotype</p>
<p>We can represent the probability of offspring having the dominant phenotype for each genotype pairing as follows: 1. <strong>AA-AA</strong>: <span class="math inline">\(1.0\)</span> 2. <strong>AA-Aa</strong>: <span class="math inline">\(1.0\)</span> 3. <strong>AA-aa</strong>: <span class="math inline">\(1.0\)</span> 4. <strong>Aa-Aa</strong>: <span class="math inline">\(0.75\)</span> 5. <strong>Aa-aa</strong>: <span class="math inline">\(0.5\)</span> 6. <strong>aa-aa</strong>: <span class="math inline">\(0.0\)</span></p>
</section>
<section id="expected-number-of-dominant-offspring" class="level2" data-number="14.5">
<h2 data-number="14.5" class="anchored" data-anchor-id="expected-number-of-dominant-offspring"><span class="header-section-number">14.5</span> Expected Number of Dominant Offspring</h2>
<p>For each couple, since they produce exactly two offspring, we can multiply the number of couples by 2 and then by the probability of having a dominant phenotype to get the expected number of dominant offspring per genotype pairing.</p>
</section>
<section id="implementation-2" class="level2" data-number="14.6">
<h2 data-number="14.6" class="anchored" data-anchor-id="implementation-2"><span class="header-section-number">14.6</span> Implementation</h2>
<p>Here’s the Python code to compute the expected number of dominant offspring:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expected_dominant_offspring(couples):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities of offspring having dominant phenotype for each genotype pairing</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    probabilities <span class="op">=</span> [<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">0.75</span>, <span class="fl">0.5</span>, <span class="fl">0.0</span>]</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the expected number of dominant offspring</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    expected_value <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>):</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        expected_value <span class="op">+=</span> couples[i] <span class="op">*</span> probabilities[i] <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> expected_value</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"1 0 0 1 0 1"</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>input_ <span class="op">=</span> [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="st">"1 0 0 1 0 1"</span>.split()]</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(expected_dominant_offspring(input_))  <span class="co"># Output: 3.5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-10" class="level2" data-number="14.7">
<h2 data-number="14.7" class="anchored" data-anchor-id="explanation-10"><span class="header-section-number">14.7</span> Explanation</h2>
<ol type="1">
<li><strong>Input</strong>: We take a list of six integers representing the number of each genotype pairing.</li>
<li><strong>Probabilities</strong>: We define the probabilities for each pairing’s offspring to display the dominant phenotype.</li>
<li><strong>Calculation</strong>: We iterate through each pairing, multiply the number of couples by the corresponding probability and by 2 (since each couple has 2 offspring), and sum these values to get the total expected number of dominant offspring.</li>
<li><strong>Output</strong>: The result is the expected number of dominant phenotype offspring.</li>
</ol>
<p>This code will compute the expected number of offspring displaying the dominant phenotype for any valid input as specified by the problem statement.</p>
</section>
</section>
<section id="finding-a-shared-motif" class="level1" data-number="15">
<h1 data-number="15"><span class="header-section-number">15</span> Finding a Shared Motif</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/common-substring/">common substring</a>&nbsp;of a collection of strings is a&nbsp;<a href="https://rosalind.info/glossary/substring/">substring</a>&nbsp;of every member of the collection. We say that a common substring is a&nbsp;<a href="https://rosalind.info/glossary/longest-common-substring/">longest common substring</a>&nbsp;if there does not exist a longer common substring. For example, “CG” is a common substring of “A<strong>CG</strong>TACGT” and “AAC<strong>CG</strong>TATA”, but it is not as long as possible; in this case, “CGTA” is a longest common substring of “A<strong>CGTA</strong>CGT” and “AAC<strong>CGTA</strong>TA”.</p>
<p>Note that the longest common substring is not necessarily unique; for a simple example, “AA” and “CC” are both longest common substrings of “AACC” and “CCAA”.</p>
<p>Given:&nbsp;A collection of&nbsp;<span class="math inline">\(k\)</span>&nbsp;(<span class="math inline">\(k≤100\)</span>)&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;each in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;A longest common substring of the collection. (If multiple solutions exist, you may return any single solution.)</p>
<section id="sample-dataset-14" class="level2" data-number="15.1">
<h2 data-number="15.1" class="anchored" data-anchor-id="sample-dataset-14"><span class="header-section-number">15.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_1
GATTACA
&gt;Rosalind_2
TAGACCA
&gt;Rosalind_3
ATACA</code></pre>
</section>
<section id="sample-output-15" class="level2" data-number="15.2">
<h2 data-number="15.2" class="anchored" data-anchor-id="sample-output-15"><span class="header-section-number">15.2</span> Sample Output</h2>
<pre><code>AC</code></pre>
</section>
<section id="solution-13" class="level2" data-number="15.3">
<h2 data-number="15.3" class="anchored" data-anchor-id="solution-13"><span class="header-section-number">15.3</span> Solution</h2>
<p>To find the longest common substring (LCS) among a collection of DNA strings given in FASTA format, we can use the following approach:</p>
<ol type="1">
<li><strong>Read and Parse Input</strong>: Parse the input FASTA format to get a list of DNA strings.</li>
<li><strong>Identify Potential Substrings</strong>: Generate all possible substrings of the shortest DNA string since the longest common substring can’t be longer than the shortest string.</li>
<li><strong>Check Commonality</strong>: Check each substring from longest to shortest to see if it appears in all DNA strings.</li>
<li><strong>Return the LCS</strong>: Return the first longest common substring found.</li>
</ol>
</section>
<section id="detailed-steps" class="level2" data-number="15.4">
<h2 data-number="15.4" class="anchored" data-anchor-id="detailed-steps"><span class="header-section-number">15.4</span> Detailed Steps</h2>
<ol type="1">
<li><strong>Parse the Input</strong>:
<ul>
<li>Read the input strings and remove the FASTA headers.</li>
<li>Collect the DNA strings into a list.</li>
</ul></li>
<li><strong>Generate All Substrings</strong>:
<ul>
<li>Generate all substrings of the shortest string in the list. Start with the longest substrings and move to shorter ones.</li>
</ul></li>
<li><strong>Check Substrings</strong>:
<ul>
<li>For each substring generated, check if it exists in all other DNA strings.</li>
<li>Return the first substring that is found in all strings since we are generating substrings from longest to shortest.</li>
</ul></li>
</ol>
</section>
<section id="implementation-3" class="level2" data-number="15.5">
<h2 data-number="15.5" class="anchored" data-anchor-id="implementation-3"><span class="header-section-number">15.5</span> Implementation</h2>
<p>Here’s a Python function that implements the above plan:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> <span class="st">""</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> seq:</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>                sequences.append(seq)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>                seq <span class="op">=</span> <span class="st">""</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            seq <span class="op">+=</span> line.strip()</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> seq:</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        sequences.append(seq)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_longest_common_substring(dna_strings):</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the shortest string in the list</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>    shortest_str <span class="op">=</span> <span class="bu">min</span>(dna_strings, key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    len_shortest <span class="op">=</span> <span class="bu">len</span>(shortest_str)</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to check if a substring is common in all strings</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_common(sub):</span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(sub <span class="kw">in</span> dna <span class="cf">for</span> dna <span class="kw">in</span> dna_strings)</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over all substrings of the shortest string</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(len_shortest, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> start <span class="kw">in</span> <span class="bu">range</span>(len_shortest <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>            candidate <span class="op">=</span> shortest_str[start:start <span class="op">+</span> length]</span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_common(candidate):</span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> candidate</span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset</span></span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">"""&gt;Rosalind_1</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a><span class="st">GATTACA</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_2</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a><span class="st">TAGACCA</span></span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_3</span></span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a><span class="st">ATACA"""</span></span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the FASTA format data</span></span>
<span id="cb46-41"><a href="#cb46-41" aria-hidden="true" tabindex="-1"></a>dna_strings <span class="op">=</span> parse_fasta(data)</span>
<span id="cb46-42"><a href="#cb46-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-43"><a href="#cb46-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Find and print the longest common substring</span></span>
<span id="cb46-44"><a href="#cb46-44" aria-hidden="true" tabindex="-1"></a>lcs <span class="op">=</span> find_longest_common_substring(dna_strings)</span>
<span id="cb46-45"><a href="#cb46-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lcs)  <span class="co"># Output: AC</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-11" class="level2" data-number="15.6">
<h2 data-number="15.6" class="anchored" data-anchor-id="explanation-11"><span class="header-section-number">15.6</span> Explanation</h2>
<ol type="1">
<li><strong>Parsing the Input</strong>:
<ul>
<li>The <code>parse_fasta</code> function reads the FASTA data, splits it into individual sequences, and returns a list of DNA strings.</li>
</ul></li>
<li><strong>Finding the Longest Common Substring</strong>:
<ul>
<li>The <code>find_longest_common_substring</code> function first identifies the shortest string among the DNA strings.</li>
<li>It then iterates over all possible substrings of the shortest string, starting from the longest possible substrings.</li>
<li>For each candidate substring, it checks if this substring is present in all other DNA strings using the <code>is_common</code> function.</li>
<li>The first substring found that is common to all DNA strings is returned as the result.</li>
</ul></li>
</ol>
<p>This approach ensures that we find the longest common substring efficiently by leveraging the properties of substrings and the fact that the longest common substring cannot be longer than the shortest string in the list.</p>
</section>
</section>
<section id="independent-alleles" class="level1" data-number="16">
<h1 data-number="16"><span class="header-section-number">16</span> Independent Alleles</h1>
<p>Two&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">events</a>&nbsp;<code>A</code>&nbsp;and&nbsp;<code>B</code>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/independent-events/">independent</a>&nbsp;if&nbsp;<span class="math inline">\(Pr(A&nbsp;and&nbsp;B)\)</span>&nbsp;is equal to&nbsp;<span class="math inline">\(Pr(A)×Pr(B)\)</span>. In other words, the events do not influence each other, so that we may simply calculate each of the individual probabilities separately and then multiply.</p>
<p>More generally,&nbsp;<a href="https://rosalind.info/glossary/random-variable/">random variables</a>&nbsp;<code>X</code> and&nbsp;<code>Y</code>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/independent-random-variables/">independent</a>&nbsp;if whenever&nbsp;<code>A</code>&nbsp;and&nbsp;<code>B</code>&nbsp;are respective events for&nbsp;<code>X</code>&nbsp;and&nbsp;<code>Y</code>,&nbsp;<code>A</code>&nbsp;and&nbsp;<code>B</code>&nbsp;are independent (i.e.,&nbsp;<span class="math inline">\(Pr(A&nbsp;and&nbsp;B)=Pr(A)×Pr(B)\)</span>.</p>
<p>As an example of how helpful independence can be for calculating probabilities, let&nbsp;<code>X</code>&nbsp;and&nbsp;<code>Y</code>&nbsp;represent the numbers showing on two six-sided dice. Intuitively, the number of pips showing on one die should not affect the number showing on the other die. If we want to find the probability that&nbsp;<span class="math inline">\(X+Y\)</span>&nbsp;is odd, then we don’t need to draw a tree diagram and consider all possibilities. We simply first note that for&nbsp;<span class="math inline">\(X+Y\)</span>&nbsp;to be odd, either&nbsp;<code>X</code>&nbsp;is even and&nbsp;<code>Y</code>&nbsp;is odd or&nbsp;<code>X</code>&nbsp;is odd and&nbsp;<code>Y</code>&nbsp;is even. In terms of probability,&nbsp;<span class="math inline">\(Pr(X+Y&nbsp;is odd)=Pr(X&nbsp;is even and&nbsp;Y&nbsp;is odd)+Pr(X&nbsp;is odd and&nbsp;Y&nbsp;is even)\)</span>. Using independence, this becomes&nbsp;<span class="math inline">\([Pr(X&nbsp;is even)×Pr(Y&nbsp;is odd)]+[Pr(X&nbsp;is odd)×Pr(Y&nbsp;is even)]\)</span>.</p>
<p>Given:&nbsp;Two positive integers&nbsp;<code>k</code>&nbsp;(<span class="math inline">\(k≤7\)</span>) and&nbsp;<code>N</code>&nbsp;(<span class="math inline">\(N≤2k\)</span>). In this problem, we begin with Tom, who in the 0th generation has genotype Aa Bb. Tom has two children in the 1st generation, each of whom has two children, and so on. Each organism always mates with an organism having genotype Aa Bb.</p>
<p>Return:&nbsp;The probability that at least&nbsp;<code>N</code>&nbsp;Aa Bb organisms will belong to the&nbsp;<code>k</code>-th generation of Tom’s family tree (don’t count the Aa Bb mates at each level). Assume that Mendel’s second law holds for the factors.</p>
<section id="sample-dataset-15" class="level2" data-number="16.1">
<h2 data-number="16.1" class="anchored" data-anchor-id="sample-dataset-15"><span class="header-section-number">16.1</span> Sample Dataset</h2>
<pre><code>2 1</code></pre>
</section>
<section id="sample-output-16" class="level2" data-number="16.2">
<h2 data-number="16.2" class="anchored" data-anchor-id="sample-output-16"><span class="header-section-number">16.2</span> Sample Output</h2>
<pre><code>0.684</code></pre>
</section>
</section>
<section id="finding-a-protein-motif" class="level1" data-number="17">
<h1 data-number="17"><span class="header-section-number">17</span> Finding a Protein Motif</h1>
<p>To allow for the presence of its varying forms, a protein motif is represented by a shorthand as follows: <code>[XY]</code> means “either <code>X</code> or <code>Y</code>” and <code>{X}</code> means “any amino acid except <code>X</code>.” For example, the N-glycosylation motif is written as <code>N{P}[ST]{P}</code>.</p>
<p>You can see the complete description and features of a particular protein by its acces ID “uniprot_id” in the UniProt database, by inserting the ID number into <code>http://www.uniprot.org/uniprot/uniprot_id</code> Alternatively, you can obtain a protein sequence in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;by following <code>http://www.uniprot.org/uniprot/uniprot_id.fasta</code>.</p>
<p>For example, the data for protein B5ZC00 can be found at&nbsp;<a href="http://www.uniprot.org/uniprot/B5ZC00"></a><a href="http://www.uniprot.org/uniprot/B5ZC00"></a><a href="http://www.uniprot.org/uniprot/B5ZC00">http://www.uniprot.org/uniprot/B5ZC00</a>.</p>
<p>Given:&nbsp;At most 15 UniProt Protein Database acces IDs.</p>
<p>Return:&nbsp;For each protein possessing the N-glycosylation motif, output its given acces ID followed by a list of&nbsp;<a href="https://rosalind.info/glossary/location/">locations</a>&nbsp;in the protein string where the motif can be found.</p>
<section id="sample-dataset-16" class="level2" data-number="17.1">
<h2 data-number="17.1" class="anchored" data-anchor-id="sample-dataset-16"><span class="header-section-number">17.1</span> Sample Dataset</h2>
<pre><code>A2Z669
B5ZC00
P07204_TRBM_HUMAN
P20840_SAG1_YEAST</code></pre>
</section>
<section id="sample-output-17" class="level2" data-number="17.2">
<h2 data-number="17.2" class="anchored" data-anchor-id="sample-output-17"><span class="header-section-number">17.2</span> Sample Output</h2>
<pre><code>B5ZC00
85 118 142 306 395
P07204_TRBM_HUMAN
47 115 116 382 409
P20840_SAG1_YEAST
79 109 135 248 306 348 364 402 485 501 614</code></pre>
</section>
<section id="solution-14" class="level2" data-number="17.3">
<h2 data-number="17.3" class="anchored" data-anchor-id="solution-14"><span class="header-section-number">17.3</span> Solution</h2>
<p>To solve the problem of identifying N-glycosylation motifs in protein sequences from the UniProt database, we need to follow these steps:</p>
<ol type="1">
<li><strong>Fetch Protein Sequences</strong>: Retrieve the protein sequences in FASTA format from UniProt using the given acces IDs.</li>
<li><strong>Identify Motif Locations</strong>: Search for the motif <code>N{P}[ST]{P}</code> in each protein sequence and record the positions where it occurs.</li>
<li><strong>Output Results</strong>: For each protein containing the motif, output its ID followed by the positions where the motif is found.</li>
</ol>
<p>Here is a complete Python script to perform these tasks:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_fasta(uniprot_id):</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> <span class="ss">f"http://www.uniprot.org/uniprot/</span><span class="sc">{</span>uniprot_id<span class="sc">}</span><span class="ss">.fasta"</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    response <span class="op">=</span> requests.get(url)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    response.raise_for_status()  <span class="co"># Ensure we notice bad responses</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    fasta_data <span class="op">=</span> response.text</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(fasta_data.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)[<span class="dv">1</span>:])  <span class="co"># Remove the first line and join the rest</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_motif_locations(sequence, motif_regex):</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> re.finditer(motif_regex, sequence)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [match.start() <span class="op">+</span> <span class="dv">1</span> <span class="cf">for</span> match <span class="kw">in</span> matches]  <span class="co"># Convert to 1-based index</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_input(data):</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    ids <span class="op">=</span> []</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        ids.append(line)</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ids</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a><span class="st">A2Z669</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a><span class="st">B5ZC00</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a><span class="st">P07204_TRBM_HUMAN</span></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a><span class="st">P20840_SAG1_YEAST</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>ids <span class="op">=</span> fetch_input(data)</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>motif_regex <span class="op">=</span> re.<span class="bu">compile</span>(<span class="vs">r'N[^P][ST][^P]'</span>)</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> uniprot_id <span class="kw">in</span> ids:</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> fetch_fasta(uniprot_id)</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>    locations <span class="op">=</span> find_motif_locations(sequence, motif_regex)</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> locations:</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>        results[uniprot_id] <span class="op">=</span> locations</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> uniprot_id, locations <span class="kw">in</span> results.items():</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(uniprot_id)</span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, locations)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-12" class="level2" data-number="17.4">
<h2 data-number="17.4" class="anchored" data-anchor-id="explanation-12"><span class="header-section-number">17.4</span> Explanation</h2>
<ol type="1">
<li><strong><code>fetch_fasta(uniprot_id)</code></strong>:
<ul>
<li>Takes a UniProt ID and fetches the corresponding protein sequence in FASTA format.</li>
<li>Strips out the header line and joins the remaining lines to form the complete sequence.</li>
</ul></li>
<li><strong><code>find_motif_locations(sequence, motif_regex)</code></strong>:
<ul>
<li>Uses the regex <code>N[^P][ST][^P]</code> to find all positions of the motif in the sequence.</li>
<li>Returns a list of start positions in 1-based index format.</li>
</ul></li>
<li><strong><code>main()</code></strong>:
<ul>
<li>Defines the list of UniProt IDs.</li>
<li>Compiles the regex for the motif.</li>
<li>Fetches each protein sequence, finds motif locations, and stores the results.</li>
<li>Outputs the protein IDs followed by the locations of the motif.</li>
</ul></li>
</ol>
<p>This script fetches protein sequences from UniProt, searches for the N-glycosylation motif, and prints the locations where the motif occurs for each protein that contains it.</p>
</section>
</section>
<section id="open-reading-frames" class="level1" data-number="18">
<h1 data-number="18"><span class="header-section-number">18</span> Open Reading Frames</h1>
<p>Either strand of a DNA double helix can serve as the&nbsp;<a href="https://rosalind.info/glossary/coding-strand/">coding strand</a>&nbsp;for RNA transcription. Hence, a given DNA string implies six total&nbsp;<a href="https://rosalind.info/glossary/reading-frame/">reading frames</a>, or ways in which the same region of DNA can be translated into amino acids: three reading frames result from reading the string itself, whereas three more result from reading its&nbsp;<a href="https://rosalind.info/glossary/reverse-complement/">reverse complement</a>.</p>
<p>An&nbsp;<a href="https://rosalind.info/glossary/open-reading-frame/">open reading frame</a>&nbsp;(ORF) is one which starts from the&nbsp;<a href="https://rosalind.info/glossary/start-codon/">start codon</a>&nbsp;and ends by&nbsp;<a href="https://rosalind.info/glossary/stop-codon/">stop codon</a>, without any other&nbsp;<a href="https://rosalind.info/glossary/stop-codon/">stop codons</a>&nbsp;in between. Thus, a candidate protein string is derived by translating an open reading frame into amino acids until a stop codon is reached.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<code>s</code>&nbsp;of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;Every distinct candidate protein string that can be translated from ORFs of&nbsp;<code>s</code>. Strings can be returned in any order.</p>
<section id="sample-dataset-17" class="level2" data-number="18.1">
<h2 data-number="18.1" class="anchored" data-anchor-id="sample-dataset-17"><span class="header-section-number">18.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_99
AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG</code></pre>
</section>
<section id="sample-output-18" class="level2" data-number="18.2">
<h2 data-number="18.2" class="anchored" data-anchor-id="sample-output-18"><span class="header-section-number">18.2</span> Sample Output</h2>
<pre><code>MLLGSFRLIPKETLIQVAGSSPCNLS
M
MGMTPRLGLESLLE
MTPRLGLESLLE</code></pre>
</section>
<section id="solution-15" class="level2" data-number="18.3">
<h2 data-number="18.3" class="anchored" data-anchor-id="solution-15"><span class="header-section-number">18.3</span> Solution</h2>
<p>To find all distinct candidate protein strings from open reading frames (ORFs) in the given DNA sequence, the following approach is used:</p>
<ol type="1">
<li><strong>Parse the Input DNA Sequence</strong>: Read the input in FASTA format and obtain the DNA sequence.</li>
<li><strong>Generate Reading Frames</strong>: Generate six reading frames: three from the original DNA strand and three from its reverse complement.</li>
<li><strong>Identify ORFs</strong>: For each reading frame, identify sequences that start with a start codon (ATG) and end with a stop codon (TAA, TAG, TGA).</li>
<li><strong>Translate to Proteins</strong>: Translate the identified ORFs to protein sequences.</li>
<li><strong>Collect and Print Distinct Proteins</strong>: Collect all distinct protein sequences.</li>
</ol>
<p>Here’s the complete implementation in Python:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>CODON_TABLE <span class="op">=</span> {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ATA'</span>:<span class="st">'I'</span>, <span class="st">'ATC'</span>:<span class="st">'I'</span>, <span class="st">'ATT'</span>:<span class="st">'I'</span>, <span class="st">'ATG'</span>:<span class="st">'M'</span>,</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ACA'</span>:<span class="st">'T'</span>, <span class="st">'ACC'</span>:<span class="st">'T'</span>, <span class="st">'ACG'</span>:<span class="st">'T'</span>, <span class="st">'ACT'</span>:<span class="st">'T'</span>,</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AAC'</span>:<span class="st">'N'</span>, <span class="st">'AAT'</span>:<span class="st">'N'</span>, <span class="st">'AAA'</span>:<span class="st">'K'</span>, <span class="st">'AAG'</span>:<span class="st">'K'</span>,</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AGC'</span>:<span class="st">'S'</span>, <span class="st">'AGT'</span>:<span class="st">'S'</span>, <span class="st">'AGA'</span>:<span class="st">'R'</span>, <span class="st">'AGG'</span>:<span class="st">'R'</span>,</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CTA'</span>:<span class="st">'L'</span>, <span class="st">'CTC'</span>:<span class="st">'L'</span>, <span class="st">'CTG'</span>:<span class="st">'L'</span>, <span class="st">'CTT'</span>:<span class="st">'L'</span>,</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CCA'</span>:<span class="st">'P'</span>, <span class="st">'CCC'</span>:<span class="st">'P'</span>, <span class="st">'CCG'</span>:<span class="st">'P'</span>, <span class="st">'CCT'</span>:<span class="st">'P'</span>,</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CAC'</span>:<span class="st">'H'</span>, <span class="st">'CAT'</span>:<span class="st">'H'</span>, <span class="st">'CAA'</span>:<span class="st">'Q'</span>, <span class="st">'CAG'</span>:<span class="st">'Q'</span>,</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CGA'</span>:<span class="st">'R'</span>, <span class="st">'CGC'</span>:<span class="st">'R'</span>, <span class="st">'CGG'</span>:<span class="st">'R'</span>, <span class="st">'CGT'</span>:<span class="st">'R'</span>,</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GTA'</span>:<span class="st">'V'</span>, <span class="st">'GTC'</span>:<span class="st">'V'</span>, <span class="st">'GTG'</span>:<span class="st">'V'</span>, <span class="st">'GTT'</span>:<span class="st">'V'</span>,</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GCA'</span>:<span class="st">'A'</span>, <span class="st">'GCC'</span>:<span class="st">'A'</span>, <span class="st">'GCG'</span>:<span class="st">'A'</span>, <span class="st">'GCT'</span>:<span class="st">'A'</span>,</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GAC'</span>:<span class="st">'D'</span>, <span class="st">'GAT'</span>:<span class="st">'D'</span>, <span class="st">'GAA'</span>:<span class="st">'E'</span>, <span class="st">'GAG'</span>:<span class="st">'E'</span>,</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GGA'</span>:<span class="st">'G'</span>, <span class="st">'GGC'</span>:<span class="st">'G'</span>, <span class="st">'GGG'</span>:<span class="st">'G'</span>, <span class="st">'GGT'</span>:<span class="st">'G'</span>,</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TCA'</span>:<span class="st">'S'</span>, <span class="st">'TCC'</span>:<span class="st">'S'</span>, <span class="st">'TCG'</span>:<span class="st">'S'</span>, <span class="st">'TCT'</span>:<span class="st">'S'</span>,</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TTC'</span>:<span class="st">'F'</span>, <span class="st">'TTT'</span>:<span class="st">'F'</span>, <span class="st">'TTA'</span>:<span class="st">'L'</span>, <span class="st">'TTG'</span>:<span class="st">'L'</span>,</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TAC'</span>:<span class="st">'Y'</span>, <span class="st">'TAT'</span>:<span class="st">'Y'</span>, <span class="st">'TAA'</span>:<span class="st">'*'</span>, <span class="st">'TAG'</span>:<span class="st">'*'</span>,</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TGC'</span>:<span class="st">'C'</span>, <span class="st">'TGT'</span>:<span class="st">'C'</span>, <span class="st">'TGA'</span>:<span class="st">'*'</span>, <span class="st">'TGG'</span>:<span class="st">'W'</span>,</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> translate_dna_to_protein(dna_seq):</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>    protein <span class="op">=</span> []</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>    has_stop_codon <span class="op">=</span> <span class="va">False</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(dna_seq) <span class="op">-</span> <span class="dv">2</span>, <span class="dv">3</span>):</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>        codon <span class="op">=</span> dna_seq[i:i <span class="op">+</span> <span class="dv">3</span>]</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>        amino_acid <span class="op">=</span> CODON_TABLE.get(codon, <span class="st">''</span>)</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> amino_acid <span class="op">==</span> <span class="st">'*'</span>:</span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>            has_stop_codon <span class="op">=</span> <span class="va">True</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>        protein.append(amino_acid)</span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(protein), has_stop_codon</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_orfs(dna_seq):</span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>    orfs <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate 3 reading frames for the DNA sequence</span></span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> frame <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(frame, <span class="bu">len</span>(dna_seq) <span class="op">-</span> <span class="dv">2</span>, <span class="dv">3</span>):</span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dna_seq[i:i <span class="op">+</span> <span class="dv">3</span>] <span class="op">==</span> <span class="st">'ATG'</span>:</span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>                protein, has_stop_codon <span class="op">=</span> translate_dna_to_protein(dna_seq[i:])</span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> protein <span class="kw">and</span> has_stop_codon:</span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>                    orfs.add(protein)</span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> orfs</span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna_seq):</span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>    complement <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'T'</span>, <span class="st">'T'</span>: <span class="st">'A'</span>, <span class="st">'C'</span>: <span class="st">'G'</span>, <span class="st">'G'</span>: <span class="st">'C'</span>}</span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(complement[base] <span class="cf">for</span> base <span class="kw">in</span> <span class="bu">reversed</span>(dna_seq))</span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>    fasta_input <span class="op">=</span> <span class="st">"""&gt;Rosalind_99</span></span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a><span class="st">AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG"""</span></span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a>    dna_seq <span class="op">=</span> <span class="st">''</span>.join(line.strip() <span class="cf">for</span> line <span class="kw">in</span> fasta_input.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>) <span class="cf">if</span> <span class="kw">not</span> line.startswith(<span class="st">'&gt;'</span>))</span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get reverse complement of the DNA sequence</span></span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>    reverse_complement_seq <span class="op">=</span> reverse_complement(dna_seq)</span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find ORFs in the original and reverse complement sequences</span></span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a>    original_orfs <span class="op">=</span> find_orfs(dna_seq)</span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a>    reverse_orfs <span class="op">=</span> find_orfs(reverse_complement_seq)</span>
<span id="cb54-61"><a href="#cb54-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-62"><a href="#cb54-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine results and remove duplicates</span></span>
<span id="cb54-63"><a href="#cb54-63" aria-hidden="true" tabindex="-1"></a>    all_orfs <span class="op">=</span> original_orfs.union(reverse_orfs)</span>
<span id="cb54-64"><a href="#cb54-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-65"><a href="#cb54-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print all distinct protein sequences</span></span>
<span id="cb54-66"><a href="#cb54-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> protein <span class="kw">in</span> all_orfs:</span>
<span id="cb54-67"><a href="#cb54-67" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(protein)</span>
<span id="cb54-68"><a href="#cb54-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-69"><a href="#cb54-69" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb54-70"><a href="#cb54-70" aria-hidden="true" tabindex="-1"></a>    main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanations" class="level2" data-number="18.4">
<h2 data-number="18.4" class="anchored" data-anchor-id="explanations"><span class="header-section-number">18.4</span> Explanations</h2>
<ol type="1">
<li><strong>translate_dna_to_protein</strong>: Now returns a tuple containing the translated protein and a boolean indicating if a stop codon was found.</li>
<li><strong>find_orfs</strong>: Checks for the presence of a stop codon in the translated protein before adding it to the set of ORFs.</li>
</ol>
</section>
</section>
<section id="enumerating-gene-orders" class="level1" data-number="19">
<h1 data-number="19"><span class="header-section-number">19</span> Enumerating Gene Orders</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/permutation/">permutation</a>&nbsp;of length&nbsp;<code>n</code>&nbsp;is an ordering of the positive integers&nbsp;<span class="math inline">\({1,2,…,n}\)</span>. For example,&nbsp;<span class="math inline">\(π=(5,3,2,1,4)\)</span>&nbsp;is a permutation of length&nbsp;5.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n≤7\)</span>.</p>
<p>Return:&nbsp;The total number of permutations of length&nbsp;<code>n</code>, followed by a list of all such permutations (in any order).</p>
<section id="sample-dataset-18" class="level2" data-number="19.1">
<h2 data-number="19.1" class="anchored" data-anchor-id="sample-dataset-18"><span class="header-section-number">19.1</span> Sample Dataset</h2>
<pre><code>3</code></pre>
</section>
<section id="sample-output-19" class="level2" data-number="19.2">
<h2 data-number="19.2" class="anchored" data-anchor-id="sample-output-19"><span class="header-section-number">19.2</span> Sample Output</h2>
<pre><code>6
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1</code></pre>
</section>
<section id="solution-16" class="level2" data-number="19.3">
<h2 data-number="19.3" class="anchored" data-anchor-id="solution-16"><span class="header-section-number">19.3</span> Solution</h2>
<p>To solve the problem of enumerating all permutations of a given integer <span class="math inline">\(n\)</span>, we can use Python’s <code>itertools.permutations</code> to generate all possible permutations. Here’s a simple code that accomplishes this:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enumerate_gene_orders(n):</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate permutations</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    perm <span class="op">=</span> permutations(<span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert permutations to a list</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    perm_list <span class="op">=</span> <span class="bu">list</span>(perm)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print the number of permutations</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">len</span>(perm_list))</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print each permutation</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> perm_list:</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, p)))</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>enumerate_gene_orders(n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-13" class="level2" data-number="19.4">
<h2 data-number="19.4" class="anchored" data-anchor-id="explanation-13"><span class="header-section-number">19.4</span> Explanation</h2>
<ol type="1">
<li><strong>Importing permutations</strong>: We import the <code>permutations</code> function from Python’s <code>itertools</code> module, which is perfect for generating permutations of a sequence.</li>
<li><strong>Generating permutations</strong>: Using <code>permutations(range(1, n + 1))</code>, we generate all permutations of the list <code>[1, 2, ..., n]</code>.</li>
<li><strong>Converting to a list</strong>: We convert the permutations object to a list to easily count and iterate over the permutations.</li>
<li><strong>Printing the count</strong>: We print the total number of permutations.</li>
<li><strong>Printing each permutation</strong>: We iterate through each permutation and print it in the required format.</li>
</ol>
</section>
</section>
<section id="calculating-protein-mass" class="level1" data-number="20">
<h1 data-number="20"><span class="header-section-number">20</span> Calculating Protein Mass</h1>
<p>In a&nbsp;<a href="https://rosalind.info/glossary/weighted-alphabet/">weighted alphabet</a>, every symbol is assigned a positive real number called a&nbsp;<a href="https://rosalind.info/glossary/symbol-weight/">weight</a>. A string formed from a weighted alphabet is called a&nbsp;<a href="https://rosalind.info/glossary/weighted-string/">weighted string</a>, and its&nbsp;<a href="https://rosalind.info/glossary/string-weight/">weight</a>&nbsp;is equal to the sum of the weights of its symbols.</p>
<p>The standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mas of the corresponding amino acid.</p>
<p>Given:&nbsp;A protein string&nbsp;<code>P</code>&nbsp;of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>.</p>
<p>Return:&nbsp;The total weight of&nbsp;<code>P</code>. Consult the&nbsp;<a href="https://rosalind.info/glossary/monoisotopic-mass-table/">monoisotopic mas table</a>.</p>
<section id="sample-dataset-19" class="level2" data-number="20.1">
<h2 data-number="20.1" class="anchored" data-anchor-id="sample-dataset-19"><span class="header-section-number">20.1</span> Sample Dataset</h2>
<pre><code>SKADYEK</code></pre>
</section>
<section id="sample-output-20" class="level2" data-number="20.2">
<h2 data-number="20.2" class="anchored" data-anchor-id="sample-output-20"><span class="header-section-number">20.2</span> Sample Output</h2>
<pre><code>821.392</code></pre>
</section>
<section id="solution-17" class="level2" data-number="20.3">
<h2 data-number="20.3" class="anchored" data-anchor-id="solution-17"><span class="header-section-number">20.3</span> Solution</h2>
<ol type="1">
<li>먼저, 각 아미노산의 질량을 딕셔너리로 정의합니다.</li>
<li>주어진 단백질 문자열의 각 아미노산의 질량을 더해서 총 질량을 계산합니다.</li>
</ol>
<div class="sourceCode" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 아미노산 질량 테이블</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>mass_table <span class="op">=</span> {</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: <span class="fl">71.03711</span>, <span class="st">'C'</span>: <span class="fl">103.00919</span>, <span class="st">'D'</span>: <span class="fl">115.02694</span>, <span class="st">'E'</span>: <span class="fl">129.04259</span>,</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'F'</span>: <span class="fl">147.06841</span>, <span class="st">'G'</span>: <span class="fl">57.02146</span>, <span class="st">'H'</span>: <span class="fl">137.05891</span>, <span class="st">'I'</span>: <span class="fl">113.08406</span>,</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'K'</span>: <span class="fl">128.09496</span>, <span class="st">'L'</span>: <span class="fl">113.08406</span>, <span class="st">'M'</span>: <span class="fl">131.04049</span>, <span class="st">'N'</span>: <span class="fl">114.04293</span>,</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'P'</span>: <span class="fl">97.05276</span>, <span class="st">'Q'</span>: <span class="fl">128.05858</span>, <span class="st">'R'</span>: <span class="fl">156.10111</span>, <span class="st">'S'</span>: <span class="fl">87.03203</span>,</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'T'</span>: <span class="fl">101.04768</span>, <span class="st">'V'</span>: <span class="fl">99.06841</span>, <span class="st">'W'</span>: <span class="fl">186.07931</span>, <span class="st">'Y'</span>: <span class="fl">163.06333</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_protein_mass(protein):</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    total_mas <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> amino_acid <span class="kw">in</span> protein:</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> amino_acid <span class="kw">in</span> mass_table:</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>            total_mas <span class="op">+=</span> mass_table[amino_acid]</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Unknown amino acid: </span><span class="sc">{</span>amino_acid<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_mass</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 샘플 데이터셋</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>sequence <span class="op">=</span> <span class="st">"SKADYEK"</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a><span class="co"># 총 질량 계산</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>total_mas <span class="op">=</span> calculate_protein_mass(sequence)</span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>total_mass<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 코드는 단백질 문자열 <code>SKADYEK</code> 의 총 질량을 계산하여 <code>821.392</code> 라는 결과를 출력합니다. <code>mass_table</code> 에 정의된 각 아미노산의 질량을 이용하여 문자열을 순회하면서 질량을 더해 총 질량을 계산합니다.</p>
</section>
</section>
<section id="locating-restriction-sites" class="level1" data-number="21">
<h1 data-number="21"><span class="header-section-number">21</span> Locating Restriction Sites</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/reverse-palindrome/">reverse palindrome</a>&nbsp;if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See&nbsp;<a href="https://rosalind.info/media/problems/revp/palindrome.png">Figure 2</a>.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;The&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;and&nbsp;<a href="https://rosalind.info/glossary/string-length/">length</a>&nbsp;of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.</p>
<section id="sample-dataset-20" class="level2" data-number="21.1">
<h2 data-number="21.1" class="anchored" data-anchor-id="sample-dataset-20"><span class="header-section-number">21.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_24
TCAATGCATGCGGGTCTATATGCAT</code></pre>
</section>
<section id="sample-output-21" class="level2" data-number="21.2">
<h2 data-number="21.2" class="anchored" data-anchor-id="sample-output-21"><span class="header-section-number">21.2</span> Sample Output</h2>
<pre><code>4 6
5 4
6 6
7 4
17 4
18 4
20 6
21 4</code></pre>
</section>
<section id="solution-18" class="level2" data-number="21.3">
<h2 data-number="21.3" class="anchored" data-anchor-id="solution-18"><span class="header-section-number">21.3</span> Solution</h2>
<p>주어진 DNA 문자열에서 역방향 팔린드롬을 찾는 코드를 작성하겠습니다. 역방향 팔린드롬은 해당 문자열이 그 역상 보완 문자열과 동일한 문자열을 말합니다. 역방향 팔린드롬의 위치와 길이를 반환하도록 하겠습니다.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna):</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    complement <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'T'</span>, <span class="st">'T'</span>: <span class="st">'A'</span>, <span class="st">'C'</span>: <span class="st">'G'</span>, <span class="st">'G'</span>: <span class="st">'C'</span>}</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(complement[base] <span class="cf">for</span> base <span class="kw">in</span> <span class="bu">reversed</span>(dna))</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_reverse_palindromes(dna):</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(dna)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length):</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">13</span>):  <span class="co"># 길이가 4에서 12까지인 모든 경우를 확인</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">+</span> j <span class="op">&gt;</span> length:</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>            substring <span class="op">=</span> dna[i:i<span class="op">+</span>j]</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> substring <span class="op">==</span> reverse_complement(substring):</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>                results.append((i<span class="op">+</span><span class="dv">1</span>, j))</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 샘플 데이터셋</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>sample_fasta <span class="op">=</span> <span class="st">"""&gt;Rosalind_24</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a><span class="st">TCAATGCATGCGGGTCTATATGCAT"""</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a><span class="co"># FASTA 포맷에서 DNA 문자열 추출</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>dna_string <span class="op">=</span> <span class="st">''</span>.join(sample_fasta.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)[<span class="dv">1</span>:])</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a><span class="co"># 역방향 팔린드롬 찾기</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>palindromes <span class="op">=</span> find_reverse_palindromes(dna_string)</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pos, length <span class="kw">in</span> palindromes:</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(pos, length)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위 코드는 다음과 같이 작동합니다:</p>
<ol type="1">
<li><code>reverse_complement</code> 함수는 DNA 문자열의 역상 보완 문자열을 생성합니다.</li>
<li><code>find_reverse_palindromes</code> 함수는 DNA 문자열을 순회하면서 길이가 4 에서 12 사이인 모든 부분 문자열에 대해 역방향 팔린드롬인지 확인합니다.</li>
<li>샘플 데이터를 입력으로 사용하여 역방향 팔린드롬의 위치와 길이를 출력합니다.</li>
</ol>
</section>
</section>
<section id="rna-splicing" class="level1" data-number="22">
<h1 data-number="22"><span class="header-section-number">22</span> RNA Splicing</h1>
<p>After identifying the exons and introns of an&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>, we only need to delete the introns and concatenate the exons to form a new string ready for translation.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<code>s</code>&nbsp;(of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) and a collection of&nbsp;<a href="https://rosalind.info/glossary/substring/">substrings</a>&nbsp;of&nbsp;<code>s</code>&nbsp;acting as introns. All strings are given in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein string</a>&nbsp;resulting from transcribing and translating the exons of&nbsp;<code>s</code>. (Note: Only one solution will exist for the dataset provided.)</p>
<section id="sample-dataset-21" class="level2" data-number="22.1">
<h2 data-number="22.1" class="anchored" data-anchor-id="sample-dataset-21"><span class="header-section-number">22.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_10
ATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG
&gt;Rosalind_12
ATCGGTCGAA
&gt;Rosalind_15
ATCGGTCGAGCGTGT</code></pre>
</section>
<section id="sample-output-22" class="level2" data-number="22.2">
<h2 data-number="22.2" class="anchored" data-anchor-id="sample-output-22"><span class="header-section-number">22.2</span> Sample Output</h2>
<pre><code>MVYIADKQHVASREAYGHMFKVCA</code></pre>
</section>
<section id="solution-19" class="level2" data-number="22.3">
<h2 data-number="22.3" class="anchored" data-anchor-id="solution-19"><span class="header-section-number">22.3</span> Solution</h2>
<p>먼저, 주어진 데이터를 파싱하고 인트론을 제거한 후 RNA 로 전사하고, 이를 단백질로 번역합니다.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># DNA 문자열에서 RNA로 전사</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transcribe(dna):</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dna.replace(<span class="st">'T'</span>, <span class="st">'U'</span>)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co"># RNA를 단백질로 번역하기 위한 코돈 테이블</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>codon_table <span class="op">=</span> {</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AUG'</span>: <span class="st">'M'</span>, <span class="st">'UGU'</span>: <span class="st">'C'</span>, <span class="st">'UGC'</span>: <span class="st">'C'</span>, <span class="st">'UGA'</span>: <span class="st">''</span>, <span class="st">'UAA'</span>: <span class="st">''</span>, <span class="st">'UAG'</span>: <span class="st">''</span>,</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'UUU'</span>: <span class="st">'F'</span>, <span class="st">'UUC'</span>: <span class="st">'F'</span>, <span class="st">'UUA'</span>: <span class="st">'L'</span>, <span class="st">'UUG'</span>: <span class="st">'L'</span>, <span class="st">'UAU'</span>: <span class="st">'Y'</span>, <span class="st">'UAC'</span>: <span class="st">'Y'</span>,</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'UGG'</span>: <span class="st">'W'</span>, <span class="st">'CUU'</span>: <span class="st">'L'</span>, <span class="st">'CUC'</span>: <span class="st">'L'</span>, <span class="st">'CUA'</span>: <span class="st">'L'</span>, <span class="st">'CUG'</span>: <span class="st">'L'</span>, <span class="st">'CCU'</span>: <span class="st">'P'</span>,</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CCC'</span>: <span class="st">'P'</span>, <span class="st">'CCA'</span>: <span class="st">'P'</span>, <span class="st">'CCG'</span>: <span class="st">'P'</span>, <span class="st">'CAU'</span>: <span class="st">'H'</span>, <span class="st">'CAC'</span>: <span class="st">'H'</span>, <span class="st">'CAA'</span>: <span class="st">'Q'</span>,</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'CAG'</span>: <span class="st">'Q'</span>, <span class="st">'CGU'</span>: <span class="st">'R'</span>, <span class="st">'CGC'</span>: <span class="st">'R'</span>, <span class="st">'CGA'</span>: <span class="st">'R'</span>, <span class="st">'CGG'</span>: <span class="st">'R'</span>, <span class="st">'AUU'</span>: <span class="st">'I'</span>,</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AUC'</span>: <span class="st">'I'</span>, <span class="st">'AUA'</span>: <span class="st">'I'</span>, <span class="st">'ACU'</span>: <span class="st">'T'</span>, <span class="st">'ACC'</span>: <span class="st">'T'</span>, <span class="st">'ACA'</span>: <span class="st">'T'</span>, <span class="st">'ACG'</span>: <span class="st">'T'</span>,</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AAU'</span>: <span class="st">'N'</span>, <span class="st">'AAC'</span>: <span class="st">'N'</span>, <span class="st">'AAA'</span>: <span class="st">'K'</span>, <span class="st">'AAG'</span>: <span class="st">'K'</span>, <span class="st">'AGU'</span>: <span class="st">'S'</span>, <span class="st">'AGC'</span>: <span class="st">'S'</span>,</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'AGA'</span>: <span class="st">'R'</span>, <span class="st">'AGG'</span>: <span class="st">'R'</span>, <span class="st">'GUU'</span>: <span class="st">'V'</span>, <span class="st">'GUC'</span>: <span class="st">'V'</span>, <span class="st">'GUA'</span>: <span class="st">'V'</span>, <span class="st">'GUG'</span>: <span class="st">'V'</span>,</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GCU'</span>: <span class="st">'A'</span>, <span class="st">'GCC'</span>: <span class="st">'A'</span>, <span class="st">'GCA'</span>: <span class="st">'A'</span>, <span class="st">'GCG'</span>: <span class="st">'A'</span>, <span class="st">'GAU'</span>: <span class="st">'D'</span>, <span class="st">'GAC'</span>: <span class="st">'D'</span>,</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'GAA'</span>: <span class="st">'E'</span>, <span class="st">'GAG'</span>: <span class="st">'E'</span>, <span class="st">'GGU'</span>: <span class="st">'G'</span>, <span class="st">'GGC'</span>: <span class="st">'G'</span>, <span class="st">'GGA'</span>: <span class="st">'G'</span>, <span class="st">'GGG'</span>: <span class="st">'G'</span>,</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'UCU'</span>: <span class="st">'S'</span>, <span class="st">'UCC'</span>: <span class="st">'S'</span>, <span class="st">'UCA'</span>: <span class="st">'S'</span>, <span class="st">'UCG'</span>: <span class="st">'S'</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a><span class="co"># RNA 문자열을 단백질로 번역</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> translate(rna):</span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>    protein <span class="op">=</span> []</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(rna) <span class="op">-</span> <span class="dv">2</span>, <span class="dv">3</span>):</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>        codon <span class="op">=</span> rna[i:i<span class="op">+</span><span class="dv">3</span>]</span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> codon <span class="kw">in</span> codon_table:</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> codon_table[codon] <span class="op">==</span> <span class="st">''</span>:</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>            protein.append(codon_table[codon])</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(protein)</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a><span class="co"># FASTA 형식의 데이터를 파싱하여 DNA 문자열과 인트론을 추출</span></span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_data):</span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>    label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>            sequences.append([])</span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a>            sequences[<span class="op">-</span><span class="dv">1</span>].append(line)</span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="st">''</span>.join(seq) <span class="cf">for</span> seq <span class="kw">in</span> sequences]</span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a><span class="co"># 샘플 데이터셋</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a>sample_data <span class="op">=</span> <span class="st">"""&gt;Rosalind_10</span></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a><span class="st">ATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_12</span></span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a><span class="st">ATCGGTCGAA</span></span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_15</span></span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a><span class="st">ATCGGTCGAGCGTGT"""</span></span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a><span class="co"># FASTA 데이터를 파싱하여 주어진 DNA와 인트론 추출</span></span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_data)</span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a>main_dna <span class="op">=</span> sequences[<span class="dv">0</span>]</span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>introns <span class="op">=</span> sequences[<span class="dv">1</span>:]</span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a><span class="co"># 인트론을 제거하여 엑손 결합</span></span>
<span id="cb66-57"><a href="#cb66-57" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> intron <span class="kw">in</span> introns:</span>
<span id="cb66-58"><a href="#cb66-58" aria-hidden="true" tabindex="-1"></a>    main_dna <span class="op">=</span> main_dna.replace(intron, <span class="st">''</span>)</span>
<span id="cb66-59"><a href="#cb66-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-60"><a href="#cb66-60" aria-hidden="true" tabindex="-1"></a><span class="co"># 엑손을 RNA로 전사</span></span>
<span id="cb66-61"><a href="#cb66-61" aria-hidden="true" tabindex="-1"></a>rna <span class="op">=</span> transcribe(main_dna)</span>
<span id="cb66-62"><a href="#cb66-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-63"><a href="#cb66-63" aria-hidden="true" tabindex="-1"></a><span class="co"># RNA를 단백질로 번역</span></span>
<span id="cb66-64"><a href="#cb66-64" aria-hidden="true" tabindex="-1"></a>protein <span class="op">=</span> translate(rna)</span>
<span id="cb66-65"><a href="#cb66-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-66"><a href="#cb66-66" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb66-67"><a href="#cb66-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(protein)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 코드는 다음과 같이 동작합니다:</p>
<ol type="1">
<li><code>parse_fasta</code> 함수는 FASTA 형식의 데이터를 파싱하여 DNA 문자열과 인트론을 추출합니다.</li>
<li><code>main_dna</code> 에서 모든 인트론을 제거하여 엑손을 결합합니다.</li>
<li><code>transcribe</code> 함수는 DNA 를 RNA 로 전사합니다.</li>
<li><code>translate</code> 함수는 RNA 를 단백질로 번역합니다.</li>
<li>최종 결과를 출력합니다.</li>
</ol>
<p>샘플 데이터를 사용하여 실행하면, 결과는 <code>MVYIADKQHVASREAYGHMFKVCA</code> 가 됩니다.</p>
</section>
</section>
<section id="enumerating-k-mers-lexicographically" class="level1" data-number="23">
<h1 data-number="23"><span class="header-section-number">23</span> Enumerating k-mers Lexicographically</h1>
<p>Assume that an&nbsp;<a href="https://rosalind.info/glossary/alphabet/">alphabet</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;has a predetermined order; that is, we write the alphabet as a&nbsp;<a href="https://rosalind.info/glossary/permutation/">permutation</a>&nbsp;<span class="math inline">\(A=(a1,a2,…,ak)\)</span> where&nbsp;<span class="math inline">\(a1&lt;a2&lt;⋯&lt;ak\)</span>. For instance, the English alphabet is organized as&nbsp;<span class="math inline">\((A,B,…,Z)\)</span>.</p>
<p>Given two strings&nbsp;s and&nbsp;t having the same length&nbsp;<span class="math inline">\(n\)</span>, we say that&nbsp;<span class="math inline">\(s\)</span>&nbsp;precedes&nbsp;t in the&nbsp;<a href="https://rosalind.info/glossary/lexicographic-order/">lexicographic order</a>&nbsp;(and write&nbsp;<span class="math inline">\(s&lt;L_{ex}t\)</span>𝑡) if the first symbol&nbsp;<span class="math inline">\(s[j]\)</span>&nbsp;that doesn’t match&nbsp;<span class="math inline">\(t[j]\)</span>&nbsp;satisfies&nbsp;<span class="math inline">\(sj&lt;tj\)</span>&nbsp;in&nbsp;<span class="math inline">\(A\)</span>.</p>
<p>Given:&nbsp;A collection of at most 10 symbols defining an ordered alphabet, and a positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤10\)</span>).</p>
<p>Return:&nbsp;All strings of length&nbsp;n that can be formed from the alphabet, ordered lexicographically (use the standard order of symbols in the English alphabet).</p>
<section id="sample-dataset-22" class="level2" data-number="23.1">
<h2 data-number="23.1" class="anchored" data-anchor-id="sample-dataset-22"><span class="header-section-number">23.1</span> Sample Dataset</h2>
<pre><code>A C G T
2</code></pre>
</section>
<section id="sample-output-23" class="level2" data-number="23.2">
<h2 data-number="23.2" class="anchored" data-anchor-id="sample-output-23"><span class="header-section-number">23.2</span> Sample Output</h2>
<pre><code>AA
AC
AG
AT
CA
CC
CG
CT
GA
GC
GG
GT
TA
TC
TG
TT</code></pre>
</section>
<section id="solution-20" class="level2" data-number="23.3">
<h2 data-number="23.3" class="anchored" data-anchor-id="solution-20"><span class="header-section-number">23.3</span> Solution</h2>
<p>주어진 알파벳과 길이 <span class="math inline">\(n\)</span> 에 대해 가능한 모든 <span class="math inline">\(n\)</span> 길이의 문자열을 사전순으로 나열하는 파이썬 코드를 작성하겠습니다. 이를 위해 itertools 모듈의 <code>product</code> 함수를 사용할 수 있습니다.</p>
<p>다음은 이를 구현한 파이썬 코드입니다:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enumerate_kmers(alphabet, n):</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="st">''</span>.join(p) <span class="cf">for</span> p <span class="kw">in</span> itertools.product(alphabet, repeat<span class="op">=</span>n)]</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 샘플 데이터셋</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>alphabet <span class="op">=</span> <span class="st">"A C G T"</span>.split()</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co"># k-mer를 나열하고 사전순으로 정렬</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>kmers <span class="op">=</span> enumerate_kmers(alphabet, n)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> kmer <span class="kw">in</span> kmers:</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(kmer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이 코드는 다음과 같은 절차로 동작합니다:</p>
<ol type="1">
<li><code>itertools.product</code> 를 사용하여 주어진 알파벳의 모든 가능한 길이 <span class="math inline">\(n\)</span> 의 조합을 생성합니다.</li>
<li>각 조합을 문자열로 변환하여 리스트에 저장합니다.</li>
<li>결과 리스트를 출력합니다.</li>
</ol>
<p>샘플 데이터를 사용하여 실행하면, 결과는 다음과 같습니다:</p>
<pre><code>AA
AC
AG
AT
CA
CC
CG
CT
GA
GC
GG
GT
TA
TC
TG
TT</code></pre>
<p>이 코드는 주어진 알파벳과 길이 <code>n</code> 에 대해 가능한 모든 문자열을 사전순으로 올바르게 나열합니다.</p>
</section>
</section>
<section id="longest-increasing-subsequence" class="level1" data-number="24">
<h1 data-number="24"><span class="header-section-number">24</span> Longest Increasing Subsequence</h1>
<p><a href="https://rosalind.info/glossary/permutation/">순열</a> 의 <a href="https://rosalind.info/glossary/permutation-subsequence/">부분열</a> 은 순열의 요소들이 나타나는 순서대로 나열된 집합입니다. 예를 들어 (5, 3, 4) 는 (5, 1, 3, 4, 2) 의 수열입니다.</p>
<p>수열의 원소가 증가하면 <a href="https://rosalind.info/glossary/increasing-permutation-subsequence/">증가</a> 이고, 원소가 감소하면 <a href="https://rosalind.info/glossary/decreasing-permutation-subsequence/">감소</a> 입니다. 예를 들어 순열 (8, 2, 1, 6, 5, 7, 4, 3, 9) 이 주어졌을 때 증가하는 수열은 (2, 6, 7, 9) 이고 감소하는 수열은 (8, 6, 5, 4, 3) 입니다.</p>
<p>Given: 양수 <span class="math inline">\(n≤10000\)</span> 와 길이 <span class="math inline">\(n\)</span> 의 순열 <span class="math inline">\(π\)</span> 가 주어집니다.</p>
<p>Return: 가장 긴 <span class="math inline">\(π\)</span> 의 증가 수열과 그 뒤에 오는 가장 긴 <span class="math inline">\(π\)</span> 의 감소 수열을 반환합니다.</p>
<section id="sample-dataset-23" class="level2" data-number="24.1">
<h2 data-number="24.1" class="anchored" data-anchor-id="sample-dataset-23"><span class="header-section-number">24.1</span> Sample Dataset</h2>
<pre><code>5
5 1 4 2 3</code></pre>
</section>
<section id="sample-output-24" class="level2" data-number="24.2">
<h2 data-number="24.2" class="anchored" data-anchor-id="sample-output-24"><span class="header-section-number">24.2</span> Sample Output</h2>
<pre><code>1 2 3
5 4 2</code></pre>
</section>
<section id="solution-21" class="level2" data-number="24.3">
<h2 data-number="24.3" class="anchored" data-anchor-id="solution-21"><span class="header-section-number">24.3</span> Solution</h2>
<p>주어진 시퀀스에서 ” 가장 긴 증가하는 부분 수열 ” 과 ” 가장 긴 감소하는 부분 수열 ” 을 찾아서 출력하는 기능을 합니다.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> input_processor(seq_str):</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="co">    입력 문자열을 처리하여 정수 리스트로 변환하는 함수</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, seq_str.split()))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_subsequence(long_type, seq):</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="co">    가장 긴 증가 또는 감소하는 부분 수열을 찾는 함수</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - long_type (str): 부분 수열의 종류 ("inc" 또는 "dec")</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - seq (list of int): 입력 시퀀스</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - prev_idxes (list of int): 이전 인덱스를 기록한 리스트</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a><span class="co">    - seq (list of int): 변환된 입력 시퀀스</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 입력 시퀀스를 내림차순으로 변경할지 여부에 따라 결정</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(seq)) <span class="cf">if</span> long_type <span class="op">!=</span> <span class="st">"inc"</span> <span class="cf">else</span> seq</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 부분 수열의 길이를 저장할 리스트 초기화</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> <span class="bu">len</span>(seq)</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 이전 인덱스를 저장할 리스트 초기화</span></span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    prev_idxes <span class="op">=</span> []</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 위치마다 최장 부분 수열의 길이 계산</span></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(L)):</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>        subproblems <span class="op">=</span> [L[k] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i) <span class="cf">if</span> seq[k] <span class="op">&lt;</span> seq[i]]</span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>        L[i] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">max</span>(subproblems, default<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(subproblems) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>            prev_idxes.append(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 최장 부분 수열의 마지막 인덱스 계산</span></span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>            last_idx <span class="op">=</span> <span class="bu">len</span>(L[:i]) <span class="op">-</span> L[:i][::<span class="op">-</span><span class="dv">1</span>].index(<span class="bu">max</span>(subproblems)) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>            prev_idxes.append(last_idx)</span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev_idxes, seq</span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decode_prev_idx(data_package):</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a><span class="co">    이전 인덱스를 기반으로 최장 부분 수열을 복원하는 함수</span></span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a><span class="co">    - data_package (tuple): (prev_idxes, seq), 이전 인덱스 리스트와 시퀀스</span></span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a><span class="co">    - vals (list of list): 복원된 최장 부분 수열들의 리스트</span></span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a>    prev_idxes, seq <span class="op">=</span> data_package</span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a>    vals <span class="op">=</span> []</span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 최장 부분 수열을 복원</span></span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> cur_idx <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(prev_idxes) <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> []</span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> cur_idx <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>            cur_val <span class="op">=</span> seq[cur_idx]</span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>            val.append(cur_val)</span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>            prev_idx <span class="op">=</span> prev_idxes[cur_idx]</span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>            cur_idx <span class="op">=</span> prev_idx</span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>        vals.append(val)</span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vals</span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_result(long_type, seq):</span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a><span class="co">    결과를 출력하는 함수</span></span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a><span class="co">    - long_type (str): 부분 수열의 종류 ("inc" 또는 "dec")</span></span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a><span class="co">    - seq (list of int): 출력할 시퀀스</span></span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> long_type <span class="op">==</span> <span class="st">"inc"</span>:</span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="op">*</span>seq[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="op">*</span>seq)</span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a><span class="co"># 입력 데이터</span></span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">"5 1 4 2 3"</span></span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a><span class="co"># "inc"와 "dec" 각각에 대해 최장 부분 수열을 찾고 출력</span></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> long_type <span class="kw">in</span> [<span class="st">"inc"</span>, <span class="st">"dec"</span>]:</span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> input_processor(data)</span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a>    prev_idxes, seq <span class="op">=</span> longest_subsequence(long_type, seq)</span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a>    vals <span class="op">=</span> decode_prev_idx((prev_idxes, seq))</span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a>    longest_subseq <span class="op">=</span> <span class="bu">max</span>(vals, key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb73-88"><a href="#cb73-88" aria-hidden="true" tabindex="-1"></a>    print_result(long_type, longest_subseq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><strong>longest_subsequence(long_type, seq)</strong>:
<ul>
<li>long_type 이 “inc” 인 경우에는 시퀀스를 그대로 사용하고, “dec” 인 경우에는 시퀀스를 뒤집어서 사용합니다.</li>
<li><code>L</code> 리스트를 초기화하고 각 위치에서 최장 증가 부분 수열의 길이를 계산합니다.</li>
<li><code>prev_idxes</code> 리스트에는 각 위치에서의 이전 인덱스를 기록하여 후에 부분 수열을 복원하는 데 사용됩니다.</li>
</ul></li>
<li><strong>decode_prev_idx(data_package)</strong>:
<ul>
<li><code>longest_subsequence</code> 함수에서 반환된 (prev_idxes, seq) 를 받아서 이전 인덱스를 기반으로 최장 부분 수열을 복원합니다.</li>
<li>각 부분 수열을 <code>vals</code> 리스트에 저장하고 반환합니다.</li>
</ul></li>
<li><strong>print_result(long_type, seq)</strong>:
<ul>
<li>long_type 이 “inc” 인 경우에는 시퀀스를 역순으로 출력하고, “dec” 인 경우에는 그대로 출력합니다.</li>
</ul></li>
<li><strong>Main Loop</strong>:
<ul>
<li>입력 데이터인 “5 1 4 2 3” 에 대해 “inc” 와 “dec” 각각에 대해 최장 부분 수열을 찾고 출력합니다.</li>
<li>예를 들어, “inc” 인 경우 [1, 2, 3] 이 출력되며, “dec” 인 경우 [5, 4, 2] 가 출력됩니다.</li>
</ul></li>
</ol>
</section>
</section>
<section id="genome-assembly-as-shortest-superstring" class="level1" data-number="25">
<h1 data-number="25"><span class="header-section-number">25</span> Genome Assembly as Shortest Superstring</h1>
<p>For a collection of strings, a larger string containing every one of the smaller strings as a substring is called a&nbsp;<a href="https://rosalind.info/glossary/superstring/">superstring</a>.</p>
<p>By the assumption of&nbsp;<a href="https://rosalind.info/glossary/parsimony/">parsimony</a>, a shortest possible superstring over a collection of reads serves as a candidate&nbsp;<a href="https://rosalind.info/glossary/chromosome/">chromosome</a>.</p>
<p>Given:&nbsp;At most 50&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;of approximately equal length, not exceeding 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>, in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(which represent reads deriving from the same&nbsp;<a href="https://rosalind.info/glossary/strand/">strand</a>&nbsp;of a single linear chromosome).</p>
<p>The dataset is guaranteed to satisfy the following condition: there exists a unique way to reconstruct the entire chromosome from these reads by gluing together pairs of reads that overlap by more than half their length.</p>
<p>Return:&nbsp;A shortest superstring containing all the given strings (thus corresponding to a reconstructed chromosome).</p>
<section id="sample-dataset-24" class="level2" data-number="25.1">
<h2 data-number="25.1" class="anchored" data-anchor-id="sample-dataset-24"><span class="header-section-number">25.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_56
ATTAGACCTG
&gt;Rosalind_57
CCTGCCGGAA
&gt;Rosalind_58
AGACCTGCCG
&gt;Rosalind_59
GCCGGAATAC</code></pre>
</section>
<section id="sample-output-25" class="level2" data-number="25.2">
<h2 data-number="25.2" class="anchored" data-anchor-id="sample-output-25"><span class="header-section-number">25.2</span> Sample Output</h2>
<pre><code>ATTAGACCTGCCGGAATAC</code></pre>
</section>
<section id="solution-22" class="level2" data-number="25.3">
<h2 data-number="25.3" class="anchored" data-anchor-id="solution-22"><span class="header-section-number">25.3</span> Solution</h2>
<p>아래는 주어진 FASTA 형식 텍스트를 입력으로 받아 최단 슈퍼스트링을 계산하는 파이썬 코드입니다.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_text):</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    current_header <span class="op">=</span> <span class="va">None</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> []</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> fasta_text.splitlines()</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_header:</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>                sequences[current_header] <span class="op">=</span> <span class="st">''</span>.join(current_sequence)</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>                current_sequence <span class="op">=</span> []</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>            current_header <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>            current_sequence.append(line)</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 마지막 시퀀스 처리</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_header:</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>        sequences[current_header] <span class="op">=</span> <span class="st">''</span>.join(current_sequence)</span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> overlap(s1, s2):</span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a>    max_len <span class="op">=</span> <span class="bu">min</span>(<span class="bu">len</span>(s1), <span class="bu">len</span>(s2))</span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(max_len, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s1[<span class="op">-</span>i:] <span class="op">==</span> s2[:i]:</span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shortest_superstring(dna_sequences):</span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>    strings <span class="op">=</span> <span class="bu">list</span>(dna_sequences.values())</span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(strings)</span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> n <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a>        max_overlap <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a>        best_i, best_j <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span></span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb76-38"><a href="#cb76-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb76-39"><a href="#cb76-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb76-40"><a href="#cb76-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">!=</span> j:</span>
<span id="cb76-41"><a href="#cb76-41" aria-hidden="true" tabindex="-1"></a>                    overlap_len <span class="op">=</span> overlap(strings[i], strings[j])</span>
<span id="cb76-42"><a href="#cb76-42" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> overlap_len <span class="op">&gt;</span> max_overlap:</span>
<span id="cb76-43"><a href="#cb76-43" aria-hidden="true" tabindex="-1"></a>                        max_overlap <span class="op">=</span> overlap_len</span>
<span id="cb76-44"><a href="#cb76-44" aria-hidden="true" tabindex="-1"></a>                        best_i, best_j <span class="op">=</span> i, j</span>
<span id="cb76-45"><a href="#cb76-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb76-46"><a href="#cb76-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_overlap <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb76-47"><a href="#cb76-47" aria-hidden="true" tabindex="-1"></a>            strings[best_i] <span class="op">+=</span> strings[best_j][max_overlap:]</span>
<span id="cb76-48"><a href="#cb76-48" aria-hidden="true" tabindex="-1"></a>            strings.pop(best_j)</span>
<span id="cb76-49"><a href="#cb76-49" aria-hidden="true" tabindex="-1"></a>            n <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb76-50"><a href="#cb76-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb76-51"><a href="#cb76-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb76-52"><a href="#cb76-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-53"><a href="#cb76-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> strings[<span class="dv">0</span>]</span>
<span id="cb76-54"><a href="#cb76-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-55"><a href="#cb76-55" aria-hidden="true" tabindex="-1"></a><span class="co"># 예시로 주어진 FASTA 형식 텍스트</span></span>
<span id="cb76-56"><a href="#cb76-56" aria-hidden="true" tabindex="-1"></a>fasta_text <span class="op">=</span> <span class="st">'''&gt;Rosalind_56</span></span>
<span id="cb76-57"><a href="#cb76-57" aria-hidden="true" tabindex="-1"></a><span class="st">ATTAGACCTG</span></span>
<span id="cb76-58"><a href="#cb76-58" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_57</span></span>
<span id="cb76-59"><a href="#cb76-59" aria-hidden="true" tabindex="-1"></a><span class="st">CCTGCCGGAA</span></span>
<span id="cb76-60"><a href="#cb76-60" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_58</span></span>
<span id="cb76-61"><a href="#cb76-61" aria-hidden="true" tabindex="-1"></a><span class="st">AGACCTGCCG</span></span>
<span id="cb76-62"><a href="#cb76-62" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_59</span></span>
<span id="cb76-63"><a href="#cb76-63" aria-hidden="true" tabindex="-1"></a><span class="st">GCCGGAATAC'''</span></span>
<span id="cb76-64"><a href="#cb76-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-65"><a href="#cb76-65" aria-hidden="true" tabindex="-1"></a><span class="co"># FASTA 형식 텍스트를 파싱하여 DNA 시퀀스 딕셔너리를 얻음</span></span>
<span id="cb76-66"><a href="#cb76-66" aria-hidden="true" tabindex="-1"></a>dna_sequences <span class="op">=</span> parse_fasta(fasta_text)</span>
<span id="cb76-67"><a href="#cb76-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-68"><a href="#cb76-68" aria-hidden="true" tabindex="-1"></a><span class="co"># 최단 슈퍼스트링 계산</span></span>
<span id="cb76-69"><a href="#cb76-69" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> shortest_superstring(dna_sequences)</span>
<span id="cb76-70"><a href="#cb76-70" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shortest superstring:"</span>, result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="코드-설명" class="level2" data-number="25.4">
<h2 data-number="25.4" class="anchored" data-anchor-id="코드-설명"><span class="header-section-number">25.4</span> 코드 설명</h2>
<ol type="1">
<li><p><strong>parse_fasta 함수</strong>: 입력으로 받은 FASTA 형식 텍스트를 파싱하여 시퀀스 헤더를 키로, 시퀀스를 값으로 갖는 딕셔너리를 반환합니다.</p></li>
<li><p><strong>overlap 함수</strong>: 두 문자열 사이의 최대 겹치는 길이를 계산합니다.</p></li>
<li><p><strong>shortest_superstring 함수</strong>: DNA 시퀀스들을 최단 슈퍼스트링으로 합치는 과정을 반복하여 수행합니다. 각 반복에서 가장 많이 겹치는 두 시퀀스를 찾아 이어붙이고, 필요 없는 시퀀스는 제거합니다.</p></li>
<li><p><strong>예시 입력 (fasta_text)</strong>: 문제에서 제공된 예시 FASTA 형식의 텍스트입니다. 이를 통해 각 DNA 시퀀스를 추출하여 최단 슈퍼스트링을 계산합니다.</p></li>
<li><p><strong>결과 출력</strong>: 계산된 최단 슈퍼스트링을 출력합니다.</p></li>
</ol>
<p>이 코드를 실행하면 주어진 FASTA 형식 텍스트에서 DNA 시퀀스들을 추출하고, 이를 이용하여 최단 슈퍼스트링을 계산하여 출력합니다.</p>
</section>
</section>
<section id="perfect-matchings-and-rna-secondary-structures" class="level1" data-number="26">
<h1 data-number="26"><span class="header-section-number">26</span> Perfect Matchings and RNA Secondary Structures</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/matching/">matching</a>&nbsp;in a&nbsp;<a href="https://rosalind.info/glossary/graph/">graph</a>&nbsp;<span class="math inline">\(G\)</span>&nbsp;is a collection of&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;of&nbsp;<span class="math inline">\(G\)</span>&nbsp;for which no node belongs to more than one edge in the collection. See&nbsp;<a href="https://rosalind.info/media/problems/pmch/matching.png">Figure 2</a>&nbsp;for examples of matchings. If&nbsp;<span class="math inline">\(G\)</span>&nbsp;contains an even number of nodes (say&nbsp;<span class="math inline">\(2n\)</span>), then a matching on&nbsp;<span class="math inline">\(G\)</span>&nbsp;is&nbsp;<a href="https://rosalind.info/glossary/perfect-matching/">perfect</a>&nbsp;if it contains&nbsp;<span class="math inline">\(n\)</span>&nbsp;edges, which is clearly the maximum possible. An example of a graph containing a perfect matching is shown in&nbsp;<a href="https://rosalind.info/media/problems/pmch/perfect_matching.png">Figure 3</a>.</p>
<p>First, let&nbsp;<span class="math inline">\(Kn\)</span>&nbsp;denote the&nbsp;<a href="https://rosalind.info/glossary/complete-graph/">complete graph</a>&nbsp;on&nbsp;<span class="math inline">\(2n\)</span>&nbsp;labeled nodes, in which every&nbsp;<a href="https://rosalind.info/glossary/node/">node</a>&nbsp;is connected to every other node with an edge, and let&nbsp;pn𝑝𝑛&nbsp;denote the total number of perfect matchings in&nbsp;<span class="math inline">\(Kn\)</span>. For a given node&nbsp;<span class="math inline">\(x\)</span>, there are&nbsp;<span class="math inline">\(2n−1\)</span>&nbsp;ways to join&nbsp;x𝑥&nbsp;to the other nodes in the graph, after which point we must form a perfect matching on the remaining&nbsp;<span class="math inline">\(2n−2\)</span>&nbsp;nodes. This reasoning provides us with the&nbsp;<a href="https://rosalind.info/glossary/recurrence-relation/">recurrence relation</a>&nbsp;<span class="math inline">\(pn=(2n−1)⋅pn−1\)</span>; using the fact that&nbsp;<span class="math inline">\(p1\)</span>&nbsp;is 1, this recurrence relation implies the closed equation&nbsp;<span class="math inline">\(pn=(2n−1)(2n−3)(2n−5)⋯(3)(1)\)</span>.</p>
<p>Given an&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;<span class="math inline">\(s=s1…sn\)</span>, a&nbsp;<a href="https://rosalind.info/glossary/bonding-graph/">bonding graph</a>&nbsp;for&nbsp;<span class="math inline">\(s\)</span>&nbsp;is formed as follows. First, assign each symbol of&nbsp;s to a node, and arrange these nodes in order around a circle, connecting them with edges called&nbsp;<a href="https://rosalind.info/glossary/adjacency-edges/">adjacency edges</a>. Second, form all possible edges <span class="math inline">\({A, U}\)</span> and <span class="math inline">\({C, G}\)</span>, called&nbsp;<a href="https://rosalind.info/glossary/basepair-edges/">basepair edges</a>; we will represent basepair edges with dashed edges, as illustrated by the bonding graph in&nbsp;<a href="https://rosalind.info/media/problems/pmch/bonding_graph.png">Figure 4</a>.</p>
<p>Note that a matching contained in the basepair edges will represent one possibility for base pairing interactions in&nbsp;<code>s</code>, as shown in&nbsp;<a href="https://rosalind.info/media/problems/pmch/bonding_crossing.png">Figure 5</a>. For such a matching to exist,&nbsp;<code>s</code>&nbsp;must have the same number of occurrences of <code>A</code> as <code>U</code> and the same number of occurrences of <code>C</code> as <code>G</code>.</p>
<p>Given:&nbsp;An RNA string&nbsp;s of length at most 80 bp having the same number of occurrences of <code>A</code> as <code>U</code> and the same number of occurrences of <code>C</code> as <code>G</code>.</p>
<p>Return:&nbsp;The total possible number of&nbsp;perfect&nbsp;matchings of basepair edges in the bonding graph of&nbsp;<code>s</code>.</p>
<section id="sample-dataset-25" class="level2" data-number="26.1">
<h2 data-number="26.1" class="anchored" data-anchor-id="sample-dataset-25"><span class="header-section-number">26.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_23
AGCUAGUCAU</code></pre>
</section>
<section id="sample-output-26" class="level2" data-number="26.2">
<h2 data-number="26.2" class="anchored" data-anchor-id="sample-output-26"><span class="header-section-number">26.2</span> Sample Output</h2>
<pre><code>12</code></pre>
</section>
<section id="solution-23" class="level2" data-number="26.3">
<h2 data-number="26.3" class="anchored" data-anchor-id="solution-23"><span class="header-section-number">26.3</span> Solution</h2>
<p>To solve the problem of calculating the total number of perfect matchings in the bonding graph of an RNA string <code>s</code>, we can break down the solution into clear steps:</p>
</section>
<section id="steps-to-solve-the-problem-5" class="level2" data-number="26.4">
<h2 data-number="26.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-5"><span class="header-section-number">26.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><p><strong>Parse the Input</strong>: Extract the RNA string from the input, ignoring the header line (if any).</p></li>
<li><p><strong>Count Nucleotide Pairs</strong>: Count the occurrences of each nucleotide (<code>A</code>, <code>U</code>, <code>C</code>, <code>G</code>) in the RNA string <code>s</code>.</p></li>
<li><p><strong>Calculate Perfect Matchings</strong>:</p>
<ul>
<li>The number of perfect matchings in the bonding graph of <code>s</code> is determined by pairing each <code>A</code> with a <code>U</code> and each <code>C</code> with a <code>G</code>.</li>
<li>Compute the factorial of half the count of each nucleotide pair (<code>A</code> with <code>U</code> and <code>C</code> with <code>G</code>). This gives the number of ways to form perfect matchings for each pair.</li>
</ul></li>
<li><p><strong>Output the Result</strong>: Print the computed number of perfect matchings.</p></li>
</ol>
</section>
<section id="python-implementation" class="level2" data-number="26.5">
<h2 data-number="26.5" class="anchored" data-anchor-id="python-implementation"><span class="header-section-number">26.5</span> Python Implementation</h2>
<p>Here’s the Python code that implements the above approach:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_nucleotides(s):</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    count_A <span class="op">=</span> s.count(<span class="st">'A'</span>)</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    count_U <span class="op">=</span> s.count(<span class="st">'U'</span>)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    count_C <span class="op">=</span> s.count(<span class="st">'C'</span>)</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    count_G <span class="op">=</span> s.count(<span class="st">'G'</span>)</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_A, count_U, count_C, count_G</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_perfect_matchings(s):</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    count_A, count_U, count_C, count_G <span class="op">=</span> count_nucleotides(s)</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if counts of A == U and C == G</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count_A <span class="op">!=</span> count_U <span class="kw">or</span> count_C <span class="op">!=</span> count_G:</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate number of perfect matchings</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>    perfect_matchings <span class="op">=</span> math.factorial(count_A) <span class="op">*</span> math.factorial(count_C)</span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> perfect_matchings</span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage with sample dataset</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>rna_string <span class="op">=</span> <span class="st">"AGCUAGUCAU"</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> calculate_perfect_matchings(rna_string)</span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-2" class="level2" data-number="26.6">
<h2 data-number="26.6" class="anchored" data-anchor-id="explanation-of-the-code-2"><span class="header-section-number">26.6</span> Explanation of the Code</h2>
<ul>
<li><p><strong>count_nucleotides</strong>: This function counts the occurrences of <code>A</code>, <code>U</code>, <code>C</code>, and <code>G</code> in the RNA string <code>s</code>.</p></li>
<li><p><strong>calculate_perfect_matchings</strong>:</p>
<ul>
<li>It first calls <code>count_nucleotides</code> to get the counts of each nucleotide.</li>
<li>Checks if the counts of <code>A</code> equal <code>U</code> and <code>C</code> equal <code>G</code>. If not, it returns <code>0</code> since perfect matchings are not possible.</li>
<li>Calculates the number of perfect matchings using factorials of half the counts of <code>A</code> and <code>C</code> (since each <code>A</code> pairs with a <code>U</code> and each <code>C</code> pairs with a <code>G</code>).</li>
</ul></li>
<li><p><strong>Example Usage</strong>:</p>
<ul>
<li>It demonstrates how to use the <code>calculate_perfect_matchings</code> function with the RNA string <code>"AGCUAGUCAU"</code>, which is given in the sample dataset.</li>
<li>The result is printed, which in this case would be <code>12</code>, indicating the total number of perfect matchings in the bonding graph of <code>"AGCUAGUCAU"</code>.</li>
</ul></li>
</ul>
<p>This code efficiently calculates the required number of perfect matchings based on the properties of RNA and the bonding rules specified. Adjustments can be made to handle different inputs as needed, ensuring accurate computation of perfect matchings.</p>
</section>
</section>
<section id="partial-permutations" class="level1" data-number="27">
<h1 data-number="27"><span class="header-section-number">27</span> Partial Permutations</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/partial-permutation/">partial permutation</a>&nbsp;is an ordering of only&nbsp;<span class="math inline">\(k\)</span>&nbsp;objects taken from a collection containing&nbsp;<span class="math inline">\(n\)</span>&nbsp;objects (i.e.,&nbsp;<span class="math inline">\(k≤n\)</span>). For example, one partial permutation of three of the first eight positive integers is given by&nbsp;<span class="math inline">\((5,7,2)\)</span>.</p>
<p>The statistic&nbsp;<span class="math inline">\(P(n,k)\)</span> counts the total number of partial permutations of&nbsp;<span class="math inline">\(k\)</span>&nbsp;objects that can be formed from a collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;objects. Note that&nbsp;<span class="math inline">\(P(n,n)\)</span>&nbsp;is just the number of permutations of&nbsp;<span class="math inline">\(n\)</span>&nbsp;objects, which we found to be equal to&nbsp;<span class="math inline">\(n!=n(n−1)(n−2)⋯(3)(2)\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/problems/perm/">“Enumerating Gene Orders”</a>.</p>
<p>Given:&nbsp;Positive integers&nbsp;<span class="math inline">\(n\)</span>&nbsp;and&nbsp;<span class="math inline">\(k\)</span>&nbsp;such that&nbsp;<span class="math inline">\(100≥n&gt;0\)</span>&nbsp;and&nbsp;<span class="math inline">\(10≥k&gt;0\)</span>.</p>
<p>Return:&nbsp;The total number of partial permutations&nbsp;<span class="math inline">\(P(n,k)\)</span>,&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000.</p>
<section id="sample-dataset-26" class="level2" data-number="27.1">
<h2 data-number="27.1" class="anchored" data-anchor-id="sample-dataset-26"><span class="header-section-number">27.1</span> Sample Dataset</h2>
<pre><code>21 7</code></pre>
</section>
<section id="sample-output-27" class="level2" data-number="27.2">
<h2 data-number="27.2" class="anchored" data-anchor-id="sample-output-27"><span class="header-section-number">27.2</span> Sample Output</h2>
<pre><code>51200</code></pre>
</section>
<section id="solution-24" class="level2" data-number="27.3">
<h2 data-number="27.3" class="anchored" data-anchor-id="solution-24"><span class="header-section-number">27.3</span> Solution</h2>
<p>To solve the problem of calculating the number of partial permutations <span class="math inline">\(P(n, k)\)</span>, where <span class="math inline">\(P(n, k) = \frac{n!}{(n-k)!}\)</span>, we need to consider the constraints provided and handle computations under a modulo operation.</p>
<p>Here’s a step-by-step approach to implement the solution:</p>
<ol type="1">
<li><p><strong>Read Input</strong>: Extract integers <span class="math inline">\(n\)</span> and <span class="math inline">\(k\)</span> from the input.</p></li>
<li><p><strong>Compute Factorials</strong>: Calculate <span class="math inline">\(n!\)</span> and <span class="math inline">\((n-k)!\)</span> using factorial computations. Since <span class="math inline">\(n\)</span> can be up to 100, Python’s built-in <code>math.factorial</code> function is suitable for this task.</p></li>
<li><p><strong>Compute Partial Permutations</strong>: Compute <span class="math inline">\(P(n, k)\)</span> using the formula <span class="math inline">\(P(n, k) = \frac{n!}{(n-k)!}\)</span>.</p></li>
<li><p><strong>Apply Modulo Operation</strong>: Since the result needs to be modulo <span class="math inline">\(1,000,000\)</span>, compute the result using <code>% 1,000,000</code> to prevent overflow and adhere to the problem’s requirement.</p></li>
<li><p><strong>Output the Result</strong>: Print the computed result.</p></li>
</ol>
<p>Here’s the Python code that implements the above plan:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> partial_permutations(n, k):</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate n!</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    n_fact <span class="op">=</span> math.factorial(n)</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate (n-k)!</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    nk_fact <span class="op">=</span> math.factorial(n <span class="op">-</span> k)</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate P(n, k) = n! / (n-k)!</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    P_n_k <span class="op">=</span> n_fact <span class="op">//</span> nk_fact</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return P(n, k) % 1,000,000</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P_n_k <span class="op">%</span> <span class="dv">1000000</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage with sample dataset</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>n, k <span class="op">=</span> <span class="dv">21</span>, <span class="dv">7</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> partial_permutations(n, k)</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-14" class="level2" data-number="27.4">
<h2 data-number="27.4" class="anchored" data-anchor-id="explanation-14"><span class="header-section-number">27.4</span> Explanation</h2>
<ul>
<li><p><code>math.factorial</code>: This function from the <code>math</code> module efficiently computes factorials, which is crucial given the constraints <span class="math inline">\(n \leq 100\)</span>.</p></li>
<li><p><strong>partial_permutations function</strong>:</p>
<ul>
<li>Computes <span class="math inline">\(n!\)</span> and <span class="math inline">\((n-k)!\)</span>.</li>
<li>Computes <span class="math inline">\(P(n, k)\)</span> using integer division <code>//</code> to ensure the result is an integer.</li>
<li>Applies the modulo operation <code>% 1,000,000</code> to handle large numbers and ensure the result fits within the specified range.</li>
</ul></li>
<li><p><strong>Example Usage</strong>:</p>
<ul>
<li>The code snippet demonstrates how to compute <span class="math inline">\(P(21, 7)\)</span> using the <code>partial_permutations</code> function and prints the result.</li>
</ul></li>
</ul>
<p>This approach efficiently computes the required number of partial permutations while adhering to the constraints and output requirements specified in the problem statement.</p>
</section>
</section>
<section id="introduction-to-random-strings" class="level1" data-number="28">
<h1 data-number="28"><span class="header-section-number">28</span> Introduction to Random Strings</h1>
<p>An&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;is a structure containing an ordered collection of objects (numbers, strings, other arrays, etc.). We let&nbsp;<span class="math inline">\(A[k]\)</span>&nbsp;denote the&nbsp;<span class="math inline">\(k\)</span>-th value in array&nbsp;<span class="math inline">\(A\)</span>. You may like to think of an array as simply a&nbsp;<a href="https://rosalind.info/glossary/matrix/">matrix</a>&nbsp;having only one row.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/random-string/">random string</a>&nbsp;is constructed so that the probability of choosing each subsequent symbol is based on a fixed underlying symbol frequency.</p>
<p><a href="https://rosalind.info/glossary/gc-content/">GC-content</a>&nbsp;offers us natural symbol frequencies for constructing random&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>. If the GC-content is&nbsp;<span class="math inline">\(x\)</span>, then we set the symbol frequencies of C and G equal to&nbsp;<span class="math inline">\(\frac{x}{2}\)</span>&nbsp;and the symbol frequencies of A and T equal to&nbsp;<span class="math inline">\(\frac{1−x}{2}\)</span>. For example, if the GC-content is 40%, then as we construct the string, the next symbol is ‘G’/‘C’ with probability 0.2, and the next symbol is ‘A’/‘T’ with probability 0.3.</p>
<p>In practice, many probabilities wind up being very small. In order to work with small probabilities, we may plug them into a function that “blows them up” for the sake of comparison. Specifically, the&nbsp;<a href="https://rosalind.info/glossary/common-logarithm/">common logarithm</a>&nbsp;of&nbsp;<span class="math inline">\(x\)</span>&nbsp;(defined for&nbsp;<span class="math inline">\(x&gt;0\)</span> and denoted&nbsp;<span class="math inline">\(\log_{10}(x)\)</span> is the exponent to which we must raise 10 to obtain&nbsp;<span class="math inline">\(x\)</span>.</p>
<p>A graph of the common logarithm function&nbsp;<span class="math inline">\(y=\log_{10}(x)\)</span>, we can see that the logarithm of&nbsp;<span class="math inline">\(x\)</span>-values between 0 and 1 always winds up mapping to&nbsp;<span class="math inline">\(y\)</span>-values between&nbsp;<span class="math inline">\(−∞\)</span>&nbsp;and 0:&nbsp;<span class="math inline">\(x\)</span>-values near 0 have logarithms close to&nbsp;<span class="math inline">\(−∞\)</span>, and&nbsp;<span class="math inline">\(x\)</span>-values close to 1 have logarithms close to&nbsp;0. Thus, we will select the common logarithm as our function to “blow up” small probability values for comparison.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<span class="math inline">\(s\)</span> of length at most 100&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>&nbsp;and an array&nbsp;<span class="math inline">\(A\)</span>&nbsp;containing at most 20 numbers between 0 and 1.</p>
<p>Return:&nbsp;An array&nbsp;<span class="math inline">\(B\)</span>&nbsp;having the same length as&nbsp;<span class="math inline">\(A\)</span> in which&nbsp;<span class="math inline">\(B[k]\)</span>&nbsp;represents the common logarithm of the probability that a random string constructed with the GC-content found in&nbsp;<span class="math inline">\(A[k]\)</span>&nbsp;will match&nbsp;<span class="math inline">\(s\)</span>&nbsp;exactly.</p>
<section id="hint" class="level2" data-number="28.1">
<h2 data-number="28.1" class="anchored" data-anchor-id="hint"><span class="header-section-number">28.1</span> Hint</h2>
<p>One property of the logarithm function is that for any positive numbers&nbsp;<span class="math inline">\(x\)</span>&nbsp;and&nbsp;<span class="math inline">\(y\)</span>,&nbsp;<span class="math inline">\(\log_{10}(x⋅y)= \log_{10}(x)+ \log_{10}(y)\)</span>.</p>
</section>
<section id="sample-dataset-27" class="level2" data-number="28.2">
<h2 data-number="28.2" class="anchored" data-anchor-id="sample-dataset-27"><span class="header-section-number">28.2</span> Sample Dataset</h2>
<pre><code>ACGATACAA
0.129 0.287 0.423 0.476 0.641 0.742 0.783</code></pre>
</section>
<section id="sample-output-28" class="level2" data-number="28.3">
<h2 data-number="28.3" class="anchored" data-anchor-id="sample-output-28"><span class="header-section-number">28.3</span> Sample Output</h2>
<pre><code>-5.737 -5.217 -5.263 -5.360 -5.958 -6.628 -7.009</code></pre>
</section>
<section id="solution-25" class="level2" data-number="28.4">
<h2 data-number="28.4" class="anchored" data-anchor-id="solution-25"><span class="header-section-number">28.4</span> Solution</h2>
<div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_log_probabilities(s, gc_contents):</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the logarithm of the probabilities of the DNA string s</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="co">    matching random strings generated with different GC-contents.</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a><span class="co">    s (str): DNA string</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a><span class="co">    gc_contents (list of float): List of GC-content values</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a><span class="co">    list of float: List of log probabilities for each GC-content</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    log_probs <span class="op">=</span> [calculate_log_prob_for_gc_content(s, gc_content) <span class="cf">for</span> gc_content <span class="kw">in</span> gc_contents]</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> log_probs</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_log_prob_for_gc_content(s, gc_content):</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the logarithm of the probability of the DNA string s</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a><span class="co">    given a specific GC-content.</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a><span class="co">    s (str): DNA string</span></span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a><span class="co">    gc_content (float): GC-content value</span></span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a><span class="co">    float: Logarithm of the probability</span></span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>    p_gc <span class="op">=</span> gc_content <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>    p_at <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> gc_content) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>    log_prob <span class="op">=</span> <span class="bu">sum</span>(math.log10(p_gc <span class="cf">if</span> nucleotide <span class="kw">in</span> <span class="st">'GC'</span> <span class="cf">else</span> p_at) <span class="cf">for</span> nucleotide <span class="kw">in</span> s)</span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> log_prob</span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_string):</span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb85-37"><a href="#cb85-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Parse the input string to extract the DNA string and GC-content values.</span></span>
<span id="cb85-38"><a href="#cb85-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-39"><a href="#cb85-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb85-40"><a href="#cb85-40" aria-hidden="true" tabindex="-1"></a><span class="co">    input_string (str): Input string containing the DNA string and GC-content values</span></span>
<span id="cb85-41"><a href="#cb85-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-42"><a href="#cb85-42" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb85-43"><a href="#cb85-43" aria-hidden="true" tabindex="-1"></a><span class="co">    tuple: DNA string and list of GC-content values</span></span>
<span id="cb85-44"><a href="#cb85-44" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb85-45"><a href="#cb85-45" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb85-46"><a href="#cb85-46" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> lines[<span class="dv">0</span>]</span>
<span id="cb85-47"><a href="#cb85-47" aria-hidden="true" tabindex="-1"></a>    gc_contents <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, lines[<span class="dv">1</span>].split()))</span>
<span id="cb85-48"><a href="#cb85-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s, gc_contents</span>
<span id="cb85-49"><a href="#cb85-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-50"><a href="#cb85-50" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_output(log_probs):</span>
<span id="cb85-51"><a href="#cb85-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb85-52"><a href="#cb85-52" aria-hidden="true" tabindex="-1"></a><span class="co">    Format the output to match the required format.</span></span>
<span id="cb85-53"><a href="#cb85-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-54"><a href="#cb85-54" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb85-55"><a href="#cb85-55" aria-hidden="true" tabindex="-1"></a><span class="co">    log_probs (list of float): List of log probabilities</span></span>
<span id="cb85-56"><a href="#cb85-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-57"><a href="#cb85-57" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb85-58"><a href="#cb85-58" aria-hidden="true" tabindex="-1"></a><span class="co">    str: Formatted output string</span></span>
<span id="cb85-59"><a href="#cb85-59" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb85-60"><a href="#cb85-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">' '</span>.join(<span class="ss">f'</span><span class="sc">{</span>x<span class="sc">:f}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> log_probs)</span>
<span id="cb85-61"><a href="#cb85-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-62"><a href="#cb85-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb85-63"><a href="#cb85-63" aria-hidden="true" tabindex="-1"></a>input_string <span class="op">=</span> <span class="st">"""ACGATACAA</span></span>
<span id="cb85-64"><a href="#cb85-64" aria-hidden="true" tabindex="-1"></a><span class="st">0.129 0.287 0.423 0.476 0.641 0.742 0.783"""</span></span>
<span id="cb85-65"><a href="#cb85-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-66"><a href="#cb85-66" aria-hidden="true" tabindex="-1"></a>s, gc_contents <span class="op">=</span> parse_input(input_string)</span>
<span id="cb85-67"><a href="#cb85-67" aria-hidden="true" tabindex="-1"></a>log_probs <span class="op">=</span> calculate_log_probabilities(s, gc_contents)</span>
<span id="cb85-68"><a href="#cb85-68" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> format_output(log_probs)</span>
<span id="cb85-69"><a href="#cb85-69" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-3" class="level2" data-number="28.5">
<h2 data-number="28.5" class="anchored" data-anchor-id="explanation-of-the-code-3"><span class="header-section-number">28.5</span> Explanation of the Code</h2>
<ol type="1">
<li><p><strong>Function <code>calculate_log_probabilities</code>:</strong></p>
<ul>
<li>This is the main function that calculates the log probabilities for each GC-content in the input list.</li>
<li>It uses a list comprehension to call <code>calculate_log_prob_for_gc_content</code> for each GC-content value.</li>
</ul></li>
<li><p><strong>Function <code>calculate_log_prob_for_gc_content</code>:</strong></p>
<ul>
<li>This function calculates the log probability for a specific GC-content value.</li>
<li>It computes the probabilities of <code>G</code>/<code>C</code> and <code>A</code>/<code>T</code> based on the GC-content.</li>
<li>It sums the logarithms of the probabilities of each nucleotide in the DNA string <code>s</code>.</li>
</ul></li>
<li><p><strong>Function <code>parse_input</code>:</strong></p>
<ul>
<li>This function parses the input string to extract the DNA string and the list of GC-content values.</li>
<li>It splits the input string into lines and processes them accordingly.</li>
</ul></li>
<li><p><strong>Function <code>format_output</code>:</strong></p>
<ul>
<li>This function formats the list of log probabilities to the required output format.</li>
<li>It uses a list comprehension to format each log probability to three decimal places.</li>
</ul></li>
</ol>
</section>
</section>
<section id="enumerating-oriented-gene-orderings" class="level1" data-number="29">
<h1 data-number="29"><span class="header-section-number">29</span> Enumerating Oriented Gene Orderings</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/signed-permutation/">signed permutation</a>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;is some ordering of the positive integers&nbsp;<span class="math inline">\({1,2,…,n}\)</span>&nbsp;in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example,&nbsp;<span class="math inline">\(π=(5,−3,−2,1,4)\)</span>&nbsp;is a signed permutation of length&nbsp;<span class="math inline">\(5\)</span>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n≤6\)</span>.</p>
<p>Return:&nbsp;The total number of signed permutations of length&nbsp;n𝑛, followed by a list of all such permutations (you may list the signed permutations in any order).</p>
<section id="sample-dataset-28" class="level2" data-number="29.1">
<h2 data-number="29.1" class="anchored" data-anchor-id="sample-dataset-28"><span class="header-section-number">29.1</span> Sample Dataset</h2>
<pre><code>2</code></pre>
</section>
<section id="sample-output-29" class="level2" data-number="29.2">
<h2 data-number="29.2" class="anchored" data-anchor-id="sample-output-29"><span class="header-section-number">29.2</span> Sample Output</h2>
<pre><code>8
-1 -2
-1 2
1 -2
1 2
-2 -1
-2 1
2 -1
2 1</code></pre>
</section>
<section id="solution-26" class="level2" data-number="29.3">
<h2 data-number="29.3" class="anchored" data-anchor-id="solution-26"><span class="header-section-number">29.3</span> solution</h2>
<p>To generate the correct total number of signed permutations and their combinations, we need to combine each permutation of the numbers with all possible sign variations correctly. Here’s the revised approach:</p>
<ol type="1">
<li><p><strong>Generate Permutations</strong>: First, generate all possible permutations of the integers from 1 to <span class="math inline">\(n\)</span>.</p></li>
<li><p><strong>Generate Signed Permutations</strong>: For each permutation, generate all possible signed versions of that permutation. Each integer in the permutation can be either positive or negative.</p></li>
<li><p><strong>Combine and Output</strong>: Combine all the signed permutations and output the total count followed by all the signed permutations.</p></li>
</ol>
<p>Here’s the corrected implementation:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations, product</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> signed_permutations(n):</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate all permutations of length n</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    perms <span class="op">=</span> <span class="bu">list</span>(permutations(<span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>)))</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate all possible signed permutations</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>    signed_perms <span class="op">=</span> []</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> perm <span class="kw">in</span> perms:</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> signs <span class="kw">in</span> product([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], repeat<span class="op">=</span>n):</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>            signed_perm <span class="op">=</span> [a <span class="op">*</span> sign <span class="cf">for</span> a, sign <span class="kw">in</span> <span class="bu">zip</span>(perm, signs)]</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>            signed_perms.append(signed_perm)</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> signed_perms</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the input</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Example input, you can change this value</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Get all signed permutations</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> signed_permutations(n)</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the total number of signed permutations</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(result))</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Output each signed permutation</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> perm <span class="kw">in</span> result:</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, perm)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-15" class="level2" data-number="29.4">
<h2 data-number="29.4" class="anchored" data-anchor-id="explanation-15"><span class="header-section-number">29.4</span> Explanation</h2>
<ol type="1">
<li><strong>Generating Permutations</strong>:
<ul>
<li>Use <code>itertools.permutations</code> to generate all permutations of the integers from 1 to <span class="math inline">\(n\)</span>.</li>
</ul></li>
<li><strong>Generating Signed Permutations</strong>:
<ul>
<li>For each permutation, we use <code>itertools.product</code> to generate all possible sign combinations (each element can be either -1 or 1).</li>
<li>For each sign combination, multiply each element of the permutation with the respective sign to create a signed permutation.</li>
</ul></li>
<li><strong>Combining and Output</strong>:
<ul>
<li>We store all the signed permutations in a list.</li>
<li>First, print the total number of signed permutations.</li>
<li>Then, print each signed permutation.</li>
</ul></li>
</ol>
<p>This should correctly generate all signed permutations and output them in the desired format. The total number of signed permutations for a given <span class="math inline">\(n\)</span> is <span class="math inline">\(n! \times 2^n\)</span>, ensuring all combinations of signs and orderings are included.</p>
</section>
</section>
<section id="finding-a-spliced-motif" class="level1" data-number="30">
<h1 data-number="30"><span class="header-section-number">30</span> Finding a Spliced Motif</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/subsequence/">subsequence</a>&nbsp;of a string is a collection of symbols contained in order (though not necessarily contiguously) in the string (e.g., ACG is a subsequence of T_A_TG_C_TAA_G_ATC). The&nbsp;<a href="https://rosalind.info/glossary/subsequence-indices/">indices</a>&nbsp;of a subsequence are the&nbsp;<a href="https://rosalind.info/glossary/position/">positions</a>&nbsp;in the string at which the symbols of the subsequence appear; thus, the indices of ACG in TATGCTAAGATC can be represented by (2, 5, 9).</p>
<p>As a substring can have multiple&nbsp;<a href="https://rosalind.info/glossary/location/">locations</a>, a subsequence can have multiple collections of indices, and the same index can be reused in more than one appearance of the subsequence; for example, ACG is a subsequence of AACCGGt in 8 different ways.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;(each of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;One collection of indices of&nbsp;<span class="math inline">\(s\)</span>&nbsp;in which the symbols of&nbsp;<span class="math inline">\(t\)</span>&nbsp;appear as a subsequence of&nbsp;<span class="math inline">\(s\)</span>. If multiple solutions exist, you may return any one.</p>
<section id="sample-dataset-29" class="level2" data-number="30.1">
<h2 data-number="30.1" class="anchored" data-anchor-id="sample-dataset-29"><span class="header-section-number">30.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_14
ACGTACGTGACG
&gt;Rosalind_18
GTA</code></pre>
</section>
<section id="sample-output-30" class="level2" data-number="30.2">
<h2 data-number="30.2" class="anchored" data-anchor-id="sample-output-30"><span class="header-section-number">30.2</span> Sample Output</h2>
<pre><code>3 4 5</code></pre>
</section>
<section id="solution-27" class="level2" data-number="30.3">
<h2 data-number="30.3" class="anchored" data-anchor-id="solution-27"><span class="header-section-number">30.3</span> Solution</h2>
<p>Thank you for the clarification. Let’s refine the approach to ensure it correctly finds the indices of the subsequence.</p>
<p>Here’s the corrected version of the code without any hardcoding:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_seq:</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>                current_seq <span class="op">=</span> []</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line)</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_seq:</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_spliced_motif(s, t):</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> []</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    t_index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s_index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t_index <span class="op">&lt;</span> <span class="bu">len</span>(t) <span class="kw">and</span> s[s_index] <span class="op">==</span> t[t_index]:</span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>            indices.append(s_index <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>            t_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> t_index <span class="op">==</span> <span class="bu">len</span>(t):</span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> indices</span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""&gt;Rosalind_14</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a><span class="st">ACGTACGTGACG</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_18</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a><span class="st">GTA"""</span></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> sequences[<span class="dv">0</span>]</span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> sequences[<span class="dv">1</span>]</span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> find_spliced_motif(s, t)</span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, result)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-16" class="level2" data-number="30.4">
<h2 data-number="30.4" class="anchored" data-anchor-id="explanation-16"><span class="header-section-number">30.4</span> Explanation</h2>
<ol type="1">
<li><strong>parse_fasta Function:</strong>
<ul>
<li>This function parses the input FASTA string into sequences. It collects lines of sequences until it encounters a new sequence identifier (a line starting with <code>&gt;</code>). This function does not hardcode sequence identifiers and can handle any number of sequences.</li>
</ul></li>
<li><strong>find_spliced_motif Function:</strong>
<ul>
<li>This function searches for the subsequence <code>t</code> within the sequence <code>s</code> and returns the 1-based indices of <code>s</code> where the characters of <code>t</code> appear in order.</li>
<li>It uses a single loop over <code>s</code> to find matches for the characters in <code>t</code>.</li>
<li>It stops searching as soon as it finds all characters of <code>t</code> within <code>s</code>.</li>
</ul></li>
</ol>
<p>The sample dataset should now correctly produce the output <code>3 8 10</code>.</p>
</section>
</section>
<section id="transitions-and-transversions" class="level1" data-number="31">
<h1 data-number="31"><span class="header-section-number">31</span> Transitions and Transversions</h1>
<p>For&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and&nbsp;<span class="math inline">\(s2\)</span>&nbsp;having the same length, their&nbsp;<a href="https://rosalind.info/glossary/transitiontransversion-ratio/">transition/transversion ratio</a>&nbsp;<span class="math inline">\(R(s1,s2)\)</span>&nbsp;is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatched corresponding symbols as when calculating&nbsp;<a href="https://rosalind.info/glossary/hamming-distance/">Hamming distance</a>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/hamm/">“Counting Point Mutations”</a>).</p>
<p>Given:&nbsp;Two DNA strings&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and&nbsp;<span class="math inline">\(s2\)</span>&nbsp;of equal length (at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;The transition/transversion ratio&nbsp;<span class="math inline">\(R(s1,s2)\)</span>.</p>
<section id="sample-dataset-30" class="level2" data-number="31.1">
<h2 data-number="31.1" class="anchored" data-anchor-id="sample-dataset-30"><span class="header-section-number">31.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_0209
GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA
AGTACGGGCATCAACCCAGTT
&gt;Rosalind_2200
TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC
GGTACGAGTGTTCCTTTGGGT</code></pre>
</section>
<section id="sample-output-31" class="level2" data-number="31.2">
<h2 data-number="31.2" class="anchored" data-anchor-id="sample-output-31"><span class="header-section-number">31.2</span> Sample Output</h2>
<pre><code>1.21428571429</code></pre>
</section>
<section id="solution-28" class="level2" data-number="31.3">
<h2 data-number="31.3" class="anchored" data-anchor-id="solution-28"><span class="header-section-number">31.3</span> Solution</h2>
<p>To solve the problem of calculating the transition/transversion ratio, we need to perform the following steps:</p>
<ol type="1">
<li><strong>Parse the input data</strong> to extract the two DNA sequences.</li>
<li><strong>Define transition and transversion mutations</strong>:
<ul>
<li><strong>Transitions</strong> are interchanges of two purines (A &lt;-&gt; G) or two pyrimidines (C &lt;-&gt; T).</li>
<li><strong>Transversions</strong> are interchanges between a purine and a pyrimidine (A &lt;-&gt; C, A &lt;-&gt; T, G &lt;-&gt; C, G &lt;-&gt; T).</li>
</ul></li>
<li><strong>Count the number of transitions and transversions</strong> between the two sequences.</li>
<li><strong>Calculate the ratio</strong> of transitions to transversions.</li>
</ol>
</section>
<section id="step-by-step-implementation" class="level2" data-number="31.4">
<h2 data-number="31.4" class="anchored" data-anchor-id="step-by-step-implementation"><span class="header-section-number">31.4</span> Step-by-step Implementation</h2>
<ol type="1">
<li><strong>Parsing the Input</strong>:
<ul>
<li>Read the input in FASTA format.</li>
<li>Extract the sequences associated with each identifier.</li>
</ul></li>
<li><strong>Counting Mutations</strong>:
<ul>
<li>Compare each base of the two sequences.</li>
<li>Increment the transition count if a transition mutation is found.</li>
<li>Increment the transversion count if a transversion mutation is found.</li>
</ul></li>
<li><strong>Calculating the Ratio</strong>:
<ul>
<li>Compute the ratio of the number of transitions to the number of transversions.</li>
</ul></li>
</ol>
<p>Here’s the Python implementation of the solution:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_seq:</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>                current_seq <span class="op">=</span> []</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line)</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_seq:</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_transitions_transversions(s1, s2):</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>    transitions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>    transversions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a>    transitions_set <span class="op">=</span> {(<span class="st">'A'</span>, <span class="st">'G'</span>), (<span class="st">'G'</span>, <span class="st">'A'</span>), (<span class="st">'C'</span>, <span class="st">'T'</span>), (<span class="st">'T'</span>, <span class="st">'C'</span>)}</span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-21"><a href="#cb94-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base1, base2 <span class="kw">in</span> <span class="bu">zip</span>(s1, s2):</span>
<span id="cb94-22"><a href="#cb94-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> base1 <span class="op">!=</span> base2:</span>
<span id="cb94-23"><a href="#cb94-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (base1, base2) <span class="kw">in</span> transitions_set:</span>
<span id="cb94-24"><a href="#cb94-24" aria-hidden="true" tabindex="-1"></a>                transitions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-25"><a href="#cb94-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb94-26"><a href="#cb94-26" aria-hidden="true" tabindex="-1"></a>                transversions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-27"><a href="#cb94-27" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb94-28"><a href="#cb94-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transitions, transversions</span>
<span id="cb94-29"><a href="#cb94-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-30"><a href="#cb94-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition_transversion_ratio(s1, s2):</span>
<span id="cb94-31"><a href="#cb94-31" aria-hidden="true" tabindex="-1"></a>    transitions, transversions <span class="op">=</span> count_transitions_transversions(s1, s2)</span>
<span id="cb94-32"><a href="#cb94-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> transversions <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb94-33"><a href="#cb94-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">float</span>(<span class="st">'inf'</span>)  <span class="co"># or some other large number or special case</span></span>
<span id="cb94-34"><a href="#cb94-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transitions <span class="op">/</span> transversions</span>
<span id="cb94-35"><a href="#cb94-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-36"><a href="#cb94-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb94-37"><a href="#cb94-37" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""&gt;Rosalind_0209</span></span>
<span id="cb94-38"><a href="#cb94-38" aria-hidden="true" tabindex="-1"></a><span class="st">GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGA</span></span>
<span id="cb94-39"><a href="#cb94-39" aria-hidden="true" tabindex="-1"></a><span class="st">AGTACGGGCATCAACCCAGTT</span></span>
<span id="cb94-40"><a href="#cb94-40" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_2200</span></span>
<span id="cb94-41"><a href="#cb94-41" aria-hidden="true" tabindex="-1"></a><span class="st">TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGC</span></span>
<span id="cb94-42"><a href="#cb94-42" aria-hidden="true" tabindex="-1"></a><span class="st">GGTACGAGTGTTCCTTTGGGT"""</span></span>
<span id="cb94-43"><a href="#cb94-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-44"><a href="#cb94-44" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb94-45"><a href="#cb94-45" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> sequences[<span class="dv">0</span>]</span>
<span id="cb94-46"><a href="#cb94-46" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> sequences[<span class="dv">1</span>]</span>
<span id="cb94-47"><a href="#cb94-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-48"><a href="#cb94-48" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> transition_transversion_ratio(s1, s2)</span>
<span id="cb94-49"><a href="#cb94-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result<span class="sc">:.11f}</span><span class="ss">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-17" class="level2" data-number="31.5">
<h2 data-number="31.5" class="anchored" data-anchor-id="explanation-17"><span class="header-section-number">31.5</span> Explanation</h2>
<ol type="1">
<li><strong>parse_fasta Function</strong>:
<ul>
<li>This function parses the FASTA formatted input to extract sequences. It handles multiple sequences and collects lines until a new identifier is found.</li>
</ul></li>
<li><strong>count_transitions_transversions Function</strong>:
<ul>
<li>This function takes two DNA sequences and counts the transitions and transversions by comparing each nucleotide in the two sequences.</li>
<li>It uses a set of tuples to check if a given mutation is a transition.</li>
</ul></li>
<li><strong>transition_transversion_ratio Function</strong>:
<ul>
<li>This function calculates the ratio of transitions to transversions. If there are no transversions, it handles this by returning infinity or some other large number.</li>
</ul></li>
</ol>
</section>
</section>
<section id="completing-a-tree" class="level1" data-number="32">
<h1 data-number="32"><span class="header-section-number">32</span> Completing a Tree</h1>
<p>An undirected&nbsp;<a href="https://rosalind.info/glossary/graph/">graph</a>&nbsp;is&nbsp;<a href="https://rosalind.info/glossary/connected-graph/">connected</a>&nbsp;if there is a&nbsp;<a href="https://rosalind.info/glossary/path/">path</a>&nbsp;connecting any two&nbsp;<a href="https://rosalind.info/glossary/node/">nodes</a>. A&nbsp;<a href="https://rosalind.info/glossary/tree/">tree</a>&nbsp;is a connected (undirected) graph containing no&nbsp;<a href="https://rosalind.info/glossary/cycle/">cycles</a>; this definition forces the tree to have a branching structure organized around a central core of nodes, just like its living counterpart.</p>
<p>We have already grown familiar with trees in&nbsp;<a href="https://rosalind.info/problems/iprb/">“Mendel’s First Law”</a>, where we introduced the&nbsp;<a href="https://rosalind.info/glossary/probability-tree-diagram/">probability tree diagram</a>&nbsp;to visualize the&nbsp;<a href="https://rosalind.info/glossary/outcome/">outcomes</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/random-variable/">random variable</a>.</p>
<p>In the creation of a phylogeny, taxa are encoded by the tree’s&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>, or nodes having&nbsp;<a href="https://rosalind.info/glossary/degree/">degree</a>&nbsp;1. A node of a tree having degree larger than 1 is called an&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal node</a>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤1000\)</span>) and an&nbsp;<a href="https://rosalind.info/glossary/adjacency-list/">adjacency list</a>&nbsp;corresponding to a graph on&nbsp;<span class="math inline">\(n\)</span>&nbsp;nodes that contains no cycles.</p>
<p>Return:&nbsp;The minimum number of&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;that can be added to the graph to produce a tree.</p>
<section id="sample-dataset-31" class="level2" data-number="32.1">
<h2 data-number="32.1" class="anchored" data-anchor-id="sample-dataset-31"><span class="header-section-number">32.1</span> Sample Dataset</h2>
<pre><code>10
1 2
2 8
4 10
5 9
6 10
7 9</code></pre>
</section>
<section id="sample-output-32" class="level2" data-number="32.2">
<h2 data-number="32.2" class="anchored" data-anchor-id="sample-output-32"><span class="header-section-number">32.2</span> Sample Output</h2>
<pre><code>3</code></pre>
</section>
<section id="solution-29" class="level2" data-number="32.3">
<h2 data-number="32.3" class="anchored" data-anchor-id="solution-29"><span class="header-section-number">32.3</span> Solution</h2>
<p>To solve the problem of determining the minimum number of edges needed to make a given graph a tree, we can follow these steps:</p>
<ol type="1">
<li><p><strong>Understand the Input and Output</strong>:</p>
<ul>
<li>The input consists of an integer <code>n</code>, which is the number of nodes, followed by a list of edges given as pairs of integers.</li>
<li>The output should be the minimum number of edges required to make the graph a tree.</li>
</ul></li>
<li><p><strong>Concepts</strong>:</p>
<ul>
<li>A tree is a connected graph with no cycles.</li>
<li>For a graph with <code>n</code> nodes to be a tree, it must have exactly <code>n-1</code> edges.</li>
<li>If the graph has fewer than <code>n-1</code> edges, it must be connected. If it is not connected, it will have multiple connected components.</li>
</ul></li>
<li><p><strong>Algorithm</strong>:</p>
<ul>
<li>Use a graph traversal algorithm (e.g., Depth-First Search (DFS) or Breadth-First Search (BFS)) to find all the connected components of the graph.</li>
<li>Count the number of connected components, <code>c</code>.</li>
<li>The minimum number of edges needed to connect all components to form a single connected component (tree) is <code>c-1</code>.</li>
</ul></li>
</ol>
<p>Here is the implementation in Python:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_connected_components(n, edges):</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> defaultdict, deque</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bfs(start):</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>        queue <span class="op">=</span> deque([start])</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>        visited.add(start)</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> queue:</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> queue.popleft()</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> neighbor <span class="kw">in</span> graph[node]:</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> neighbor <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>                    visited.add(neighbor)</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>                    queue.append(neighbor)</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>        graph[u].append(v)</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>        graph[v].append(u)</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>    num_components <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>            bfs(node)</span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>            num_components <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num_components</span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_edges_to_tree(n, edges):</span>
<span id="cb97-30"><a href="#cb97-30" aria-hidden="true" tabindex="-1"></a>    num_components <span class="op">=</span> find_connected_components(n, edges)</span>
<span id="cb97-31"><a href="#cb97-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num_components <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb97-32"><a href="#cb97-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-33"><a href="#cb97-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_text):</span>
<span id="cb97-34"><a href="#cb97-34" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_text.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb97-35"><a href="#cb97-35" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">int</span>(lines[<span class="dv">0</span>])</span>
<span id="cb97-36"><a href="#cb97-36" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> [<span class="bu">tuple</span>(<span class="bu">map</span>(<span class="bu">int</span>, line.split())) <span class="cf">for</span> line <span class="kw">in</span> lines[<span class="dv">1</span>:]]</span>
<span id="cb97-37"><a href="#cb97-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n, edges</span>
<span id="cb97-38"><a href="#cb97-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-39"><a href="#cb97-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb97-40"><a href="#cb97-40" aria-hidden="true" tabindex="-1"></a>input_text <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb97-41"><a href="#cb97-41" aria-hidden="true" tabindex="-1"></a><span class="st">10</span></span>
<span id="cb97-42"><a href="#cb97-42" aria-hidden="true" tabindex="-1"></a><span class="st">1 2</span></span>
<span id="cb97-43"><a href="#cb97-43" aria-hidden="true" tabindex="-1"></a><span class="st">2 8</span></span>
<span id="cb97-44"><a href="#cb97-44" aria-hidden="true" tabindex="-1"></a><span class="st">4 10</span></span>
<span id="cb97-45"><a href="#cb97-45" aria-hidden="true" tabindex="-1"></a><span class="st">5 9</span></span>
<span id="cb97-46"><a href="#cb97-46" aria-hidden="true" tabindex="-1"></a><span class="st">6 10</span></span>
<span id="cb97-47"><a href="#cb97-47" aria-hidden="true" tabindex="-1"></a><span class="st">7 9</span></span>
<span id="cb97-48"><a href="#cb97-48" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb97-49"><a href="#cb97-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-50"><a href="#cb97-50" aria-hidden="true" tabindex="-1"></a>n, edges <span class="op">=</span> parse_input(input_text)</span>
<span id="cb97-51"><a href="#cb97-51" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> min_edges_to_tree(n, edges)</span>
<span id="cb97-52"><a href="#cb97-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-18" class="level2" data-number="32.4">
<h2 data-number="32.4" class="anchored" data-anchor-id="explanation-18"><span class="header-section-number">32.4</span> Explanation</h2>
<ol type="1">
<li><strong>find_connected_components Function</strong>:
<ul>
<li>This function remains the same, using BFS to find the number of connected components in the graph.</li>
</ul></li>
<li><strong>min_edges_to_tree Function</strong>:
<ul>
<li>This function remains the same, calculating the minimum number of edges required to connect all components into a single tree.</li>
</ul></li>
<li><strong>parse_input Function</strong>:
<ul>
<li>This function takes the input as a string, splits it into lines, and processes the first line to get the number of nodes <code>n</code>.</li>
<li>The remaining lines are processed to extract the edges as tuples of integers.</li>
</ul></li>
<li><strong>Sample Input and Running the Code</strong>:
<ul>
<li>The sample input is provided as a multi-line string.</li>
<li>The <code>parse_input</code> function parses this string to extract <code>n</code> and the list of edges.</li>
<li>The <code>min_edges_to_tree</code> function calculates the result and prints it.</li>
</ul></li>
</ol>
<p>The expected output for the provided sample input is <code>3</code>, which is the minimum number of edges required to make the graph a tree.</p>
</section>
</section>
<section id="catalan-numbers-and-rna-secondary-structures" class="level1" data-number="33">
<h1 data-number="33"><span class="header-section-number">33</span> Catalan Numbers and RNA Secondary Structures</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/matching/">matching</a>&nbsp;in a&nbsp;<a href="https://rosalind.info/glossary/graph/">graph</a>&nbsp;is&nbsp;<a href="https://rosalind.info/glossary/noncrossing-matching/">noncrossing</a>&nbsp;if none of its&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;cros each other. If we assume that the&nbsp;n <a href="https://rosalind.info/glossary/node/">nodes</a>&nbsp;of this graph are arranged around a circle, and if we label these nodes with positive integers between 1 and&nbsp;n, then a matching is noncrossing as long as there are not edges&nbsp;<span class="math inline">\({i,j}\)</span>&nbsp;and&nbsp;<span class="math inline">\({k,l}\)</span>&nbsp;such that&nbsp;<span class="math inline">\(i&lt;k&lt;j&lt;l\)</span>.</p>
<p>A noncrossing matching of&nbsp;<a href="https://rosalind.info/glossary/basepair-edges/">basepair edges</a>&nbsp;in the&nbsp;<a href="https://rosalind.info/glossary/bonding-graph/">bonding graph</a>&nbsp;corresponding to an&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;will correspond to a possible secondary structure of the underlying RNA strand that lacks pseudoknots, as shown in&nbsp;<a href="https://rosalind.info/media/problems/cat/noncrossing_bonding_perfect.png">Figure 3</a>.</p>
<p>In this problem, we will consider counting noncrossing perfect matchings of basepair edges. As a motivating example of how to count noncrossing perfect matchings, let&nbsp;cn𝑐𝑛&nbsp;denote the number of noncrossing perfect matchings in the&nbsp;<a href="https://rosalind.info/glossary/complete-graph/">complete graph</a>&nbsp;<span class="math inline">\(K2n\)</span>. After setting&nbsp;<span class="math inline">\(c0=1\)</span>, we can see that&nbsp;<span class="math inline">\(c1\)</span>&nbsp;should equal 1 as well. As for the case of a general&nbsp;<span class="math inline">\(n\)</span>, say that the nodes of&nbsp;<span class="math inline">\(K2n\)</span> are labeled with the positive integers from 1 to&nbsp;<span class="math inline">\(2n\)</span>. We can join node 1 to any of the remaining&nbsp;<span class="math inline">\(2n−1\)</span>&nbsp;nodes; yet once we have chosen this node (say&nbsp;<span class="math inline">\(m\)</span>), we cannot add another edge to the matching that crosses the edge&nbsp;<span class="math inline">\({1,m}\)</span>. As a result, we must match all the edges on one side of&nbsp;<span class="math inline">\({1,m}\)</span>&nbsp;to each other. This requirement forces&nbsp;m𝑚&nbsp;to be even, so that we can write&nbsp;<span class="math inline">\(m=2k\)</span>&nbsp;for some positive integer&nbsp;<span class="math inline">\(k\)</span>.</p>
<p>There are&nbsp;<span class="math inline">\(2k−2\)</span>&nbsp;nodes on one side of&nbsp;<span class="math inline">\({1,m}\)</span>&nbsp;and&nbsp;<span class="math inline">\(2n−2k\)</span>&nbsp;nodes on the other side of&nbsp;{1,m}{1,𝑚}, so that in turn there will be&nbsp;<span class="math inline">\(ck−1⋅cn−k\)</span>&nbsp;different ways of forming a perfect matching on the remaining nodes of&nbsp;<span class="math inline">\(K2n\)</span>. If we let&nbsp;<span class="math inline">\(m\)</span>&nbsp;vary over all possible&nbsp;<span class="math inline">\(n−1\)</span> choices of even numbers between 1 and&nbsp;<span class="math inline">\(2n\)</span>, then we obtain the&nbsp;<a href="https://rosalind.info/glossary/recurrence-relation/">recurrence relation</a>&nbsp;<span class="math inline">\(c_{n}= \sum ^{n}_{k=1}ck−1⋅cn−k\)</span>. The resulting numbers&nbsp;cn𝑐𝑛&nbsp;counting noncrossing perfect matchings in&nbsp;<span class="math inline">\(K_{2n}\)</span>&nbsp;are called the&nbsp;<a href="https://rosalind.info/glossary/catalan-numbers/">Catalan numbers</a>, and they appear in a huge number of other settings.</p>
<p>Given:&nbsp;An RNA string&nbsp;s having the same number of occurrences of ‘A’ as ‘U’ and the same number of occurrences of ‘C’ as ‘G’. The length of the string is at most 300 bp.</p>
<p>Return:&nbsp;The total number of noncrossing perfect matchings of basepair edges in the bonding graph of&nbsp;<span class="math inline">\(s\)</span>,&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000.</p>
<section id="sample-dataset-32" class="level2" data-number="33.1">
<h2 data-number="33.1" class="anchored" data-anchor-id="sample-dataset-32"><span class="header-section-number">33.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_57
AUAU</code></pre>
</section>
<section id="sample-output-33" class="level2" data-number="33.2">
<h2 data-number="33.2" class="anchored" data-anchor-id="sample-output-33"><span class="header-section-number">33.2</span> Sample Output</h2>
<pre><code>2</code></pre>
</section>
<section id="solution-30" class="level2" data-number="33.3">
<h2 data-number="33.3" class="anchored" data-anchor-id="solution-30"><span class="header-section-number">33.3</span> Solution</h2>
<div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(rna):</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Given an RNA string consisting of {A, U, C, G},</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co">    calculates the number of non-overlapping perfect matchings.</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="co">    rna (str): The RNA string.</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a><span class="co">    int: The number of non-overlapping perfect matchings modulo 1,000,000.</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_non_crossing_matchings(rna) <span class="op">%</span> <span class="dv">1000000</span></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_non_crossing_matchings(rna):</span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Helper function that recursively calculates the number of non-crossing perfect matchings</span></span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a><span class="co">    of base pairs in the RNA string.</span></span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a><span class="co">    rna (str): The RNA string.</span></span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb100-22"><a href="#cb100-22" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb100-23"><a href="#cb100-23" aria-hidden="true" tabindex="-1"></a><span class="co">    int: The number of non-crossing perfect matchings modulo 1,000,000.</span></span>
<span id="cb100-24"><a href="#cb100-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb100-25"><a href="#cb100-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define complementary nucleotides</span></span>
<span id="cb100-26"><a href="#cb100-26" aria-hidden="true" tabindex="-1"></a>    mapping <span class="op">=</span> {</span>
<span id="cb100-27"><a href="#cb100-27" aria-hidden="true" tabindex="-1"></a>        <span class="st">"A"</span>: <span class="st">"U"</span>,</span>
<span id="cb100-28"><a href="#cb100-28" aria-hidden="true" tabindex="-1"></a>        <span class="st">"U"</span>: <span class="st">"A"</span>,</span>
<span id="cb100-29"><a href="#cb100-29" aria-hidden="true" tabindex="-1"></a>        <span class="st">"G"</span>: <span class="st">"C"</span>,</span>
<span id="cb100-30"><a href="#cb100-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">"C"</span>: <span class="st">"G"</span></span>
<span id="cb100-31"><a href="#cb100-31" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb100-32"><a href="#cb100-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-33"><a href="#cb100-33" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(rna)</span>
<span id="cb100-34"><a href="#cb100-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-35"><a href="#cb100-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If the length of the RNA string is odd, return 0</span></span>
<span id="cb100-36"><a href="#cb100-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb100-37"><a href="#cb100-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb100-38"><a href="#cb100-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-39"><a href="#cb100-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Memoization dictionary</span></span>
<span id="cb100-40"><a href="#cb100-40" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> {}</span>
<span id="cb100-41"><a href="#cb100-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-42"><a href="#cb100-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(lo, hi):</span>
<span id="cb100-43"><a href="#cb100-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb100-44"><a href="#cb100-44" aria-hidden="true" tabindex="-1"></a><span class="co">        Recursive helper function that computes the number of non-crossing perfect matchings</span></span>
<span id="cb100-45"><a href="#cb100-45" aria-hidden="true" tabindex="-1"></a><span class="co">        between indices lo and hi in the RNA string.</span></span>
<span id="cb100-46"><a href="#cb100-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-47"><a href="#cb100-47" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters:</span></span>
<span id="cb100-48"><a href="#cb100-48" aria-hidden="true" tabindex="-1"></a><span class="co">        lo (int): Start index of the substring.</span></span>
<span id="cb100-49"><a href="#cb100-49" aria-hidden="true" tabindex="-1"></a><span class="co">        hi (int): End index of the substring.</span></span>
<span id="cb100-50"><a href="#cb100-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-51"><a href="#cb100-51" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb100-52"><a href="#cb100-52" aria-hidden="true" tabindex="-1"></a><span class="co">        int: Number of non-crossing perfect matchings between indices lo and hi.</span></span>
<span id="cb100-53"><a href="#cb100-53" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb100-54"><a href="#cb100-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Base cases</span></span>
<span id="cb100-55"><a href="#cb100-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> lo <span class="op">&gt;=</span> hi:</span>
<span id="cb100-56"><a href="#cb100-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb100-57"><a href="#cb100-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (lo, hi) <span class="kw">in</span> dp:</span>
<span id="cb100-58"><a href="#cb100-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dp[(lo, hi)]</span>
<span id="cb100-59"><a href="#cb100-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb100-60"><a href="#cb100-60" aria-hidden="true" tabindex="-1"></a>        curr <span class="op">=</span> rna[lo]</span>
<span id="cb100-61"><a href="#cb100-61" aria-hidden="true" tabindex="-1"></a>        target <span class="op">=</span> mapping[curr]</span>
<span id="cb100-62"><a href="#cb100-62" aria-hidden="true" tabindex="-1"></a>        acc <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb100-63"><a href="#cb100-63" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb100-64"><a href="#cb100-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Iterate through the possible pairs</span></span>
<span id="cb100-65"><a href="#cb100-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lo <span class="op">+</span> <span class="dv">1</span>, hi <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span>):</span>
<span id="cb100-66"><a href="#cb100-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> rna[i] <span class="op">==</span> target:</span>
<span id="cb100-67"><a href="#cb100-67" aria-hidden="true" tabindex="-1"></a>                left <span class="op">=</span> helper(lo <span class="op">+</span> <span class="dv">1</span>, i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb100-68"><a href="#cb100-68" aria-hidden="true" tabindex="-1"></a>                right <span class="op">=</span> helper(i <span class="op">+</span> <span class="dv">1</span>, hi)</span>
<span id="cb100-69"><a href="#cb100-69" aria-hidden="true" tabindex="-1"></a>                acc <span class="op">+=</span> (left <span class="op">*</span> right) <span class="op">%</span> <span class="dv">1000000</span></span>
<span id="cb100-70"><a href="#cb100-70" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb100-71"><a href="#cb100-71" aria-hidden="true" tabindex="-1"></a>        dp[(lo, hi)] <span class="op">=</span> acc <span class="op">%</span> <span class="dv">1000000</span></span>
<span id="cb100-72"><a href="#cb100-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[(lo, hi)]</span>
<span id="cb100-73"><a href="#cb100-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-74"><a href="#cb100-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Call the helper function starting from index 0 to n-1</span></span>
<span id="cb100-75"><a href="#cb100-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> helper(<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb100-76"><a href="#cb100-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-77"><a href="#cb100-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Parsing the input</span></span>
<span id="cb100-78"><a href="#cb100-78" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb100-79"><a href="#cb100-79" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb100-80"><a href="#cb100-80" aria-hidden="true" tabindex="-1"></a>    current_label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb100-81"><a href="#cb100-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-82"><a href="#cb100-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb100-83"><a href="#cb100-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb100-84"><a href="#cb100-84" aria-hidden="true" tabindex="-1"></a>            current_label <span class="op">=</span> line[<span class="dv">1</span>:].strip()</span>
<span id="cb100-85"><a href="#cb100-85" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb100-86"><a href="#cb100-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb100-87"><a href="#cb100-87" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">+=</span> line.strip()</span>
<span id="cb100-88"><a href="#cb100-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-89"><a href="#cb100-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb100-90"><a href="#cb100-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-91"><a href="#cb100-91" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input in FASTA format</span></span>
<span id="cb100-92"><a href="#cb100-92" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb100-93"><a href="#cb100-93" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_9378</span></span>
<span id="cb100-94"><a href="#cb100-94" aria-hidden="true" tabindex="-1"></a><span class="st">AUAU</span></span>
<span id="cb100-95"><a href="#cb100-95" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb100-96"><a href="#cb100-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-97"><a href="#cb100-97" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the input to get the RNA string</span></span>
<span id="cb100-98"><a href="#cb100-98" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb100-99"><a href="#cb100-99" aria-hidden="true" tabindex="-1"></a>rna_string <span class="op">=</span> <span class="bu">list</span>(sequences.values())[<span class="dv">0</span>]</span>
<span id="cb100-100"><a href="#cb100-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-101"><a href="#cb100-101" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the result</span></span>
<span id="cb100-102"><a href="#cb100-102" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(solve(rna_string))  <span class="co"># Output should be 2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-19" class="level2" data-number="33.4">
<h2 data-number="33.4" class="anchored" data-anchor-id="explanation-19"><span class="header-section-number">33.4</span> Explanation</h2>
<ol type="1">
<li><code>solve(rna)</code> function:
<ul>
<li>This function is the entry point that computes and returns the number of non-overlapping perfect matchings of the RNA string modulo 1,000,000.</li>
<li>It calls <code>count_non_crossing_matchings(rna)</code> and returns its result modulo 1,000,000.</li>
</ul></li>
<li><code>count_non_crossing_matchings(rna)</code> function:
<ul>
<li>This is the core function that recursively computes the number of non-crossing perfect matchings.</li>
<li>It uses a helper function <code>helper(lo, hi)</code> which performs the recursive computation.</li>
<li>The function checks for edge cases such as odd length of RNA string and uses memoization (<code>dp</code> dictionary) to store already computed results to avoid redundant computations.</li>
<li>It iterates through possible pairs of nucleotides and calculates the number of matchings recursively using the defined base cases and recurrence relations.</li>
</ul></li>
<li><code>parse_fasta(fasta_str)</code> function:
<ul>
<li>This function parses the given FASTA formatted input string and extracts the RNA sequence from it.</li>
<li>It returns a dictionary where the key is the label (e.g., <code>Rosalind_9378</code>) and the value is the RNA sequence.</li>
</ul></li>
<li>Usage:
<ul>
<li>The sample input in FASTA format is parsed to obtain the RNA sequence.</li>
<li>The <code>solve</code> function is called with the RNA sequence as input, and the result is printed out.</li>
</ul></li>
</ol>
<p>This approach efficiently computes the desired number of non-crossing perfect matchings using recursion with memoization, ensuring that the computation remains feasible even for longer RNA sequences up to 300 base pairs.</p>
</section>
</section>
<section id="error-correction-in-reads" class="level1" data-number="34">
<h1 data-number="34"><span class="header-section-number">34</span> Error Correction in Reads</h1>
<p>As is the case with&nbsp;<a href="https://rosalind.info/glossary/point-mutation/">point mutations</a>, the most common type of sequencing error occurs when a single nucleotide from a read is interpreted incorrectly.</p>
<p>Given:&nbsp;A collection of up to 1000&nbsp;<a href="https://rosalind.info/glossary/read/">reads</a>&nbsp;of equal length (at most 50&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>) in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>. Some of these reads were generated with a single-nucleotide error. For each read&nbsp;<span class="math inline">\(s\)</span> in the dataset, one of the following applies:</p>
<ul>
<li><span class="math inline">\(s\)</span>&nbsp;was correctly sequenced and appears in the dataset at least twice (possibly as a&nbsp;<a href="https://rosalind.info/glossary/reverse-complement/">reverse complement</a>);</li>
<li><span class="math inline">\(s\)</span>&nbsp;is incorrect, it appears in the dataset exactly once, and its&nbsp;<a href="https://rosalind.info/glossary/hamming-distance/">Hamming distance</a>&nbsp;is 1 with respect to exactly one correct read in the dataset (or its reverse complement).</li>
</ul>
<p>Return:&nbsp;A list of all corrections in the form “[old read]-&gt;[new read]”. (Each correction must be a single symbol substitution, and you may return the corrections in any order.)</p>
<section id="sample-dataset-33" class="level2" data-number="34.1">
<h2 data-number="34.1" class="anchored" data-anchor-id="sample-dataset-33"><span class="header-section-number">34.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_52
TCATC
&gt;Rosalind_44
TTCAT
&gt;Rosalind_68
TCATC
&gt;Rosalind_28
TGAAA
&gt;Rosalind_95
GAGGA
&gt;Rosalind_66
TTTCA
&gt;Rosalind_33
ATCAA
&gt;Rosalind_21
TTGAT
&gt;Rosalind_18
TTTCC</code></pre>
</section>
<section id="sample-output-34" class="level2" data-number="34.2">
<h2 data-number="34.2" class="anchored" data-anchor-id="sample-output-34"><span class="header-section-number">34.2</span> Sample Output</h2>
<pre><code>TTCAT-&gt;TTGAT
GAGGA-&gt;GATGA
TTTCC-&gt;TTTCA</code></pre>
</section>
<section id="solution-31" class="level2" data-number="34.3">
<h2 data-number="34.3" class="anchored" data-anchor-id="solution-31"><span class="header-section-number">34.3</span> Solution</h2>
<ol type="1">
<li><strong>Parse the FASTA format input to extract reads.</strong></li>
<li><strong>Identify correct reads:</strong>
<ul>
<li>Reads that appear at least twice or appear once but their reverse complement also appears at least once.</li>
</ul></li>
<li><strong>Identify incorrect reads:</strong>
<ul>
<li>Reads that appear exactly once and do not have their reverse complement in the list of correct reads.</li>
</ul></li>
<li><strong>Correct the errors:</strong>
<ul>
<li>For each incorrect read, find the correct read that has a Hamming distance of 1 with the incorrect read or its reverse complement.</li>
</ul></li>
<li><strong>Output the corrections.</strong></li>
</ol>
</section>
<section id="step-by-step-implementation-1" class="level2" data-number="34.4">
<h2 data-number="34.4" class="anchored" data-anchor-id="step-by-step-implementation-1"><span class="header-section-number">34.4</span> Step-by-step Implementation</h2>
<p>Here’s the revised Python code to achieve the above steps:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses a FASTA formatted string.</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    current_label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>            current_label <span class="op">=</span> line[<span class="dv">1</span>:].strip()</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">+=</span> line.strip()</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna):</span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the reverse complement of a DNA string.</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>    complement <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'T'</span>, <span class="st">'T'</span>: <span class="st">'A'</span>, <span class="st">'C'</span>: <span class="st">'G'</span>, <span class="st">'G'</span>: <span class="st">'C'</span>}</span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span>.join(complement[base] <span class="cf">for</span> base <span class="kw">in</span> <span class="bu">reversed</span>(dna))</span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(s1, s2):</span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Hamming distance between two strings.</span></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> a, b <span class="kw">in</span> <span class="bu">zip</span>(s1, s2) <span class="cf">if</span> a <span class="op">!=</span> b)</span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_correct_reads(reads):</span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a><span class="co">    Identifies the correct reads in the dataset.</span></span>
<span id="cb103-31"><a href="#cb103-31" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb103-32"><a href="#cb103-32" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb103-33"><a href="#cb103-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb103-34"><a href="#cb103-34" aria-hidden="true" tabindex="-1"></a>    read_counts <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb103-35"><a href="#cb103-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> read <span class="kw">in</span> reads:</span>
<span id="cb103-36"><a href="#cb103-36" aria-hidden="true" tabindex="-1"></a>        read_counts[read] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb103-37"><a href="#cb103-37" aria-hidden="true" tabindex="-1"></a>        read_counts[reverse_complement(read)] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb103-38"><a href="#cb103-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb103-39"><a href="#cb103-39" aria-hidden="true" tabindex="-1"></a>    correct_reads <span class="op">=</span> {read <span class="cf">for</span> read, count <span class="kw">in</span> read_counts.items() <span class="cf">if</span> count <span class="op">&gt;</span> <span class="dv">1</span>}</span>
<span id="cb103-40"><a href="#cb103-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> correct_reads</span>
<span id="cb103-41"><a href="#cb103-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-42"><a href="#cb103-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_corrections(reads, correct_reads):</span>
<span id="cb103-43"><a href="#cb103-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb103-44"><a href="#cb103-44" aria-hidden="true" tabindex="-1"></a><span class="co">    Identifies corrections needed for the erroneous reads.</span></span>
<span id="cb103-45"><a href="#cb103-45" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb103-46"><a href="#cb103-46" aria-hidden="true" tabindex="-1"></a>    corrections <span class="op">=</span> []</span>
<span id="cb103-47"><a href="#cb103-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> read <span class="kw">in</span> reads:</span>
<span id="cb103-48"><a href="#cb103-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> read <span class="kw">not</span> <span class="kw">in</span> correct_reads:</span>
<span id="cb103-49"><a href="#cb103-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> correct_read <span class="kw">in</span> correct_reads:</span>
<span id="cb103-50"><a href="#cb103-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> hamming_distance(read, correct_read) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb103-51"><a href="#cb103-51" aria-hidden="true" tabindex="-1"></a>                    corrections.append(<span class="ss">f"</span><span class="sc">{</span>read<span class="sc">}</span><span class="ss">-&gt;</span><span class="sc">{</span>correct_read<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb103-52"><a href="#cb103-52" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb103-53"><a href="#cb103-53" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> hamming_distance(read, reverse_complement(correct_read)) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb103-54"><a href="#cb103-54" aria-hidden="true" tabindex="-1"></a>                    corrections.append(<span class="ss">f"</span><span class="sc">{</span>read<span class="sc">}</span><span class="ss">-&gt;</span><span class="sc">{</span>reverse_complement(correct_read)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb103-55"><a href="#cb103-55" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb103-56"><a href="#cb103-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> corrections</span>
<span id="cb103-57"><a href="#cb103-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-58"><a href="#cb103-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input in FASTA format</span></span>
<span id="cb103-59"><a href="#cb103-59" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb103-60"><a href="#cb103-60" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_52</span></span>
<span id="cb103-61"><a href="#cb103-61" aria-hidden="true" tabindex="-1"></a><span class="st">TCATC</span></span>
<span id="cb103-62"><a href="#cb103-62" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_44</span></span>
<span id="cb103-63"><a href="#cb103-63" aria-hidden="true" tabindex="-1"></a><span class="st">TTCAT</span></span>
<span id="cb103-64"><a href="#cb103-64" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_68</span></span>
<span id="cb103-65"><a href="#cb103-65" aria-hidden="true" tabindex="-1"></a><span class="st">TCATC</span></span>
<span id="cb103-66"><a href="#cb103-66" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_28</span></span>
<span id="cb103-67"><a href="#cb103-67" aria-hidden="true" tabindex="-1"></a><span class="st">TGAAA</span></span>
<span id="cb103-68"><a href="#cb103-68" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_95</span></span>
<span id="cb103-69"><a href="#cb103-69" aria-hidden="true" tabindex="-1"></a><span class="st">GAGGA</span></span>
<span id="cb103-70"><a href="#cb103-70" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_66</span></span>
<span id="cb103-71"><a href="#cb103-71" aria-hidden="true" tabindex="-1"></a><span class="st">TTTCA</span></span>
<span id="cb103-72"><a href="#cb103-72" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_33</span></span>
<span id="cb103-73"><a href="#cb103-73" aria-hidden="true" tabindex="-1"></a><span class="st">ATCAA</span></span>
<span id="cb103-74"><a href="#cb103-74" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_21</span></span>
<span id="cb103-75"><a href="#cb103-75" aria-hidden="true" tabindex="-1"></a><span class="st">TTGAT</span></span>
<span id="cb103-76"><a href="#cb103-76" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_18</span></span>
<span id="cb103-77"><a href="#cb103-77" aria-hidden="true" tabindex="-1"></a><span class="st">TTTCC</span></span>
<span id="cb103-78"><a href="#cb103-78" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb103-79"><a href="#cb103-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-80"><a href="#cb103-80" aria-hidden="true" tabindex="-1"></a><span class="co"># Parsing the input</span></span>
<span id="cb103-81"><a href="#cb103-81" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb103-82"><a href="#cb103-82" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> <span class="bu">list</span>(sequences.values())</span>
<span id="cb103-83"><a href="#cb103-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-84"><a href="#cb103-84" aria-hidden="true" tabindex="-1"></a><span class="co"># Find correct reads</span></span>
<span id="cb103-85"><a href="#cb103-85" aria-hidden="true" tabindex="-1"></a>correct_reads <span class="op">=</span> find_correct_reads(reads)</span>
<span id="cb103-86"><a href="#cb103-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-87"><a href="#cb103-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Find necessary corrections</span></span>
<span id="cb103-88"><a href="#cb103-88" aria-hidden="true" tabindex="-1"></a>corrections <span class="op">=</span> find_corrections(reads, correct_reads)</span>
<span id="cb103-89"><a href="#cb103-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-90"><a href="#cb103-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the corrections</span></span>
<span id="cb103-91"><a href="#cb103-91" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> correction <span class="kw">in</span> corrections:</span>
<span id="cb103-92"><a href="#cb103-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(correction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-20" class="level2" data-number="34.5">
<h2 data-number="34.5" class="anchored" data-anchor-id="explanation-20"><span class="header-section-number">34.5</span> Explanation</h2>
<ol type="1">
<li><strong><code>parse_fasta(fasta_str)</code></strong>: Parses the input FASTA formatted string to extract the reads.</li>
<li><strong><code>reverse_complement(dna)</code></strong>: Returns the reverse complement of a given DNA string.</li>
<li><strong><code>hamming_distance(s1, s2)</code></strong>: Computes the Hamming distance between two strings.</li>
<li><strong><code>find_correct_reads(reads)</code></strong>: Identifies reads that are correct (appear at least twice considering both original and reverse complement).</li>
<li><strong><code>find_corrections(reads, correct_reads)</code></strong>: Identifies the necessary corrections for erroneous reads by checking each read against the set of correct reads and their reverse complements.</li>
</ol>
</section>
</section>
<section id="counting-phylogenetic-ancestors" class="level1" data-number="35">
<h1 data-number="35"><span class="header-section-number">35</span> Counting Phylogenetic Ancestors</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/binary-tree/">binary tree</a>&nbsp;is a tree in which each node has&nbsp;<a href="https://rosalind.info/glossary/degree/">degree</a>&nbsp;equal to at most 3. The binary tree will be our main tool in the construction of phylogenies.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;is a tree in which one node (the&nbsp;<a href="https://rosalind.info/glossary/root/">root</a>) is set aside to serve as the pinnacle of the tree. A standard&nbsp;<a href="https://rosalind.info/glossary/graph-theory/">graph theory</a>&nbsp;exercise is to verify that for any two&nbsp;<a href="https://rosalind.info/glossary/node/">nodes</a>&nbsp;of a tree, exactly one path connects the nodes. In a rooted tree, every node&nbsp;<span class="math inline">\(v\)</span>&nbsp;will therefore have a single&nbsp;<a href="https://rosalind.info/glossary/parent/">parent</a>, or the unique node&nbsp;<span class="math inline">\(w\)</span>&nbsp;such that the&nbsp;<a href="https://rosalind.info/glossary/path/">path</a>&nbsp;from&nbsp;<span class="math inline">\(v\)</span>&nbsp;to the root contains&nbsp;<span class="math inline">\({v,w}\)</span>. Any other node&nbsp;<span class="math inline">\(x\)</span>&nbsp;<a href="https://rosalind.info/glossary/adjacent-nodes/">adjacent</a>&nbsp;to&nbsp;<span class="math inline">\(v\)</span>&nbsp;is called a&nbsp;<a href="https://rosalind.info/glossary/child/">child</a>&nbsp;of&nbsp;<span class="math inline">\(v\)</span>&nbsp;because&nbsp;<span class="math inline">\(v\)</span>&nbsp;must be the parent of&nbsp;<span class="math inline">\(x\)</span>; note that a node may have multiple children. In other words, a rooted tree possesses an ordered hierarchy from the root down to its&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>, and as a result, we may often view a rooted tree with undirected edges as a&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">directed graph</a>&nbsp;in which each edge is oriented from parent to child. We should already be familiar with this idea; it’s how the&nbsp;<a href="http://rosalind.info/problems/as-graph/">Rosalind problem tree</a>&nbsp;works!</p>
<p>Even though a binary tree can include nodes having degree 2, an&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary tree</a>&nbsp;is defined more specifically: all internal nodes have degree 3. In turn, a&nbsp;<a href="https://rosalind.info/glossary/rooted-binary-tree/">rooted binary tree</a>&nbsp;is such that only the root has degree 2 (all other internal nodes have degree 3).</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(3≤n≤10000\)</span>).</p>
<p>Return:&nbsp;The number of internal nodes of any unrooted binary tree having&nbsp;<span class="math inline">\(n\)</span>&nbsp;leaves.</p>
<section id="sample-dataset-34" class="level2" data-number="35.1">
<h2 data-number="35.1" class="anchored" data-anchor-id="sample-dataset-34"><span class="header-section-number">35.1</span> Sample Dataset</h2>
<pre><code>4</code></pre>
</section>
<section id="sample-output-35" class="level2" data-number="35.2">
<h2 data-number="35.2" class="anchored" data-anchor-id="sample-output-35"><span class="header-section-number">35.2</span> Sample Output</h2>
<pre><code>2</code></pre>
</section>
<section id="solution-32" class="level2" data-number="35.3">
<h2 data-number="35.3" class="anchored" data-anchor-id="solution-32"><span class="header-section-number">35.3</span> Solution</h2>
<p>To solve the problem of finding the number of internal nodes in an unrooted binary tree given <span class="math inline">\(n\)</span> leaves, let’s delve into some tree properties and the characteristics of unrooted binary trees.</p>
</section>
<section id="key-concepts-and-approach" class="level2" data-number="35.4">
<h2 data-number="35.4" class="anchored" data-anchor-id="key-concepts-and-approach"><span class="header-section-number">35.4</span> Key Concepts and Approach</h2>
<ol type="1">
<li><strong>Tree Properties</strong>:
<ul>
<li>An unrooted binary tree is a tree where every internal node has exactly three connections (degree 3), and each leaf node has one connection (degree 1).</li>
</ul></li>
<li><strong>Leaves and Internal Nodes Relationship</strong>:
<ul>
<li>In any tree, if we let <span class="math inline">\(L\)</span> be the number of leaves and <span class="math inline">\(I\)</span> be the number of internal nodes, for an unrooted binary tree, there is a specific relationship:</li>
<li>For every new leaf added to maintain the tree as binary, you essentially add a new internal node to accommodate the structure.</li>
</ul></li>
<li><strong>Mathematical Relationship</strong>:
<ul>
<li>It is known that for an unrooted binary tree with <span class="math inline">\(n\)</span> leaves, the number of internal nodes <span class="math inline">\(I\)</span> is given by: [ I = n - 2 ]</li>
<li>This is derived from the fact that the total number of nodes in an unrooted binary tree with <span class="math inline">\(n\)</span> leaves is <span class="math inline">\(2n - 2\)</span>. Out of these, <span class="math inline">\(n\)</span> are leaves, and the remaining <span class="math inline">\(n - 2\)</span> are internal nodes.</li>
</ul></li>
</ol>
</section>
<section id="implementation-4" class="level2" data-number="35.5">
<h2 data-number="35.5" class="anchored" data-anchor-id="implementation-4"><span class="header-section-number">35.5</span> Implementation</h2>
<p>Given this understanding, the implementation to find the number of internal nodes in an unrooted binary tree with <span class="math inline">\(n\)</span> leaves is straightforward. Here’s the Python code to accomplish this:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_internal_nodes(n):</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_internal_nodes(n))  <span class="co"># Output should be 2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="k-mer-composition" class="level1" data-number="36">
<h1 data-number="36"><span class="header-section-number">36</span> k-Mer Composition</h1>
<p>For a fixed positive integer&nbsp;<span class="math inline">\(k\)</span>, order all possible k-mers taken from an underlying alphabet&nbsp;<a href="https://rosalind.info/glossary/lexicographic-order/">lexicographically</a>.</p>
<p>Then the k-mer composition of a string&nbsp;<span class="math inline">\(s\)</span>&nbsp;can be represented by an&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;for which&nbsp;<span class="math inline">\(A[m]\)</span>&nbsp;denotes the number of times that the&nbsp;<span class="math inline">\(m\)</span>th k-mer (with respect to the lexicographic order) appears in&nbsp;<span class="math inline">\(s\)</span>.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(having length at most 100&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;The 4-mer composition of&nbsp;<span class="math inline">\(s\)</span>.</p>
<section id="sample-dataset-35" class="level2" data-number="36.1">
<h2 data-number="36.1" class="anchored" data-anchor-id="sample-dataset-35"><span class="header-section-number">36.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_6431
CTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG
CCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT
TTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA
AATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG
GGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA
CTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA
CCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG</code></pre>
</section>
<section id="sample-output-36" class="level2" data-number="36.2">
<h2 data-number="36.2" class="anchored" data-anchor-id="sample-output-36"><span class="header-section-number">36.2</span> Sample Output</h2>
<pre><code>4 1 4 3 0 1 1 5 1 3 1 2 2 1 2 0 1 1 3 1 2 1 3 1 1 1 1 2 2 5 1 3 0 2 2 1 1 1 1 3 1 0 0 1 5 5 1 5 0 2 0 2 1 2 1 1 1 2 0 1 0 0 1 1 3 2 1 0 3 2 3 0 0 2 0 8 0 0 1 0 2 1 3 0 0 0 1 4 3 2 1 1 3 1 2 1 3 1 2 1 2 1 1 1 2 3 2 1 1 0 1 1 3 2 1 2 6 2 1 1 1 2 3 3 3 2 3 0 3 2 1 1 0 0 1 4 3 0 1 5 0 2 0 1 2 1 3 0 1 2 2 1 1 0 3 0 0 4 5 0 3 0 2 1 1 3 0 3 2 2 1 1 0 2 1 0 2 2 1 2 0 2 2 5 2 2 1 1 2 1 2 2 2 2 1 1 3 4 0 2 1 1 0 1 2 2 1 1 1 5 2 0 3 2 1 1 2 2 3 0 3 0 1 3 1 2 3 0 2 1 2 2 1 2 3 0 1 2 3 1 1 3 1 0 1 1 3 0 2 1 2 2 0 2 1 1</code></pre>
</section>
<section id="solution-33" class="level2" data-number="36.3">
<h2 data-number="36.3" class="anchored" data-anchor-id="solution-33"><span class="header-section-number">36.3</span> Solution</h2>
<p>To solve the problem of finding the 4-mer composition of a given DNA string, we need to follow these steps:</p>
<ol type="1">
<li><strong>Parse the input FASTA format to extract the DNA sequence.</strong></li>
<li><strong>Generate all possible 4-mers from the given DNA alphabet.</strong></li>
<li><strong>Count the occurrences of each 4-mer in the DNA sequence.</strong></li>
<li><strong>Output the counts in lexicographical order of the 4-mers.</strong></li>
</ol>
</section>
<section id="detailed-explanation" class="level2" data-number="36.4">
<h2 data-number="36.4" class="anchored" data-anchor-id="detailed-explanation"><span class="header-section-number">36.4</span> Detailed Explanation</h2>
<ol type="1">
<li><p><strong>Parsing the FASTA format</strong>: The input DNA sequence is provided in FASTA format. We need to extract the actual DNA string from this format.</p></li>
<li><p><strong>Generating all possible 4-mers</strong>: A 4-mer is a sequence of 4 nucleotides. Since the DNA alphabet consists of {A, C, G, T}, there are $4^4 = 256) possible 4-mers. We can generate these 4-mers lexicographically (sorted order).</p></li>
<li><p><strong>Counting occurrences of each 4-mer</strong>: We will slide a window of length 4 acros the DNA sequence and count how many times each 4-mer appears.</p></li>
<li><p><strong>Output the results</strong>: We output the counts of each 4-mer in the lexicographical order.</p></li>
</ol>
</section>
<section id="python-implementation-1" class="level2" data-number="36.5">
<h2 data-number="36.5" class="anchored" data-anchor-id="python-implementation-1"><span class="header-section-number">36.5</span> Python Implementation</h2>
<p>Here is the complete Python code that implements the above steps:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    current_label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>            current_label <span class="op">=</span> line[<span class="dv">1</span>:].strip()</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">+=</span> line.strip()</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_kmers(k, alphabet<span class="op">=</span><span class="st">'ACGT'</span>):</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="st">''</span>.join(p) <span class="cf">for</span> p <span class="kw">in</span> product(alphabet, repeat<span class="op">=</span>k)]</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_kmers(dna, k):</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>    kmer_counts <span class="op">=</span> {}</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(dna) <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>        kmer <span class="op">=</span> dna[i:i<span class="op">+</span>k]</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> kmer <span class="kw">in</span> kmer_counts:</span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>            kmer_counts[kmer] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>            kmer_counts[kmer] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kmer_counts</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kmer_composition(dna, k<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>    kmers <span class="op">=</span> generate_kmers(k)</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>    kmer_counts <span class="op">=</span> count_kmers(dna, k)</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [kmer_counts.get(kmer, <span class="dv">0</span>) <span class="cf">for</span> kmer <span class="kw">in</span> kmers]</span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input in FASTA format</span></span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_6431</span></span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a><span class="st">CTTCGAAAGTTTGGGCCGAGTCTTACAGTCGGTCTTGAAGCAAAGTAACGAACTCCACGG</span></span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a><span class="st">CCCTGACTACCGAACCAGTTGTGAGTACTCAACTGGGTGAGAGTGCAGTCCCTATTGAGT</span></span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a><span class="st">TTCCGAGACTCACCGGGATTTTCGATCCAGCCTCAGTCCAGTCTTGTGGCCAACTCACCA</span></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true" tabindex="-1"></a><span class="st">AATGACGTTGGAATATCCCTGTCTAGCTCACGCAGTACTTAGTAAGAGGTCGCTGCAGCG</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true" tabindex="-1"></a><span class="st">GGGCAAGGAGATCGGAAAATGTGCTCTATATGCGACTAAAGCTCCTAACTTACACGTAGA</span></span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true" tabindex="-1"></a><span class="st">CTTGCCCGTGTTAAAAACTCGGCTCACATGCTGTCTGCGGCTGGCTGTATACAGTATCTA</span></span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true" tabindex="-1"></a><span class="st">CCTAATACCCTTCAGTTCGCCGCACAAAAGCTGGGAGTTACCGCGGAAATCACAG</span></span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Parsing the input</span></span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb109-49"><a href="#cb109-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-50"><a href="#cb109-50" aria-hidden="true" tabindex="-1"></a><span class="co"># There should be only one sequence in the given input</span></span>
<span id="cb109-51"><a href="#cb109-51" aria-hidden="true" tabindex="-1"></a>dna_string <span class="op">=</span> <span class="bu">list</span>(sequences.values())[<span class="dv">0</span>]</span>
<span id="cb109-52"><a href="#cb109-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-53"><a href="#cb109-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Getting the 4-mer composition</span></span>
<span id="cb109-54"><a href="#cb109-54" aria-hidden="true" tabindex="-1"></a>composition <span class="op">=</span> kmer_composition(dna_string, k<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb109-55"><a href="#cb109-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-56"><a href="#cb109-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the result</span></span>
<span id="cb109-57"><a href="#cb109-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, composition)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-4" class="level2" data-number="36.6">
<h2 data-number="36.6" class="anchored" data-anchor-id="explanation-of-the-code-4"><span class="header-section-number">36.6</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>parse_fasta(fasta_str)</strong>: This function parses the input FASTA format string and returns a dictionary of sequences.</li>
<li><strong>generate_kmers(k, alphabet=‘ACGT’)</strong>: This function generates all possible k-mers of length <code>k</code> using the given alphabet.</li>
<li><strong>count_kmers(dna, k)</strong>: This function counts the occurrences of each k-mer in the DNA sequence.</li>
<li><strong>kmer_composition(dna, k=4)</strong>: This function calculates the k-mer composition by using the previous two functions. It returns a list of counts of each k-mer in lexicographical order.</li>
<li><strong>The main block</strong>: Parses the input, extracts the DNA sequence, computes the 4-mer composition, and prints the results.</li>
</ol>
</section>
</section>
<section id="speeding-up-motif-finding" class="level1" data-number="37">
<h1 data-number="37"><span class="header-section-number">37</span> Speeding Up Motif Finding</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefix</a>&nbsp;of a length&nbsp;<span class="math inline">\(n\)</span>&nbsp;string&nbsp;<span class="math inline">\(s\)</span>&nbsp;is a substring&nbsp;<span class="math inline">\(s[1:j]\)</span>; a&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;is a substring&nbsp;<span class="math inline">\(s[k:n]\)</span>.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/failure-array/">failure array</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;is an&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(P\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;for which&nbsp;<span class="math inline">\(P[k]\)</span>&nbsp;is the length of the longest substring&nbsp;<span class="math inline">\(s[j:k]\)</span>&nbsp;that is equal to some prefix&nbsp;<span class="math inline">\(s[1:k−j+1]\)</span>, where&nbsp;<span class="math inline">\(j\)</span>&nbsp;cannot equal&nbsp;11&nbsp;(otherwise,&nbsp;<span class="math inline">\(P[k]\)</span>&nbsp;would always equal&nbsp;<span class="math inline">\(k\)</span>). By convention,&nbsp;<span class="math inline">\(P[1]=0\)</span>.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;(of length at most 100&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;The failure array of&nbsp;<span class="math inline">\(s\)</span>.</p>
<section id="sample-dataset-36" class="level2" data-number="37.1">
<h2 data-number="37.1" class="anchored" data-anchor-id="sample-dataset-36"><span class="header-section-number">37.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_87
CAGCATGGTATCACAGCAGAG</code></pre>
</section>
<section id="sample-output-37" class="level2" data-number="37.2">
<h2 data-number="37.2" class="anchored" data-anchor-id="sample-output-37"><span class="header-section-number">37.2</span> Sample Output</h2>
<pre><code>0 0 0 1 2 0 0 0 0 0 0 1 2 1 2 3 4 5 3 0 0</code></pre>
</section>
<section id="solution-34" class="level2" data-number="37.3">
<h2 data-number="37.3" class="anchored" data-anchor-id="solution-34"><span class="header-section-number">37.3</span> Solution</h2>
<p>To solve the problem of computing the failure array of a given DNA string in FASTA format, we need to follow these steps:</p>
<ol type="1">
<li><strong>Parse the input FASTA format to extract the DNA sequence.</strong></li>
<li><strong>Compute the failure array using the Knuth-Morris-Prat (KMP) algorithm.</strong></li>
<li><strong>Output the failure array.</strong></li>
</ol>
</section>
<section id="detailed-explanation-1" class="level2" data-number="37.4">
<h2 data-number="37.4" class="anchored" data-anchor-id="detailed-explanation-1"><span class="header-section-number">37.4</span> Detailed Explanation</h2>
<ol type="1">
<li><p><strong>Parsing the FASTA format</strong>: We need to extract the actual DNA string from the provided FASTA format.</p></li>
<li><p><strong>Computing the Failure Array</strong>: The failure array is computed using the KMP preprocessing algorithm. The failure array <code>P</code> at position <code>k</code> represents the length of the longest prefix of the substring <code>s[1:k]</code> that is also a suffix of this substring.</p></li>
</ol>
</section>
<section id="python-implementation-2" class="level2" data-number="37.5">
<h2 data-number="37.5" class="anchored" data-anchor-id="python-implementation-2"><span class="header-section-number">37.5</span> Python Implementation</h2>
<p>Here is the complete Python code that implements the above steps:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses a FASTA format string and returns the DNA sequence.</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>            sequences.append(line.strip())</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span>.join(sequences)</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_failure_array(s):</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the failure array for a given string s using the KMP algorithm.</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> k <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s[k] <span class="op">!=</span> s[i]:</span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> P[k <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[k] <span class="op">==</span> s[i]:</span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>            k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>        P[i] <span class="op">=</span> k</span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P</span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input in FASTA format</span></span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_87</span></span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a><span class="st">CAGCATGGTATCACAGCAGAG</span></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Parsing the input</span></span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a>dna_string <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-39"><a href="#cb112-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Computing the failure array</span></span>
<span id="cb112-40"><a href="#cb112-40" aria-hidden="true" tabindex="-1"></a>failure_array <span class="op">=</span> compute_failure_array(dna_string)</span>
<span id="cb112-41"><a href="#cb112-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-42"><a href="#cb112-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the result</span></span>
<span id="cb112-43"><a href="#cb112-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, failure_array)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-5" class="level2" data-number="37.6">
<h2 data-number="37.6" class="anchored" data-anchor-id="explanation-of-the-code-5"><span class="header-section-number">37.6</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>parse_fasta(fasta_str)</strong>: This function parses the input FASTA format string and returns the concatenated DNA sequence.</li>
<li><strong>compute_failure_array(s)</strong>: This function computes the failure array for the string <code>s</code> using the KMP algorithm.
<ul>
<li>Initialize an array <code>P</code> of length <code>n</code> with zeros.</li>
<li>Iterate through the string <code>s</code> from the second character to the end.</li>
<li>For each character, update the value of <code>k</code> to the length of the longest prefix which is also a suffix for the substring <code>s[1:i+1]</code>.</li>
<li>Store the value of <code>k</code> in <code>P[i]</code>.</li>
</ul></li>
<li><strong>The main block</strong>:
<ul>
<li>Parse the input FASTA format string to extract the DNA sequence.</li>
<li>Compute the failure array for the DNA sequence.</li>
<li>Print the failure array as a space-separated string.</li>
</ul></li>
</ol>
</section>
</section>
<section id="finding-a-shared-spliced-motif" class="level1" data-number="38">
<h1 data-number="38"><span class="header-section-number">38</span> Finding a Shared Spliced Motif</h1>
<p>A string&nbsp;<span class="math inline">\(u\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/common-subsequence/">common subsequence</a>&nbsp;of strings&nbsp;s and&nbsp;t&nbsp;if the symbols of&nbsp;u𝑢&nbsp;appear in order as a&nbsp;<a href="https://rosalind.info/glossary/subsequence/">subsequence</a>&nbsp;of both&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. For example, “ACTG” is a common subsequence of “A<strong>A</strong>C<strong>C</strong>T<strong>T</strong>G<strong>G</strong>” and “<strong>A</strong>CA<strong>CTG</strong>TGA”.</p>
<p>Analogously to the definition of&nbsp;<a href="https://rosalind.info/glossary/longest-common-substring/">longest common substring</a>,&nbsp;<span class="math inline">\(u\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/longest-common-subsequence/">longest common subsequence</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;if there does not exist a longer common subsequence of the two strings. Continuing our above example, “ACCTTG” is a longest common subsequence of “A<strong>ACCTTG</strong>G” and “<strong>AC</strong>A<strong>CT</strong>G<strong>TG</strong>A”, as is “AACTGG”.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;(each having length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;A longest common subsequence of&nbsp;s and&nbsp;<span class="math inline">\(t\)</span>. (If more than one solution exists, you may return any one.)</p>
<section id="sample-dataset-37" class="level2" data-number="38.1">
<h2 data-number="38.1" class="anchored" data-anchor-id="sample-dataset-37"><span class="header-section-number">38.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_23
AACCTTGG
&gt;Rosalind_64
ACACTGTGA</code></pre>
</section>
<section id="sample-output-38" class="level2" data-number="38.2">
<h2 data-number="38.2" class="anchored" data-anchor-id="sample-output-38"><span class="header-section-number">38.2</span> Sample Output</h2>
<pre><code>AACTGG</code></pre>
</section>
<section id="solution-35" class="level2" data-number="38.3">
<h2 data-number="38.3" class="anchored" data-anchor-id="solution-35"><span class="header-section-number">38.3</span> Solution</h2>
<p>To solve the problem of finding the longest common subsequence (LCS) between two DNA strings provided in FASTA format, you can use dynamic programming. Here’s a step-by-step explanation and implementation:</p>
</section>
<section id="steps-to-solve-the-problem-6" class="level2" data-number="38.4">
<h2 data-number="38.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-6"><span class="header-section-number">38.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><p><strong>Parse the FASTA Input</strong>: Extract the DNA sequences from the FASTA format input.</p></li>
<li><p><strong>Compute the Longest Common Subsequence</strong>: Use a dynamic programming approach to find the LCS. The idea is to use a 2D table where <code>dp[i][j]</code> represents the length of the longest common subsequence of the substrings <code>s[0:i]</code> and <code>t[0:j]</code>.</p></li>
<li><p><strong>Reconstruct the LCS</strong>: Once the table is filled, backtrack to reconstruct the longest common subsequence from the table.</p></li>
</ol>
</section>
<section id="detailed-explanation-2" class="level2" data-number="38.5">
<h2 data-number="38.5" class="anchored" data-anchor-id="detailed-explanation-2"><span class="header-section-number">38.5</span> Detailed Explanation</h2>
<ol type="1">
<li><strong>Dynamic Programming Table Initialization</strong>:
<ul>
<li>Create a 2D list <code>dp</code> where <code>dp[i][j]</code> contains the length of the LCS of substrings <code>s[0:i]</code> and <code>t[0:j]</code>.</li>
<li>Initialize the first row and first column of the table to 0 because an LCS with an empty string is 0.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>Iterate through each character of <code>s</code> and <code>t</code>. If the characters match, update <code>dp[i][j]</code> based on <code>dp[i-1][j-1] + 1</code>.</li>
<li>If they do not match, set <code>dp[i][j]</code> to the maximum of <code>dp[i-1][j]</code> and <code>dp[i][j-1]</code>.</li>
</ul></li>
<li><strong>Backtracking to Find LCS</strong>:
<ul>
<li>Start from <code>dp[len(s)][len(t)]</code> and trace back to build the LCS string by comparing characters and using the DP table to decide whether to include a character or move in a specific direction.</li>
</ul></li>
</ol>
</section>
<section id="python-implementation-3" class="level2" data-number="38.6">
<h2 data-number="38.6" class="anchored" data-anchor-id="python-implementation-3"><span class="header-section-number">38.6</span> Python Implementation</h2>
<p>Here’s the Python code to achieve the above steps:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses a FASTA format string and returns the DNA sequences.</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> []</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sequence:</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">""</span>.join(current_sequence))</span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>                current_sequence <span class="op">=</span> []</span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>            current_sequence.append(line.strip())</span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_sequence:</span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">""</span>.join(current_sequence))</span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_common_subsequence(s, t):</span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Finds the longest common subsequence between strings s and t.</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a 2D table to store lengths of longest common subsequences.</span></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the table</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb115-29"><a href="#cb115-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb115-30"><a href="#cb115-30" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb115-31"><a href="#cb115-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb115-32"><a href="#cb115-32" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb115-33"><a href="#cb115-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb115-34"><a href="#cb115-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack to find the LCS</span></span>
<span id="cb115-35"><a href="#cb115-35" aria-hidden="true" tabindex="-1"></a>    lcs <span class="op">=</span> []</span>
<span id="cb115-36"><a href="#cb115-36" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> m, n</span>
<span id="cb115-37"><a href="#cb115-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb115-38"><a href="#cb115-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb115-39"><a href="#cb115-39" aria-hidden="true" tabindex="-1"></a>            lcs.append(s[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb115-40"><a href="#cb115-40" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb115-41"><a href="#cb115-41" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb115-42"><a href="#cb115-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">&gt;</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb115-43"><a href="#cb115-43" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb115-44"><a href="#cb115-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb115-45"><a href="#cb115-45" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb115-46"><a href="#cb115-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb115-47"><a href="#cb115-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(<span class="bu">reversed</span>(lcs))</span>
<span id="cb115-48"><a href="#cb115-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-49"><a href="#cb115-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input in FASTA format</span></span>
<span id="cb115-50"><a href="#cb115-50" aria-hidden="true" tabindex="-1"></a>fasta_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb115-51"><a href="#cb115-51" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_23</span></span>
<span id="cb115-52"><a href="#cb115-52" aria-hidden="true" tabindex="-1"></a><span class="st">AACCTTGG</span></span>
<span id="cb115-53"><a href="#cb115-53" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_64</span></span>
<span id="cb115-54"><a href="#cb115-54" aria-hidden="true" tabindex="-1"></a><span class="st">ACACTGTGA</span></span>
<span id="cb115-55"><a href="#cb115-55" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb115-56"><a href="#cb115-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-57"><a href="#cb115-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Parsing the input</span></span>
<span id="cb115-58"><a href="#cb115-58" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(fasta_input)</span>
<span id="cb115-59"><a href="#cb115-59" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> sequences[<span class="dv">0</span>]</span>
<span id="cb115-60"><a href="#cb115-60" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> sequences[<span class="dv">1</span>]</span>
<span id="cb115-61"><a href="#cb115-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-62"><a href="#cb115-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Finding the longest common subsequence</span></span>
<span id="cb115-63"><a href="#cb115-63" aria-hidden="true" tabindex="-1"></a>lcs <span class="op">=</span> longest_common_subsequence(s, t)</span>
<span id="cb115-64"><a href="#cb115-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-65"><a href="#cb115-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the result</span></span>
<span id="cb115-66"><a href="#cb115-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lcs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-6" class="level2" data-number="38.7">
<h2 data-number="38.7" class="anchored" data-anchor-id="explanation-of-the-code-6"><span class="header-section-number">38.7</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>parse_fasta(fasta_str)</strong>: This function parses the FASTA format string and returns a list of DNA sequences.</li>
<li><strong>longest_common_subsequence(s, t)</strong>: This function calculates the longest common subsequence using a dynamic programming table and then backtracks to reconstruct the LCS.</li>
<li><strong>Main Execution</strong>:
<ul>
<li>Parse the input FASTA string to get the DNA sequences.</li>
<li>Compute the LCS using the <code>longest_common_subsequence</code> function.</li>
<li>Print the result.</li>
</ul></li>
</ol>
<p>This code will correctly find and output the longest common subsequence of the given DNA sequences.</p>
</section>
</section>
<section id="ordering-strings-of-varying-length-lexicographically" class="level1" data-number="39">
<h1 data-number="39"><span class="header-section-number">39</span> Ordering Strings of Varying Length Lexicographically</h1>
<p>Say that we have strings&nbsp;<span class="math inline">\(s=s1s2⋯sm\)</span>&nbsp;and&nbsp;<span class="math inline">\(t=t1t2⋯tn\)</span>&nbsp;with&nbsp;<span class="math inline">\(m&lt;n\)</span>. Consider the substring&nbsp;<span class="math inline">\(t′=t[1:m]\)</span>. We have two cases:</p>
<ol type="1">
<li>If&nbsp;<span class="math inline">\(s=t′\)</span>, then we set&nbsp;<span class="math inline">\(s&lt;Lext\)</span>&nbsp;because&nbsp;<span class="math inline">\(s\)</span>&nbsp;is shorter than&nbsp;<span class="math inline">\(t\)</span>&nbsp;(e.g.,&nbsp;<span class="math inline">\(APPLE&lt;APPLET\)</span>).</li>
<li>Otherwise,&nbsp;<span class="math inline">\(s≠t′\)</span>. We define&nbsp;<span class="math inline">\(s&lt;Lext\)</span>&nbsp;if&nbsp;<span class="math inline">\(s&lt;Lext′\)</span>&nbsp;and define&nbsp;<span class="math inline">\(s&gt;Lext\)</span>&nbsp;if&nbsp;<span class="math inline">\(s&gt;Lext′\)</span>&nbsp;(e.g.,&nbsp;<span class="math inline">\(APPLET&lt;LexARTS\)</span>&nbsp;because&nbsp;<span class="math inline">\(APPL&lt;LexARTS\)</span>).</li>
</ol>
<p>Given:&nbsp;A permutation of at most 12 symbols defining an&nbsp;<a href="https://rosalind.info/glossary/alphabet/">ordered alphabet</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;and a positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤4\)</span>).</p>
<p>Return:&nbsp;All strings of length at most&nbsp;<span class="math inline">\(n\)</span>&nbsp;formed from&nbsp;<span class="math inline">\(A\)</span>, ordered lexicographically. (Note: As in&nbsp;<a href="https://rosalind.info/problems/lexf/">“Enumerating k-mers Lexicographically”</a>, alphabet order is based on the order in which the symbols are given.)</p>
<section id="sample-dataset-38" class="level2" data-number="39.1">
<h2 data-number="39.1" class="anchored" data-anchor-id="sample-dataset-38"><span class="header-section-number">39.1</span> Sample Dataset</h2>
<pre><code>D N A
3</code></pre>
</section>
<section id="sample-output-39" class="level2" data-number="39.2">
<h2 data-number="39.2" class="anchored" data-anchor-id="sample-output-39"><span class="header-section-number">39.2</span> Sample Output</h2>
<pre><code>D
DD
DDD
DDN
DDA
DN
DND
DNN
DNA
DA
DAD
DAN
DAA
N
ND
NDD
NDN
NDA
NN
NND
NNN
NNA
NA
NAD
NAN
NAA
A
AD
ADD
ADN
ADA
AN
AND
ANN
ANA
AA
AAD
AAN
AAA</code></pre>
</section>
<section id="solution-36" class="level2" data-number="39.3">
<h2 data-number="39.3" class="anchored" data-anchor-id="solution-36"><span class="header-section-number">39.3</span> Solution</h2>
<p>To solve the problem of generating all strings of length up to <span class="math inline">\(n\)</span> formed from an ordered alphabet <span class="math inline">\(A\)</span>, and then ordering them lexicographically based on the given alphabet order, we can use a recursive approach or itertools to generate the permutations. Here is a detailed step-by-step explanation and implementation:</p>
</section>
<section id="steps-to-solve-the-problem-7" class="level2" data-number="39.4">
<h2 data-number="39.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-7"><span class="header-section-number">39.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Input Parsing</strong>:
<ul>
<li>Parse the given ordered alphabet <span class="math inline">\(A\)</span> and the integer <span class="math inline">\(n\)</span>.</li>
</ul></li>
<li><strong>Generate All Possible Strings</strong>:
<ul>
<li>Use recursion or itertools to generate all strings of length from 1 to <span class="math inline">\(n\)</span> using the symbols in <span class="math inline">\(A\)</span>.</li>
</ul></li>
<li><strong>Sorting</strong>:
<ul>
<li>Sort the generated strings based on the custom order provided by <span class="math inline">\(A\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="detailed-explanation-3" class="level2" data-number="39.5">
<h2 data-number="39.5" class="anchored" data-anchor-id="detailed-explanation-3"><span class="header-section-number">39.5</span> Detailed Explanation</h2>
<ol type="1">
<li><strong>Generating Combinations</strong>:
<ul>
<li>For each length <span class="math inline">\(k\)</span> from 1 to <span class="math inline">\(n\)</span>, generate all possible strings of that length using the symbols in <span class="math inline">\(A\)</span>.</li>
</ul></li>
<li><strong>Custom Sorting</strong>:
<ul>
<li>Use the order of symbols in <span class="math inline">\(A\)</span> to sort the generated strings lexicographically.</li>
</ul></li>
</ol>
</section>
<section id="python-implementation-4" class="level2" data-number="39.6">
<h2 data-number="39.6" class="anchored" data-anchor-id="python-implementation-4"><span class="header-section-number">39.6</span> Python Implementation</h2>
<p>Here is the Python code to achieve the above steps:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_str):</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    alphabet <span class="op">=</span> lines[<span class="dv">0</span>].split()</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">int</span>(lines[<span class="dv">1</span>])</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alphabet, n</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_strings(alphabet, n):</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    all_strings <span class="op">=</span> []</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> combo <span class="kw">in</span> itertools.product(alphabet, repeat<span class="op">=</span>length):</span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>            all_strings.append(<span class="st">""</span>.join(combo))</span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_strings</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> custom_sort(strings, alphabet):</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>    order_map <span class="op">=</span> {char: idx <span class="cf">for</span> idx, char <span class="kw">in</span> <span class="bu">enumerate</span>(alphabet)}</span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(strings, key<span class="op">=</span><span class="kw">lambda</span> word: [order_map[char] <span class="cf">for</span> char <span class="kw">in</span> word])</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a><span class="st">D N A</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a><span class="st">3</span></span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input</span></span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a>alphabet, n <span class="op">=</span> parse_input(input_data)</span>
<span id="cb118-28"><a href="#cb118-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-29"><a href="#cb118-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate all strings of length up to n</span></span>
<span id="cb118-30"><a href="#cb118-30" aria-hidden="true" tabindex="-1"></a>all_strings <span class="op">=</span> generate_strings(alphabet, n)</span>
<span id="cb118-31"><a href="#cb118-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-32"><a href="#cb118-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort the strings based on the custom lexicographical order</span></span>
<span id="cb118-33"><a href="#cb118-33" aria-hidden="true" tabindex="-1"></a>sorted_strings <span class="op">=</span> custom_sort(all_strings, alphabet)</span>
<span id="cb118-34"><a href="#cb118-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-35"><a href="#cb118-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb118-36"><a href="#cb118-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> sorted_strings:</span>
<span id="cb118-37"><a href="#cb118-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-7" class="level2" data-number="39.7">
<h2 data-number="39.7" class="anchored" data-anchor-id="explanation-of-the-code-7"><span class="header-section-number">39.7</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>parse_input(input_str)</strong>: This function parses the input string to extract the alphabet and the integer <span class="math inline">\(n\)</span>.</li>
<li><strong>generate_strings(alphabet, n)</strong>: This function generates all possible strings of lengths from 1 to <span class="math inline">\(n\)</span> using itertools.product.</li>
<li><strong>custom_sort(strings, alphabet)</strong>: This function sorts the generated strings based on the custom order defined by the alphabet. It uses a mapping of characters to their indices in the given order for sorting.</li>
<li><strong>Main Execution</strong>:
<ul>
<li>Parse the input data.</li>
<li>Generate all possible strings.</li>
<li>Sort the strings using the custom lexicographical order.</li>
<li>Print each string in the sorted list.</li>
</ul></li>
</ol>
</section>
</section>
<section id="maximum-matchings-and-rna-secondary-structures" class="level1" data-number="40">
<h1 data-number="40"><span class="header-section-number">40</span> Maximum Matchings and RNA Secondary Structures</h1>
<p>The&nbsp;<a href="https://rosalind.info/glossary/graph-theory/">graph theoretical</a>&nbsp;analogue of the quandary stated in the introduction above is that if we have an&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;s that does not have the same number of occurrences of ‘C’ as ‘G’ and the same number of occurrences of ‘A’ as ‘U’, then the&nbsp;<a href="https://rosalind.info/glossary/bonding-graph/">bonding graph</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;cannot possibly posses a&nbsp;<a href="https://rosalind.info/glossary/perfect-matching/">perfect matching</a>&nbsp;among its&nbsp;<a href="https://rosalind.info/glossary/basepair-edges/">basepair edges</a>. For example, see&nbsp;<a href="https://rosalind.info/media/problems/mmch/unbalanced_bonding_graph.png">Figure 1</a>; in fact, most bonding graphs will not contain a perfect matching.</p>
<p>In light of this fact, we define a&nbsp;<a href="https://rosalind.info/glossary/maximum-matching/">maximum matching</a>&nbsp;in a graph as a&nbsp;<a href="https://rosalind.info/glossary/matching/">matching</a>&nbsp;containing as many&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;as possible.</p>
<p>A maximum matching of basepair edges will correspond to a way of forming as many base pairs as possible in an RNA string.</p>
<p>Given:&nbsp;An RNA string&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length at most 100.</p>
<p>Return:&nbsp;The total possible number of maximum matchings of basepair edges in the bonding graph of&nbsp;s𝑠.</p>
<section id="sample-dataset-39" class="level2" data-number="40.1">
<h2 data-number="40.1" class="anchored" data-anchor-id="sample-dataset-39"><span class="header-section-number">40.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_92
AUGCUUC</code></pre>
</section>
<section id="sample-output-40" class="level2" data-number="40.2">
<h2 data-number="40.2" class="anchored" data-anchor-id="sample-output-40"><span class="header-section-number">40.2</span> Sample Output</h2>
<pre><code>6</code></pre>
</section>
<section id="solution-37" class="level2" data-number="40.3">
<h2 data-number="40.3" class="anchored" data-anchor-id="solution-37"><span class="header-section-number">40.3</span> Solution</h2>
<ol type="1">
<li><strong>Counting Nucleotides</strong>: Count occurrences of each nucleotide.</li>
<li><strong>Calculating Pairings</strong>:
<ul>
<li>The number of possible AU pairs is determined by the minimum of A and U.</li>
<li>Similarly, the number of possible GC pairs is determined by the minimum of G and C.</li>
</ul></li>
<li><strong>Using Factorials</strong>: Calculate how many ways to pair these nucleotides.</li>
</ol>
<p>Let’s correct the implementation:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> factorial</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_nucleotides(sequence):</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Count the occurrences of each nucleotide in the RNA sequence.</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a><span class="co">    sequence (str): The RNA sequence as a string.</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="co">    dict: A dictionary with counts for 'A', 'U', 'G', and 'C'.</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> {<span class="st">'A'</span>: <span class="dv">0</span>, <span class="st">'U'</span>: <span class="dv">0</span>, <span class="st">'G'</span>: <span class="dv">0</span>, <span class="st">'C'</span>: <span class="dv">0</span>}</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nucleotide <span class="kw">in</span> sequence:</span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nucleotide <span class="kw">in</span> counts:</span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>            counts[nucleotide] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> counts</span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_matching_pairs(a, b):</span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the number of ways to pair 'a' items with 'b' items.</span></span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a><span class="co">    a (int): Number of items of type A.</span></span>
<span id="cb121-25"><a href="#cb121-25" aria-hidden="true" tabindex="-1"></a><span class="co">    b (int): Number of items of type B.</span></span>
<span id="cb121-26"><a href="#cb121-26" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-27"><a href="#cb121-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb121-28"><a href="#cb121-28" aria-hidden="true" tabindex="-1"></a><span class="co">    int: The number of maximum matching pairs.</span></span>
<span id="cb121-29"><a href="#cb121-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb121-30"><a href="#cb121-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> factorial(a) <span class="op">//</span> (factorial(b) <span class="op">*</span> factorial(a <span class="op">-</span> b))</span>
<span id="cb121-31"><a href="#cb121-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-32"><a href="#cb121-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximum_matchings(sequence):</span>
<span id="cb121-33"><a href="#cb121-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb121-34"><a href="#cb121-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the number of maximum matchings in an RNA sequence.</span></span>
<span id="cb121-35"><a href="#cb121-35" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-36"><a href="#cb121-36" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb121-37"><a href="#cb121-37" aria-hidden="true" tabindex="-1"></a><span class="co">    sequence (str): The RNA sequence.</span></span>
<span id="cb121-38"><a href="#cb121-38" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb121-39"><a href="#cb121-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb121-40"><a href="#cb121-40" aria-hidden="true" tabindex="-1"></a><span class="co">    int: The number of maximum matchings.</span></span>
<span id="cb121-41"><a href="#cb121-41" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb121-42"><a href="#cb121-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count nucleotides</span></span>
<span id="cb121-43"><a href="#cb121-43" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> count_nucleotides(sequence)</span>
<span id="cb121-44"><a href="#cb121-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-45"><a href="#cb121-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get counts for each nucleotide</span></span>
<span id="cb121-46"><a href="#cb121-46" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> counts[<span class="st">'A'</span>]</span>
<span id="cb121-47"><a href="#cb121-47" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> counts[<span class="st">'U'</span>]</span>
<span id="cb121-48"><a href="#cb121-48" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> counts[<span class="st">'G'</span>]</span>
<span id="cb121-49"><a href="#cb121-49" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> counts[<span class="st">'C'</span>]</span>
<span id="cb121-50"><a href="#cb121-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-51"><a href="#cb121-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the number of possible AU and GC pairings</span></span>
<span id="cb121-52"><a href="#cb121-52" aria-hidden="true" tabindex="-1"></a>    min_au_pairs <span class="op">=</span> <span class="bu">min</span>(A, U)</span>
<span id="cb121-53"><a href="#cb121-53" aria-hidden="true" tabindex="-1"></a>    min_gc_pairs <span class="op">=</span> <span class="bu">min</span>(G, C)</span>
<span id="cb121-54"><a href="#cb121-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-55"><a href="#cb121-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute number of ways to form these pairs</span></span>
<span id="cb121-56"><a href="#cb121-56" aria-hidden="true" tabindex="-1"></a>    au_pairings <span class="op">=</span> max_matching_pairs(A, min_au_pairs) <span class="op">*</span> max_matching_pairs(U, min_au_pairs)</span>
<span id="cb121-57"><a href="#cb121-57" aria-hidden="true" tabindex="-1"></a>    gc_pairings <span class="op">=</span> max_matching_pairs(G, min_gc_pairs) <span class="op">*</span> max_matching_pairs(C, min_gc_pairs)</span>
<span id="cb121-58"><a href="#cb121-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb121-59"><a href="#cb121-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total number of maximum matchings</span></span>
<span id="cb121-60"><a href="#cb121-60" aria-hidden="true" tabindex="-1"></a>    total_matchings <span class="op">=</span> au_pairings <span class="op">*</span> gc_pairings</span>
<span id="cb121-61"><a href="#cb121-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_matchings</span>
<span id="cb121-62"><a href="#cb121-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-63"><a href="#cb121-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Example RNA sequence</span></span>
<span id="cb121-64"><a href="#cb121-64" aria-hidden="true" tabindex="-1"></a>rna_sequence <span class="op">=</span> <span class="st">"AUGCUUC"</span></span>
<span id="cb121-65"><a href="#cb121-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-66"><a href="#cb121-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute and print the number of maximum matchings</span></span>
<span id="cb121-67"><a href="#cb121-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maximum_matchings(rna_sequence))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-changes" class="level2" data-number="40.4">
<h2 data-number="40.4" class="anchored" data-anchor-id="explanation-of-changes"><span class="header-section-number">40.4</span> Explanation of Changes</h2>
<ol type="1">
<li><p><strong><code>count_nucleotides(sequence)</code></strong>: Counts the number of each nucleotide.</p></li>
<li><p><strong><code>max_matching_pairs(a, b)</code></strong>: Calculates the number of ways to form <code>b</code> pairs from <code>a</code> items using factorials. This function helps in calculating possible pairings for nucleotides.</p></li>
<li><p><strong><code>maximum_matchings(sequence)</code></strong>: Computes the number of ways to match <code>A</code> with <code>U</code> and <code>G</code> with <code>C</code>, and then multiplies these to get the total number of matchings.</p></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Rosalind 의 서버는 python2.7 로 구현되어 있어 python3 에서 실행한 결과는 옳지 않다고 판단합니다. 따라서 상대적으로 정확도가 떨어지는 python2.7 로 실행하세요.</p>
</div>
</div>
</section>
</section>
<section id="creating-a-distance-matrix" class="level1" data-number="41">
<h1 data-number="41"><span class="header-section-number">41</span> Creating a Distance Matrix</h1>
<p>For two&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and&nbsp;<span class="math inline">\(s2\)</span>&nbsp;of equal length, the&nbsp;<a href="https://rosalind.info/glossary/p-distance/">p-distance</a>&nbsp;between them, denoted&nbsp;<span class="math inline">\(dp(s1,s2)\)</span>, is the proportion of corresponding symbols that differ between&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and&nbsp;<span class="math inline">\(s2\)</span>.</p>
<p>For a general distance function&nbsp;<span class="math inline">\(d\)</span>&nbsp;on&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa&nbsp;<span class="math inline">\(s1,s2,…,sn\)</span>&nbsp;(taxa are often represented by&nbsp;<a href="https://rosalind.info/glossary/genetic-string/">genetic strings</a>), we may encode the distances between pairs of taxa via a&nbsp;<a href="https://rosalind.info/glossary/distance-matrix/">distance matrix</a>&nbsp;<span class="math inline">\(D\)</span>&nbsp;in which&nbsp;<span class="math inline">\(D_{i,j}=d(s_i,s_j)\)</span>.</p>
<p>Given:&nbsp;A collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;<span class="math inline">\((n≤10)\)</span>&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s1,…,sn\)</span>&nbsp;of equal length (at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>). Strings are given in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;The matrix&nbsp;<span class="math inline">\(D\)</span>&nbsp;corresponding to the p-distance&nbsp;<span class="math inline">\(d_p\)</span>&nbsp;on the given strings. As always, note that your answer is allowed an&nbsp;<a href="https://rosalind.info/glossary/absolute-error/">absolute error</a>&nbsp;of 0.001.</p>
<section id="sample-dataset-40" class="level2" data-number="41.1">
<h2 data-number="41.1" class="anchored" data-anchor-id="sample-dataset-40"><span class="header-section-number">41.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_9499
TTTCCATTTA
&gt;Rosalind_0942
GATTCATTTC
&gt;Rosalind_6568
TTTCCATTTT
&gt;Rosalind_1833
GTTCCATTTA</code></pre>
</section>
<section id="sample-output-41" class="level2" data-number="41.2">
<h2 data-number="41.2" class="anchored" data-anchor-id="sample-output-41"><span class="header-section-number">41.2</span> Sample Output</h2>
<pre><code>0.00000 0.40000 0.10000 0.10000
0.40000 0.00000 0.40000 0.30000
0.10000 0.40000 0.00000 0.20000
0.10000 0.30000 0.20000 0.00000</code></pre>
</section>
<section id="solution-38" class="level2" data-number="41.3">
<h2 data-number="41.3" class="anchored" data-anchor-id="solution-38"><span class="header-section-number">41.3</span> Solution</h2>
<p>To create a distance matrix based on the p-distance for a given set of DNA strings, we will follow these steps:</p>
<ol type="1">
<li><strong>Read the Input</strong>: Parse the FASTA formatted input to extract DNA strings.</li>
<li><strong>Calculate p-distance</strong>: Compute the p-distance between each pair of DNA strings. The p-distance is defined as the proportion of differing symbols between two strings of equal length.</li>
<li><strong>Construct the Distance Matrix</strong>: Populate the distance matrix with the computed p-distances.</li>
</ol>
</section>
<section id="detailed-implementation" class="level2" data-number="41.4">
<h2 data-number="41.4" class="anchored" data-anchor-id="detailed-implementation"><span class="header-section-number">41.4</span> Detailed Implementation</h2>
<ol type="1">
<li><strong>Reading the Input</strong>: We’ll parse the input to extract the DNA sequences.</li>
<li><strong>Computing p-distance</strong>: For each pair of sequences, we’ll count the differing positions and divide by the total length of the sequences.</li>
<li><strong>Output the Distance Matrix</strong>: Format the matrix with each entry having a precision up to five decimal places.</li>
</ol>
<p>Here’s the Python code to achieve this:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_fasta(fasta_string):</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses a FASTA formatted string and returns a list of sequences.</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> []</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sequence:</span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_sequence))</span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>                current_sequence <span class="op">=</span> []</span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>            current_sequence.append(line.strip())</span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_sequence:</span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_sequence))</span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> p_distance(s1, s2):</span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the p-distance between two DNA sequences of equal length.</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(s1) <span class="op">==</span> <span class="bu">len</span>(s2), <span class="st">"Sequences must be of equal length."</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a>    differences <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> a, b <span class="kw">in</span> <span class="bu">zip</span>(s1, s2) <span class="cf">if</span> a <span class="op">!=</span> b)</span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> differences <span class="op">/</span> <span class="bu">len</span>(s1)</span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance_matrix(sequences):</span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the distance matrix for a list of sequences based on p-distance.</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(sequences)</span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">!=</span> j:</span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a>                matrix[i][j] <span class="op">=</span> p_distance(sequences[i], sequences[j])</span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-38"><a href="#cb124-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_matrix(matrix):</span>
<span id="cb124-39"><a href="#cb124-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb124-40"><a href="#cb124-40" aria-hidden="true" tabindex="-1"></a><span class="co">    Formats the matrix for output with each entry having five decimal places.</span></span>
<span id="cb124-41"><a href="#cb124-41" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb124-42"><a href="#cb124-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(<span class="st">' '</span>.join(<span class="ss">f"</span><span class="sc">{</span>cell<span class="sc">:f}</span><span class="ss">"</span> <span class="cf">for</span> cell <span class="kw">in</span> row) <span class="cf">for</span> row <span class="kw">in</span> matrix)</span>
<span id="cb124-43"><a href="#cb124-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-44"><a href="#cb124-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset</span></span>
<span id="cb124-45"><a href="#cb124-45" aria-hidden="true" tabindex="-1"></a>fasta_string <span class="op">=</span> <span class="st">"""&gt;Rosalind_9499</span></span>
<span id="cb124-46"><a href="#cb124-46" aria-hidden="true" tabindex="-1"></a><span class="st">TTTCCATTTA</span></span>
<span id="cb124-47"><a href="#cb124-47" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_0942</span></span>
<span id="cb124-48"><a href="#cb124-48" aria-hidden="true" tabindex="-1"></a><span class="st">GATTCATTTC</span></span>
<span id="cb124-49"><a href="#cb124-49" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_6568</span></span>
<span id="cb124-50"><a href="#cb124-50" aria-hidden="true" tabindex="-1"></a><span class="st">TTTCCATTTT</span></span>
<span id="cb124-51"><a href="#cb124-51" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_1833</span></span>
<span id="cb124-52"><a href="#cb124-52" aria-hidden="true" tabindex="-1"></a><span class="st">GTTCCATTTA"""</span></span>
<span id="cb124-53"><a href="#cb124-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-54"><a href="#cb124-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Reading sequences from the sample dataset</span></span>
<span id="cb124-55"><a href="#cb124-55" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> read_fasta(fasta_string)</span>
<span id="cb124-56"><a href="#cb124-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-57"><a href="#cb124-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculating the distance matrix</span></span>
<span id="cb124-58"><a href="#cb124-58" aria-hidden="true" tabindex="-1"></a>dist_matrix <span class="op">=</span> distance_matrix(sequences)</span>
<span id="cb124-59"><a href="#cb124-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-60"><a href="#cb124-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatting and printing the distance matrix</span></span>
<span id="cb124-61"><a href="#cb124-61" aria-hidden="true" tabindex="-1"></a>formatted_matrix <span class="op">=</span> format_matrix(dist_matrix)</span>
<span id="cb124-62"><a href="#cb124-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(formatted_matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-21" class="level2" data-number="41.5">
<h2 data-number="41.5" class="anchored" data-anchor-id="explanation-21"><span class="header-section-number">41.5</span> Explanation</h2>
<ol type="1">
<li><strong>Reading FASTA Data</strong>: The <code>read_fasta</code> function processes the input FASTA data and extracts the sequences.</li>
<li><strong>Calculating p-distance</strong>: The <code>p_distance</code> function computes the proportion of differing symbols between two sequences.</li>
<li><strong>Constructing Distance Matrix</strong>: The <code>distance_matrix</code> function creates a matrix where each entry $(i, j)) contains the p-distance between sequences $i) and $j).</li>
<li><strong>Formatting the Output</strong>: The <code>format_matrix</code> function ensures that each entry in the matrix is printed with five decimal places for precision.</li>
</ol>
</section>
</section>
<section id="reversal-distance" class="level1" data-number="42">
<h1 data-number="42"><span class="header-section-number">42</span> Reversal Distance</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/reversal/">reversal</a>&nbsp;of a permutation creates a new permutation by inverting some interval of the permutation;&nbsp;<span class="math inline">\((5,2,3,1,4)\)</span>,&nbsp;<span class="math inline">\((5,3,4,1,2)\)</span>, and&nbsp;<span class="math inline">\((4,1,2,3,5)\)</span>,&nbsp;are all reversals of&nbsp;<span class="math inline">\((5,3,2,1,4)\)</span>. The&nbsp;<a href="https://rosalind.info/glossary/reversal-distance/">reversal distance</a>&nbsp;between two permutations&nbsp;π𝜋&nbsp;and&nbsp;σ𝜎, written&nbsp;<span class="math inline">\(d_rev(π,σ)\)</span>, is the minimum number of reversals required to transform&nbsp;<span class="math inline">\(π\)</span>&nbsp;into&nbsp;<span class="math inline">\(σ\)</span>&nbsp;(this assumes that&nbsp;<span class="math inline">\(π\)</span>&nbsp;and&nbsp;<span class="math inline">\(σ\)</span>&nbsp;have the same length).</p>
<p>Given:&nbsp;A collection of at most 5 pairs of permutations, all of which have length 10.</p>
<p>Return:&nbsp;The reversal distance between each permutation pair.</p>
<section id="sample-dataset-41" class="level2" data-number="42.1">
<h2 data-number="42.1" class="anchored" data-anchor-id="sample-dataset-41"><span class="header-section-number">42.1</span> Sample Dataset</h2>
<pre><code>1 2 3 4 5 6 7 8 9 10
3 1 5 2 7 4 9 6 10 8

3 10 8 2 5 4 7 1 6 9
5 2 3 1 7 4 10 8 6 9

8 6 7 9 4 1 3 10 2 5
8 2 7 6 9 1 5 3 10 4

3 9 10 4 1 8 6 7 5 2
2 9 8 5 1 7 3 4 6 10

1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10</code></pre>
</section>
<section id="sample-output-42" class="level2" data-number="42.2">
<h2 data-number="42.2" class="anchored" data-anchor-id="sample-output-42"><span class="header-section-number">42.2</span> Sample Output</h2>
<pre><code>9 4 5 7 0</code></pre>
</section>
<section id="solution-39" class="level2" data-number="42.3">
<h2 data-number="42.3" class="anchored" data-anchor-id="solution-39"><span class="header-section-number">42.3</span> Solution</h2>
<div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> collections</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_all_permutations(s):</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">2</span>, <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> s[:i] <span class="op">+</span> s[i:j][::<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s[j:]</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_reversal_distance(p1, p2):</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> p1 <span class="op">==</span> p2:</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> <span class="bu">tuple</span>(p2)</span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>    fromfirst <span class="op">=</span> {<span class="bu">tuple</span>(p1): <span class="dv">0</span>}</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> collections.deque([p1])</span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> q.popleft()</span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> fromfirst[s]</span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> get_all_permutations(s):</span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">==</span> target:</span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> c <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="kw">not</span> <span class="kw">in</span> fromfirst:</span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a>                fromfirst[j] <span class="op">=</span> c <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb127-27"><a href="#cb127-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> c <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb127-28"><a href="#cb127-28" aria-hidden="true" tabindex="-1"></a>                    q.append(j)</span>
<span id="cb127-29"><a href="#cb127-29" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb127-30"><a href="#cb127-30" aria-hidden="true" tabindex="-1"></a>    fromsecond <span class="op">=</span> {<span class="bu">tuple</span>(p2): <span class="dv">0</span>}</span>
<span id="cb127-31"><a href="#cb127-31" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> <span class="bu">tuple</span>(p1)</span>
<span id="cb127-32"><a href="#cb127-32" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> collections.deque([p2])</span>
<span id="cb127-33"><a href="#cb127-33" aria-hidden="true" tabindex="-1"></a>    answer <span class="op">=</span> <span class="dv">100000</span></span>
<span id="cb127-34"><a href="#cb127-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb127-35"><a href="#cb127-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb127-36"><a href="#cb127-36" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> q.popleft()</span>
<span id="cb127-37"><a href="#cb127-37" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> fromsecond[s]</span>
<span id="cb127-38"><a href="#cb127-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb127-39"><a href="#cb127-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb127-40"><a href="#cb127-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb127-41"><a href="#cb127-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb127-42"><a href="#cb127-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> get_all_permutations(s):</span>
<span id="cb127-43"><a href="#cb127-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">==</span> target:</span>
<span id="cb127-44"><a href="#cb127-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> c <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb127-45"><a href="#cb127-45" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb127-46"><a href="#cb127-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="kw">not</span> <span class="kw">in</span> fromsecond:</span>
<span id="cb127-47"><a href="#cb127-47" aria-hidden="true" tabindex="-1"></a>                fromsecond[j] <span class="op">=</span> c <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb127-48"><a href="#cb127-48" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb127-49"><a href="#cb127-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> c <span class="op">!=</span> <span class="dv">3</span>:</span>
<span id="cb127-50"><a href="#cb127-50" aria-hidden="true" tabindex="-1"></a>                    q.append(j)</span>
<span id="cb127-51"><a href="#cb127-51" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb127-52"><a href="#cb127-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="kw">in</span> fromfirst:</span>
<span id="cb127-53"><a href="#cb127-53" aria-hidden="true" tabindex="-1"></a>                answer <span class="op">=</span> <span class="bu">min</span>(answer, fromfirst[j] <span class="op">+</span> fromsecond[j])</span>
<span id="cb127-54"><a href="#cb127-54" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb127-55"><a href="#cb127-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> answer</span>
<span id="cb127-56"><a href="#cb127-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-57"><a href="#cb127-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-58"><a href="#cb127-58" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb127-59"><a href="#cb127-59" aria-hidden="true" tabindex="-1"></a><span class="st">1 2 3 4 5 6 7 8 9 10</span></span>
<span id="cb127-60"><a href="#cb127-60" aria-hidden="true" tabindex="-1"></a><span class="st">3 1 5 2 7 4 9 6 10 8</span></span>
<span id="cb127-61"><a href="#cb127-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-62"><a href="#cb127-62" aria-hidden="true" tabindex="-1"></a><span class="st">3 10 8 2 5 4 7 1 6 9</span></span>
<span id="cb127-63"><a href="#cb127-63" aria-hidden="true" tabindex="-1"></a><span class="st">5 2 3 1 7 4 10 8 6 9</span></span>
<span id="cb127-64"><a href="#cb127-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-65"><a href="#cb127-65" aria-hidden="true" tabindex="-1"></a><span class="st">8 6 7 9 4 1 3 10 2 5</span></span>
<span id="cb127-66"><a href="#cb127-66" aria-hidden="true" tabindex="-1"></a><span class="st">8 2 7 6 9 1 5 3 10 4</span></span>
<span id="cb127-67"><a href="#cb127-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-68"><a href="#cb127-68" aria-hidden="true" tabindex="-1"></a><span class="st">3 9 10 4 1 8 6 7 5 2</span></span>
<span id="cb127-69"><a href="#cb127-69" aria-hidden="true" tabindex="-1"></a><span class="st">2 9 8 5 1 7 3 4 6 10</span></span>
<span id="cb127-70"><a href="#cb127-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-71"><a href="#cb127-71" aria-hidden="true" tabindex="-1"></a><span class="st">1 2 3 4 5 6 7 8 9 10</span></span>
<span id="cb127-72"><a href="#cb127-72" aria-hidden="true" tabindex="-1"></a><span class="st">1 2 3 4 5 6 7 8 9 10</span></span>
<span id="cb127-73"><a href="#cb127-73" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb127-74"><a href="#cb127-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-75"><a href="#cb127-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Proces input data</span></span>
<span id="cb127-76"><a href="#cb127-76" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>.strip, input_data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)))</span>
<span id="cb127-77"><a href="#cb127-77" aria-hidden="true" tabindex="-1"></a>distances <span class="op">=</span> []</span>
<span id="cb127-78"><a href="#cb127-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-79"><a href="#cb127-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(dataset), <span class="dv">3</span>):</span>
<span id="cb127-80"><a href="#cb127-80" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">map</span>(<span class="bu">int</span>, dataset[i].split()))</span>
<span id="cb127-81"><a href="#cb127-81" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">map</span>(<span class="bu">int</span>, dataset[i <span class="op">+</span> <span class="dv">1</span>].split()))</span>
<span id="cb127-82"><a href="#cb127-82" aria-hidden="true" tabindex="-1"></a>    distances.append(get_reversal_distance(t, s))</span>
<span id="cb127-83"><a href="#cb127-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-84"><a href="#cb127-84" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, distances)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="key-changes-and-additions" class="level2" data-number="42.4">
<h2 data-number="42.4" class="anchored" data-anchor-id="key-changes-and-additions"><span class="header-section-number">42.4</span> Key Changes and Additions</h2>
<ol type="1">
<li><strong>Conversion to Python 3</strong>:
<ul>
<li>Changed <code>xrange</code> to <code>range</code>.</li>
<li>Changed <code>print</code> statement to <code>print()</code> function.</li>
</ul></li>
<li><strong>Input Handling</strong>:
<ul>
<li>Replaced file reading with a direct <code>input_data</code> string for simplicity and demonstration purposes.</li>
<li>Processed the <code>input_data</code> string to split it into individual lines and then handled them similarly to how they would be read from a file.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-subsets" class="level1" data-number="43">
<h1 data-number="43"><span class="header-section-number">43</span> Counting Subsets</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/set/">set</a>&nbsp;is the mathematical term for a loose collection of objects, called&nbsp;<a href="https://rosalind.info/glossary/element/">elements</a>. Examples of sets include&nbsp;<span class="math inline">\({the moon, the&nbsp;sun, Wilford Brimley}\)</span>&nbsp;and&nbsp;<span class="math inline">\(R\)</span>, the set containing all real numbers. We even have the&nbsp;<a href="https://rosalind.info/glossary/empty-set/">empty set</a>, represented by&nbsp;<span class="math inline">\(∅\)</span>&nbsp;or&nbsp;<span class="math inline">\({}\)</span>, which contains no elements at all. Two sets are equal when they contain the same elements. In other words, in contrast to&nbsp;<a href="https://rosalind.info/glossary/permutation/">permutations</a>, the ordering of the elements of a set is unimportant (e.g.,&nbsp;<span class="math inline">\({the moon, the sun, Wilford Brimley}\)</span>&nbsp;is equivalent to <span class="math inline">\({Wilford Brimley, the moon, the sun}\)</span>). Sets are not allowed to contain duplicate elements, so that&nbsp;<span class="math inline">\({Wilford Brimley, the sun, the sun}\)</span>&nbsp;is not a set. We have already used sets of 2 elements to represent&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;from a&nbsp;<a href="https://rosalind.info/glossary/graph/">graph</a>.</p>
<p>A set&nbsp;<span class="math inline">\(A\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/subset/">subset</a>&nbsp;of&nbsp;<span class="math inline">\(B\)</span>𝐵&nbsp;if every element of&nbsp;<span class="math inline">\(A\)</span>&nbsp;is also an element of&nbsp;B𝐵, and we write&nbsp;<span class="math inline">\(A⊆B\)</span>. For example,&nbsp;<span class="math inline">\({the sun, the moon}⊆{the sun,&nbsp;the moon, Wilford Brimley}\)</span>, and&nbsp;<span class="math inline">\(∅\)</span>&nbsp;is a subset of&nbsp;<em>every</em>&nbsp;set (including itself!).</p>
<p>As illustrated in the biological introduction, we can use subsets to represent the collection of taxa possessing a character. However, the number of applications is endless; for example, an&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">event</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;can now be defined as a subset of the set containing all possible&nbsp;<a href="https://rosalind.info/glossary/outcome/">outcomes</a>.</p>
<p>Our first question is to count the total number of possible subsets of a given set.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤1000\)</span>).</p>
<p>Return:&nbsp;The total number of subsets of&nbsp;<span class="math inline">\({1,2,…,n}\)</span> <a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000.</p>
<section id="sample-dataset-42" class="level2" data-number="43.1">
<h2 data-number="43.1" class="anchored" data-anchor-id="sample-dataset-42"><span class="header-section-number">43.1</span> Sample Dataset</h2>
<pre><code>3</code></pre>
</section>
<section id="sample-output-43" class="level2" data-number="43.2">
<h2 data-number="43.2" class="anchored" data-anchor-id="sample-output-43"><span class="header-section-number">43.2</span> Sample Output</h2>
<pre><code>8</code></pre>
</section>
<section id="solution-40" class="level2" data-number="43.3">
<h2 data-number="43.3" class="anchored" data-anchor-id="solution-40"><span class="header-section-number">43.3</span> Solution</h2>
<p>To solve the problem of counting the total number of subsets of the set <span class="math inline">\({1, 2, \ldots, n}\)</span> modulo 1,000,000, we need to understand a few key points:</p>
<ol type="1">
<li><strong>Subsets of a Set</strong>:
<ul>
<li>For any set of size <span class="math inline">\(n\)</span>, the number of possible subsets is <span class="math inline">\(2^n\)</span>. This includes the empty set and the set itself.</li>
</ul></li>
<li><strong>Modulo Operation</strong>:
<ul>
<li>Since <span class="math inline">\(n\)</span> can be as large as 1000, <span class="math inline">\(2^n\)</span> can be a very large number. To manage this, we will compute the result modulo 1,000,000.</li>
</ul></li>
</ol>
</section>
<section id="steps-to-solution" class="level2" data-number="43.4">
<h2 data-number="43.4" class="anchored" data-anchor-id="steps-to-solution"><span class="header-section-number">43.4</span> Steps to Solution</h2>
<ol type="1">
<li><strong>Calculate <span class="math inline">\(2^n \mod 1,000,000\)</span></strong>:
<ul>
<li>We will use modular exponentiation to compute this efficiently. Direct computation of <span class="math inline">\(2^n\)</span> for large <span class="math inline">\(n\)</span> is impractical due to the size of the number.</li>
</ul></li>
<li><strong>Modular Exponentiation</strong>:
<ul>
<li>This technique allows us to compute <span class="math inline">\((base^{exp}) \mod mod\)</span> efficiently using an iterative or recursive approach that reduces the number of multiplications required.</li>
</ul></li>
</ol>
<p>Here’s the Python code to solve the problem:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> modular_exponentiation(base, exp, mod):</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    base <span class="op">=</span> base <span class="op">%</span> mod</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> exp <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (exp <span class="op">%</span> <span class="dv">2</span>) <span class="op">==</span> <span class="dv">1</span>:  <span class="co"># If exp is odd, multiply base with result</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> (result <span class="op">*</span> base) <span class="op">%</span> mod</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">=</span> exp <span class="op">&gt;&gt;</span> <span class="dv">1</span>  <span class="co"># exp = exp // 2</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>        base <span class="op">=</span> (base <span class="op">*</span> base) <span class="op">%</span> mod  <span class="co"># Change base to base^2</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_subsets(n):</span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>    mod <span class="op">=</span> <span class="dv">1000000</span></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> modular_exponentiation(<span class="dv">2</span>, n, mod)</span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_subsets(n))  <span class="co"># Output should be 8</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-8" class="level2" data-number="43.5">
<h2 data-number="43.5" class="anchored" data-anchor-id="explanation-of-the-code-8"><span class="header-section-number">43.5</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Function <code>modular_exponentiation</code></strong>:
<ul>
<li><strong>Inputs</strong>: <code>base</code> (2), <code>exp</code> (n), and <code>mod</code> (1,000,000).</li>
<li><strong>Process</strong>: This function uses an efficient loop to compute the exponentiation modulo <code>mod</code>. By squaring the base and halving the exponent iteratively, it ensures that we keep the numbers manageable and perform fewer multiplications.</li>
</ul></li>
<li><strong>Function <code>count_subsets</code></strong>:
<ul>
<li>This function simply calls <code>modular_exponentiation</code> with <code>base</code> 2, <code>exp</code> n, and <code>mod</code> 1,000,000.</li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li>The sample input <code>n = 3</code> is used to demonstrate the function, which should output <code>8</code> as expected.</li>
<li>The script can also read from standard input for actual use cases.</li>
</ul></li>
</ol>
</section>
</section>
<section id="matching-random-motifs" class="level1" data-number="44">
<h1 data-number="44"><span class="header-section-number">44</span> Matching Random Motifs</h1>
<p>Our aim in this problem is to determine the&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;with which a given motif (a known promoter, say) occurs in a randomly constructed genome. Unfortunately, finding this probability is tricky; instead of forming a long genome, we will form a large collection of smaller&nbsp;<a href="https://rosalind.info/glossary/random-string/">random strings</a>&nbsp;having the same length as the motif; these smaller strings represent the genome’s&nbsp;<a href="https://rosalind.info/glossary/substring/">substrings</a>, which we can then test against our motif.</p>
<p>Given a&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">probabilistic event</a>&nbsp;<span class="math inline">\(A\)</span>, the&nbsp;<a href="https://rosalind.info/glossary/complementary-event/">complement</a>&nbsp;of&nbsp;<span class="math inline">\(A\)</span>&nbsp;is the collection&nbsp;<span class="math inline">\(A^c\)</span>&nbsp;of&nbsp;<a href="https://rosalind.info/glossary/outcome/">outcomes</a>&nbsp;not belonging to&nbsp;<span class="math inline">\(A\)</span>. Because&nbsp;<span class="math inline">\(A^c\)</span>&nbsp;takes place precisely when&nbsp;<span class="math inline">\(A\)</span> does not, we may also call&nbsp;<span class="math inline">\(A^c\)</span>&nbsp;“not&nbsp;<span class="math inline">\(A\)</span>.”</p>
<p>For a simple example, if&nbsp;<span class="math inline">\(A\)</span>&nbsp;is the event that a rolled die is 2 or 4, then&nbsp;<span class="math inline">\(Pr(A)= \frac {1}{3}\)</span>.&nbsp;<span class="math inline">\(A^c\)</span>&nbsp;is the event that the die is 1, 3, 5, or 6, and&nbsp;<span class="math inline">\(Pr(A^c)= \frac{2}{3}\)</span>. In general, for any event we will have the identity that&nbsp;<span class="math inline">\(Pr(A)+Pr(A^c)=1\)</span>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(N≤100000\)</span>, a number&nbsp;<span class="math inline">\(x\)</span>&nbsp;between 0 and 1, and a DNA string&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length at most 10 bp.</p>
<p>Return:&nbsp;The probability that if&nbsp;<span class="math inline">\(N\)</span>&nbsp;random DNA strings having the same length as&nbsp;<span class="math inline">\(s\)</span>&nbsp;are constructed with&nbsp;<a href="https://rosalind.info/glossary/gc-content/">GC-content</a>&nbsp;<span class="math inline">\(x\)</span>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/prob/">“Introduction to Random Strings”</a>), then at least one of the strings equals&nbsp;s𝑠. We allow for the same random string to be created more than once.</p>
<section id="sample-dataset-43" class="level2" data-number="44.1">
<h2 data-number="44.1" class="anchored" data-anchor-id="sample-dataset-43"><span class="header-section-number">44.1</span> Sample Dataset</h2>
<pre><code>90000 0.6
ATAGCCGA</code></pre>
</section>
<section id="sample-output-44" class="level2" data-number="44.2">
<h2 data-number="44.2" class="anchored" data-anchor-id="sample-output-44"><span class="header-section-number">44.2</span> Sample Output</h2>
<pre><code>0.689</code></pre>
</section>
<section id="solution-41" class="level2" data-number="44.3">
<h2 data-number="44.3" class="anchored" data-anchor-id="solution-41"><span class="header-section-number">44.3</span> Solution</h2>
<p>To solve the problem of calculating the probability that at least one out of <span class="math inline">\(N\)</span>random DNA strings matches a given DNA string <span class="math inline">\(s\)</span>, we can follow these steps:</p>
<ol type="1">
<li><strong>Calculate the Probability of Matching a Single String</strong>:
<ul>
<li>The probability of a specific base in <span class="math inline">\(s\)</span>matching a random base depends on the GC-content <span class="math inline">\(x\)</span>.</li>
<li>For GC-content <span class="math inline">\(x\)</span>, the probabilities are:
<ul>
<li>Probability of ‘G’ or ‘C’: <span class="math inline">\(\frac{x}{2}\)</span></li>
<li>Probability of ‘A’ or ‘T’: <span class="math inline">\(\frac{1 - x}{2}\)</span></li>
</ul></li>
</ul></li>
<li><strong>Compute the Probability of the Entire String Matching</strong>:
<ul>
<li>The probability that a random DNA string of the same length as <span class="math inline">\(s\)</span>matches <span class="math inline">\(s\)</span>exactly is the product of the probabilities for each individual base.</li>
</ul></li>
<li><strong>Calculate the Complementary Probability</strong>:
<ul>
<li>Compute the probability that a single random DNA string does NOT match <span class="math inline">\(s\)</span>.</li>
<li>Using this, compute the probability that all <span class="math inline">\(N\)</span>random strings do NOT match <span class="math inline">\(s\)</span>.</li>
</ul></li>
<li><strong>Compute the Final Probability</strong>:
<ul>
<li>The probability that at least one out of <span class="math inline">\(N\)</span>random DNA strings matches <span class="math inline">\(s\)</span>is the complement of the probability that none of them matches <span class="math inline">\(s\)</span>.</li>
</ul></li>
</ol>
<p>Let’s go through the implementation of this step-by-step:</p>
</section>
<section id="implementation-5" class="level2" data-number="44.4">
<h2 data-number="44.4" class="anchored" data-anchor-id="implementation-5"><span class="header-section-number">44.4</span> Implementation</h2>
<div class="sourceCode" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_probability(N, x, s):</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Calculate the probability of matching a single base</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    prob_match <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base <span class="kw">in</span> s:</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> base <span class="kw">in</span> <span class="st">'GC'</span>:</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>            prob_match <span class="op">*=</span> x <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># base in 'AT'</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>            prob_match <span class="op">*=</span> (<span class="dv">1</span> <span class="op">-</span> x) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Compute the probability of the entire string matching</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is already computed as prob_match</span></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Calculate the complementary probability</span></span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>    prob_not_match <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> prob_match</span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Compute the final probability</span></span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>    prob_all_not_match <span class="op">=</span> prob_not_match <span class="op">**</span> N</span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a>    prob_at_least_one_match <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> prob_all_not_match</span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prob_at_least_one_match</span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">90000</span></span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">0.6</span></span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"ATAGCCGA"</span></span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and print the probability</span></span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> calculate_probability(N, x, s)</span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result<span class="sc">:f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-9" class="level2" data-number="44.5">
<h2 data-number="44.5" class="anchored" data-anchor-id="explanation-of-the-code-9"><span class="header-section-number">44.5</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Probability Calculation for Each Base</strong>:
<ul>
<li>For each base in the string <span class="math inline">\(s\)</span>, the probability of it being either ‘G’ or ‘C’ is <span class="math inline">\(\frac{x}{2}\)</span> and for ‘A’ or ‘T’ is <span class="math inline">\(\frac{1 - x}{2}\)</span>.</li>
</ul></li>
<li><strong>Computing Probability for the Entire String</strong>:
<ul>
<li>Multiply the probabilities of each base matching to get the probability of the entire string matching a random string of the same length.</li>
</ul></li>
<li><strong>Complementary Probability</strong>:
<ul>
<li>Compute the probability that a single random DNA string does NOT match <span class="math inline">\(s\)</span>.</li>
<li>Raise this probability to the power <span class="math inline">\(N\)</span> to get the probability that none of the <span class="math inline">\(N\)</span> strings match <span class="math inline">\(s\)</span>.</li>
</ul></li>
<li><strong>Final Probability</strong>:
<ul>
<li>Subtract the complementary probability from 1 to get the probability that at least one out of <span class="math inline">\(N\)</span> random strings matches <span class="math inline">\(s\)</span>.</li>
</ul></li>
</ol>
</section>
</section>
<section id="introduction-to-alternative-splicing" class="level1" data-number="45">
<h1 data-number="45"><span class="header-section-number">45</span> Introduction to Alternative Splicing</h1>
<p>In&nbsp;<a href="https://rosalind.info/problems/sset/">“Counting Subsets”</a>, we saw that the total number of&nbsp;<a href="https://rosalind.info/glossary/subset/">subsets</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/set/">set</a>&nbsp;<span class="math inline">\(S\)</span>&nbsp;containing&nbsp;<span class="math inline">\(n\)</span> elements is equal to&nbsp;<span class="math inline">\(2^n\)</span>.</p>
<p>However, if we intend to count the total number of&nbsp;<a href="https://rosalind.info/glossary/subset/">subsets</a>&nbsp;of&nbsp;<span class="math inline">\(S\)</span>&nbsp;having a fixed size&nbsp;<span class="math inline">\(k\)</span>, then we use the&nbsp;<a href="https://rosalind.info/glossary/combination/">combination</a>&nbsp;statistic&nbsp;<span class="math inline">\(C(n,k)\)</span> also written&nbsp;<span class="math inline">\(\binom{n}k\)</span>.</p>
<p>Given:&nbsp;Positive integers&nbsp;n and&nbsp;<span class="math inline">\(m\)</span>&nbsp;with&nbsp;<span class="math inline">\(0≤m≤n≤20000\)</span>.</p>
<p>Return:&nbsp;The sum of combinations&nbsp;<span class="math inline">\(C(n,k)\)</span>&nbsp;for all&nbsp;k satisfying&nbsp;<span class="math inline">\(m≤k≤n\)</span>,&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000. In shorthand,&nbsp;<span class="math inline">\(\sum^n_{k=m} \binom{n+1}k\)</span>.</p>
<section id="sample-dataset-44" class="level2" data-number="45.1">
<h2 data-number="45.1" class="anchored" data-anchor-id="sample-dataset-44"><span class="header-section-number">45.1</span> Sample Dataset</h2>
<pre><code>6 3</code></pre>
</section>
<section id="sample-output-45" class="level2" data-number="45.2">
<h2 data-number="45.2" class="anchored" data-anchor-id="sample-output-45"><span class="header-section-number">45.2</span> Sample Output</h2>
<pre><code>42</code></pre>
</section>
<section id="solution-42" class="level2" data-number="45.3">
<h2 data-number="45.3" class="anchored" data-anchor-id="solution-42"><span class="header-section-number">45.3</span> Solution</h2>
<p>Here’s the refactored code that performs the required calculation using Python’s built-in <code>math</code> module while maintaining readability and simplicity.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_of_combinations(n, m, MOD):</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(m, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate C(n, k) using math.factorial</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>        comb <span class="op">=</span> math.factorial(n) <span class="op">//</span> (math.factorial(k) <span class="op">*</span> math.factorial(n <span class="op">-</span> k))</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> (total <span class="op">+</span> comb) <span class="op">%</span> MOD</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"6 3"</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, sample_input.strip().split())</span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the modulo</span></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a>MOD <span class="op">=</span> <span class="dv">1000000</span></span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-18"><a href="#cb136-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the sum of combinations</span></span>
<span id="cb136-19"><a href="#cb136-19" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> sum_of_combinations(n, m, MOD)</span>
<span id="cb136-20"><a href="#cb136-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-21"><a href="#cb136-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb136-22"><a href="#cb136-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-22" class="level2" data-number="45.4">
<h2 data-number="45.4" class="anchored" data-anchor-id="explanation-22"><span class="header-section-number">45.4</span> Explanation</h2>
<ol type="1">
<li><strong>Function Definition</strong>:</li>
<li><strong>Main Logic</strong>:
<ul>
<li>Iterate through all <span class="math inline">\(k\)</span>from <span class="math inline">\(m\)</span>to <span class="math inline">\(n\)</span>.</li>
<li>Calculate <span class="math inline">\(C(n, k)\)</span> using the factorial function.</li>
<li>Sum the results, taking modulo <span class="math inline">\(1000000\)</span>at each step to handle large numbers efficiently.</li>
</ul></li>
<li><strong>Sample Input Handling</strong>:
<ul>
<li>Parse the sample input to get the values of <span class="math inline">\(n\)</span>and <span class="math inline">\(m\)</span>.</li>
<li>Define the modulo value <span class="math inline">\(MOD = 1000000\)</span>.</li>
<li>Calculate the result using the <code>sum_of_combinations</code> function and print the results.</li>
</ul></li>
</ol>
</section>
</section>
<section id="edit-distance" class="level1" data-number="46">
<h1 data-number="46"><span class="header-section-number">46</span> Edit Distance</h1>
<p>Given two&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;(of possibly different lengths), the&nbsp;<a href="https://rosalind.info/glossary/edit-distance/">edit distance</a>&nbsp;<span class="math inline">\(d_E(s,t)\)</span>&nbsp;is the minimum number of&nbsp;<a href="https://rosalind.info/glossary/edit-operation/">edit operations</a>&nbsp;needed to transform&nbsp;<span class="math inline">\(s\)</span>&nbsp;into&nbsp;<span class="math inline">\(t\)</span>, where an edit operation is defined as the substitution, insertion, or deletion of a single symbol.</p>
<p>The latter two operations incorporate the case in which a contiguous interval is inserted into or deleted from a string; such an interval is called a&nbsp;<a href="https://rosalind.info/glossary/gap/">gap</a>. For the purposes of this problem, the insertion or deletion of a gap of length&nbsp;<span class="math inline">\(k\)</span>&nbsp;still counts as&nbsp;<span class="math inline">\(k\)</span>&nbsp;distinct edit operations.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The edit distance&nbsp;<span class="math inline">\(d_E(s,t)\)</span>.</p>
<section id="sample-dataset-45" class="level2" data-number="46.1">
<h2 data-number="46.1" class="anchored" data-anchor-id="sample-dataset-45"><span class="header-section-number">46.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_39
PLEASANTLY
&gt;Rosalind_11
MEANLY</code></pre>
</section>
<section id="sample-output-46" class="level2" data-number="46.2">
<h2 data-number="46.2" class="anchored" data-anchor-id="sample-output-46"><span class="header-section-number">46.2</span> Sample Output</h2>
<pre><code>5</code></pre>
</section>
</section>
<section id="expected-number-of-restriction-sites" class="level1" data-number="47">
<h1 data-number="47"><span class="header-section-number">47</span> Expected Number of Restriction Sites</h1>
<p>Say that you place a number of bets on your favorite sports teams. If their chances of winning are 0.3, 0.8, and 0.6, then you should expect on average to win <span class="math inline">\(0.3 + 0.8 + 0.6 = 1.7\)</span> of your bets (of course, you can never win exactly 1.7!)</p>
<p>More generally, if we have a collection of&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">events</a>&nbsp;<span class="math inline">\(A1,A2,…,An\)</span> then the&nbsp;<a href="https://rosalind.info/glossary/expected-value/">expected number</a>&nbsp;of events occurring is&nbsp;<span class="math inline">\(Pr(A1)+Pr(A2)+⋯+Pr(An)\)</span>&nbsp;(consult the note following the problem for a precise explanation of this fact). In this problem, we extend the idea of finding an expected number of events to finding the expected number of times that a given string occurs as a&nbsp;<a href="https://rosalind.info/glossary/substring/">substring</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/random-string/">random string</a>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤1,000,000\)</span>), a DNA string&nbsp;<span class="math inline">\(s\)</span>&nbsp;of even length at most 10, and an&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;of length at most 20, containing numbers between 0 and 1.</p>
<p>Return:&nbsp;An array&nbsp;<span class="math inline">\(B\)</span>&nbsp;having the same length as&nbsp;<span class="math inline">\(A\)</span>&nbsp;in which&nbsp;<span class="math inline">\(B[i]\)</span>&nbsp;represents the expected number of times that&nbsp;<span class="math inline">\(s\)</span>&nbsp;will appear as a substring of a random DNA string&nbsp;<span class="math inline">\(t\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>, where&nbsp;<span class="math inline">\(t\)</span>&nbsp;is formed with&nbsp;<a href="https://rosalind.info/glossary/gc-content/">GC-content</a>&nbsp;<span class="math inline">\(A[i]\)</span>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/prob/">“Introduction to Random Strings”</a>).</p>
<section id="sample-dataset-46" class="level2" data-number="47.1">
<h2 data-number="47.1" class="anchored" data-anchor-id="sample-dataset-46"><span class="header-section-number">47.1</span> Sample Dataset</h2>
<pre><code>10
AG
0.25 0.5 0.75</code></pre>
</section>
<section id="sample-output-47" class="level2" data-number="47.2">
<h2 data-number="47.2" class="anchored" data-anchor-id="sample-output-47"><span class="header-section-number">47.2</span> Sample Output</h2>
<pre><code>0.422 0.563 0.422</code></pre>
</section>
<section id="solution-43" class="level2" data-number="47.3">
<h2 data-number="47.3" class="anchored" data-anchor-id="solution-43"><span class="header-section-number">47.3</span> Solution</h2>
<p>To solve this problem, we need to compute the expected number of times a given DNA string <span class="math inline">\(s\)</span>will appear as a substring in a random DNA string <span class="math inline">\(t\)</span>of length <span class="math inline">\(n\)</span>. The DNA string <span class="math inline">\(t\)</span>is generated with varying GC-content values given in an array <span class="math inline">\(A\)</span>.</p>
</section>
<section id="approach" class="level2" data-number="47.4">
<h2 data-number="47.4" class="anchored" data-anchor-id="approach"><span class="header-section-number">47.4</span> Approach</h2>
<ol type="1">
<li><strong>Calculate Probabilities:</strong>
<ul>
<li>The probability of each nucleotide (A, T, C, G) depends on the GC-content.</li>
<li>For a given GC-content <span class="math inline">\(gc\)</span>:
<ul>
<li>Probability of G or C: <span class="math inline">\(\frac{gc}{2}\)</span></li>
<li>Probability of A or T: <span class="math inline">\(\frac{1 - gc}{2}\)</span></li>
</ul></li>
</ul></li>
<li><strong>Compute the Probability of <span class="math inline">\(s\)</span>as a Substring:</strong>
<ul>
<li>For each GC-content value <span class="math inline">\(A[i]\)</span>, compute the probability that <span class="math inline">\(s\)</span>appears at any specific position in <span class="math inline">\(t\)</span>.</li>
<li>Sum the probabilities for all possible starting positions of <span class="math inline">\(s\)</span>in <span class="math inline">\(t\)</span>(from 0 to <span class="math inline">\(n - \text{len}(s)\)</span>).</li>
</ul></li>
<li><strong>Expected Value:</strong>
<ul>
<li>Multiply the single-position probability by the number of possible starting positions to get the expected number of times <span class="math inline">\(s\)</span>appears in <span class="math inline">\(t\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="detailed-steps-and-code" class="level2" data-number="47.5">
<h2 data-number="47.5" class="anchored" data-anchor-id="detailed-steps-and-code"><span class="header-section-number">47.5</span> Detailed Steps and Code</h2>
<ol type="1">
<li><strong>Reading Input:</strong>
<ul>
<li>Read <span class="math inline">\(n\)</span>, the DNA string <span class="math inline">\(s\)</span>, and the array <span class="math inline">\(A\)</span>.</li>
</ul></li>
<li><strong>Probability Calculation:</strong>
<ul>
<li>For each GC-content value in <span class="math inline">\(A\)</span>, compute the probability of <span class="math inline">\(s\)</span>.</li>
</ul></li>
<li><strong>Output:</strong>
<ul>
<li>Print the expected values for each GC-content in <span class="math inline">\(A\)</span>.</li>
</ul></li>
</ol>
<p>Here’s the Python code to achieve this:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expected_restriction_sites(n, s, A):</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    len_s <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> []</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> gc_content <span class="kw">in</span> A:</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>        p_gc <span class="op">=</span> gc_content <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>        p_at <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> gc_content) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>        prob_s <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nucleotide <span class="kw">in</span> s:</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nucleotide <span class="kw">in</span> <span class="st">'GC'</span>:</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>                prob_s <span class="op">*=</span> p_gc</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>                prob_s <span class="op">*=</span> p_at</span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>        expected_count <span class="op">=</span> prob_s <span class="op">*</span> (n <span class="op">-</span> len_s <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>        B.append(expected_count)</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a><span class="st">10</span></span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a><span class="st">AG</span></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a><span class="st">0.25 0.5 0.75"""</span></span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(text.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)[<span class="dv">0</span>])</span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> text.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)[<span class="dv">1</span>]</span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> text.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)[<span class="dv">2</span>].split()]</span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> expected_restriction_sites(n, s, A)</span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:f}</span><span class="ss">"</span> <span class="cf">for</span> x <span class="kw">in</span> result))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-23" class="level2" data-number="47.6">
<h2 data-number="47.6" class="anchored" data-anchor-id="explanation-23"><span class="header-section-number">47.6</span> Explanation</h2>
<ul>
<li><strong>Reading Input:</strong>
<ul>
<li><code>n</code> is the length of the random DNA string.</li>
<li><code>s</code> is the DNA substring we are looking for.</li>
<li><code>A</code> is an array of GC-content values.</li>
</ul></li>
<li><strong>Probability Calculation:</strong>
<ul>
<li>For each GC-content <span class="math inline">\(gc\)</span>, compute the probability <code>prob_s</code> that the substring <span class="math inline">\(s\)</span> will match exactly at a given position.</li>
<li>Use the formula: <span class="math display">\[
\text{prob\_s} = \prod_{i=1}^{\text{len}(s)} \text{probability of } s[i]
\]</span></li>
</ul></li>
<li><strong>Expected Value:</strong>
<ul>
<li>Multiply <code>prob_s</code> by the number of possible starting positions in the string <span class="math inline">\(t\)</span>(which is <span class="math inline">\(n - \text{len}(s) + 1\)</span>).</li>
</ul></li>
<li><strong>Output:</strong>
<ul>
<li>Print the expected counts, formatted to three decimal places.</li>
</ul></li>
</ul>
</section>
</section>
<section id="motzkin-numbers-and-rna-secondary-structures" class="level1" data-number="48">
<h1 data-number="48"><span class="header-section-number">48</span> Motzkin Numbers and RNA Secondary Structures</h1>
<p>Similarly to our definition of the&nbsp;<a href="https://rosalind.info/glossary/catalan-numbers/">Catalan numbers</a>, the&nbsp;<span class="math inline">\(n\)</span>-th&nbsp;<a href="https://rosalind.info/glossary/motzkin-numbers/">Motzkin number</a>&nbsp;<span class="math inline">\(mn\)</span>&nbsp;counts the number of ways to form a (not necessarily&nbsp;<a href="https://rosalind.info/glossary/perfect-matching/">perfect</a>)&nbsp;<a href="https://rosalind.info/glossary/noncrossing-matching/">noncrossing matching</a>&nbsp;in the&nbsp;<a href="https://rosalind.info/glossary/complete-graph/">complete graph</a>&nbsp;<span class="math inline">\(Kn\)</span>&nbsp;containing&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/node/">nodes</a>.</p>
<p>How should we compute the Motzkin numbers? As with Catalan numbers, we will take&nbsp;<span class="math inline">\(m0=m1=1\)</span>. To calculate&nbsp;<span class="math inline">\(mn\)</span>&nbsp;in general, assume that the nodes of&nbsp;<span class="math inline">\(Kn\)</span>&nbsp;are labeled around the outside of a circle with the integers between 1 and&nbsp;<span class="math inline">\(n\)</span>, and consider node 1, which may or may not be involved in a matching. If node 1 is&nbsp;<em>not</em>&nbsp;involved in a matching, then there are&nbsp;<span class="math inline">\(m_{n−1}\)</span>&nbsp;ways of matching the remaining&nbsp;<span class="math inline">\(n−1\)</span>&nbsp;nodes. If node 1&nbsp;<em>is</em>&nbsp;involved in a matching, then say it is matched to node&nbsp;<span class="math inline">\(k\)</span>: this leaves&nbsp;<span class="math inline">\(k−2\)</span>&nbsp;nodes on one side of edge&nbsp;<span class="math inline">\({1,k}\)</span>&nbsp;and&nbsp;<span class="math inline">\(n−k\)</span>&nbsp;nodes on the other side; as with the Catalan numbers, no edge can connect the two sides, which gives us&nbsp;<span class="math inline">\(m_{k−2}⋅m_{n−k}\)</span>&nbsp;ways of matching the remaining edges. Allowing&nbsp;<span class="math inline">\(k\)</span>&nbsp;to vary between&nbsp;22&nbsp;and&nbsp;<span class="math inline">\(n\)</span>&nbsp;yields the following&nbsp;<a href="https://rosalind.info/glossary/recurrence-relation/">recurrence relation</a>&nbsp;for the Motzkin numbers:&nbsp;<span class="math inline">\(m_n=m_{n−1} + \sum ^n_{k=2} m_k−2⋅m_{n−k}\)</span>.</p>
<p>To count all possible secondary structures of a given&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;that do not contain pseudoknots, we need to modify the Motzkin recurrence so that it counts only matchings of&nbsp;<a href="https://rosalind.info/glossary/basepair-edges/">basepair edges</a>&nbsp;in the&nbsp;<a href="https://rosalind.info/glossary/bonding-graph/">bonding graph</a>&nbsp;corresponding to the RNA string.</p>
<p>Given:&nbsp;An RNA string&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length at most 300 bp.</p>
<p>Return:&nbsp;The total number of noncrossing matchings of basepair edges in the bonding graph of&nbsp;<span class="math inline">\(s\)</span>,&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000.</p>
<section id="sample-dataset-47" class="level2" data-number="48.1">
<h2 data-number="48.1" class="anchored" data-anchor-id="sample-dataset-47"><span class="header-section-number">48.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_57
AUAU</code></pre>
</section>
<section id="sample-output-48" class="level2" data-number="48.2">
<h2 data-number="48.2" class="anchored" data-anchor-id="sample-output-48"><span class="header-section-number">48.2</span> Sample Output</h2>
<pre><code>7</code></pre>
</section>
<section id="solution-44" class="level2" data-number="48.3">
<h2 data-number="48.3" class="anchored" data-anchor-id="solution-44"><span class="header-section-number">48.3</span> Solution</h2>
<p>We want to count the number of ways to form noncrossing matchings of basepair edges in an RNA string. RNA strings can form base pairs between <code>A</code> and <code>U</code> or <code>C</code> and <code>G</code>.</p>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li><strong>Input</strong>: An RNA string <code>rna</code> of length <code>n</code>.</li>
<li><strong>DP Table</strong>: We create a 2D list <code>dp</code> of size <code>(n+1) x (n+1)</code> initialized to zero. <code>dp[i][j]</code> will store the number of noncrossing matchings in the substring from index <code>i</code> to <code>j-1</code> of the RNA string.</li>
<li><strong>Base Case</strong>:
<ul>
<li><code>dp[i][i] = 1</code> because a single nucleotide can only be matched with itself.</li>
<li><code>dp[i][i+1] = 1</code> because a pair of adjacent nucleotides can either be unmatched or form one valid base pair.</li>
</ul></li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>We iterate over all possible substring lengths starting from 2 up to <code>n</code>.</li>
<li>For each substring of length <code>length</code> starting at index <code>i</code> and ending at index <code>j-1</code>:
<ul>
<li>We start by assuming the first nucleotide <code>rna[i]</code> is not paired, so the count of valid matchings is initially <code>dp[i+1][j]</code>.</li>
<li>Then we check all possible positions <code>k</code> where <code>rna[i]</code> can form a valid base pair (i.e., <code>rna[i]</code> with <code>rna[k]</code>). If they form a valid base pair:
<ul>
<li>We add the number of ways to match the left part (<code>dp[i+1][k]</code>) and the right part (<code>dp[k+1][j]</code>).</li>
</ul></li>
<li>Sum the results and take modulo $10^6) to avoid large numbers.</li>
</ul></li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>The result for the entire RNA string is stored in <code>dp[0][n]</code>.</li>
</ul></li>
</ol>
</section>
<section id="code-explanation" class="level2" data-number="48.4">
<h2 data-number="48.4" class="anchored" data-anchor-id="code-explanation"><span class="header-section-number">48.4</span> Code Explanation</h2>
<p>Here’s the code again with comments to explain each part:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_noncrossing_matchings(rna):</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(rna)  <span class="co"># Length of the RNA string</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    MOD <span class="op">=</span> <span class="dv">1000000</span>  <span class="co"># Modulo value to avoid large numbers</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize a dp table with all zeros</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: Single nucleotides and empty string</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># A single nucleotide matches with itself</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> n:</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>            dp[i][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Two adjacent nucleotides can be unmatched or paired</span></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table for all substring lengths</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># Length of the substring</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j]  <span class="co"># Case when the first nucleotide is unpaired</span></span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, j):</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Check if rna[i] and rna[k] can form a valid base pair</span></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (rna[i] <span class="op">==</span> <span class="st">'A'</span> <span class="kw">and</span> rna[k] <span class="op">==</span> <span class="st">'U'</span>) <span class="kw">or</span> (rna[i] <span class="op">==</span> <span class="st">'U'</span> <span class="kw">and</span> rna[k] <span class="op">==</span> <span class="st">'A'</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a>                   (rna[i] <span class="op">==</span> <span class="st">'C'</span> <span class="kw">and</span> rna[k] <span class="op">==</span> <span class="st">'G'</span>) <span class="kw">or</span> (rna[i] <span class="op">==</span> <span class="st">'G'</span> <span class="kw">and</span> rna[k] <span class="op">==</span> <span class="st">'C'</span>):</span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][k] <span class="op">*</span> dp[k <span class="op">+</span> <span class="dv">1</span>][j]</span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">%=</span> MOD  <span class="co"># Take modulo to avoid large numbers</span></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The result for the entire string</span></span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n]</span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true" tabindex="-1"></a>rna_string <span class="op">=</span> <span class="st">"AUAU"</span></span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_noncrossing_matchings(rna_string)</span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 7</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="key-points" class="level2" data-number="48.5">
<h2 data-number="48.5" class="anchored" data-anchor-id="key-points"><span class="header-section-number">48.5</span> Key Points</h2>
<ul>
<li><strong>Base Cases</strong>: Handle single and adjacent nucleotides.</li>
<li><strong>Dynamic Programming</strong>: Use a table to store results of subproblems to build up the solution for the entire string.</li>
<li><strong>Modulo Operation</strong>: Keep results manageable by taking modulo $10^6).</li>
</ul>
<p>This approach efficiently calculates the number of noncrossing matchings for the given RNA string.</p>
</section>
</section>
<section id="distances-in-trees" class="level1" data-number="49">
<h1 data-number="49"><span class="header-section-number">49</span> Distances in Trees</h1>
<p><a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;is a way of representing trees even more concisely than using an adjacency list, especially when dealing with trees whose&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal nodes</a>&nbsp;have not been labeled.</p>
<p>First, consider the case of a&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;<span class="math inline">\(T\)</span>. A collection of leaves&nbsp;<span class="math inline">\(v1,v2,…,vn\)</span>&nbsp;of&nbsp;<span class="math inline">\(T\)</span>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/neighbor/">neighbors</a>&nbsp;if they are all adjacent to some internal node&nbsp;<span class="math inline">\(u\)</span>. Newick format for&nbsp;<span class="math inline">\(T\)</span>&nbsp;is obtained by iterating the following key step: delete all the edges&nbsp;<span class="math inline">\({vi,u}\)</span>&nbsp;from&nbsp;<span class="math inline">\(T\)</span>&nbsp;and label&nbsp;<span class="math inline">\(u\)</span>&nbsp;with&nbsp;<span class="math inline">\((v1,v2,…,vn)u\)</span>. This proces is repeated all the way to the root, at which point a semicolon signals the end of the tree.</p>
<p>A number of variations of Newick format exist. First, if a node is not labeled in&nbsp;<span class="math inline">\(T\)</span>, then we simply leave blank the space occupied by the node. In the key step, we can write&nbsp;<span class="math inline">\((v1,v2,…,vn)\)</span>&nbsp;in place of&nbsp;<span class="math inline">\((v1,v2,…,vn)u\)</span>&nbsp;if the&nbsp;<span class="math inline">\(v_i\)</span>&nbsp;are labeled; if none of the nodes are labeled, we can write&nbsp;<span class="math inline">\((,,…,)\)</span>.</p>
<p>A second variation of Newick format occurs when&nbsp;<span class="math inline">\(T\)</span>&nbsp;is unrooted, in which case we simply select any internal node to serve as the root of&nbsp;<span class="math inline">\(T\)</span>. A particularly peculiar case of Newick format arises when we choose a leaf to serve as the root.</p>
<p>Note that there will be a large number of different ways to represent&nbsp;<span class="math inline">\(T\)</span>&nbsp;in Newick format.</p>
<p>Given:&nbsp;A collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;trees (<span class="math inline">\(n≤40\)</span>) in Newick format, with each tree containing at most 200 nodes; each tree&nbsp;<span class="math inline">\(Tk\)</span>&nbsp;is followed by a pair of nodes&nbsp;<span class="math inline">\(xk\)</span>&nbsp;and&nbsp;<span class="math inline">\(yk\)</span>&nbsp;in&nbsp;<span class="math inline">\(Tk\)</span>.</p>
<p>Return:&nbsp;A collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;positive integers, for which the&nbsp;<span class="math inline">\(k\)</span>th integer represents the distance between&nbsp;<span class="math inline">\(xk\)</span>&nbsp;and&nbsp;<span class="math inline">\(yk\)</span>&nbsp;in&nbsp;<span class="math inline">\(Tk\)</span>.</p>
<section id="sample-dataset-48" class="level2" data-number="49.1">
<h2 data-number="49.1" class="anchored" data-anchor-id="sample-dataset-48"><span class="header-section-number">49.1</span> Sample Dataset</h2>
<pre><code>(cat)dog;
dog cat

(dog,cat);
dog cat</code></pre>
</section>
<section id="sample-output-49" class="level2" data-number="49.2">
<h2 data-number="49.2" class="anchored" data-anchor-id="sample-output-49"><span class="header-section-number">49.2</span> Sample Output</h2>
<pre><code>1 2</code></pre>
</section>
<section id="solution-45" class="level2" data-number="49.3">
<h2 data-number="49.3" class="anchored" data-anchor-id="solution-45"><span class="header-section-number">49.3</span> Solution</h2>
<div class="sourceCode" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dis_tree(T, x, y):</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the indices of x and y in the Newick string T</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    x_index <span class="op">=</span> T.find(x)</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    y_index <span class="op">=</span> T.find(y)</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract the relevant substring between the indices of x and y</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>    sub_tree <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> T[<span class="bu">min</span>(x_index, y_index):<span class="bu">max</span>(x_index, y_index)] <span class="cf">if</span> i <span class="kw">in</span> [<span class="st">')'</span>, <span class="st">'('</span>, <span class="st">','</span>]]</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the list of characters to a string</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>    bracket <span class="op">=</span> <span class="st">''</span>.join(sub_tree)</span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove empty pairs of parentheses</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="st">'(,)'</span> <span class="kw">in</span> bracket:</span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>        bracket <span class="op">=</span> bracket.replace(<span class="st">'(,)'</span>, <span class="st">''</span>)</span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Determine the number of steps based on the type of brackets remaining</span></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> bracket.count(<span class="st">'('</span>) <span class="op">==</span> <span class="bu">len</span>(bracket) <span class="kw">or</span> bracket.count(<span class="st">')'</span>) <span class="op">==</span> <span class="bu">len</span>(bracket):</span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(bracket)</span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> bracket.count(<span class="st">','</span>) <span class="op">==</span> <span class="bu">len</span>(bracket):</span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> bracket.count(<span class="st">')'</span>) <span class="op">+</span> bracket.count(<span class="st">'('</span>) <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_input(input_data):</span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse the input data into a list of tree and node pairs</span></span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a>    tree_data <span class="op">=</span> [line.strip().replace(<span class="st">";"</span>, <span class="st">""</span>) <span class="cf">for</span> line <span class="kw">in</span> input_data.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) <span class="cf">if</span> line.strip()]</span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-29"><a href="#cb147-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate through the parsed data to proces each tree and node pair</span></span>
<span id="cb147-30"><a href="#cb147-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(tree_data), <span class="dv">2</span>):</span>
<span id="cb147-31"><a href="#cb147-31" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> tree_data[i]</span>
<span id="cb147-32"><a href="#cb147-32" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> tree_data[i<span class="op">+</span><span class="dv">1</span>].split(<span class="st">' '</span>)</span>
<span id="cb147-33"><a href="#cb147-33" aria-hidden="true" tabindex="-1"></a>        results.append(dis_tree(T, x, y))</span>
<span id="cb147-34"><a href="#cb147-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb147-35"><a href="#cb147-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb147-36"><a href="#cb147-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-37"><a href="#cb147-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb147-38"><a href="#cb147-38" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb147-39"><a href="#cb147-39" aria-hidden="true" tabindex="-1"></a><span class="st">(cat)dog;</span></span>
<span id="cb147-40"><a href="#cb147-40" aria-hidden="true" tabindex="-1"></a><span class="st">dog cat</span></span>
<span id="cb147-41"><a href="#cb147-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-42"><a href="#cb147-42" aria-hidden="true" tabindex="-1"></a><span class="st">(dog,cat);</span></span>
<span id="cb147-43"><a href="#cb147-43" aria-hidden="true" tabindex="-1"></a><span class="st">dog cat</span></span>
<span id="cb147-44"><a href="#cb147-44" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb147-45"><a href="#cb147-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-46"><a href="#cb147-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Proces the input and print the results</span></span>
<span id="cb147-47"><a href="#cb147-47" aria-hidden="true" tabindex="-1"></a>output_data <span class="op">=</span> process_input(input_data)</span>
<span id="cb147-48"><a href="#cb147-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, output_data)))  <span class="co"># Output should be: 1 2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-24" class="level2" data-number="49.4">
<h2 data-number="49.4" class="anchored" data-anchor-id="explanation-24"><span class="header-section-number">49.4</span> Explanation</h2>
<ul>
<li>The <code>dis_tree</code> function computes the distance between nodes <code>x</code> and <code>y</code> in the given Newick string <code>T</code>.</li>
<li>The <code>process_input</code> function processes the input string, extracts the tree and node pairs, and computes the distances using the <code>dis_tree</code> function.</li>
<li>Finally, the results are printed in the required format.</li>
</ul>
</section>
</section>
<section id="interleaving-two-motifs" class="level1" data-number="50">
<h1 data-number="50"><span class="header-section-number">50</span> Interleaving Two Motifs</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/string/">string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/supersequence/">supersequence</a>&nbsp;of another string&nbsp;<span class="math inline">\(t\)</span>&nbsp;if&nbsp;<span class="math inline">\(s\)</span>&nbsp;contains&nbsp;<span class="math inline">\(t\)</span>&nbsp;as a&nbsp;<a href="https://rosalind.info/glossary/subsequence/">subsequence</a>.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/common-supersequence/">common supersequence</a>&nbsp;of strings&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;is a string that serves as a supersequence of both&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. For example, “GACCTAGGAACTC” serves as a common supersequence of “ACGTC” and “ATAT”. A&nbsp;<a href="https://rosalind.info/glossary/shortest-common-supersequence/">shortest common supersequence</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;is a supersequence for which there does not exist a shorter common supersequence. Continuing our example, “ACGTACT” is a shortest common supersequence of “ACGTC” and “ATAT”.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>.</p>
<p>Return:&nbsp;A shortest common supersequence of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. If multiple solutions exist, you may output any one.</p>
<section id="sample-dataset-49" class="level2" data-number="50.1">
<h2 data-number="50.1" class="anchored" data-anchor-id="sample-dataset-49"><span class="header-section-number">50.1</span> Sample Dataset</h2>
<pre><code>ATCTGAT
TGCATA</code></pre>
</section>
<section id="sample-output-50" class="level2" data-number="50.2">
<h2 data-number="50.2" class="anchored" data-anchor-id="sample-output-50"><span class="header-section-number">50.2</span> Sample Output</h2>
<pre><code>ATGCATGAT</code></pre>
</section>
<section id="solution-46" class="level2" data-number="50.3">
<h2 data-number="50.3" class="anchored" data-anchor-id="solution-46"><span class="header-section-number">50.3</span> Solution</h2>
<p>To solve the problem of finding the shortest common supersequence (SCS) of two DNA strings $ s$ and $ t$, we can use a dynamic programming approach. The idea is similar to finding the longest common subsequence (LCS), but with a few modifications to ensure that we construct the SCS.</p>
</section>
<section id="steps-to-solve-the-problem-8" class="level2" data-number="50.4">
<h2 data-number="50.4" class="anchored" data-anchor-id="steps-to-solve-the-problem-8"><span class="header-section-number">50.4</span> Steps to Solve the Problem</h2>
<ol type="1">
<li><strong>Define the Dynamic Programming Table:</strong>
<ul>
<li>Let <span class="math inline">\(dp[i][j]\)</span> represent the length of the SCS of the substrings <span class="math inline">\(s[0:i]\)</span> and <span class="math inline">\(t[0:j]\)</span>.</li>
</ul></li>
<li><strong>Initialize the Table:</strong>
<ul>
<li>For <span class="math inline">\(dp[i][0]\)</span>, the SCS is simply the prefix of <span class="math inline">\(s\)</span> of length <span class="math inline">\(i\)</span>, so <span class="math inline">\(dp[i][0] = i\)</span>.</li>
<li>For <span class="math inline">\(dp[0][j]\)</span>, the SCS is simply the prefix of <span class="math inline">\(t\)</span> of length <span class="math inline">\(j\)</span>, so <span class="math inline">\(dp[0][j] = j\)</span>.</li>
</ul></li>
<li><strong>Fill the DP Table:</strong>
<ul>
<li>If <span class="math inline">\(s[i-1] == t[j-1]\)</span>, then <span class="math inline">\(dp[i][j] = dp[i-1][j-1] + 1\)</span> because the characters match and they contribute once to the SCS.</li>
<li>Otherwise, <span class="math inline">\(dp[i][j] = \min(dp[i-1][j], dp[i][j-1]) + 1\)</span>, meaning we take the shorter SCS by either adding the current character of <span class="math inline">\(s\)</span> or <span class="math inline">\(t\)</span>.</li>
</ul></li>
<li><strong>Construct the SCS:</strong>
<ul>
<li>Use the DP table to backtrack and construct the SCS by starting from <span class="math inline">\(dp[len(s)][len(t)]\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="code-implementation" class="level2" data-number="50.5">
<h2 data-number="50.5" class="anchored" data-anchor-id="code-implementation"><span class="header-section-number">50.5</span> Code Implementation</h2>
<p>Here’s the code to solve the problem:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shortest_common_supersequence(s, t):</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the DP table</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the base cases</span></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack to find the SCS</span></span>
<span id="cb150-22"><a href="#cb150-22" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> m, n</span>
<span id="cb150-23"><a href="#cb150-23" aria-hidden="true" tabindex="-1"></a>    scs <span class="op">=</span> []</span>
<span id="cb150-24"><a href="#cb150-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-25"><a href="#cb150-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb150-26"><a href="#cb150-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb150-27"><a href="#cb150-27" aria-hidden="true" tabindex="-1"></a>            scs.append(s[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb150-28"><a href="#cb150-28" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-29"><a href="#cb150-29" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-30"><a href="#cb150-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">&lt;</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb150-31"><a href="#cb150-31" aria-hidden="true" tabindex="-1"></a>            scs.append(s[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb150-32"><a href="#cb150-32" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-33"><a href="#cb150-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb150-34"><a href="#cb150-34" aria-hidden="true" tabindex="-1"></a>            scs.append(t[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb150-35"><a href="#cb150-35" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-36"><a href="#cb150-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-37"><a href="#cb150-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb150-38"><a href="#cb150-38" aria-hidden="true" tabindex="-1"></a>        scs.append(s[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb150-39"><a href="#cb150-39" aria-hidden="true" tabindex="-1"></a>        i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-40"><a href="#cb150-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb150-41"><a href="#cb150-41" aria-hidden="true" tabindex="-1"></a>        scs.append(t[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb150-42"><a href="#cb150-42" aria-hidden="true" tabindex="-1"></a>        j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb150-43"><a href="#cb150-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb150-44"><a href="#cb150-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(<span class="bu">reversed</span>(scs))</span>
<span id="cb150-45"><a href="#cb150-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-46"><a href="#cb150-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb150-47"><a href="#cb150-47" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"ATCTGAT"</span></span>
<span id="cb150-48"><a href="#cb150-48" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="st">"TGCATA"</span></span>
<span id="cb150-49"><a href="#cb150-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-50"><a href="#cb150-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and print the shortest common supersequence</span></span>
<span id="cb150-51"><a href="#cb150-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shortest_common_supersequence(s, t))  <span class="co"># Output should be a valid SCS like "ATGCATGAT"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="introduction-to-set-operations" class="level1" data-number="51">
<h1 data-number="51"><span class="header-section-number">51</span> Introduction to Set Operations</h1>
<p>If&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>&nbsp;are sets, then their&nbsp;<a href="https://rosalind.info/glossary/union/">union</a>&nbsp;<span class="math inline">\(A∪B\)</span>&nbsp;is the set comprising any elements in&nbsp;<em>either</em>&nbsp;<span class="math inline">\(A\)</span>&nbsp;or&nbsp;<span class="math inline">\(B\)</span>; their&nbsp;<a href="https://rosalind.info/glossary/intersection/">intersection</a>&nbsp;<span class="math inline">\(A∩B\)</span> is the set of elements in&nbsp;<em>both</em>&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>; and their&nbsp;<a href="https://rosalind.info/glossary/set-difference/">set difference</a>&nbsp;<span class="math inline">\(A−B\)</span>&nbsp;is the set of elements in&nbsp;<span class="math inline">\(A\)</span>&nbsp;but not in&nbsp;<span class="math inline">\(B\)</span>.</p>
<p>Furthermore, if&nbsp;<span class="math inline">\(A\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/subset/">subset</a>&nbsp;of another set&nbsp;<span class="math inline">\(U\)</span>, then the&nbsp;<a href="https://rosalind.info/glossary/set-complement/">set complement</a>&nbsp;of&nbsp;<span class="math inline">\(A\)</span>&nbsp;with respect to&nbsp;<span class="math inline">\(U\)</span>&nbsp;is defined as the set&nbsp;<span class="math inline">\(A^c=U−A\)</span>. See the Sample sections below for examples.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤20,000\)</span>) and two subsets&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>&nbsp;of&nbsp;<span class="math inline">\({1,2,…,n}\)</span>.</p>
<p>Return:&nbsp;Six sets:&nbsp;<span class="math inline">\(A∪B\)</span>,&nbsp;<span class="math inline">\(A∩B\)</span>,&nbsp;<span class="math inline">\(A−B\)</span>,&nbsp;<span class="math inline">\(B−A\)</span>,&nbsp;<span class="math inline">\(A^c\)</span>, and&nbsp;<span class="math inline">\(B^c\)</span>&nbsp;(where set complements are taken with respect to&nbsp;<span class="math inline">\({1,2,…,n}\)</span>.</p>
<section id="sample-dataset-50" class="level2" data-number="51.1">
<h2 data-number="51.1" class="anchored" data-anchor-id="sample-dataset-50"><span class="header-section-number">51.1</span> Sample Dataset</h2>
<pre><code>10
{1, 2, 3, 4, 5}
{2, 8, 5, 10}</code></pre>
</section>
<section id="sample-output-51" class="level2" data-number="51.2">
<h2 data-number="51.2" class="anchored" data-anchor-id="sample-output-51"><span class="header-section-number">51.2</span> Sample Output</h2>
<pre><code>{1, 2, 3, 4, 5, 8, 10}
{2, 5}
{1, 3, 4}
{8, 10}
{8, 9, 10, 6, 7}
{1, 3, 4, 6, 7, 9}</code></pre>
</section>
<section id="solution-47" class="level2" data-number="51.3">
<h2 data-number="51.3" class="anchored" data-anchor-id="solution-47"><span class="header-section-number">51.3</span> Solution</h2>
<p>To solve this problem involving set operations, we need to perform union, intersection, set difference, and complement operations on two given sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, with respect to a universal set <span class="math inline">\(U\)</span> which contains all integers from 1 to <span class="math inline">\(n\)</span>. Here’s how we can approach this step-by-step:</p>
</section>
<section id="steps" class="level2" data-number="51.4">
<h2 data-number="51.4" class="anchored" data-anchor-id="steps"><span class="header-section-number">51.4</span> Steps</h2>
<ol type="1">
<li><strong>Read Input</strong>:
<ul>
<li>The first line contains the integer <span class="math inline">\(n\)</span>, the size of the universal set.</li>
<li>The second line contains set <span class="math inline">\(A\)</span>.</li>
<li>The third line contains set <span class="math inline">\(B\)</span>.</li>
</ul></li>
<li><strong>Parse Sets</strong>:
<ul>
<li>Extract the elements of sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> from the input strings.</li>
</ul></li>
<li><strong>Define Universal Set <span class="math inline">\(U\)</span></strong>:
<ul>
<li>This is simply the set of all integers from 1 to <span class="math inline">\(n\)</span>.</li>
</ul></li>
<li><strong>Perform Set Operations</strong>:
<ul>
<li><strong>Union <span class="math inline">\(A \cup B\)</span></strong>: Elements in either <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>.</li>
<li><strong>Intersection <span class="math inline">\(A \cap B\)</span></strong>: Elements common to both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</li>
<li><strong>Difference <span class="math inline">\(A - B\)</span></strong>: Elements in <span class="math inline">\(A\)</span> but not in <span class="math inline">\(B\)</span>.</li>
<li><strong>Difference <span class="math inline">\(B - A\)</span></strong>: Elements in <span class="math inline">\(B\)</span> but not in <span class="math inline">\(A\)</span>.</li>
<li><strong>Complement <span class="math inline">\(A^c\)</span></strong>: Elements in <span class="math inline">\(U\)</span> but not in <span class="math inline">\(A\)</span>.</li>
<li><strong>Complement <span class="math inline">\(B^c\)</span></strong>: Elements in <span class="math inline">\(U\)</span> but not in <span class="math inline">\(B\)</span>.</li>
</ul></li>
</ol>
<p>Here’s the Python code to implement the above logic:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_operations(n, A, B):</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> <span class="bu">set</span>(<span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> <span class="bu">set</span>(A)</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> <span class="bu">set</span>(B)</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    union <span class="op">=</span> A <span class="op">|</span> B</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    intersection <span class="op">=</span> A <span class="op">&amp;</span> B</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>    difference_A_B <span class="op">=</span> A <span class="op">-</span> B</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>    difference_B_A <span class="op">=</span> B <span class="op">-</span> A</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>    complement_A <span class="op">=</span> U <span class="op">-</span> A</span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>    complement_B <span class="op">=</span> U <span class="op">-</span> B</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> union, intersection, difference_A_B, difference_B_A, complement_A, complement_B</span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>}</span>
<span id="cb153-18"><a href="#cb153-18" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> {<span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">5</span>, <span class="dv">10</span>}</span>
<span id="cb153-19"><a href="#cb153-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-20"><a href="#cb153-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the results</span></span>
<span id="cb153-21"><a href="#cb153-21" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> set_operations(n, A, B)</span>
<span id="cb153-22"><a href="#cb153-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-23"><a href="#cb153-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb153-24"><a href="#cb153-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> result <span class="kw">in</span> results:</span>
<span id="cb153-25"><a href="#cb153-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-25" class="level2" data-number="51.5">
<h2 data-number="51.5" class="anchored" data-anchor-id="explanation-25"><span class="header-section-number">51.5</span> Explanation</h2>
<ul>
<li><strong>Union (<span class="math inline">\(A \cup B\)</span>)</strong>: Combines all unique elements from both sets.</li>
<li><strong>Intersection (<span class="math inline">\(A \cap B\)</span>)</strong>: Selects only the elements that are present in both sets.</li>
<li><strong>Difference (<span class="math inline">\(A - B\)</span>)</strong>: Selects elements that are in <span class="math inline">\(A\)</span> but not in <span class="math inline">\(B\)</span>.</li>
<li><strong>Difference (<span class="math inline">\(B - A\)</span>)</strong>: Selects elements that are in <span class="math inline">\(B\)</span> but not in <span class="math inline">\(A\)</span>.</li>
<li><strong>Complement (<span class="math inline">\(A^c\)</span>)</strong>: Selects elements that are in the universal set <span class="math inline">\(U\)</span> but not in <span class="math inline">\(A\)</span>.</li>
<li><strong>Complement (<span class="math inline">\(B^c\)</span>)</strong>: Selects elements that are in the universal set <span class="math inline">\(U\)</span> but not in <span class="math inline">\(B\)</span>.</li>
</ul>
</section>
</section>
<section id="sorting-by-reversals" class="level1" data-number="52">
<h1 data-number="52"><span class="header-section-number">52</span> Sorting by Reversals</h1>
<p>A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms&nbsp;<span class="math inline">\((4,1,2,6,3,5)\)</span> into&nbsp;<span class="math inline">\((4,1,3,6,2,5)\)</span>&nbsp;is encoded by&nbsp;<span class="math inline">\([3,5]\)</span>.</p>
<p>A collection of reversals&nbsp;<a href="https://rosalind.info/glossary/sorting/">sorts</a>&nbsp;<span class="math inline">\(π\)</span>&nbsp;into&nbsp;<span class="math inline">\(γ\)</span>&nbsp;if the collection contains&nbsp;<span class="math inline">\(d_{rev}(π,γ)\)</span>&nbsp;reversals, which when successively applied to&nbsp;<span class="math inline">\(π\)</span>&nbsp;yield&nbsp;<span class="math inline">\(γ\)</span>.</p>
<p>Given:&nbsp;Two permutations&nbsp;π𝜋&nbsp;and&nbsp;<span class="math inline">\(γ\)</span>, each of length 10.</p>
<p>Return:&nbsp;The reversal distance&nbsp;<span class="math inline">\(d_{rev}(π,γ)\)</span>, followed by a collection of reversals sorting&nbsp;<span class="math inline">\(π\)</span>&nbsp;into&nbsp;<span class="math inline">\(γ\)</span>. If multiple collections of such reversals exist, you may return any one.</p>
<section id="sample-dataset-51" class="level2" data-number="52.1">
<h2 data-number="52.1" class="anchored" data-anchor-id="sample-dataset-51"><span class="header-section-number">52.1</span> Sample Dataset</h2>
<pre><code>1 2 3 4 5 6 7 8 9 10
1 8 9 3 2 7 6 5 4 10</code></pre>
</section>
<section id="sample-output-52" class="level2" data-number="52.2">
<h2 data-number="52.2" class="anchored" data-anchor-id="sample-output-52"><span class="header-section-number">52.2</span> Sample Output</h2>
<pre><code>2
4 9
2 5</code></pre>
</section>
<section id="solution-48" class="level2" data-number="52.3">
<h2 data-number="52.3" class="anchored" data-anchor-id="solution-48"><span class="header-section-number">52.3</span> Solution</h2>
<p>To solve the problem of sorting by reversals, we need to find the minimum number of reversals needed to transform one permutation <span class="math inline">\(\pi\)</span> into another permutation <span class="math inline">\(\gamma\)</span>, as well as the specific reversals that accomplish this transformation.</p>
</section>
<section id="key-concepts" class="level2" data-number="52.4">
<h2 data-number="52.4" class="anchored" data-anchor-id="key-concepts"><span class="header-section-number">52.4</span> Key Concepts</h2>
<ol type="1">
<li><strong>Reversal</strong>: A reversal is an operation that takes a segment of the permutation and reverses the order of the elements within that segment.</li>
<li><strong>Reversal Distance</strong>: The reversal distance between two permutations is the minimum number of reversals needed to transform one permutation into another.</li>
</ol>
</section>
<section id="approach-1" class="level2" data-number="52.5">
<h2 data-number="52.5" class="anchored" data-anchor-id="approach-1"><span class="header-section-number">52.5</span> Approach</h2>
<ol type="1">
<li><strong>Graph Representation</strong>:
<ul>
<li>Represent the permutations as nodes in a graph, where each node is a permutation and edges represent a single reversal operation transforming one permutation into another.</li>
</ul></li>
<li><strong>Breadth-First Search (BFS)</strong>:
<ul>
<li>Use BFS to find the shortest path from the starting permutation <span class="math inline">\(\pi\)</span> to the target permutation <span class="math inline">\(\gamma\)</span>. Each level of BFS corresponds to one reversal.</li>
<li>Track the reversals used to transform <span class="math inline">\(\pi\)</span> to <span class="math inline">\(\gamma\)</span>.</li>
</ul></li>
<li><strong>Implementing BFS</strong>:
<ul>
<li>Use a queue to manage the permutations to explore.</li>
<li>Use a set to keep track of visited permutations to avoid redundant work.</li>
<li>For each permutation, generate all possible permutations resulting from a single reversal and enqueue them if they haven’t been visited.</li>
</ul></li>
<li><strong>Reconstruct Path</strong>:
<ul>
<li>Once the target permutation <span class="math inline">\(\gamma\)</span> is reached, backtrack to reconstruct the sequence of reversals.</li>
</ul></li>
</ol>
</section>
<section id="example-solution-in-python" class="level2" data-number="52.6">
<h2 data-number="52.6" class="anchored" data-anchor-id="example-solution-in-python"><span class="header-section-number">52.6</span> Example Solution in Python</h2>
<p>Here’s the implementation of the approach:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_sublist(lst, start, end):</span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>    lst[start:end<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> lst[start:end<span class="op">+</span><span class="dv">1</span>][::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(start, target):</span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque([(start, [])])</span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>    visited.add(<span class="bu">tuple</span>(start))</span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a>        current, path <span class="op">=</span> queue.popleft()</span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">==</span> target:</span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">len</span>(path), path</span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(current)):</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(current)):</span>
<span id="cb156-19"><a href="#cb156-19" aria-hidden="true" tabindex="-1"></a>                new_perm <span class="op">=</span> current[:]</span>
<span id="cb156-20"><a href="#cb156-20" aria-hidden="true" tabindex="-1"></a>                reverse_sublist(new_perm, i, j)</span>
<span id="cb156-21"><a href="#cb156-21" aria-hidden="true" tabindex="-1"></a>                new_tuple <span class="op">=</span> <span class="bu">tuple</span>(new_perm)</span>
<span id="cb156-22"><a href="#cb156-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-23"><a href="#cb156-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> new_tuple <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb156-24"><a href="#cb156-24" aria-hidden="true" tabindex="-1"></a>                    visited.add(new_tuple)</span>
<span id="cb156-25"><a href="#cb156-25" aria-hidden="true" tabindex="-1"></a>                    queue.append((new_perm, path <span class="op">+</span> [(i<span class="op">+</span><span class="dv">1</span>, j<span class="op">+</span><span class="dv">1</span>)]))</span>
<span id="cb156-26"><a href="#cb156-26" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb156-27"><a href="#cb156-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span>, []</span>
<span id="cb156-28"><a href="#cb156-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-29"><a href="#cb156-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sorting_by_reversals(pi, gamma):</span>
<span id="cb156-30"><a href="#cb156-30" aria-hidden="true" tabindex="-1"></a>    distance, reversals <span class="op">=</span> bfs(pi, gamma)</span>
<span id="cb156-31"><a href="#cb156-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> distance, reversals</span>
<span id="cb156-32"><a href="#cb156-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb156-33"><a href="#cb156-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_string):</span>
<span id="cb156-34"><a href="#cb156-34" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_string.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb156-35"><a href="#cb156-35" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> lines[<span class="dv">0</span>].split()]</span>
<span id="cb156-36"><a href="#cb156-36" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> lines[<span class="dv">1</span>].split()]</span>
<span id="cb156-37"><a href="#cb156-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pi, gamma</span>
<span id="cb156-38"><a href="#cb156-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb156-39"><a href="#cb156-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb156-40"><a href="#cb156-40" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb156-41"><a href="#cb156-41" aria-hidden="true" tabindex="-1"></a><span class="st">6 5 4 7 2 3 9 8 10 1</span></span>
<span id="cb156-42"><a href="#cb156-42" aria-hidden="true" tabindex="-1"></a><span class="st">4 6 2 9 7 1 3 8 5 10</span></span>
<span id="cb156-43"><a href="#cb156-43" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb156-44"><a href="#cb156-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-45"><a href="#cb156-45" aria-hidden="true" tabindex="-1"></a>pi, gamma <span class="op">=</span> parse_input(sample_input)</span>
<span id="cb156-46"><a href="#cb156-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the results</span></span>
<span id="cb156-47"><a href="#cb156-47" aria-hidden="true" tabindex="-1"></a>distance, reversals <span class="op">=</span> sorting_by_reversals(pi, gamma)</span>
<span id="cb156-48"><a href="#cb156-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-49"><a href="#cb156-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb156-50"><a href="#cb156-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(distance)</span>
<span id="cb156-51"><a href="#cb156-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> r <span class="kw">in</span> reversals:</span>
<span id="cb156-52"><a href="#cb156-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(r[<span class="dv">0</span>], r[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-26" class="level2" data-number="52.7">
<h2 data-number="52.7" class="anchored" data-anchor-id="explanation-26"><span class="header-section-number">52.7</span> Explanation</h2>
<ol type="1">
<li><strong>reverse_sublist</strong>: A helper function to reverse a sublist within a list.</li>
<li><strong>bfs</strong>: The BFS function to explore all possible permutations resulting from single reversals, tracking the path taken.</li>
<li><strong>sorting_by_reversals</strong>: Main function to find the reversal distance and the specific reversals.</li>
</ol>
</section>
</section>
<section id="inferring-protein-from-spectrum" class="level1" data-number="53">
<h1 data-number="53"><span class="header-section-number">53</span> Inferring Protein from Spectrum</h1>
<p>The&nbsp;<a href="https://rosalind.info/glossary/prefix-spectrum/">prefix spectrum</a>&nbsp;of a weighted string is the collection of all its prefix&nbsp;<a href="https://rosalind.info/glossary/string-weight/">weights</a>.</p>
<p>Given:&nbsp;A list&nbsp;<span class="math inline">\(L\)</span>&nbsp;of&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤100\)</span>) positive real numbers.</p>
<p>Return:&nbsp;A protein string of length&nbsp;<span class="math inline">\(n−1\)</span>&nbsp;whose prefix spectrum is equal to&nbsp;<span class="math inline">\(L\)</span>&nbsp;(if multiple solutions exist, you may output any one of them). Consult the&nbsp;<a href="https://rosalind.info/glossary/monoisotopic-mass-table/">monoisotopic mas table</a>.</p>
<section id="sample-dataset-52" class="level2" data-number="53.1">
<h2 data-number="53.1" class="anchored" data-anchor-id="sample-dataset-52"><span class="header-section-number">53.1</span> Sample Dataset</h2>
<pre><code>3524.8542
3710.9335
3841.974
3970.0326
4057.0646</code></pre>
</section>
<section id="sample-output-53" class="level2" data-number="53.2">
<h2 data-number="53.2" class="anchored" data-anchor-id="sample-output-53"><span class="header-section-number">53.2</span> Sample Output</h2>
<pre><code>WMQS</code></pre>
</section>
<section id="solution-49" class="level2" data-number="53.3">
<h2 data-number="53.3" class="anchored" data-anchor-id="solution-49"><span class="header-section-number">53.3</span> Solution</h2>
<p>To solve this problem, we need to infer a protein string from its prefix spectrum. The prefix spectrum is a list of cumulative masses of prefixes of the protein. Given a list of masses, our goal is to determine which amino acids correspond to the differences between successive masses in this list.</p>
<p>Here’s a step-by-step approach to solve the problem:</p>
<ol type="1">
<li><strong>Parse the input list</strong> of masses.</li>
<li><strong>Compute the differences</strong> between successive masses. These differences should correspond to the masses of amino acids.</li>
<li><strong>Match the computed differences</strong> to the known monoisotopic masses of amino acids.</li>
<li><strong>Construct the protein string</strong> from the matched amino acids.</li>
</ol>
<p>We’ll use the monoisotopic mas table for amino acids, which provides the exact masses of each amino acid.</p>
<p>Here’s the Python code to implement this:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Monoisotopic mas table for amino acids</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>monoisotopic_mass_table <span class="op">=</span> {</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: <span class="fl">71.03711</span>, <span class="st">'C'</span>: <span class="fl">103.00919</span>, <span class="st">'D'</span>: <span class="fl">115.02694</span>, <span class="st">'E'</span>: <span class="fl">129.04259</span>, <span class="st">'F'</span>: <span class="fl">147.06841</span>,</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'G'</span>: <span class="fl">57.02146</span>, <span class="st">'H'</span>: <span class="fl">137.05891</span>, <span class="st">'I'</span>: <span class="fl">113.08406</span>, <span class="st">'K'</span>: <span class="fl">128.09496</span>, <span class="st">'L'</span>: <span class="fl">113.08406</span>,</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'M'</span>: <span class="fl">131.04049</span>, <span class="st">'N'</span>: <span class="fl">114.04293</span>, <span class="st">'P'</span>: <span class="fl">97.05276</span>, <span class="st">'Q'</span>: <span class="fl">128.05858</span>, <span class="st">'R'</span>: <span class="fl">156.10111</span>,</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'S'</span>: <span class="fl">87.03203</span>, <span class="st">'T'</span>: <span class="fl">101.04768</span>, <span class="st">'V'</span>: <span class="fl">99.06841</span>, <span class="st">'W'</span>: <span class="fl">186.07931</span>, <span class="st">'Y'</span>: <span class="fl">163.06333</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_string):</span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, input_string.strip().split()))</span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_amino_acid(delta_mass):</span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> amino_acid, mas <span class="kw">in</span> monoisotopic_mass_table.items():</span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(mas <span class="op">-</span> delta_mass) <span class="op">&lt;</span> <span class="fl">0.01</span>:  <span class="co"># Allowing a small tolerance</span></span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> amino_acid</span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> infer_protein_from_spectrum(spectrum):</span>
<span id="cb159-19"><a href="#cb159-19" aria-hidden="true" tabindex="-1"></a>    protein <span class="op">=</span> <span class="st">""</span></span>
<span id="cb159-20"><a href="#cb159-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(spectrum)):</span>
<span id="cb159-21"><a href="#cb159-21" aria-hidden="true" tabindex="-1"></a>        delta_mas <span class="op">=</span> spectrum[i] <span class="op">-</span> spectrum[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb159-22"><a href="#cb159-22" aria-hidden="true" tabindex="-1"></a>        amino_acid <span class="op">=</span> find_amino_acid(delta_mass)</span>
<span id="cb159-23"><a href="#cb159-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> amino_acid:</span>
<span id="cb159-24"><a href="#cb159-24" aria-hidden="true" tabindex="-1"></a>            protein <span class="op">+=</span> amino_acid</span>
<span id="cb159-25"><a href="#cb159-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb159-26"><a href="#cb159-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"No matching amino acid found for mas difference </span><span class="sc">{</span>delta_mass<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb159-27"><a href="#cb159-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> protein</span>
<span id="cb159-28"><a href="#cb159-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-29"><a href="#cb159-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb159-30"><a href="#cb159-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sample input</span></span>
<span id="cb159-31"><a href="#cb159-31" aria-hidden="true" tabindex="-1"></a>    sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb159-32"><a href="#cb159-32" aria-hidden="true" tabindex="-1"></a><span class="st">    3524.8542</span></span>
<span id="cb159-33"><a href="#cb159-33" aria-hidden="true" tabindex="-1"></a><span class="st">    3710.9335</span></span>
<span id="cb159-34"><a href="#cb159-34" aria-hidden="true" tabindex="-1"></a><span class="st">    3841.974</span></span>
<span id="cb159-35"><a href="#cb159-35" aria-hidden="true" tabindex="-1"></a><span class="st">    3970.0326</span></span>
<span id="cb159-36"><a href="#cb159-36" aria-hidden="true" tabindex="-1"></a><span class="st">    4057.0646</span></span>
<span id="cb159-37"><a href="#cb159-37" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb159-38"><a href="#cb159-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-39"><a href="#cb159-39" aria-hidden="true" tabindex="-1"></a>    spectrum <span class="op">=</span> parse_input(sample_input)</span>
<span id="cb159-40"><a href="#cb159-40" aria-hidden="true" tabindex="-1"></a>    protein <span class="op">=</span> infer_protein_from_spectrum(spectrum)</span>
<span id="cb159-41"><a href="#cb159-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(protein)</span>
<span id="cb159-42"><a href="#cb159-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-43"><a href="#cb159-43" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb159-44"><a href="#cb159-44" aria-hidden="true" tabindex="-1"></a>    main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-27" class="level2" data-number="53.4">
<h2 data-number="53.4" class="anchored" data-anchor-id="explanation-27"><span class="header-section-number">53.4</span> Explanation</h2>
<ol type="1">
<li><strong>parse_input</strong>: This function parses the input string into a list of floats representing the masses.</li>
<li><strong>find_amino_acid</strong>: This function takes a mas difference and finds the corresponding amino acid by comparing it against the monoisotopic mas table, allowing for a small tolerance due to floating-point precision issues.</li>
<li><strong>infer_protein_from_spectrum</strong>: This function computes the differences between successive masses in the spectrum and uses <code>find_amino_acid</code> to map these differences to amino acids, constructing the protein string.</li>
</ol>
</section>
</section>
<section id="introduction-to-pattern-matching" class="level1" data-number="54">
<h1 data-number="54"><span class="header-section-number">54</span> Introduction to Pattern Matching</h1>
<p>Given a collection of&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>, their&nbsp;<a href="https://rosalind.info/glossary/trie/">trie</a>&nbsp;(often pronounced “try” to avoid ambiguity with the general term&nbsp;<a href="https://rosalind.info/glossary/tree/">tree</a>) is a&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;formed as follows. For every unique first symbol in the strings, an&nbsp;<a href="https://rosalind.info/glossary/edge/">edge</a>&nbsp;is formed connecting the&nbsp;<a href="https://rosalind.info/glossary/root/">root</a>&nbsp;to a new vertex. This symbol is then used to label the edge.</p>
<p>We may then iterate the proces by moving down one level as follows. Say that an edge connecting the root to a&nbsp;<a href="https://rosalind.info/glossary/node/">node</a>&nbsp;<span class="math inline">\(v\)</span>&nbsp;is labeled with ‘A’; then we delete the first symbol from every string in the collection beginning with ‘A’ and then treat&nbsp;<span class="math inline">\(v\)</span>&nbsp;as our root. We apply this proces to all nodes that are&nbsp;<a href="https://rosalind.info/glossary/adjacent-nodes/">adjacent</a>&nbsp;to the root, and then we move down another level and continue.</p>
<p>As a result of this method of construction, the symbols along the edges of any path in the trie from the root to a&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaf</a>&nbsp;will spell out a unique string from the collection, as long as no string is a&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefix</a>&nbsp;of another in the collection (this would cause the first string to be encoded as a path terminating at an&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal node</a>).</p>
<p>Given:&nbsp;A list of at most 100&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;of length at most 100&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>, none of which is a prefix of another.</p>
<p>Return:&nbsp;The&nbsp;<a href="https://rosalind.info/glossary/adjacency-list/">adjacency list</a>&nbsp;corresponding to the trie&nbsp;<span class="math inline">\(T\)</span>&nbsp;for these patterns, in the following format. If&nbsp;<span class="math inline">\(T\)</span>&nbsp;has&nbsp;<span class="math inline">\(n\)</span>&nbsp;nodes, first label the root with 1 and then label the remaining nodes with the integers 2 through&nbsp;<span class="math inline">\(n\)</span>&nbsp;in any order you like. Each edge of the adjacency list of&nbsp;<span class="math inline">\(T\)</span>&nbsp;will be encoded by a triple containing the integer representing the edge’s&nbsp;<a href="https://rosalind.info/glossary/parent/">parent node</a>, followed by the integer representing the edge’s&nbsp;<a href="https://rosalind.info/glossary/child/">child node</a>, and finally the&nbsp;<a href="https://rosalind.info/glossary/symbol/">symbol</a>&nbsp;labeling the edge.</p>
<section id="sample-dataset-53" class="level2" data-number="54.1">
<h2 data-number="54.1" class="anchored" data-anchor-id="sample-dataset-53"><span class="header-section-number">54.1</span> Sample Dataset</h2>
<pre><code>ATAGA
ATC
GAT</code></pre>
</section>
<section id="sample-output-54" class="level2" data-number="54.2">
<h2 data-number="54.2" class="anchored" data-anchor-id="sample-output-54"><span class="header-section-number">54.2</span> Sample Output</h2>
<pre><code>1 2 A
2 3 T
3 4 A
4 5 G
5 6 A
3 7 C
1 8 G
8 9 A
9 10 T</code></pre>
</section>
<section id="solution-50" class="level2" data-number="54.3">
<h2 data-number="54.3" class="anchored" data-anchor-id="solution-50"><span class="header-section-number">54.3</span> Solution</h2>
<p>To construct a trie from a given collection of DNA strings, we need to follow these steps:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start with a root node.</li>
<li><strong>Insertion</strong>: For each string in the collection, insert it into the trie by creating new nodes and edges as necessary.</li>
<li><strong>Output</strong>: Generate the adjacency list representation of the trie.</li>
</ol>
<p>Here is the Python code to accomplish this task:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_trie(patterns):</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    trie <span class="op">=</span> {<span class="dv">1</span>: {}}</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    next_node <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pattern <span class="kw">in</span> patterns:</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>        current_node <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> char <span class="kw">in</span> pattern:</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> char <span class="kw">in</span> trie[current_node]:</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>                current_node <span class="op">=</span> trie[current_node][char]</span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a>                trie[current_node][char] <span class="op">=</span> next_node</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>                trie[next_node] <span class="op">=</span> {}</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a>                current_node <span class="op">=</span> next_node</span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>                next_node <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trie</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> trie_to_adjacency_list(trie):</span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a>    adjacency_list <span class="op">=</span> []</span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> parent <span class="kw">in</span> trie:</span>
<span id="cb162-19"><a href="#cb162-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> char, child <span class="kw">in</span> trie[parent].items():</span>
<span id="cb162-20"><a href="#cb162-20" aria-hidden="true" tabindex="-1"></a>            adjacency_list.append((parent, child, char))</span>
<span id="cb162-21"><a href="#cb162-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> adjacency_list</span>
<span id="cb162-22"><a href="#cb162-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-23"><a href="#cb162-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb162-24"><a href="#cb162-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sample input</span></span>
<span id="cb162-25"><a href="#cb162-25" aria-hidden="true" tabindex="-1"></a>    input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb162-26"><a href="#cb162-26" aria-hidden="true" tabindex="-1"></a><span class="st">    ATAGA</span></span>
<span id="cb162-27"><a href="#cb162-27" aria-hidden="true" tabindex="-1"></a><span class="st">    ATC</span></span>
<span id="cb162-28"><a href="#cb162-28" aria-hidden="true" tabindex="-1"></a><span class="st">    GAT</span></span>
<span id="cb162-29"><a href="#cb162-29" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb162-30"><a href="#cb162-30" aria-hidden="true" tabindex="-1"></a>    patterns <span class="op">=</span> input_data.strip().split()</span>
<span id="cb162-31"><a href="#cb162-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb162-32"><a href="#cb162-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build the trie</span></span>
<span id="cb162-33"><a href="#cb162-33" aria-hidden="true" tabindex="-1"></a>    trie <span class="op">=</span> build_trie(patterns)</span>
<span id="cb162-34"><a href="#cb162-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb162-35"><a href="#cb162-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert trie to adjacency list</span></span>
<span id="cb162-36"><a href="#cb162-36" aria-hidden="true" tabindex="-1"></a>    adjacency_list <span class="op">=</span> trie_to_adjacency_list(trie)</span>
<span id="cb162-37"><a href="#cb162-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb162-38"><a href="#cb162-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print the adjacency list</span></span>
<span id="cb162-39"><a href="#cb162-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> parent, child, char <span class="kw">in</span> adjacency_list:</span>
<span id="cb162-40"><a href="#cb162-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>parent<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>child<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>char<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb162-41"><a href="#cb162-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-42"><a href="#cb162-42" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb162-43"><a href="#cb162-43" aria-hidden="true" tabindex="-1"></a>    main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-28" class="level2" data-number="54.4">
<h2 data-number="54.4" class="anchored" data-anchor-id="explanation-28"><span class="header-section-number">54.4</span> Explanation</h2>
<ol type="1">
<li><strong>Function <code>build_trie</code></strong>:
<ul>
<li>Initializes the trie with a root node labeled <code>1</code>.</li>
<li>For each pattern, it iterates through its characters, and either moves to an existing node if the character is already in the current node’s dictionary or creates a new node if the character is not present.</li>
<li>It maintains a counter <code>next_node</code> to assign new labels to nodes.</li>
</ul></li>
<li><strong>Function <code>trie_to_adjacency_list</code></strong>:
<ul>
<li>Converts the trie structure into an adjacency list format, which is a list of tuples where each tuple represents an edge from a parent node to a child node labeled by a character.</li>
</ul></li>
<li><strong>Function <code>main</code></strong>:
<ul>
<li>Handles input and output operations.</li>
<li>Reads the input strings, constructs the trie, converts it to an adjacency list, and then prints the adjacency list.</li>
</ul></li>
</ol>
</section>
</section>
<section id="comparing-spectra-with-the-spectral-convolution" class="level1" data-number="55">
<h1 data-number="55"><span class="header-section-number">55</span> Comparing Spectra with the Spectral Convolution</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/multiset/">multiset</a>&nbsp;is a generalization of the notion of&nbsp;<a href="https://rosalind.info/glossary/set/">set</a>&nbsp;to include a collection of objects in which each object may occur more than once (the order in which objects are given is still unimportant). For a multiset&nbsp;<span class="math inline">\(S\)</span>, the&nbsp;<a href="https://rosalind.info/glossary/multiplicity/">multiplicity</a>&nbsp;of an element&nbsp;<span class="math inline">\(x\)</span>&nbsp;is the number of times that&nbsp;<span class="math inline">\(x\)</span>&nbsp;occurs in the set; this multiplicity is denoted&nbsp;<span class="math inline">\(S(x)\)</span>. Note that every set is included in the definition of multiset.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/minkowski-sum/">Minkowski sum</a>&nbsp;of multisets&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and&nbsp;<span class="math inline">\(S2\)</span>&nbsp;containing real numbers is the new multiset&nbsp;<span class="math inline">\(S1⊕S2\)</span>&nbsp;formed by taking all possible sums&nbsp;<span class="math inline">\(s1+s2\)</span>&nbsp;of an element&nbsp;<span class="math inline">\(s1\)</span>&nbsp;from&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and an element&nbsp;<span class="math inline">\(s2\)</span>&nbsp;from&nbsp;<span class="math inline">\(S2\)</span>. The Minkowski sum could be defined more concisely as&nbsp;<span class="math inline">\(S1⊕S2=s1+s2:s1∈S1,s2∈S2\)</span>, The&nbsp;<a href="https://rosalind.info/glossary/minkowski-difference/">Minkowski difference</a>&nbsp;<span class="math inline">\(S1⊖S2\)</span>&nbsp;is defined analogously by taking all possible differences&nbsp;<span class="math inline">\(s1−s2\)</span>.</p>
<p>If&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and&nbsp;<span class="math inline">\(S2\)</span>&nbsp;represent simplified spectra taken from two peptides, then&nbsp;<span class="math inline">\(S1⊖S2\)</span>&nbsp;is called the&nbsp;<a href="https://rosalind.info/glossary/spectral-convolution/">spectral convolution</a>&nbsp;of&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and&nbsp;<span class="math inline">\(S2\)</span>. In this notation, the shared peaks count is represented by&nbsp;<span class="math inline">\((S2⊖S1)(0)\)</span>, and the value of&nbsp;<span class="math inline">\(x\)</span>&nbsp;for which&nbsp;<span class="math inline">\((S2⊖S1)(x)\)</span>&nbsp;has the maximal value is the shift value maximizing the number of shared masses of&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and&nbsp;<span class="math inline">\(S2\)</span>.</p>
<p>Given:&nbsp;Two multisets of positive real numbers&nbsp;<span class="math inline">\(S1\)</span>&nbsp;and&nbsp;<span class="math inline">\(S2\)</span>. The size of each multiset is at most 200.</p>
<p>Return:&nbsp;The largest multiplicity of&nbsp;<span class="math inline">\(S1⊖S2\)</span>, as well as the absolute value of the number&nbsp;<span class="math inline">\(x\)</span>&nbsp;maximizing&nbsp;<span class="math inline">\((S1⊖S2)(x)\)</span>&nbsp;(you may return any such value if multiple solutions exist).</p>
<section id="sample-dataset-54" class="level2" data-number="55.1">
<h2 data-number="55.1" class="anchored" data-anchor-id="sample-dataset-54"><span class="header-section-number">55.1</span> Sample Dataset</h2>
<pre><code>186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544
101.04768 158.06914 202.09536 318.09979 419.14747 463.17369</code></pre>
</section>
<section id="sample-output-55" class="level2" data-number="55.2">
<h2 data-number="55.2" class="anchored" data-anchor-id="sample-output-55"><span class="header-section-number">55.2</span> Sample Output</h2>
<pre><code>3
85.03163</code></pre>
</section>
<section id="solution-51" class="level2" data-number="55.3">
<h2 data-number="55.3" class="anchored" data-anchor-id="solution-51"><span class="header-section-number">55.3</span> Solution</h2>
<p>To solve the problem of comparing spectra using the spectral convolution, we need to follow these steps:</p>
<ol type="1">
<li><strong>Parse the input</strong>: Read the two multisets <span class="math inline">\(S1\)</span> and <span class="math inline">\(S2\)</span>.</li>
<li><strong>Compute the spectral convolution</strong>: For each pair of elements <span class="math inline">\((s1, s2)\)</span> where <span class="math inline">\(s1 \in S1\)</span> and <span class="math inline">\(s2 \in S2\)</span>, compute the difference <span class="math inline">\(s1 - s2\)</span>.</li>
<li><strong>Count the occurrences of each difference</strong>: Track how many times each difference appears.</li>
<li><strong>Find the most frequent difference</strong>: Identify the difference that appears most frequently and its multiplicity.</li>
</ol>
<p>Here’s the Python code to implement the above steps:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(input_data):</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_data.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>    S1 <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, lines[<span class="dv">0</span>].split()))</span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>    S2 <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, lines[<span class="dv">1</span>].split()))</span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S1, S2</span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_convolution(S1, S2):</span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    convolution <span class="op">=</span> []</span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s1 <span class="kw">in</span> S1:</span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s2 <span class="kw">in</span> S2:</span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true" tabindex="-1"></a>            convolution.append(<span class="bu">round</span>(s1 <span class="op">-</span> s2, <span class="dv">5</span>))</span>
<span id="cb165-14"><a href="#cb165-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> convolution</span>
<span id="cb165-15"><a href="#cb165-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-16"><a href="#cb165-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_max_multiplicity(convolution):</span>
<span id="cb165-17"><a href="#cb165-17" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> Counter(convolution)</span>
<span id="cb165-18"><a href="#cb165-18" aria-hidden="true" tabindex="-1"></a>    max_value, max_count <span class="op">=</span> <span class="bu">max</span>(count.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb165-19"><a href="#cb165-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_count, <span class="bu">abs</span>(max_value)</span>
<span id="cb165-20"><a href="#cb165-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-21"><a href="#cb165-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main(input_data):</span>
<span id="cb165-22"><a href="#cb165-22" aria-hidden="true" tabindex="-1"></a>    S1, S2 <span class="op">=</span> parse_input(input_data)</span>
<span id="cb165-23"><a href="#cb165-23" aria-hidden="true" tabindex="-1"></a>    convolution <span class="op">=</span> spectral_convolution(S1, S2)</span>
<span id="cb165-24"><a href="#cb165-24" aria-hidden="true" tabindex="-1"></a>    max_count, max_value <span class="op">=</span> find_max_multiplicity(convolution)</span>
<span id="cb165-25"><a href="#cb165-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_count, max_value</span>
<span id="cb165-26"><a href="#cb165-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-27"><a href="#cb165-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb165-28"><a href="#cb165-28" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb165-29"><a href="#cb165-29" aria-hidden="true" tabindex="-1"></a><span class="st">186.07931 287.12699 548.20532 580.18077 681.22845 706.27446 782.27613 968.35544 968.35544</span></span>
<span id="cb165-30"><a href="#cb165-30" aria-hidden="true" tabindex="-1"></a><span class="st">101.04768 158.06914 202.09536 318.09979 419.14747 463.17369</span></span>
<span id="cb165-31"><a href="#cb165-31" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb165-32"><a href="#cb165-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-33"><a href="#cb165-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Proces the input and get the result</span></span>
<span id="cb165-34"><a href="#cb165-34" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> main(sample_input)</span>
<span id="cb165-35"><a href="#cb165-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result[<span class="dv">0</span>])</span>
<span id="cb165-36"><a href="#cb165-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result[<span class="dv">1</span>]<span class="sc">:f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-29" class="level2" data-number="55.4">
<h2 data-number="55.4" class="anchored" data-anchor-id="explanation-29"><span class="header-section-number">55.4</span> Explanation</h2>
<ol type="1">
<li><strong>Parsing Input</strong>:
<ul>
<li>The <code>parse_input</code> function reads the input data, splits it into lines, and then converts each line into a list of floats representing <span class="math inline">\(S1\)</span> and <span class="math inline">\(S2\)</span>.</li>
</ul></li>
<li><strong>Computing Spectral Convolution</strong>:
<ul>
<li>The <code>spectral_convolution</code> function takes all pairs <span class="math inline">\((s1, s2)\)</span> from <span class="math inline">\(S1\)</span> and <span class="math inline">\(S2\)</span>, computes the difference <span class="math inline">\(s1 - s2\)</span>, and stores these differences in a list. The <code>round</code> function ensures precision to 5 decimal places, as floating-point arithmetic can introduce small errors.</li>
</ul></li>
<li><strong>Counting Occurrences</strong>:
<ul>
<li>The <code>find_max_multiplicity</code> function uses Python’s <code>Counter</code> from the <code>collections</code> module to count how often each difference appears in the convolution list. It then finds the difference with the maximum count (multiplicity) and its corresponding value.</li>
</ul></li>
<li><strong>Main Function</strong>:
<ul>
<li>The <code>main</code> function orchestrates the proces by calling the helper functions and printing the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="creating-a-character-table" class="level1" data-number="56">
<h1 data-number="56"><span class="header-section-number">56</span> Creating a Character Table</h1>
<p>Given a collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa, any&nbsp;<a href="https://rosalind.info/glossary/subset/">subset</a>&nbsp;<span class="math inline">\(S\)</span>&nbsp;of these taxa can be seen as encoding a character that divides the taxa into the sets&nbsp;<span class="math inline">\(S\)</span>&nbsp;and&nbsp;<span class="math inline">\(S^c\)</span>; we can represent the character by&nbsp;<span class="math inline">\(S∣S^c\)</span>, which is called a&nbsp;<a href="https://rosalind.info/glossary/split/">split</a>. Alternately, the character can be represented by a&nbsp;<a href="https://rosalind.info/glossary/array-notation/">character array</a>&nbsp;<span class="math inline">\(A\)</span> of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;for which&nbsp;<span class="math inline">\(A[j]=1\)</span>&nbsp;if the&nbsp;<span class="math inline">\(j\)</span>th taxon belongs to&nbsp;<span class="math inline">\(S\)</span>&nbsp;and&nbsp;<span class="math inline">\(A[j]=0\)</span>&nbsp;if the&nbsp;<span class="math inline">\(j\)</span>th taxon belongs to&nbsp;<span class="math inline">\(S^c\)</span>&nbsp;(recall the “ON”/“OFF” analogy from&nbsp;<a href="https://rosalind.info/problems/sset/">“Counting Subsets”</a>).</p>
<p>At the same time, observe that the removal of an&nbsp;<a href="https://rosalind.info/glossary/edge/">edge</a>&nbsp;from an&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary tree</a>&nbsp;produces two separate trees, each one containing a subset of the original taxa. So each edge may also be encoded by a split&nbsp;<span class="math inline">\(S∣S^c\)</span>.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/trivial-character/">trivial character</a>&nbsp;isolates a single taxon into a group of its own. The corresponding split&nbsp;<span class="math inline">\(S∣S^c\)</span>&nbsp;must be such that&nbsp;<span class="math inline">\(S\)</span>&nbsp;or&nbsp;<span class="math inline">\(S^c\)</span>&nbsp;contains only one element; the edge encoded by this split must be&nbsp;<a href="https://rosalind.info/glossary/incident/">incident</a>&nbsp;to a&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaf</a>&nbsp;of the unrooted binary tree, and the array for the character contains exactly one 0 or exactly one 1. Trivial characters are of no phylogenetic interest because they fail to provide us with information regarding the relationships of taxa to each other. All other characters are called&nbsp;<a href="https://rosalind.info/glossary/nontrivial-character/">nontrivial characters</a>&nbsp;(and the associated splits are called&nbsp;<a href="https://rosalind.info/glossary/nontrivial-split/">nontrivial splits</a>).</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/character-table/">character table</a>&nbsp;is a matrix&nbsp;<span class="math inline">\(C\)</span>&nbsp;in which each row represents the array notation for a nontrivial character. That is, entry&nbsp;<span class="math inline">\(C_{i,j}\)</span>&nbsp;denotes the “ON”/“OFF” position of the&nbsp;<span class="math inline">\(i\)</span>th character with respect to the&nbsp;<span class="math inline">\(j\)</span>th taxon.</p>
<p>Given:&nbsp;An unrooted binary tree&nbsp;<span class="math inline">\(T\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;for at most 200 species taxa.</p>
<p>Return:&nbsp;A character table having the same splits as the edge splits of&nbsp;<span class="math inline">\(T\)</span>. The columns of the character table should encode the taxa ordered lexicographically; the rows of the character table may be given in any order. Also, for any given character, the particular subset of taxa to which 1s are assigned is arbitrary.</p>
<section id="sample-dataset-55" class="level2" data-number="56.1">
<h2 data-number="56.1" class="anchored" data-anchor-id="sample-dataset-55"><span class="header-section-number">56.1</span> Sample Dataset</h2>
<pre><code>(dog,((elephant,mouse),robot),cat);</code></pre>
</section>
<section id="sample-output-56" class="level2" data-number="56.2">
<h2 data-number="56.2" class="anchored" data-anchor-id="sample-output-56"><span class="header-section-number">56.2</span> Sample Output</h2>
<pre><code>00110
00111</code></pre>
</section>
<section id="solution-52" class="level2" data-number="56.3">
<h2 data-number="56.3" class="anchored" data-anchor-id="solution-52"><span class="header-section-number">56.3</span> Solution</h2>
<p>The code parses a Newick string representing a phylogenetic tree and converts it into a character table, where each row of the table represents a partition of taxa.</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Node clas to represent a node in the tree</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>clas Node:</span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name<span class="op">=</span><span class="st">""</span>):</span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name         <span class="co"># Name of the taxon or internal node</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []       <span class="co"># List to store child nodes</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to parse a Newick string into a tree structure</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_newick(newick):</span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_node():</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> i</span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node()</span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> newick[i] <span class="op">==</span> <span class="st">'('</span>:</span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> newick[i] <span class="op">!=</span> <span class="st">')'</span>:</span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a>                node.children.append(parse_node())</span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> newick[i] <span class="op">==</span> <span class="st">','</span>:</span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true" tabindex="-1"></a>                    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb168-20"><a href="#cb168-20" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb168-21"><a href="#cb168-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract node name</span></span>
<span id="cb168-22"><a href="#cb168-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> newick[i] <span class="kw">not</span> <span class="kw">in</span> <span class="st">',)'</span>:</span>
<span id="cb168-23"><a href="#cb168-23" aria-hidden="true" tabindex="-1"></a>            name_start <span class="op">=</span> i</span>
<span id="cb168-24"><a href="#cb168-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> newick[i] <span class="kw">not</span> <span class="kw">in</span> <span class="st">',)'</span>:</span>
<span id="cb168-25"><a href="#cb168-25" aria-hidden="true" tabindex="-1"></a>                i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb168-26"><a href="#cb168-26" aria-hidden="true" tabindex="-1"></a>            node.name <span class="op">=</span> newick[name_start:i]</span>
<span id="cb168-27"><a href="#cb168-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb168-28"><a href="#cb168-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-29"><a href="#cb168-29" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb168-30"><a href="#cb168-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parse_node()</span>
<span id="cb168-31"><a href="#cb168-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-32"><a href="#cb168-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Recursive function to find all splits (partitions) of the taxa</span></span>
<span id="cb168-33"><a href="#cb168-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_splits(node, taxa, splits):</span>
<span id="cb168-34"><a href="#cb168-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If it's a leaf node, return the set containing the taxon name</span></span>
<span id="cb168-35"><a href="#cb168-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> node.children:</span>
<span id="cb168-36"><a href="#cb168-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {node.name}</span>
<span id="cb168-37"><a href="#cb168-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-38"><a href="#cb168-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursively find splits in left and right children</span></span>
<span id="cb168-39"><a href="#cb168-39" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> find_splits(node.children[<span class="dv">0</span>], taxa, splits)</span>
<span id="cb168-40"><a href="#cb168-40" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> find_splits(node.children[<span class="dv">1</span>], taxa, splits)</span>
<span id="cb168-41"><a href="#cb168-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-42"><a href="#cb168-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine left and right splits</span></span>
<span id="cb168-43"><a href="#cb168-43" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> left <span class="op">|</span> right</span>
<span id="cb168-44"><a href="#cb168-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-45"><a href="#cb168-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if this split is non-trivial and add it to the splits list</span></span>
<span id="cb168-46"><a href="#cb168-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(split) <span class="op">&lt;</span> <span class="bu">len</span>(taxa) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb168-47"><a href="#cb168-47" aria-hidden="true" tabindex="-1"></a>        splits.append(split)</span>
<span id="cb168-48"><a href="#cb168-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-49"><a href="#cb168-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> split</span>
<span id="cb168-50"><a href="#cb168-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-51"><a href="#cb168-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to create a character table from the splits</span></span>
<span id="cb168-52"><a href="#cb168-52" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_character_table(tree, taxa):</span>
<span id="cb168-53"><a href="#cb168-53" aria-hidden="true" tabindex="-1"></a>    splits <span class="op">=</span> []</span>
<span id="cb168-54"><a href="#cb168-54" aria-hidden="true" tabindex="-1"></a>    find_splits(tree, <span class="bu">set</span>(taxa), splits)</span>
<span id="cb168-55"><a href="#cb168-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-56"><a href="#cb168-56" aria-hidden="true" tabindex="-1"></a>    table <span class="op">=</span> []</span>
<span id="cb168-57"><a href="#cb168-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert each split into a binary row</span></span>
<span id="cb168-58"><a href="#cb168-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> split <span class="kw">in</span> splits:</span>
<span id="cb168-59"><a href="#cb168-59" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> [<span class="st">'1'</span> <span class="cf">if</span> taxon <span class="kw">in</span> split <span class="cf">else</span> <span class="st">'0'</span> <span class="cf">for</span> taxon <span class="kw">in</span> taxa]</span>
<span id="cb168-60"><a href="#cb168-60" aria-hidden="true" tabindex="-1"></a>        table.append(<span class="st">''</span>.join(row))</span>
<span id="cb168-61"><a href="#cb168-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb168-62"><a href="#cb168-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> table</span>
<span id="cb168-63"><a href="#cb168-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-64"><a href="#cb168-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Newick string</span></span>
<span id="cb168-65"><a href="#cb168-65" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb168-66"><a href="#cb168-66" aria-hidden="true" tabindex="-1"></a><span class="st">(dog,((elephant,mouse),robot),cat);</span></span>
<span id="cb168-67"><a href="#cb168-67" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb168-68"><a href="#cb168-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-69"><a href="#cb168-69" aria-hidden="true" tabindex="-1"></a><span class="co"># Strip leading/trailing whitespace and parse the Newick string</span></span>
<span id="cb168-70"><a href="#cb168-70" aria-hidden="true" tabindex="-1"></a>newick <span class="op">=</span> sample_input.strip()</span>
<span id="cb168-71"><a href="#cb168-71" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> parse_newick(newick)</span>
<span id="cb168-72"><a href="#cb168-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-73"><a href="#cb168-73" aria-hidden="true" tabindex="-1"></a>taxa <span class="op">=</span> []</span>
<span id="cb168-74"><a href="#cb168-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-75"><a href="#cb168-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to collect all taxa names from the tree</span></span>
<span id="cb168-76"><a href="#cb168-76" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> collect_taxa(node):</span>
<span id="cb168-77"><a href="#cb168-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node.name:</span>
<span id="cb168-78"><a href="#cb168-78" aria-hidden="true" tabindex="-1"></a>        taxa.append(node.name)</span>
<span id="cb168-79"><a href="#cb168-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb168-80"><a href="#cb168-80" aria-hidden="true" tabindex="-1"></a>        collect_taxa(child)</span>
<span id="cb168-81"><a href="#cb168-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-82"><a href="#cb168-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect and sort taxa names</span></span>
<span id="cb168-83"><a href="#cb168-83" aria-hidden="true" tabindex="-1"></a>collect_taxa(tree)</span>
<span id="cb168-84"><a href="#cb168-84" aria-hidden="true" tabindex="-1"></a>taxa.sort()</span>
<span id="cb168-85"><a href="#cb168-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-86"><a href="#cb168-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the character table based on the collected taxa</span></span>
<span id="cb168-87"><a href="#cb168-87" aria-hidden="true" tabindex="-1"></a>character_table <span class="op">=</span> create_character_table(tree, taxa)</span>
<span id="cb168-88"><a href="#cb168-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-89"><a href="#cb168-89" aria-hidden="true" tabindex="-1"></a><span class="co"># Print each row of the character table</span></span>
<span id="cb168-90"><a href="#cb168-90" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> character_table:</span>
<span id="cb168-91"><a href="#cb168-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explain" class="level2" data-number="56.4">
<h2 data-number="56.4" class="anchored" data-anchor-id="explain"><span class="header-section-number">56.4</span> Explain</h2>
<ol type="1">
<li><strong><code>Node</code> Class</strong>:
<ul>
<li><strong>Purpose</strong>: Represents a node in the tree.</li>
<li><strong>Attributes</strong>:
<ul>
<li><code>name</code>: Name of the taxon or internal node.</li>
<li><code>children</code>: List of child nodes.</li>
</ul></li>
</ul></li>
<li><strong><code>parse_newick</code> Function</strong>:
<ul>
<li><strong>Purpose</strong>: Parses a Newick string into a tree structure.</li>
<li><strong>Inner Function <code>parse_node</code></strong>:
<ul>
<li><strong>Handles parentheses</strong>: It processes nested parentheses to build the tree structure.</li>
<li><strong>Extracts names</strong>: It extracts the name of each node by looking for characters until it hits a delimiter (comma or closing parenthesis).</li>
</ul></li>
</ul></li>
<li><strong><code>find_splits</code> Function</strong>:
<ul>
<li><strong>Purpose</strong>: Finds and collects all non-trivial splits of the taxa.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>node</code>: Current node in the tree.</li>
<li><code>taxa</code>: Set of all taxa names.</li>
<li><code>splits</code>: List to collect all non-trivial splits.</li>
</ul></li>
<li><strong>Logic</strong>:
<ul>
<li>Recursively computes splits for left and right subtrees.</li>
<li>Combines splits and checks if they are non-trivial.</li>
<li>Adds valid splits to the <code>splits</code> list.</li>
</ul></li>
</ul></li>
<li><strong><code>create_character_table</code> Function</strong>:
<ul>
<li><strong>Purpose</strong>: Converts splits into a character table.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>tree</code>: Root node of the tree.</li>
<li><code>taxa</code>: List of sorted taxa names.</li>
</ul></li>
<li><strong>Logic</strong>:
<ul>
<li>Uses <code>find_splits</code> to get the splits.</li>
<li>Converts each split into a binary representation.</li>
<li>Constructs and returns the character table as a list of strings.</li>
</ul></li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li><strong>Input Handling</strong>: Reads and strips the Newick string, then parses it into a tree.</li>
<li><strong>Taxa Collection</strong>: Collects and sorts all taxa names from the tree.</li>
<li><strong>Character Table Creation</strong>: Generates and prints the character table based on the tree structure and taxa.</li>
</ul></li>
</ol>
</section>
</section>
<section id="constructing-a-de-bruijn-graph" class="level1" data-number="57">
<h1 data-number="57"><span class="header-section-number">57</span> Constructing a De Bruijn Graph</h1>
<p>Consider a&nbsp;<a href="https://rosalind.info/glossary/set/">set</a>&nbsp;<span class="math inline">\(S\)</span>&nbsp;of&nbsp;<span class="math inline">\((k+1)\)</span>-mers of some unknown&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>. Let&nbsp;Src𝑆rc&nbsp;denote the set containing all reverse complements of the elements of&nbsp;<span class="math inline">\(S\)</span>. (recall from&nbsp;<a href="https://rosalind.info/problems/sset/">“Counting Subsets”</a>&nbsp;that sets are not allowed to contain duplicate elements).</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/de-bruijn-graph/">de Bruijn graph</a>&nbsp;Bk𝐵𝑘&nbsp;of order&nbsp;<span class="math inline">\(k\)</span>&nbsp;corresponding to&nbsp;<span class="math inline">\(S∪S^{rc}\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">digraph</a>&nbsp;defined in the following way:</p>
<ul>
<li><a href="https://rosalind.info/glossary/node/">Nodes</a>&nbsp;of&nbsp;<span class="math inline">\(B_k\)</span>&nbsp;correspond to all&nbsp;<span class="math inline">\(k\)</span>-mers that are present as a&nbsp;<a href="https://rosalind.info/glossary/substring/">substring</a>&nbsp;of a&nbsp;<span class="math inline">\((k+1)\)</span>-mer from&nbsp;<span class="math inline">\(S∪S^{rc}\)</span>.</li>
<li><a href="https://rosalind.info/glossary/edge/">Edges</a>&nbsp;of&nbsp;<span class="math inline">\(B_k\)</span>&nbsp;are encoded by the&nbsp;<span class="math inline">\((k+1)\)</span>-mers of&nbsp;<span class="math inline">\(S∪S^{rc}\)</span>&nbsp;in the following way: for each&nbsp;<span class="math inline">\((k+1)\)</span>-mer&nbsp;<span class="math inline">\(r\)</span>&nbsp;in&nbsp;<span class="math inline">\(S∪S^{rc}\)</span>, form a&nbsp;<a href="https://rosalind.info/glossary/directed-edge/">directed edge</a>&nbsp;(<span class="math inline">\(r[1:k]\)</span>,&nbsp;<span class="math inline">\(r[2:k+1]\)</span>).</li>
</ul>
<p>Given:&nbsp;A collection of up to 1000 (possibly repeating) DNA strings of equal length (not exceeding 50 bp) corresponding to a set&nbsp;<span class="math inline">\(S\)</span> of&nbsp;<span class="math inline">\((k+1)\)</span>-mers.</p>
<p>Return:&nbsp;The&nbsp;<a href="https://rosalind.info/glossary/adjacency-list/">adjacency list</a>&nbsp;corresponding to the de Bruijn graph corresponding to&nbsp;<span class="math inline">\(S∪S^{rc}\)</span>.</p>
<section id="sample-dataset-56" class="level2" data-number="57.1">
<h2 data-number="57.1" class="anchored" data-anchor-id="sample-dataset-56"><span class="header-section-number">57.1</span> Sample Dataset</h2>
<pre><code>TGAT
CATG
TCAT
ATGC
CATC
CATC</code></pre>
</section>
<section id="sample-output-57" class="level2" data-number="57.2">
<h2 data-number="57.2" class="anchored" data-anchor-id="sample-output-57"><span class="header-section-number">57.2</span> Sample Output</h2>
<pre><code>(ATC, TCA)
(ATG, TGA)
(ATG, TGC)
(CAT, ATC)
(CAT, ATG)
(GAT, ATG)
(GCA, CAT)
(TCA, CAT)
(TGA, GAT)</code></pre>
</section>
<section id="solution-53" class="level2" data-number="57.3">
<h2 data-number="57.3" class="anchored" data-anchor-id="solution-53"><span class="header-section-number">57.3</span> Solution</h2>
<p>We’ll compute the reverse complements and the updated set separately and then proceed with constructing the De Bruijn graph.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna):</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Computes the reverse complement of a DNA string."""</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>    complement <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'T'</span>, <span class="st">'T'</span>: <span class="st">'A'</span>, <span class="st">'C'</span>: <span class="st">'G'</span>, <span class="st">'G'</span>: <span class="st">'C'</span>}</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(complement[base] <span class="cf">for</span> base <span class="kw">in</span> <span class="bu">reversed</span>(dna))</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_de_bruijn_graph(kmers):</span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Constructs the De Bruijn graph and returns the adjacency list."""</span></span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a new set to include reverse complements</span></span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a>    kmers_with_rc <span class="op">=</span> <span class="bu">set</span>(kmers)</span>
<span id="cb171-12"><a href="#cb171-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> kmer <span class="kw">in</span> kmers:</span>
<span id="cb171-13"><a href="#cb171-13" aria-hidden="true" tabindex="-1"></a>        rc_kmer <span class="op">=</span> reverse_complement(kmer)</span>
<span id="cb171-14"><a href="#cb171-14" aria-hidden="true" tabindex="-1"></a>        kmers_with_rc.add(rc_kmer)</span>
<span id="cb171-15"><a href="#cb171-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-16"><a href="#cb171-16" aria-hidden="true" tabindex="-1"></a>    adjacency_list <span class="op">=</span> defaultdict(<span class="bu">set</span>)</span>
<span id="cb171-17"><a href="#cb171-17" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(<span class="bu">next</span>(<span class="bu">iter</span>(kmers))) <span class="op">-</span> <span class="dv">1</span>  <span class="co"># Length of the k-mer</span></span>
<span id="cb171-18"><a href="#cb171-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-19"><a href="#cb171-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> kmer <span class="kw">in</span> kmers_with_rc:</span>
<span id="cb171-20"><a href="#cb171-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(kmer) <span class="op">-</span> k):</span>
<span id="cb171-21"><a href="#cb171-21" aria-hidden="true" tabindex="-1"></a>            prefix <span class="op">=</span> kmer[i:i<span class="op">+</span>k]</span>
<span id="cb171-22"><a href="#cb171-22" aria-hidden="true" tabindex="-1"></a>            suffix <span class="op">=</span> kmer[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>k<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb171-23"><a href="#cb171-23" aria-hidden="true" tabindex="-1"></a>            adjacency_list[prefix].add(suffix)</span>
<span id="cb171-24"><a href="#cb171-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-25"><a href="#cb171-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> adjacency_list</span>
<span id="cb171-26"><a href="#cb171-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-27"><a href="#cb171-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_adjacency_list(adj_list):</span>
<span id="cb171-28"><a href="#cb171-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Formats the adjacency list into the required output format."""</span></span>
<span id="cb171-29"><a href="#cb171-29" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb171-30"><a href="#cb171-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start_node, end_nodes <span class="kw">in</span> adj_list.items():</span>
<span id="cb171-31"><a href="#cb171-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> end_node <span class="kw">in</span> end_nodes:</span>
<span id="cb171-32"><a href="#cb171-32" aria-hidden="true" tabindex="-1"></a>            result.append(<span class="ss">f"(</span><span class="sc">{</span>start_node<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>end_node<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb171-33"><a href="#cb171-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(result)</span>
<span id="cb171-34"><a href="#cb171-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-35"><a href="#cb171-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main(input_data):</span>
<span id="cb171-36"><a href="#cb171-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Main function to proces the input data and generate the De Bruijn graph."""</span></span>
<span id="cb171-37"><a href="#cb171-37" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb171-38"><a href="#cb171-38" aria-hidden="true" tabindex="-1"></a>    kplus1_mers <span class="op">=</span> <span class="bu">set</span>(lines)</span>
<span id="cb171-39"><a href="#cb171-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-40"><a href="#cb171-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Determine k from the length of the (k+1)-mers</span></span>
<span id="cb171-41"><a href="#cb171-41" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(<span class="bu">next</span>(<span class="bu">iter</span>(kplus1_mers))) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb171-42"><a href="#cb171-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-43"><a href="#cb171-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Construct the De Bruijn graph</span></span>
<span id="cb171-44"><a href="#cb171-44" aria-hidden="true" tabindex="-1"></a>    adj_list <span class="op">=</span> construct_de_bruijn_graph(kplus1_mers)</span>
<span id="cb171-45"><a href="#cb171-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb171-46"><a href="#cb171-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Format and print the adjacency list</span></span>
<span id="cb171-47"><a href="#cb171-47" aria-hidden="true" tabindex="-1"></a>    formatted_output <span class="op">=</span> format_adjacency_list(adj_list)</span>
<span id="cb171-48"><a href="#cb171-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> formatted_output:</span>
<span id="cb171-49"><a href="#cb171-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(line)</span>
<span id="cb171-50"><a href="#cb171-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-51"><a href="#cb171-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb171-52"><a href="#cb171-52" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb171-53"><a href="#cb171-53" aria-hidden="true" tabindex="-1"></a><span class="st">TGAT</span></span>
<span id="cb171-54"><a href="#cb171-54" aria-hidden="true" tabindex="-1"></a><span class="st">CATG</span></span>
<span id="cb171-55"><a href="#cb171-55" aria-hidden="true" tabindex="-1"></a><span class="st">TCAT</span></span>
<span id="cb171-56"><a href="#cb171-56" aria-hidden="true" tabindex="-1"></a><span class="st">ATGC</span></span>
<span id="cb171-57"><a href="#cb171-57" aria-hidden="true" tabindex="-1"></a><span class="st">CATC</span></span>
<span id="cb171-58"><a href="#cb171-58" aria-hidden="true" tabindex="-1"></a><span class="st">CATC</span></span>
<span id="cb171-59"><a href="#cb171-59" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb171-60"><a href="#cb171-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-61"><a href="#cb171-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the main function with the sample input</span></span>
<span id="cb171-62"><a href="#cb171-62" aria-hidden="true" tabindex="-1"></a>main(sample_input)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="changes-made" class="level2" data-number="57.4">
<h2 data-number="57.4" class="anchored" data-anchor-id="changes-made"><span class="header-section-number">57.4</span> Changes Made</h2>
<ol type="1">
<li><strong>Avoided Modifying Set During Iteration</strong>:
<ul>
<li>Instead of modifying <code>kmers</code> while iterating over it, we create a new set <code>kmers_with_rc</code> that initially contains all the original <code>kmers</code> and then add reverse complements to it.</li>
</ul></li>
<li><strong>Fixed the Extraction of Prefix and Suffix</strong>:
<ul>
<li>Adjusted the slicing in the De Bruijn graph construction to ensure we correctly extract the prefix and suffix (k)-mers from each (k+1)-mer.</li>
</ul></li>
<li><strong>Ensured Proper Handling of Adjacency List</strong>:
<ul>
<li>Correctly formatted the adjacency list to meet the output requirements.</li>
</ul></li>
</ol>
</section>
</section>
<section id="edit-distance-alignment" class="level1" data-number="58">
<h1 data-number="58"><span class="header-section-number">58</span> Edit Distance Alignment</h1>
<p>An&nbsp;<a href="https://rosalind.info/glossary/alignment/">alignment</a>&nbsp;of two strings&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>&nbsp;is defined by two strings&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;satisfying the following three conditions: 1.&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;must be formed from adding&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbols</a>&nbsp;“-” to each of&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>, respectively; as a result,&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>&nbsp;will form&nbsp;<a href="https://rosalind.info/glossary/subsequence/">subsequences</a>&nbsp;of&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>. 2.&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;must have the same length. 3. Two gap symbols may not be aligned; that is, if&nbsp;<code>s′[j]</code>&nbsp;is a gap symbol, then&nbsp;<code>t′[j]</code>&nbsp;cannot be a gap symbol, and vice-versa.</p>
<p>We say that&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;<a href="https://rosalind.info/glossary/augmented-string/">augment</a>&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>. Writing&nbsp;<code>s′</code>&nbsp;directly over&nbsp;<code>t′</code>&nbsp;so that symbols are&nbsp;<em>aligned</em>&nbsp;provides us with a scenario for transforming&nbsp;<code>s</code>&nbsp;into&nbsp;<code>t</code>. Mismatched symbols from&nbsp;s and&nbsp;t&nbsp;correspond to symbol substitutions; a gap symbol&nbsp;<code>s′[j]</code>&nbsp;aligned with a non-gap symbol&nbsp;<code>t′[j]</code>&nbsp;implies the insertion of this symbol into&nbsp;<code>t</code>; a gap symbol&nbsp;<code>t′[j]</code>&nbsp;aligned with a non-gap symbol&nbsp;<code>s′[j]</code> implies the deletion of this symbol from&nbsp;<code>s</code>.</p>
<p>Thus, an alignment represents a transformation of&nbsp;s into&nbsp;t&nbsp;via edit operations. We define the corresponding&nbsp;<a href="https://rosalind.info/glossary/edit-alignment-score/">edit alignment score</a>&nbsp;of&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;as&nbsp;<span class="math inline">\(dH(s′,t′)\)</span>&nbsp;(Hamming distance is used because the gap symbol has been introduced for insertions and deletions). It follows that&nbsp;<span class="math inline">\(dE(s,t)=mins′,t′dH(s′,t′)\)</span>, where the minimum is taken over all alignments of&nbsp;s and&nbsp;t𝑡. We call such a minimum score alignment an&nbsp;<a href="https://rosalind.info/glossary/optimal-alignment/">optimal alignment</a>&nbsp;(with respect to edit distance).</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(with each string having length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The edit distance&nbsp;<span class="math inline">\(dE(s,t)\)</span>&nbsp;followed by two augmented strings&nbsp;<code>s′</code>&nbsp;and&nbsp;<code>t′</code>&nbsp;representing an optimal alignment of&nbsp;<code>s</code>&nbsp;and&nbsp;<code>t</code>.</p>
<section id="sample-dataset-57" class="level2" data-number="58.1">
<h2 data-number="58.1" class="anchored" data-anchor-id="sample-dataset-57"><span class="header-section-number">58.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_43
PRETTY
&gt;Rosalind_97
PRTTEIN</code></pre>
</section>
<section id="sample-output-58" class="level2" data-number="58.2">
<h2 data-number="58.2" class="anchored" data-anchor-id="sample-output-58"><span class="header-section-number">58.2</span> Sample Output</h2>
<pre><code>4
PRETTY--
PR-TTEIN</code></pre>
</section>
<section id="solution-54" class="level2" data-number="58.3">
<h2 data-number="58.3" class="anchored" data-anchor-id="solution-54"><span class="header-section-number">58.3</span> Solution</h2>
<div class="sourceCode" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Parse a FASTA format string into a list of sequences.</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> []</span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_str.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>):</span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sequence:</span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">""</span>.join(current_sequence))</span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>                current_sequence <span class="op">=</span> []</span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb174-13"><a href="#cb174-13" aria-hidden="true" tabindex="-1"></a>            current_sequence.append(line.strip())</span>
<span id="cb174-14"><a href="#cb174-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_sequence:</span>
<span id="cb174-15"><a href="#cb174-15" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">""</span>.join(current_sequence))</span>
<span id="cb174-16"><a href="#cb174-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb174-17"><a href="#cb174-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-18"><a href="#cb174-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_distance_alignment(s, t):</span>
<span id="cb174-19"><a href="#cb174-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb174-20"><a href="#cb174-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the edit distance and optimal alignment of two strings.</span></span>
<span id="cb174-21"><a href="#cb174-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb174-22"><a href="#cb174-22" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb174-23"><a href="#cb174-23" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb174-24"><a href="#cb174-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-25"><a href="#cb174-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the dp table for base cases</span></span>
<span id="cb174-26"><a href="#cb174-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb174-27"><a href="#cb174-27" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb174-28"><a href="#cb174-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb174-29"><a href="#cb174-29" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb174-30"><a href="#cb174-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-31"><a href="#cb174-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table</span></span>
<span id="cb174-32"><a href="#cb174-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb174-33"><a href="#cb174-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb174-34"><a href="#cb174-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> t[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb174-35"><a href="#cb174-35" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb174-36"><a href="#cb174-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb174-37"><a href="#cb174-37" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb174-38"><a href="#cb174-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-39"><a href="#cb174-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Traceback to construct the aligned strings</span></span>
<span id="cb174-40"><a href="#cb174-40" aria-hidden="true" tabindex="-1"></a>    s_aligned, t_aligned <span class="op">=</span> <span class="st">""</span>, <span class="st">""</span></span>
<span id="cb174-41"><a href="#cb174-41" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> m, n</span>
<span id="cb174-42"><a href="#cb174-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb174-43"><a href="#cb174-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> t[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb174-44"><a href="#cb174-44" aria-hidden="true" tabindex="-1"></a>            s_aligned <span class="op">=</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s_aligned</span>
<span id="cb174-45"><a href="#cb174-45" aria-hidden="true" tabindex="-1"></a>            t_aligned <span class="op">=</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> t_aligned</span>
<span id="cb174-46"><a href="#cb174-46" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-47"><a href="#cb174-47" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-48"><a href="#cb174-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb174-49"><a href="#cb174-49" aria-hidden="true" tabindex="-1"></a>            s_aligned <span class="op">=</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s_aligned</span>
<span id="cb174-50"><a href="#cb174-50" aria-hidden="true" tabindex="-1"></a>            t_aligned <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> t_aligned</span>
<span id="cb174-51"><a href="#cb174-51" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-52"><a href="#cb174-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i][j] <span class="op">==</span> dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb174-53"><a href="#cb174-53" aria-hidden="true" tabindex="-1"></a>            s_aligned <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> s_aligned</span>
<span id="cb174-54"><a href="#cb174-54" aria-hidden="true" tabindex="-1"></a>            t_aligned <span class="op">=</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> t_aligned</span>
<span id="cb174-55"><a href="#cb174-55" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-56"><a href="#cb174-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb174-57"><a href="#cb174-57" aria-hidden="true" tabindex="-1"></a>            s_aligned <span class="op">=</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s_aligned</span>
<span id="cb174-58"><a href="#cb174-58" aria-hidden="true" tabindex="-1"></a>            t_aligned <span class="op">=</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> t_aligned</span>
<span id="cb174-59"><a href="#cb174-59" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-60"><a href="#cb174-60" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-61"><a href="#cb174-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-62"><a href="#cb174-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle any remaining characters</span></span>
<span id="cb174-63"><a href="#cb174-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb174-64"><a href="#cb174-64" aria-hidden="true" tabindex="-1"></a>        s_aligned <span class="op">=</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s_aligned</span>
<span id="cb174-65"><a href="#cb174-65" aria-hidden="true" tabindex="-1"></a>        t_aligned <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> t_aligned</span>
<span id="cb174-66"><a href="#cb174-66" aria-hidden="true" tabindex="-1"></a>        i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-67"><a href="#cb174-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb174-68"><a href="#cb174-68" aria-hidden="true" tabindex="-1"></a>        s_aligned <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> s_aligned</span>
<span id="cb174-69"><a href="#cb174-69" aria-hidden="true" tabindex="-1"></a>        t_aligned <span class="op">=</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> t_aligned</span>
<span id="cb174-70"><a href="#cb174-70" aria-hidden="true" tabindex="-1"></a>        j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb174-71"><a href="#cb174-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-72"><a href="#cb174-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n], s_aligned, t_aligned</span>
<span id="cb174-73"><a href="#cb174-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-74"><a href="#cb174-74" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb174-75"><a href="#cb174-75" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb174-76"><a href="#cb174-76" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_43</span></span>
<span id="cb174-77"><a href="#cb174-77" aria-hidden="true" tabindex="-1"></a><span class="st">PRETTY</span></span>
<span id="cb174-78"><a href="#cb174-78" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_97</span></span>
<span id="cb174-79"><a href="#cb174-79" aria-hidden="true" tabindex="-1"></a><span class="st">PRTTEIN</span></span>
<span id="cb174-80"><a href="#cb174-80" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb174-81"><a href="#cb174-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-82"><a href="#cb174-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Proces the input</span></span>
<span id="cb174-83"><a href="#cb174-83" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb174-84"><a href="#cb174-84" aria-hidden="true" tabindex="-1"></a>s, t <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb174-85"><a href="#cb174-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-86"><a href="#cb174-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute edit distance and alignment</span></span>
<span id="cb174-87"><a href="#cb174-87" aria-hidden="true" tabindex="-1"></a>edit_distance, s_aligned, t_aligned <span class="op">=</span> edit_distance_alignment(s, t)</span>
<span id="cb174-88"><a href="#cb174-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-89"><a href="#cb174-89" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb174-90"><a href="#cb174-90" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edit_distance)</span>
<span id="cb174-91"><a href="#cb174-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(s_aligned)</span>
<span id="cb174-92"><a href="#cb174-92" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(t_aligned)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-10" class="level2" data-number="58.4">
<h2 data-number="58.4" class="anchored" data-anchor-id="explanation-of-the-code-10"><span class="header-section-number">58.4</span> Explanation of the Code</h2>
<ol type="1">
<li><code>parse_fasta(fasta_str)</code>: Convert a FASTA format string into a list of sequences.
<ul>
<li>Split the input string into lines.</li>
<li>Collect sequence lines into <code>current_sequence</code> until a new header line is encountered.</li>
<li>Append the complete sequence to <code>sequences</code> when a new header is found.</li>
<li>Return the list of sequences.</li>
</ul></li>
<li><code>edit_distance_alignment(s, t)</code>: Compute the edit distance and provide an optimal alignment of two sequences.
<ul>
<li><strong>Initialize DP Table:</strong> Set up a 2D table <code>dp</code> where <code>dp[i][j]</code> holds the minimum edit distance between the first <code>i</code> characters of <code>s</code> and the first <code>j</code> characters of <code>t</code>.</li>
<li><strong>Fill DP Table:</strong> Use dynamic programming to calculate the edit distance considering substitutions, insertions, and deletions.</li>
<li><strong>Traceback:</strong> Build the aligned sequences by following the <code>dp</code> table from the bottom-right to the top-left, handling matches, insertions, and deletions.</li>
<li><strong>Handle Remaining Characters:</strong> If there are remaining characters in either string after the traceback, append them with gaps.</li>
</ul></li>
</ol>
</section>
</section>
<section id="inferring-peptide-from-full-spectrum" class="level1" data-number="59">
<h1 data-number="59"><span class="header-section-number">59</span> Inferring Peptide from Full Spectrum</h1>
<p>Say that we have a string&nbsp;<span class="math inline">\(s\)</span> containing&nbsp;<span class="math inline">\(t\)</span>&nbsp;as an internal substring, so that there exist nonempty substrings&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and&nbsp;<span class="math inline">\(s2\)</span>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;such that&nbsp;<span class="math inline">\(s\)</span>&nbsp;can be written as&nbsp;<span class="math inline">\(s1ts2\)</span>. A&nbsp;<a href="https://rosalind.info/glossary/t-prefix/">t-prefix</a>&nbsp;contains all of&nbsp;<span class="math inline">\(s1\)</span>&nbsp;and none of&nbsp;<span class="math inline">\(s2\)</span>; likewise, a&nbsp;<a href="https://rosalind.info/glossary/t-suffix/">t-suffix</a>&nbsp;contains all of&nbsp;<span class="math inline">\(s2\)</span>&nbsp;and none of&nbsp;<span class="math inline">\(s1\)</span>.</p>
<p>Given:&nbsp;A list&nbsp;<span class="math inline">\(L\)</span>&nbsp;containing&nbsp;<span class="math inline">\(2n+3\)</span>&nbsp;positive real numbers (<span class="math inline">\(n≤100\)</span>). The first number in&nbsp;<span class="math inline">\(L\)</span>&nbsp;is the parent mas of a peptide&nbsp;<span class="math inline">\(P\)</span>, and all other numbers represent the masses of some b-ions and y-ions of&nbsp;<span class="math inline">\(P\)</span>&nbsp;(in no particular order). You may assume that if the mas of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.</p>
<p>Return:&nbsp;A protein string&nbsp;<span class="math inline">\(t\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;for which there exist two positive real numbers&nbsp;<span class="math inline">\(w1\)</span>&nbsp;and&nbsp;<span class="math inline">\(w2\)</span>&nbsp;such that for every prefix&nbsp;p𝑝&nbsp;and suffix&nbsp;<span class="math inline">\(s\)</span>&nbsp;of&nbsp;<span class="math inline">\(t\)</span>, each of&nbsp;<span class="math inline">\(w(p)+w1\)</span>&nbsp;and&nbsp;<span class="math inline">\(w(s)+w2\)</span>&nbsp;is equal to an element of&nbsp;<span class="math inline">\(L\)</span>. (In other words, there exists a protein string whose&nbsp;<span class="math inline">\(t\)</span>-prefix and&nbsp;<span class="math inline">\(t\)</span>-suffix weights correspond to the non-parent mas values of&nbsp;<span class="math inline">\(L\)</span>.) If multiple solutions exist, you may output any one.</p>
<section id="sample-dataset-58" class="level2" data-number="59.1">
<h2 data-number="59.1" class="anchored" data-anchor-id="sample-dataset-58"><span class="header-section-number">59.1</span> Sample Dataset</h2>
<pre><code>1988.21104821
610.391039105
738.485999105
766.492149105
863.544909105
867.528589105
992.587499105
995.623549105
1120.6824591
1124.6661391
1221.7188991
1249.7250491
1377.8200091</code></pre>
</section>
<section id="sample-output-59" class="level2" data-number="59.2">
<h2 data-number="59.2" class="anchored" data-anchor-id="sample-output-59"><span class="header-section-number">59.2</span> Sample Output</h2>
<pre><code>KEKEP</code></pre>
</section>
<section id="solution-55" class="level2" data-number="59.3">
<h2 data-number="59.3" class="anchored" data-anchor-id="solution-55"><span class="header-section-number">59.3</span> Solution</h2>
<div class="sourceCode" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Tuple, Dict, Union</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Amino acid mas mapping</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>amino_acid_masses: Dict[<span class="bu">float</span>, List[<span class="bu">str</span>]] <span class="op">=</span> {</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>    <span class="fl">57.02146</span>: [<span class="st">"G"</span>], <span class="fl">71.03711</span>: [<span class="st">"A"</span>], <span class="fl">87.03203</span>: [<span class="st">"S"</span>], <span class="fl">97.05276</span>: [<span class="st">"P"</span>], <span class="fl">99.06841</span>: [<span class="st">"V"</span>],</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>    <span class="fl">101.04768</span>: [<span class="st">"T"</span>], <span class="fl">103.00919</span>: [<span class="st">"C"</span>], <span class="fl">113.08406</span>: [<span class="st">"I"</span>, <span class="st">"L"</span>], <span class="fl">114.04293</span>: [<span class="st">"N"</span>], <span class="fl">115.02694</span>: [<span class="st">"D"</span>],</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>    <span class="fl">128.05858</span>: [<span class="st">"Q"</span>], <span class="fl">128.09496</span>: [<span class="st">"K"</span>], <span class="fl">129.04259</span>: [<span class="st">"E"</span>], <span class="fl">131.04049</span>: [<span class="st">"M"</span>], <span class="fl">137.05891</span>: [<span class="st">"H"</span>],</span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    <span class="fl">147.06841</span>: [<span class="st">"F"</span>], <span class="fl">156.10111</span>: [<span class="st">"R"</span>], <span class="fl">163.06333</span>: [<span class="st">"Y"</span>], <span class="fl">186.07931</span>: [<span class="st">"W"</span>],</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> infer_peptide(n: <span class="bu">int</span>, parent_mass: <span class="bu">float</span>, ion_masses: List[<span class="bu">float</span>], peptides: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Infers peptide sequences based on given ion masses and the target peptide length.</span></span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-16"><a href="#cb177-16" aria-hidden="true" tabindex="-1"></a><span class="co">    :param n: Length of the peptide to be inferred.</span></span>
<span id="cb177-17"><a href="#cb177-17" aria-hidden="true" tabindex="-1"></a><span class="co">    :param parent_mass: Mas of the parent peptide.</span></span>
<span id="cb177-18"><a href="#cb177-18" aria-hidden="true" tabindex="-1"></a><span class="co">    :param ion_masses: List of ion masses representing b-ions and y-ions.</span></span>
<span id="cb177-19"><a href="#cb177-19" aria-hidden="true" tabindex="-1"></a><span class="co">    :param peptides: List of current peptide candidates.</span></span>
<span id="cb177-20"><a href="#cb177-20" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: List of inferred peptide sequences.</span></span>
<span id="cb177-21"><a href="#cb177-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb177-22"><a href="#cb177-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(peptides[<span class="dv">0</span>]) <span class="op">==</span> n:</span>
<span id="cb177-23"><a href="#cb177-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> peptides</span>
<span id="cb177-24"><a href="#cb177-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-25"><a href="#cb177-25" aria-hidden="true" tabindex="-1"></a>    possible_ions <span class="op">=</span> []  <span class="co"># List to store possible amino acids between ion pairs</span></span>
<span id="cb177-26"><a href="#cb177-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-27"><a href="#cb177-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find possible amino acids between ion pairs</span></span>
<span id="cb177-28"><a href="#cb177-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ion_masses) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb177-29"><a href="#cb177-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(ion_masses)):</span>
<span id="cb177-30"><a href="#cb177-30" aria-hidden="true" tabindex="-1"></a>            delta_mas <span class="op">=</span> <span class="bu">round</span>(ion_masses[j] <span class="op">-</span> ion_masses[i], <span class="dv">5</span>)</span>
<span id="cb177-31"><a href="#cb177-31" aria-hidden="true" tabindex="-1"></a>            amino_acids <span class="op">=</span> amino_acid_masses.get(delta_mass, [])</span>
<span id="cb177-32"><a href="#cb177-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> amino_acids:</span>
<span id="cb177-33"><a href="#cb177-33" aria-hidden="true" tabindex="-1"></a>                possible_ions.append((i, j, amino_acids))</span>
<span id="cb177-34"><a href="#cb177-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb177-35"><a href="#cb177-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> possible_ions:</span>
<span id="cb177-36"><a href="#cb177-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update ion masses and peptide candidates</span></span>
<span id="cb177-37"><a href="#cb177-37" aria-hidden="true" tabindex="-1"></a>        new_ion_masses <span class="op">=</span> ion_masses[possible_ions[<span class="dv">0</span>][<span class="dv">1</span>]:]</span>
<span id="cb177-38"><a href="#cb177-38" aria-hidden="true" tabindex="-1"></a>        new_amino_acids <span class="op">=</span> possible_ions[<span class="dv">0</span>][<span class="dv">2</span>]</span>
<span id="cb177-39"><a href="#cb177-39" aria-hidden="true" tabindex="-1"></a>        new_peptides <span class="op">=</span> [peptide <span class="op">+</span> aa <span class="cf">for</span> peptide <span class="kw">in</span> peptides <span class="cf">for</span> aa <span class="kw">in</span> new_amino_acids]</span>
<span id="cb177-40"><a href="#cb177-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb177-41"><a href="#cb177-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recursively infer peptide sequences</span></span>
<span id="cb177-42"><a href="#cb177-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> infer_peptide(n, parent_mass, new_ion_masses, new_peptides)</span>
<span id="cb177-43"><a href="#cb177-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-44"><a href="#cb177-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> peptides</span>
<span id="cb177-45"><a href="#cb177-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-46"><a href="#cb177-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb177-47"><a href="#cb177-47" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb177-48"><a href="#cb177-48" aria-hidden="true" tabindex="-1"></a><span class="st">1988.21104821</span></span>
<span id="cb177-49"><a href="#cb177-49" aria-hidden="true" tabindex="-1"></a><span class="st">610.391039105</span></span>
<span id="cb177-50"><a href="#cb177-50" aria-hidden="true" tabindex="-1"></a><span class="st">738.485999105</span></span>
<span id="cb177-51"><a href="#cb177-51" aria-hidden="true" tabindex="-1"></a><span class="st">766.492149105</span></span>
<span id="cb177-52"><a href="#cb177-52" aria-hidden="true" tabindex="-1"></a><span class="st">863.544909105</span></span>
<span id="cb177-53"><a href="#cb177-53" aria-hidden="true" tabindex="-1"></a><span class="st">867.528589105</span></span>
<span id="cb177-54"><a href="#cb177-54" aria-hidden="true" tabindex="-1"></a><span class="st">992.587499105</span></span>
<span id="cb177-55"><a href="#cb177-55" aria-hidden="true" tabindex="-1"></a><span class="st">995.623549105</span></span>
<span id="cb177-56"><a href="#cb177-56" aria-hidden="true" tabindex="-1"></a><span class="st">1120.6824591</span></span>
<span id="cb177-57"><a href="#cb177-57" aria-hidden="true" tabindex="-1"></a><span class="st">1124.6661391</span></span>
<span id="cb177-58"><a href="#cb177-58" aria-hidden="true" tabindex="-1"></a><span class="st">1221.7188991</span></span>
<span id="cb177-59"><a href="#cb177-59" aria-hidden="true" tabindex="-1"></a><span class="st">1249.7250491</span></span>
<span id="cb177-60"><a href="#cb177-60" aria-hidden="true" tabindex="-1"></a><span class="st">1377.8200091</span></span>
<span id="cb177-61"><a href="#cb177-61" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb177-62"><a href="#cb177-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-63"><a href="#cb177-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input data</span></span>
<span id="cb177-64"><a href="#cb177-64" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> [<span class="bu">float</span>(line) <span class="cf">for</span> line <span class="kw">in</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)]</span>
<span id="cb177-65"><a href="#cb177-65" aria-hidden="true" tabindex="-1"></a>parent_mass, ion_masses <span class="op">=</span> input_lines[<span class="dv">0</span>], input_lines[<span class="dv">1</span>:]</span>
<span id="cb177-66"><a href="#cb177-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-67"><a href="#cb177-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine the length of the peptide</span></span>
<span id="cb177-68"><a href="#cb177-68" aria-hidden="true" tabindex="-1"></a>peptide_length <span class="op">=</span> (<span class="bu">len</span>(ion_masses) <span class="op">-</span> <span class="dv">2</span>) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb177-69"><a href="#cb177-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-70"><a href="#cb177-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Infer peptide sequences</span></span>
<span id="cb177-71"><a href="#cb177-71" aria-hidden="true" tabindex="-1"></a>possible_peptides <span class="op">=</span> infer_peptide(peptide_length, parent_mass, ion_masses, [<span class="st">""</span>])</span>
<span id="cb177-72"><a href="#cb177-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-73"><a href="#cb177-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Print a random peptide sequence</span></span>
<span id="cb177-74"><a href="#cb177-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(random.choice(possible_peptides))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="independent-segregation-of-chromosomes" class="level1" data-number="60">
<h1 data-number="60"><span class="header-section-number">60</span> Independent Segregation of Chromosomes</h1>
<p>Consider a collection of coin flips. One of the most natural questions we can ask is if we flip a coin 92 times, what is the&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;of obtaining 51 “heads”, vs.&nbsp;27 “heads”, vs.&nbsp;<a href="http://en.wikipedia.org/wiki/Rosencrantz_and_Guildenstern_Are_Dead">92 “heads”</a>?</p>
<p>Each coin flip can be modeled by a&nbsp;<a href="https://rosalind.info/glossary/uniform-random-variable/">uniform random variable</a>&nbsp;in which each of the two&nbsp;<a href="https://rosalind.info/glossary/outcome/">outcomes</a>&nbsp;(“heads” and “tails”) has probability equal to <span class="math inline">\(1/2\)</span>. We may assume that these random variables are&nbsp;<a href="https://rosalind.info/glossary/independent-random-variables/">independent</a>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/lia/">“Independent Alleles”</a>); in layman’s terms, the outcomes of the two coin flips do not influence each other.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/binomial-random-variable/">binomial random variable</a>&nbsp;<span class="math inline">\(X\)</span> takes a value of&nbsp;<span class="math inline">\(k\)</span>&nbsp;if&nbsp;<span class="math inline">\(n\)</span>&nbsp;consecutive “coin flips” result in&nbsp;<span class="math inline">\(k\)</span> total “heads” and&nbsp;<span class="math inline">\(n−k\)</span>&nbsp;total “tails.” We write that&nbsp;<span class="math inline">\(X∈Bin(n/2)\)</span>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n≤50\)</span>.</p>
<p>Return:&nbsp;An&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;of length&nbsp;<span class="math inline">\(2n\)</span> in which&nbsp;<span class="math inline">\(A[k]\)</span>&nbsp;represents the&nbsp;<a href="https://rosalind.info/glossary/common-logarithm/">common logarithm</a>&nbsp;of the probability that two diploid siblings share at least&nbsp;<span class="math inline">\(k\)</span>&nbsp;of their&nbsp;<span class="math inline">\(2n\)</span>&nbsp;chromosomes (we do not consider&nbsp;<a href="https://rosalind.info/glossary/genetic-recombination/">recombination</a>&nbsp;for now).</p>
<section id="sample-dataset-59" class="level2" data-number="60.1">
<h2 data-number="60.1" class="anchored" data-anchor-id="sample-dataset-59"><span class="header-section-number">60.1</span> Sample Dataset</h2>
<pre><code>5</code></pre>
</section>
<section id="sample-output-60" class="level2" data-number="60.2">
<h2 data-number="60.2" class="anchored" data-anchor-id="sample-output-60"><span class="header-section-number">60.2</span> Sample Output</h2>
<pre><code>0.000 -0.005 -0.024 -0.082 -0.206 -0.424 -0.765 -1.262 -1.969 -3.010</code></pre>
</section>
<section id="solution-56" class="level2" data-number="60.3">
<h2 data-number="60.3" class="anchored" data-anchor-id="solution-56"><span class="header-section-number">60.3</span> Solution</h2>
<div class="sourceCode" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_shared_chromosome_probabilities(sample_input: <span class="bu">str</span>):</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the common logarithm of the probability that two diploid siblings</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a><span class="co">    share at least k of their 2n chromosomes, given n.</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - sample_input (str): The input string representing the value of n.</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - List of float: Logarithm base 10 of the cumulative probabilities.</span></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse the sample input to an integer</span></span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">int</span>(sample_input.strip())</span>
<span id="cb180-16"><a href="#cb180-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-17"><a href="#cb180-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probability of sharing each chromosome (independent coin flip)</span></span>
<span id="cb180-18"><a href="#cb180-18" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb180-19"><a href="#cb180-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-20"><a href="#cb180-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the cumulative probability and the result array</span></span>
<span id="cb180-21"><a href="#cb180-21" aria-hidden="true" tabindex="-1"></a>    Pr <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb180-22"><a href="#cb180-22" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> []</span>
<span id="cb180-23"><a href="#cb180-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-24"><a href="#cb180-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Loop from 2*n down to 1 (inclusive) to calculate cumulative probabilities</span></span>
<span id="cb180-25"><a href="#cb180-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb180-26"><a href="#cb180-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the binomial coefficient: C(2n, k)</span></span>
<span id="cb180-27"><a href="#cb180-27" aria-hidden="true" tabindex="-1"></a>        binom_coeff <span class="op">=</span> math.factorial(<span class="dv">2</span> <span class="op">*</span> n) <span class="op">/</span> (math.factorial(k) <span class="op">*</span> math.factorial(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> k))</span>
<span id="cb180-28"><a href="#cb180-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-29"><a href="#cb180-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the probability of exactly k shared chromosomes</span></span>
<span id="cb180-30"><a href="#cb180-30" aria-hidden="true" tabindex="-1"></a>        Pr <span class="op">+=</span> binom_coeff <span class="op">*</span> math.<span class="bu">pow</span>(p, k) <span class="op">*</span> math.<span class="bu">pow</span>(<span class="dv">1</span> <span class="op">-</span> p, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> k)</span>
<span id="cb180-31"><a href="#cb180-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-32"><a href="#cb180-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Append the common logarithm (base 10) of the cumulative probability to the result array</span></span>
<span id="cb180-33"><a href="#cb180-33" aria-hidden="true" tabindex="-1"></a>        A.append(math.log10(Pr))</span>
<span id="cb180-34"><a href="#cb180-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-35"><a href="#cb180-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the result array in reverse order</span></span>
<span id="cb180-36"><a href="#cb180-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="bu">round</span>(value, <span class="dv">3</span>) <span class="cf">for</span> value <span class="kw">in</span> A[::<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb180-37"><a href="#cb180-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-38"><a href="#cb180-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb180-39"><a href="#cb180-39" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"5"</span></span>
<span id="cb180-40"><a href="#cb180-40" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> calculate_shared_chromosome_probabilities(sample_input)</span>
<span id="cb180-41"><a href="#cb180-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>value<span class="sc">:3f}</span><span class="ss">"</span> <span class="cf">for</span> value <span class="kw">in</span> result))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-function" class="level2" data-number="60.4">
<h2 data-number="60.4" class="anchored" data-anchor-id="explanation-of-the-function"><span class="header-section-number">60.4</span> Explanation of the Function</h2>
<ol type="1">
<li><strong>Function Definition</strong>:
<ul>
<li>The function <code>calculate_shared_chromosome_probabilities</code> takes a string <code>sample_input</code>.</li>
</ul></li>
<li><strong>Parse Input</strong>:
<ul>
<li><code>sample_input</code> is stripped of any surrounding whitespace and converted to an integer <code>n</code>.</li>
</ul></li>
<li><strong>Initialize Variables</strong>:
<ul>
<li><code>p</code> is set to 0.5, representing the probability of sharing each chromosome.</li>
<li><code>Pr</code> is initialized to store the cumulative probability.</li>
<li><code>A</code> is an empty list to store the logarithms of cumulative probabilities.</li>
</ul></li>
<li><strong>Calculate Cumulative Probabilities</strong>:
<ul>
<li>Loop from <code>2*n</code> down to <code>1</code> to calculate the cumulative probability for at least <code>k</code> shared chromosomes.</li>
<li>For each <code>k</code>, compute the binomial coefficient <span class="math inline">\(C(2n, k)\)</span>.</li>
<li>Calculate the probability of exactly <code>k</code> shared chromosomes and add it to <code>Pr</code>.</li>
<li>Append the logarithm (base 10) of <code>Pr</code> to the list <code>A</code>.</li>
</ul></li>
<li><strong>Return the Result</strong>:
<ul>
<li>Return the values in <code>A</code> in reverse order, rounded to 3 decimal places.</li>
</ul></li>
<li><strong>Example Usage</strong>:
<ul>
<li>The function is called with a sample input <code>"5"</code>, and the results are printed in the specified format.</li>
</ul></li>
</ol>
</section>
</section>
<section id="finding-disjoint-motifs-in-a-gene" class="level1" data-number="61">
<h1 data-number="61"><span class="header-section-number">61</span> Finding Disjoint Motifs in a Gene</h1>
<p>Given three strings&nbsp;<span class="math inline">\(s\)</span>,&nbsp;<span class="math inline">\(t\)</span>, and&nbsp;<span class="math inline">\(u\)</span>, we say that&nbsp;<span class="math inline">\(t\)</span>&nbsp;and&nbsp;<span class="math inline">\(u\)</span>&nbsp;can be&nbsp;<a href="https://rosalind.info/glossary/interwoven-strings/">interwoven</a>&nbsp;into&nbsp;<span class="math inline">\(s\)</span>&nbsp;if there is some substring of&nbsp;<span class="math inline">\(s\)</span>&nbsp;made up of&nbsp;<span class="math inline">\(t\)</span>&nbsp;and&nbsp;<span class="math inline">\(u\)</span>&nbsp;as disjoint&nbsp;<a href="https://rosalind.info/glossary/subsequence/">subsequences</a>.</p>
<p>For example, the strings “ACAGACAG” and “CCGCCG” can be interwoven into “GACCACGGTTGACCACGGTT”. However, they cannot be interwoven into “GACCACAAAAGGTTGACCACAAAAGGTT” because of the appearance of the four ’A’s in the middle of the subsequences. Similarly, even though both “ACACGACACG” is a&nbsp;<a href="https://rosalind.info/glossary/shortest-common-supersequence/">shortest common supersequence</a>&nbsp;of&nbsp;ACAGACAG&nbsp;and&nbsp;CCGCCG, it is not possible to interweave these two strings into “ACACGACACG” because the two desired subsequences must be disjoint; see&nbsp;<a href="https://rosalind.info/problems/scsp/">“Interleaving Two Motifs”</a>&nbsp;for details on finding a shortest common supersequence of two strings.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/text/">text</a>&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>, followed by a collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤10\)</span>) DNA strings of length at most 10&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>&nbsp;acting as&nbsp;<a href="https://rosalind.info/glossary/pattern/">patterns</a>.</p>
<p>Return:&nbsp;An&nbsp;<span class="math inline">\(n×n\)</span>&nbsp;<a href="https://rosalind.info/glossary/matrix/">matrix</a>&nbsp;<span class="math inline">\(M\)</span>&nbsp;for which&nbsp;<span class="math inline">\(M_{j,k}=1\)</span>&nbsp;if the&nbsp;<span class="math inline">\(j\)</span>th and&nbsp;<span class="math inline">\(k\)</span>th pattern strings can be interwoven into&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(M_{j,k}=0\)</span>&nbsp;otherwise.</p>
<section id="sample-dataset-60" class="level2" data-number="61.1">
<h2 data-number="61.1" class="anchored" data-anchor-id="sample-dataset-60"><span class="header-section-number">61.1</span> Sample Dataset</h2>
<pre><code>GACCACGGTT
ACAG
GT
CCG</code></pre>
</section>
<section id="sample-output-61" class="level2" data-number="61.2">
<h2 data-number="61.2" class="anchored" data-anchor-id="sample-output-61"><span class="header-section-number">61.2</span> Sample Output</h2>
<pre><code>0 0 1
0 1 0
1 0 0</code></pre>
</section>
<section id="solution-57" class="level2" data-number="61.3">
<h2 data-number="61.3" class="anchored" data-anchor-id="solution-57"><span class="header-section-number">61.3</span> Solution</h2>
<div class="sourceCode" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_interwoven(dna1, dna2, superstr):</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Recursive function to check if dna1 and dna2 can be interwoven to form superstr.</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(superstr) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> dna1 <span class="kw">and</span> dna2 <span class="kw">and</span> dna1[<span class="dv">0</span>] <span class="op">==</span> dna2[<span class="dv">0</span>] <span class="op">==</span> superstr[<span class="dv">0</span>]:</span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> is_interwoven(dna1[<span class="dv">1</span>:], dna2, superstr[<span class="dv">1</span>:]) <span class="kw">or</span> is_interwoven(dna1, dna2[<span class="dv">1</span>:], superstr[<span class="dv">1</span>:])</span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> dna1 <span class="kw">and</span> dna1[<span class="dv">0</span>] <span class="op">==</span> superstr[<span class="dv">0</span>]:</span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> is_interwoven(dna1[<span class="dv">1</span>:], dna2, superstr[<span class="dv">1</span>:])</span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> dna2 <span class="kw">and</span> dna2[<span class="dv">0</span>] <span class="op">==</span> superstr[<span class="dv">0</span>]:</span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> is_interwoven(dna1, dna2[<span class="dv">1</span>:], superstr[<span class="dv">1</span>:])</span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_disjoint_motifs(super_string, patterns):</span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Function to find the disjoint motifs matrix for the given super_string and patterns.</span></span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb183-22"><a href="#cb183-22" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(patterns)</span>
<span id="cb183-23"><a href="#cb183-23" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> np.zeros((n, n), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb183-24"><a href="#cb183-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-25"><a href="#cb183-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb183-26"><a href="#cb183-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n):</span>
<span id="cb183-27"><a href="#cb183-27" aria-hidden="true" tabindex="-1"></a>            pattern1 <span class="op">=</span> patterns[i]</span>
<span id="cb183-28"><a href="#cb183-28" aria-hidden="true" tabindex="-1"></a>            pattern2 <span class="op">=</span> patterns[j]</span>
<span id="cb183-29"><a href="#cb183-29" aria-hidden="true" tabindex="-1"></a>            combined_length <span class="op">=</span> <span class="bu">len</span>(pattern1) <span class="op">+</span> <span class="bu">len</span>(pattern2)</span>
<span id="cb183-30"><a href="#cb183-30" aria-hidden="true" tabindex="-1"></a>            combined_profile <span class="op">=</span> [pattern1.count(nuc) <span class="op">+</span> pattern2.count(nuc) <span class="cf">for</span> nuc <span class="kw">in</span> <span class="st">"ACGT"</span>]</span>
<span id="cb183-31"><a href="#cb183-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-32"><a href="#cb183-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(super_string) <span class="op">-</span> combined_length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb183-33"><a href="#cb183-33" aria-hidden="true" tabindex="-1"></a>                superstr_segment <span class="op">=</span> super_string[index:index <span class="op">+</span> combined_length]</span>
<span id="cb183-34"><a href="#cb183-34" aria-hidden="true" tabindex="-1"></a>                superstr_profile <span class="op">=</span> [superstr_segment.count(nuc) <span class="cf">for</span> nuc <span class="kw">in</span> <span class="st">"ACGT"</span>]</span>
<span id="cb183-35"><a href="#cb183-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-36"><a href="#cb183-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> combined_profile <span class="op">==</span> superstr_profile:</span>
<span id="cb183-37"><a href="#cb183-37" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> is_interwoven(pattern1 <span class="op">+</span> <span class="st">'$'</span>, pattern2 <span class="op">+</span> <span class="st">'$'</span>, superstr_segment):</span>
<span id="cb183-38"><a href="#cb183-38" aria-hidden="true" tabindex="-1"></a>                        M[i][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb183-39"><a href="#cb183-39" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span></span>
<span id="cb183-40"><a href="#cb183-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-41"><a href="#cb183-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">!=</span> j:</span>
<span id="cb183-42"><a href="#cb183-42" aria-hidden="true" tabindex="-1"></a>                M[j][i] <span class="op">=</span> M[i][j]</span>
<span id="cb183-43"><a href="#cb183-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-44"><a href="#cb183-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> M</span>
<span id="cb183-45"><a href="#cb183-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-46"><a href="#cb183-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset</span></span>
<span id="cb183-47"><a href="#cb183-47" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb183-48"><a href="#cb183-48" aria-hidden="true" tabindex="-1"></a><span class="st">GACCACGGTT</span></span>
<span id="cb183-49"><a href="#cb183-49" aria-hidden="true" tabindex="-1"></a><span class="st">ACAG</span></span>
<span id="cb183-50"><a href="#cb183-50" aria-hidden="true" tabindex="-1"></a><span class="st">GT</span></span>
<span id="cb183-51"><a href="#cb183-51" aria-hidden="true" tabindex="-1"></a><span class="st">CCG</span></span>
<span id="cb183-52"><a href="#cb183-52" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb183-53"><a href="#cb183-53" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> sample_input.strip().split()</span>
<span id="cb183-54"><a href="#cb183-54" aria-hidden="true" tabindex="-1"></a>super_string <span class="op">=</span> data[<span class="dv">0</span>]</span>
<span id="cb183-55"><a href="#cb183-55" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> data[<span class="dv">1</span>:]</span>
<span id="cb183-56"><a href="#cb183-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-57"><a href="#cb183-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the disjoint motifs matrix</span></span>
<span id="cb183-58"><a href="#cb183-58" aria-hidden="true" tabindex="-1"></a>result_matrix <span class="op">=</span> find_disjoint_motifs(super_string, patterns)</span>
<span id="cb183-59"><a href="#cb183-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-60"><a href="#cb183-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result matrix</span></span>
<span id="cb183-61"><a href="#cb183-61" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> result_matrix:</span>
<span id="cb183-62"><a href="#cb183-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, row)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-30" class="level2" data-number="61.4">
<h2 data-number="61.4" class="anchored" data-anchor-id="explanation-30"><span class="header-section-number">61.4</span> Explanation</h2>
<ol type="1">
<li><strong>is_interwoven Function</strong>:
<ul>
<li><strong>Purpose</strong>: To check if <code>dna1</code> and <code>dna2</code> can be interwoven to form <code>superstr</code>.</li>
<li><strong>Parameters</strong>: <code>dna1</code>, <code>dna2</code>, and <code>superstr</code>.</li>
<li><strong>Logic</strong>:
<ul>
<li>If <code>superstr</code> is empty, return <code>True</code> because the interweaving is complete.</li>
<li>If both <code>dna1</code> and <code>dna2</code> are non-empty and their first characters match the first character of <code>superstr</code>, recursively check both possibilities (taking from <code>dna1</code> or <code>dna2</code>).</li>
<li>If the first character of <code>dna1</code> matches the first character of <code>superstr</code>, recursively check the remaining parts.</li>
<li>If the first character of <code>dna2</code> matches the first character of <code>superstr</code>, recursively check the remaining parts.</li>
<li>If none of the above conditions are met, return <code>False</code>.</li>
</ul></li>
</ul></li>
<li><strong>find_disjoint_motifs Function</strong>:
<ul>
<li><strong>Purpose</strong>: To find the disjoint motifs matrix for the given <code>super_string</code> and <code>patterns</code>.</li>
<li><strong>Parameters</strong>: <code>super_string</code> and <code>patterns</code>.</li>
<li><strong>Logic</strong>:
<ul>
<li>Initialize a zero matrix <code>M</code> of size <code>n x n</code> where <code>n</code> is the number of patterns.</li>
<li>For each pair of patterns <code>pattern1</code> and <code>pattern2</code>, calculate their combined length and nucleotide profile.</li>
<li>Iterate over all possible substrings of <code>super_string</code> of the same length.</li>
<li>Compare the nucleotide profile of the substring with the combined profile.</li>
<li>If they match, use <code>is_interwoven</code> to check if they can be interwoven to form the substring.</li>
<li>Update the matrix <code>M</code> accordingly.</li>
<li>Since the comparison is symmetric, update both <code>M[i][j]</code> and <code>M[j][i]</code>.</li>
</ul></li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li>Parse the input to extract the <code>super_string</code> and <code>patterns</code>.</li>
<li>Call <code>find_disjoint_motifs</code> to get the result matrix.</li>
<li>Print the result matrix.</li>
</ul></li>
</ol>
</section>
</section>
<section id="finding-the-longest-multiple-repeat" class="level1" data-number="62">
<h1 data-number="62"><span class="header-section-number">62</span> Finding the Longest Multiple Repeat</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/repeated-substring/">repeated substring</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/string/">string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;is simply a substring that appears in more than one&nbsp;<a href="https://rosalind.info/glossary/location/">location</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>; more specifically, a&nbsp;<a href="https://rosalind.info/glossary/k-fold-substring/">k-fold substring</a>&nbsp;appears in at least k&nbsp;<a href="https://rosalind.info/glossary/distinct/">distinct</a>&nbsp;locations.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/suffix-tree/">suffix tree</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>, denoted&nbsp;<span class="math inline">\(T(s)\)</span>, is defined as follows:</p>
<ul>
<li><span class="math inline">\(T(s)\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;having exactly&nbsp;n&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>.</li>
<li>Every&nbsp;<a href="https://rosalind.info/glossary/edge/">edge</a>&nbsp;of&nbsp;<span class="math inline">\(T(s)\)</span>&nbsp;is labeled with a substring of&nbsp;<span class="math inline">\(s^∗\)</span>, where&nbsp;<span class="math inline">\(s^∗\)</span>&nbsp;is the string formed by adding a placeholder symbol&nbsp;<code>$</code>&nbsp;to the end of&nbsp;<span class="math inline">\(s\)</span>.</li>
<li>Every&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal node</a>&nbsp;of&nbsp;<span class="math inline">\(T(s)\)</span>&nbsp;other than the root has at least two&nbsp;<a href="https://rosalind.info/glossary/child/">children</a>; i.e., it has&nbsp;<a href="https://rosalind.info/glossary/degree/">degree</a>&nbsp;at least 3.</li>
<li>The substring labels for the edges leading from a node to its children must begin with different symbols.</li>
<li>By concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s^∗\)</span>.</li>
</ul>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;s (of length at most 20&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>) with&nbsp;<code>$</code>&nbsp;appended, a positive integer&nbsp;kk, and a list of edges defining the suffix tree of&nbsp;ss. Each edge is represented by four components:</p>
<ol type="1">
<li>the label of its parent node in&nbsp;<span class="math inline">\(T(s)\)</span>;</li>
<li>the label of its child node in&nbsp;<span class="math inline">\(T(s)\)</span>;</li>
<li>the&nbsp;<a href="https://rosalind.info/glossary/location/">location</a>&nbsp;of the substring&nbsp;<span class="math inline">\(t\)</span>&nbsp;of&nbsp;<span class="math inline">\(s^∗\)</span>&nbsp;assigned to the edge; and the length of&nbsp;<span class="math inline">\(t\)</span>.</li>
</ol>
<p>Return:&nbsp;The longest substring of&nbsp;s that occurs at least&nbsp;<span class="math inline">\(k\)</span>&nbsp;times in&nbsp;<span class="math inline">\(s\)</span>. (If multiple solutions exist, you may return any single solution.)</p>
<section id="sample-dataset-61" class="level2" data-number="62.1">
<h2 data-number="62.1" class="anchored" data-anchor-id="sample-dataset-61"><span class="header-section-number">62.1</span> Sample Dataset</h2>
<pre><code>CATACATAC$
2
node1 node2 1 1
node1 node7 2 1
node1 node14 3 3
node1 node17 10 1
node2 node3 2 4
node2 node6 10 1
node3 node4 6 5
node3 node5 10 1
node7 node8 3 3
node7 node11 5 1
node8 node9 6 5
node8 node10 10 1
node11 node12 6 5
node11 node13 10 1
node14 node15 6 5
node14 node16 10 1</code></pre>
</section>
<section id="sample-output-62" class="level2" data-number="62.2">
<h2 data-number="62.2" class="anchored" data-anchor-id="sample-output-62"><span class="header-section-number">62.2</span> Sample Output</h2>
<pre><code>CATAC</code></pre>
</section>
<section id="solution-58" class="level2" data-number="62.3">
<h2 data-number="62.3" class="anchored" data-anchor-id="solution-58"><span class="header-section-number">62.3</span> Solution</h2>
<p>To solve this problem, we need to find the longest substring that appears at least <code>k</code> times in a given string <code>s</code>, using its suffix tree. Here’s how we can approach the problem step-by-step:</p>
</section>
<section id="steps-to-approach-the-problem" class="level2" data-number="62.4">
<h2 data-number="62.4" class="anchored" data-anchor-id="steps-to-approach-the-problem"><span class="header-section-number">62.4</span> Steps to Approach the Problem</h2>
<ol type="1">
<li><strong>Parse the Input</strong>:
<ul>
<li>Read the DNA string <code>s</code> with <code>$</code> appended.</li>
<li>Read the integer <code>k</code>.</li>
<li>Parse the edges defining the suffix tree.</li>
</ul></li>
<li><strong>Suffix Tree Representation</strong>:
<ul>
<li>Use the given edges to construct the suffix tree.</li>
<li>Each edge contains information about the parent node, child node, start position of the substring in <code>s</code>, and the length of the substring.</li>
</ul></li>
<li><strong>Traverse the Suffix Tree</strong>:
<ul>
<li>Traverse the tree to count the occurrences of substrings.</li>
<li>Use a depth-first search (DFS) to explore all paths from the root to the leaves.</li>
</ul></li>
<li><strong>Identify the Longest Substring with at least <code>k</code> Occurrences</strong>:
<ul>
<li>Track the longest substring that meets the condition during the traversal.</li>
</ul></li>
</ol>
</section>
<section id="implementation-6" class="level2" data-number="62.5">
<h2 data-number="62.5" class="anchored" data-anchor-id="implementation-6"><span class="header-section-number">62.5</span> Implementation</h2>
<p>Here’s the Python code to implement the solution:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>clas SuffixTreeNode:</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> {}</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.length <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="va">None</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_suffix_tree(edges, s):</span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> {}</span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge <span class="kw">in</span> edges:</span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>        parent, child, start, length <span class="op">=</span> edge</span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent <span class="kw">not</span> <span class="kw">in</span> nodes:</span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>            nodes[parent] <span class="op">=</span> SuffixTreeNode()</span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> child <span class="kw">not</span> <span class="kw">in</span> nodes:</span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>            nodes[child] <span class="op">=</span> SuffixTreeNode()</span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>        nodes[child].parent <span class="op">=</span> nodes[parent]</span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a>        nodes[child].start <span class="op">=</span> start <span class="op">-</span> <span class="dv">1</span>  <span class="co"># Convert to zero-based index</span></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>        nodes[child].length <span class="op">=</span> length</span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>        nodes[parent].children[child] <span class="op">=</span> nodes[child]</span>
<span id="cb186-20"><a href="#cb186-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nodes</span>
<span id="cb186-21"><a href="#cb186-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-22"><a href="#cb186-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(node, s, k, path, results):</span>
<span id="cb186-23"><a href="#cb186-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(node.children) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb186-24"><a href="#cb186-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span>  <span class="co"># Leaf node</span></span>
<span id="cb186-25"><a href="#cb186-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb186-26"><a href="#cb186-26" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb186-27"><a href="#cb186-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> child <span class="kw">in</span> node.children.values():</span>
<span id="cb186-28"><a href="#cb186-28" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> dfs(child, s, k, path <span class="op">+</span> s[child.start:child.start <span class="op">+</span> child.length], results)</span>
<span id="cb186-29"><a href="#cb186-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb186-30"><a href="#cb186-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> count <span class="op">&gt;=</span> k:</span>
<span id="cb186-31"><a href="#cb186-31" aria-hidden="true" tabindex="-1"></a>        results.append((path, <span class="bu">len</span>(path)))</span>
<span id="cb186-32"><a href="#cb186-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb186-33"><a href="#cb186-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb186-34"><a href="#cb186-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-35"><a href="#cb186-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_k_fold_substring(s, k, edges):</span>
<span id="cb186-36"><a href="#cb186-36" aria-hidden="true" tabindex="-1"></a>    nodes <span class="op">=</span> build_suffix_tree(edges, s)</span>
<span id="cb186-37"><a href="#cb186-37" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> nodes[<span class="st">'node1'</span>]</span>
<span id="cb186-38"><a href="#cb186-38" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb186-39"><a href="#cb186-39" aria-hidden="true" tabindex="-1"></a>    dfs(root, s, k, <span class="st">""</span>, results)</span>
<span id="cb186-40"><a href="#cb186-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb186-41"><a href="#cb186-41" aria-hidden="true" tabindex="-1"></a>    results.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb186-42"><a href="#cb186-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb186-43"><a href="#cb186-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> results <span class="cf">else</span> <span class="st">""</span></span>
<span id="cb186-44"><a href="#cb186-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-45"><a href="#cb186-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb186-46"><a href="#cb186-46" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb186-47"><a href="#cb186-47" aria-hidden="true" tabindex="-1"></a><span class="st">CATACATAC$</span></span>
<span id="cb186-48"><a href="#cb186-48" aria-hidden="true" tabindex="-1"></a><span class="st">2</span></span>
<span id="cb186-49"><a href="#cb186-49" aria-hidden="true" tabindex="-1"></a><span class="st">node1 node2 1 1</span></span>
<span id="cb186-50"><a href="#cb186-50" aria-hidden="true" tabindex="-1"></a><span class="st">node1 node7 2 1</span></span>
<span id="cb186-51"><a href="#cb186-51" aria-hidden="true" tabindex="-1"></a><span class="st">node1 node14 3 3</span></span>
<span id="cb186-52"><a href="#cb186-52" aria-hidden="true" tabindex="-1"></a><span class="st">node1 node17 10 1</span></span>
<span id="cb186-53"><a href="#cb186-53" aria-hidden="true" tabindex="-1"></a><span class="st">node2 node3 2 4</span></span>
<span id="cb186-54"><a href="#cb186-54" aria-hidden="true" tabindex="-1"></a><span class="st">node2 node6 10 1</span></span>
<span id="cb186-55"><a href="#cb186-55" aria-hidden="true" tabindex="-1"></a><span class="st">node3 node4 6 5</span></span>
<span id="cb186-56"><a href="#cb186-56" aria-hidden="true" tabindex="-1"></a><span class="st">node3 node5 10 1</span></span>
<span id="cb186-57"><a href="#cb186-57" aria-hidden="true" tabindex="-1"></a><span class="st">node7 node8 3 3</span></span>
<span id="cb186-58"><a href="#cb186-58" aria-hidden="true" tabindex="-1"></a><span class="st">node7 node11 5 1</span></span>
<span id="cb186-59"><a href="#cb186-59" aria-hidden="true" tabindex="-1"></a><span class="st">node8 node9 6 5</span></span>
<span id="cb186-60"><a href="#cb186-60" aria-hidden="true" tabindex="-1"></a><span class="st">node8 node10 10 1</span></span>
<span id="cb186-61"><a href="#cb186-61" aria-hidden="true" tabindex="-1"></a><span class="st">node11 node12 6 5</span></span>
<span id="cb186-62"><a href="#cb186-62" aria-hidden="true" tabindex="-1"></a><span class="st">node11 node13 10 1</span></span>
<span id="cb186-63"><a href="#cb186-63" aria-hidden="true" tabindex="-1"></a><span class="st">node14 node15 6 5</span></span>
<span id="cb186-64"><a href="#cb186-64" aria-hidden="true" tabindex="-1"></a><span class="st">node14 node16 10 1</span></span>
<span id="cb186-65"><a href="#cb186-65" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb186-66"><a href="#cb186-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-67"><a href="#cb186-67" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb186-68"><a href="#cb186-68" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> data[<span class="dv">0</span>]</span>
<span id="cb186-69"><a href="#cb186-69" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="bu">int</span>(data[<span class="dv">1</span>])</span>
<span id="cb186-70"><a href="#cb186-70" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [<span class="bu">tuple</span>(line.split()) <span class="cf">for</span> line <span class="kw">in</span> data[<span class="dv">2</span>:]]</span>
<span id="cb186-71"><a href="#cb186-71" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(e[<span class="dv">0</span>], e[<span class="dv">1</span>], <span class="bu">int</span>(e[<span class="dv">2</span>]), <span class="bu">int</span>(e[<span class="dv">3</span>])) <span class="cf">for</span> e <span class="kw">in</span> edges]</span>
<span id="cb186-72"><a href="#cb186-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-73"><a href="#cb186-73" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> longest_k_fold_substring(s, k, edges)</span>
<span id="cb186-74"><a href="#cb186-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-31" class="level2" data-number="62.6">
<h2 data-number="62.6" class="anchored" data-anchor-id="explanation-31"><span class="header-section-number">62.6</span> Explanation</h2>
<ol type="1">
<li><strong>SuffixTreeNode Class</strong>:
<ul>
<li>A clas to represent each node in the suffix tree.</li>
</ul></li>
<li><strong>build_suffix_tree Function</strong>:
<ul>
<li>Constructs the suffix tree using the given edges.</li>
</ul></li>
<li><strong>dfs Function</strong>:
<ul>
<li>Performs a depth-first search to count the occurrences of substrings and keep track of the valid ones.</li>
</ul></li>
<li><strong>longest_k_fold_substring Function</strong>:
<ul>
<li>Builds the suffix tree, performs DFS, and identifies the longest substring with at least <code>k</code> occurrences.</li>
</ul></li>
<li><strong>Sample Input</strong>:
<ul>
<li>Parses the input and invokes the <code>longest_k_fold_substring</code> function to find and print the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="newick-format-with-edge-weights" class="level1" data-number="63">
<h1 data-number="63"><span class="header-section-number">63</span> Newick Format with Edge Weights</h1>
<p>In a&nbsp;<a href="https://rosalind.info/glossary/weighted-graph/">weighted tree</a>, each edge is assigned a (usually positive) number, called its&nbsp;<a href="https://rosalind.info/glossary/edge-weight/">weight</a>. The&nbsp;<a href="https://rosalind.info/glossary/distance/">distance</a>&nbsp;between two nodes in a weighted tree becomes the sum of the weights along the unique path connecting the nodes.</p>
<p>To generalize&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;to the case of a weighted tree&nbsp;<span class="math inline">\(T\)</span>, during our repeated “key step,” if&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>&nbsp;<span class="math inline">\(v_1,v_2,…,v_n\)</span>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/neighbor/">neighbors</a>&nbsp;in&nbsp;<span class="math inline">\(T\)</span>, and all these leaves are&nbsp;<a href="https://rosalind.info/glossary/incident/">incident</a>&nbsp;to&nbsp;<span class="math inline">\(u\)</span>, then we replace&nbsp;uu&nbsp;with&nbsp;<span class="math inline">\((v_1:d_1,v_2:d_2,…,v_n:d_n)u\)</span>, where&nbsp;didi&nbsp;is now the weight on the edge&nbsp;<span class="math inline">\({v_i,u}\)</span>.</p>
<p>Given:&nbsp;A collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;weighted trees (<span class="math inline">\(n≤40\)</span>) in Newick format, with each tree containing at most 200 nodes; each tree&nbsp;<span class="math inline">\(T_k\)</span> is followed by a pair of nodes&nbsp;<span class="math inline">\(x_k\)</span>&nbsp;and&nbsp;<span class="math inline">\(y_k\)</span> in&nbsp;<span class="math inline">\(T_k\)</span>.</p>
<p>Return:&nbsp;A collection of&nbsp;n&nbsp;numbers, for which the&nbsp;<span class="math inline">\(k\)</span>th number represents the distance between&nbsp;<span class="math inline">\(x_k\)</span>&nbsp;and&nbsp;<span class="math inline">\(y_k\)</span>&nbsp;in&nbsp;<span class="math inline">\(T_k\)</span>.</p>
<section id="sample-dataset-62" class="level2" data-number="63.1">
<h2 data-number="63.1" class="anchored" data-anchor-id="sample-dataset-62"><span class="header-section-number">63.1</span> Sample Dataset</h2>
<pre><code>(dog:42,cat:33);
cat dog

((dog:4,cat:3):74,robot:98,elephant:58);
dog elephant</code></pre>
</section>
<section id="sample-output-63" class="level2" data-number="63.2">
<h2 data-number="63.2" class="anchored" data-anchor-id="sample-output-63"><span class="header-section-number">63.2</span> Sample Output</h2>
<pre><code>75 136</code></pre>
</section>
<section id="solution-59" class="level2" data-number="63.3">
<h2 data-number="63.3" class="anchored" data-anchor-id="solution-59"><span class="header-section-number">63.3</span> Solution</h2>
<div class="sourceCode" id="cb189"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>clas Node:</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, number, parent, name<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.number <span class="op">=</span> number</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> <span class="st">"Node_"</span> <span class="op">+</span> <span class="bu">str</span>(<span class="va">self</span>.number) <span class="cf">if</span> name <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> name</span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>        tmp <span class="op">=</span> <span class="st">""</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.name <span class="op">!=</span> <span class="st">"Node_"</span> <span class="op">+</span> <span class="bu">str</span>(<span class="va">self</span>.number):</span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>            tmp <span class="op">=</span> <span class="ss">f"(</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>name<span class="sc">}</span><span class="ss">)"</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}{</span>tmp<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>clas WeightedNewick:</span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb189-16"><a href="#cb189-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> []</span>
<span id="cb189-17"><a href="#cb189-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edge_weight <span class="op">=</span> {}</span>
<span id="cb189-18"><a href="#cb189-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.construct_tree(data)</span>
<span id="cb189-19"><a href="#cb189-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name_index <span class="op">=</span> {node.name: node.number <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes}</span>
<span id="cb189-20"><a href="#cb189-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-21"><a href="#cb189-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> construct_tree(<span class="va">self</span>, data):</span>
<span id="cb189-22"><a href="#cb189-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Constructs the Newick Tree from the input data."""</span></span>
<span id="cb189-23"><a href="#cb189-23" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> data.replace(<span class="st">','</span>, <span class="st">' '</span>).replace(<span class="st">'('</span>, <span class="st">'( '</span>).replace(<span class="st">')'</span>, <span class="st">' )'</span>).strip(<span class="st">';'</span>).split()</span>
<span id="cb189-24"><a href="#cb189-24" aria-hidden="true" tabindex="-1"></a>        current_parent <span class="op">=</span> Node(<span class="op">-</span><span class="dv">1</span>, <span class="va">None</span>)</span>
<span id="cb189-25"><a href="#cb189-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> item <span class="kw">in</span> data:</span>
<span id="cb189-26"><a href="#cb189-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> item[<span class="dv">0</span>] <span class="op">==</span> <span class="st">'('</span>:</span>
<span id="cb189-27"><a href="#cb189-27" aria-hidden="true" tabindex="-1"></a>                <span class="co"># New internal node</span></span>
<span id="cb189-28"><a href="#cb189-28" aria-hidden="true" tabindex="-1"></a>                current_parent <span class="op">=</span> Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), current_parent.number)</span>
<span id="cb189-29"><a href="#cb189-29" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(current_parent)</span>
<span id="cb189-30"><a href="#cb189-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> item[<span class="dv">0</span>] <span class="op">==</span> <span class="st">')'</span>:</span>
<span id="cb189-31"><a href="#cb189-31" aria-hidden="true" tabindex="-1"></a>                <span class="co"># End of a subtree, backtrack to parent</span></span>
<span id="cb189-32"><a href="#cb189-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(item) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb189-33"><a href="#cb189-33" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.edge_weight[(current_parent.number, current_parent.parent)] <span class="op">=</span> <span class="bu">int</span>(item[item.find(<span class="st">':'</span>) <span class="op">+</span> <span class="dv">1</span>:])</span>
<span id="cb189-34"><a href="#cb189-34" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="bu">len</span>(item) <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb189-35"><a href="#cb189-35" aria-hidden="true" tabindex="-1"></a>                        current_parent.name <span class="op">=</span> item[<span class="dv">1</span>:item.find(<span class="st">':'</span>)]</span>
<span id="cb189-36"><a href="#cb189-36" aria-hidden="true" tabindex="-1"></a>                current_parent <span class="op">=</span> <span class="va">self</span>.nodes[current_parent.parent]</span>
<span id="cb189-37"><a href="#cb189-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb189-38"><a href="#cb189-38" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Leaf node</span></span>
<span id="cb189-39"><a href="#cb189-39" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edge_weight[(<span class="bu">len</span>(<span class="va">self</span>.nodes), current_parent.number)] <span class="op">=</span> <span class="bu">int</span>(item[item.find(<span class="st">':'</span>) <span class="op">+</span> <span class="dv">1</span>:])</span>
<span id="cb189-40"><a href="#cb189-40" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), current_parent.number, item[:item.find(<span class="st">':'</span>)]))</span>
<span id="cb189-41"><a href="#cb189-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-42"><a href="#cb189-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> distance(<span class="va">self</span>, name1, name2):</span>
<span id="cb189-43"><a href="#cb189-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Returns the distance between nodes with names name1 and name2."""</span></span>
<span id="cb189-44"><a href="#cb189-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> name1 <span class="op">==</span> name2:</span>
<span id="cb189-45"><a href="#cb189-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb189-46"><a href="#cb189-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-47"><a href="#cb189-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create the branches from the two desired nodes to the root</span></span>
<span id="cb189-48"><a href="#cb189-48" aria-hidden="true" tabindex="-1"></a>        idx1 <span class="op">=</span> <span class="va">self</span>.name_index[name1]</span>
<span id="cb189-49"><a href="#cb189-49" aria-hidden="true" tabindex="-1"></a>        branch1 <span class="op">=</span> [(idx1, <span class="va">self</span>.nodes[idx1].parent)]</span>
<span id="cb189-50"><a href="#cb189-50" aria-hidden="true" tabindex="-1"></a>        idx2 <span class="op">=</span> <span class="va">self</span>.name_index[name2]</span>
<span id="cb189-51"><a href="#cb189-51" aria-hidden="true" tabindex="-1"></a>        branch2 <span class="op">=</span> [(idx2, <span class="va">self</span>.nodes[idx2].parent)]</span>
<span id="cb189-52"><a href="#cb189-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-53"><a href="#cb189-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Trace the path to the root for both nodes</span></span>
<span id="cb189-54"><a href="#cb189-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> branch1[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb189-55"><a href="#cb189-55" aria-hidden="true" tabindex="-1"></a>            current_idx <span class="op">=</span> branch1[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb189-56"><a href="#cb189-56" aria-hidden="true" tabindex="-1"></a>            branch1.append((current_idx, <span class="va">self</span>.nodes[current_idx].parent))</span>
<span id="cb189-57"><a href="#cb189-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> branch2[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb189-58"><a href="#cb189-58" aria-hidden="true" tabindex="-1"></a>            current_idx <span class="op">=</span> branch2[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb189-59"><a href="#cb189-59" aria-hidden="true" tabindex="-1"></a>            branch2.append((current_idx, <span class="va">self</span>.nodes[current_idx].parent))</span>
<span id="cb189-60"><a href="#cb189-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-61"><a href="#cb189-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate the distance as the sum of edge weights in the symmetric difference of paths</span></span>
<span id="cb189-62"><a href="#cb189-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>([<span class="va">self</span>.edge_weight[edge] <span class="cf">for</span> edge <span class="kw">in</span> <span class="bu">set</span>(branch1) <span class="op">^</span> <span class="bu">set</span>(branch2)])</span>
<span id="cb189-63"><a href="#cb189-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-64"><a href="#cb189-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-65"><a href="#cb189-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb189-66"><a href="#cb189-66" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb189-67"><a href="#cb189-67" aria-hidden="true" tabindex="-1"></a><span class="st">(dog:42,cat:33);</span></span>
<span id="cb189-68"><a href="#cb189-68" aria-hidden="true" tabindex="-1"></a><span class="st">cat dog</span></span>
<span id="cb189-69"><a href="#cb189-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-70"><a href="#cb189-70" aria-hidden="true" tabindex="-1"></a><span class="st">((dog:4,cat:3):74,robot:98,elephant:58);</span></span>
<span id="cb189-71"><a href="#cb189-71" aria-hidden="true" tabindex="-1"></a><span class="st">dog elephant</span></span>
<span id="cb189-72"><a href="#cb189-72" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb189-73"><a href="#cb189-73" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb189-74"><a href="#cb189-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-75"><a href="#cb189-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute distances between pairs of nodes in each tree</span></span>
<span id="cb189-76"><a href="#cb189-76" aria-hidden="true" tabindex="-1"></a>distance_list <span class="op">=</span> []</span>
<span id="cb189-77"><a href="#cb189-77" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(input_lines) <span class="op">-</span> <span class="dv">1</span>, <span class="dv">3</span>):</span>
<span id="cb189-78"><a href="#cb189-78" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> input_lines[i]</span>
<span id="cb189-79"><a href="#cb189-79" aria-hidden="true" tabindex="-1"></a>    nodeA, nodeB <span class="op">=</span> input_lines[i <span class="op">+</span> <span class="dv">1</span>].split()</span>
<span id="cb189-80"><a href="#cb189-80" aria-hidden="true" tabindex="-1"></a>    distance_list.append(<span class="bu">str</span>(WeightedNewick(tree).distance(nodeA, nodeB)))</span>
<span id="cb189-81"><a href="#cb189-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-82"><a href="#cb189-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the computed distances</span></span>
<span id="cb189-83"><a href="#cb189-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(distance_list))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-32" class="level2" data-number="63.4">
<h2 data-number="63.4" class="anchored" data-anchor-id="explanation-32"><span class="header-section-number">63.4</span> Explanation</h2>
<ol type="1">
<li><strong>Node Class</strong>:
<ul>
<li>This clas represents a node in the tree.</li>
<li>Each node has a number, a parent, and an optional name.</li>
<li>The <code>__repr__</code> method provides a string representation of the node.</li>
</ul></li>
<li><strong>WeightedNewick Class</strong>:
<ul>
<li>This clas constructs a tree from a Newick string and provides functionality to compute distances between nodes.</li>
<li><code>__init__</code>: Initializes the tree, constructs it from the input data, and creates a mapping from node names to their indices.</li>
<li><code>construct_tree</code>: Parses the Newick string to build the tree structure and store edge weights.</li>
<li><code>distance</code>: Computes the distance between two nodes by tracing their paths to the root and summing the edge weights in the symmetric difference of these paths.</li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li>The sample input is split into lines, and the trees and node pairs are extracted.</li>
<li>For each tree and node pair, a <code>WeightedNewick</code> object is created, and the distance between the specified nodes is computed.</li>
<li>The distances are printed in the required format.</li>
</ul></li>
</ol>
</section>
</section>
<section id="wobble-bonding-and-rna-secondary-structures" class="level1" data-number="64">
<h1 data-number="64"><span class="header-section-number">64</span> Wobble Bonding and RNA Secondary Structures</h1>
<p>Given an&nbsp;<a href="https://rosalind.info/glossary/rna-string/">RNA string</a>&nbsp;<span class="math inline">\(s\)</span>, we will augment the&nbsp;<a href="https://rosalind.info/glossary/bonding-graph/">bonding graph</a>&nbsp;of&nbsp;s by adding&nbsp;<a href="https://rosalind.info/glossary/basepair-edges/">basepair edges</a>&nbsp;connecting all occurrences of ‘U’ to all occurrences of ‘G’ in order to represent possible wobble base pairs.</p>
<p>We say that a matching in the bonding graph for&nbsp;s is&nbsp;<a href="https://rosalind.info/glossary/valid-basepair-matching/">valid</a>&nbsp;if it is&nbsp;<a href="https://rosalind.info/glossary/noncrossing-matching/">noncrossing</a>&nbsp;(to prevent&nbsp;<a href="https://rosalind.info/glossary/pseudoknot/">pseudoknots</a>) and has the property that a basepair edge in the matching cannot connect symbols&nbsp;<span class="math inline">\(s_j\)</span>&nbsp;and&nbsp;<span class="math inline">\(s_k\)</span>&nbsp;unles <span class="math inline">\(k≥j+4\)</span>&nbsp;(to prevent nearby nucleotides from base pairing).</p>
<p>Given:&nbsp;An RNA string&nbsp;<span class="math inline">\(s\)</span>&nbsp;(of length at most 200&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>).</p>
<p>Return:&nbsp;The total number of&nbsp;<a href="https://rosalind.info/glossary/distinct/">distinct</a>&nbsp;valid matchings of basepair edges in the bonding graph of&nbsp;<span class="math inline">\(s\)</span>. Assume that wobble base pairing is allowed.</p>
<section id="sample-dataset-63" class="level2" data-number="64.1">
<h2 data-number="64.1" class="anchored" data-anchor-id="sample-dataset-63"><span class="header-section-number">64.1</span> Sample Dataset</h2>
<pre><code>AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU</code></pre>
</section>
<section id="sample-output-64" class="level2" data-number="64.2">
<h2 data-number="64.2" class="anchored" data-anchor-id="sample-output-64"><span class="header-section-number">64.2</span> Sample Output</h2>
<pre><code>284850219977421</code></pre>
</section>
<section id="solution-60" class="level2" data-number="64.3">
<h2 data-number="64.3" class="anchored" data-anchor-id="solution-60"><span class="header-section-number">64.3</span> Solution</h2>
<p>To solve the problem of counting distinct valid matchings of basepair edges in an RNA string considering wobble base pairing (G-U pairs) and noncrossing constraints, we can use a dynamic programming approach. Below is a detailed explanation and implementation in Python:</p>
</section>
<section id="approach-2" class="level2" data-number="64.4">
<h2 data-number="64.4" class="anchored" data-anchor-id="approach-2"><span class="header-section-number">64.4</span> Approach</h2>
<ol type="1">
<li><strong>Dynamic Programming (DP) Setup</strong>:
<ul>
<li>Define a 2D DP table <code>dp</code> where <code>dp[i][j]</code> represents the number of valid matchings for the substring of the RNA sequence from index <code>i</code> to index <code>j</code>.</li>
<li>Base case: <code>dp[i][i-1] = 1</code> for all <code>i</code> because an empty substring has one valid matching (the empty matching).</li>
</ul></li>
<li><strong>Recursive Relation</strong>:
<ul>
<li>For each pair of indices <code>i</code> and <code>j</code> such that <code>i &lt; j</code>, we consider the possibility of the base at position <code>i</code> pairing with any valid base at position <code>k</code> where <code>i &lt; k &lt;= j</code> and <code>k &gt;= i + 4</code> (to respect the distance constraint).</li>
<li>The RNA bases can pair if they form a valid pair: <code>A-U</code>, <code>U-A</code>, <code>C-G</code>, <code>G-C</code>, <code>G-U</code>, or <code>U-G</code>.</li>
<li>The number of matchings for substring <code>s[i:j+1]</code> is calculated by splitting it into the matchings between <code>s[i]</code> and <code>s[k]</code> and recursively solving for the substrings <code>s[i+1:k-1]</code> and <code>s[k+1:j]</code>.</li>
</ul></li>
<li><strong>Iterative Calculation</strong>:
<ul>
<li>Fill in the DP table iteratively, starting from smaller substrings and building up to the entire string.</li>
</ul></li>
</ol>
</section>
<section id="implementation-7" class="level2" data-number="64.5">
<h2 data-number="64.5" class="anchored" data-anchor-id="implementation-7"><span class="header-section-number">64.5</span> Implementation</h2>
<div class="sourceCode" id="cb192"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_valid_matchings(rna):</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(rna)</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> can_pair(b1, b2):</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (b1 <span class="op">==</span> <span class="st">'A'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'U'</span>) <span class="kw">or</span> (b1 <span class="op">==</span> <span class="st">'U'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'A'</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>               (b1 <span class="op">==</span> <span class="st">'C'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'G'</span>) <span class="kw">or</span> (b1 <span class="op">==</span> <span class="st">'G'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'C'</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>               (b1 <span class="op">==</span> <span class="st">'G'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'U'</span>) <span class="kw">or</span> (b1 <span class="op">==</span> <span class="st">'U'</span> <span class="kw">and</span> b2 <span class="op">==</span> <span class="st">'G'</span>)</span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># A single base has one valid matching (itself)</span></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length is the length of the substring</span></span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length):</span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length</span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">+</span><span class="dv">1</span>][j]  <span class="co"># Case where s[i] is not paired</span></span>
<span id="cb192-17"><a href="#cb192-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">4</span>, j <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb192-18"><a href="#cb192-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> can_pair(rna[i], rna[k]):</span>
<span id="cb192-19"><a href="#cb192-19" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> k <span class="op">==</span> j:</span>
<span id="cb192-20"><a href="#cb192-20" aria-hidden="true" tabindex="-1"></a>                        dp[i][j] <span class="op">+=</span> dp[i<span class="op">+</span><span class="dv">1</span>][k<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb192-21"><a href="#cb192-21" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb192-22"><a href="#cb192-22" aria-hidden="true" tabindex="-1"></a>                        dp[i][j] <span class="op">+=</span> dp[i<span class="op">+</span><span class="dv">1</span>][k<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> dp[k<span class="op">+</span><span class="dv">1</span>][j]</span>
<span id="cb192-23"><a href="#cb192-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-24"><a href="#cb192-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb192-25"><a href="#cb192-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-26"><a href="#cb192-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb192-27"><a href="#cb192-27" aria-hidden="true" tabindex="-1"></a>rna <span class="op">=</span> <span class="st">"AUGCUAGUACGGAGCGAGUCUAGCGAGCGAUGUCGUGAGUACUAUAUAUGCGCAUAAGCCACGU"</span></span>
<span id="cb192-28"><a href="#cb192-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-29"><a href="#cb192-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the result</span></span>
<span id="cb192-30"><a href="#cb192-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_valid_matchings(rna))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-33" class="level2" data-number="64.6">
<h2 data-number="64.6" class="anchored" data-anchor-id="explanation-33"><span class="header-section-number">64.6</span> Explanation</h2>
<ol type="1">
<li><strong>Base Case</strong>:
<ul>
<li>Each single base (or empty substring) has one valid matching (<code>dp[i][i] = 1</code>).</li>
</ul></li>
<li><strong>Filling DP Table</strong>:
<ul>
<li>For each possible substring length, calculate the number of valid matchings by considering all possible pairs for the first base and ensuring the substrings formed by removing the matched bases also have valid matchings.</li>
</ul></li>
<li><strong>Helper Function</strong>:
<ul>
<li><code>can_pair</code> checks if two bases can pair according to the given rules including wobble base pairing.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-disease-carriers" class="level1" data-number="65">
<h1 data-number="65"><span class="header-section-number">65</span> Counting Disease Carriers</h1>
<p>To model the Hardy-Weinberg principle, assume that we have a population of&nbsp;<span class="math inline">\(N\)</span>&nbsp;<a href="https://rosalind.info/glossary/diploid-cell/">diploid</a>&nbsp;individuals. If an allele is in genetic equilibrium, then because mating is random, we may view the&nbsp;<span class="math inline">\(2N\)</span>&nbsp;chromosomes as receiving their alleles&nbsp;<a href="https://rosalind.info/glossary/uniform-random-variable/">uniformly</a>. In other words, if there are&nbsp;mm&nbsp;<a href="https://rosalind.info/glossary/dominant-allele/">dominant alleles</a>, then the probability of a selected chromosome exhibiting the dominant allele is simply&nbsp;<span class="math inline">\(p= \frac{m}{2N}\)</span>.</p>
<p>Because the first assumption of genetic equilibrium states that the population is so large as to be ignored, we will assume that&nbsp;<span class="math inline">\(N\)</span>&nbsp;is infinite, so that we only need to concern ourselves with the value of&nbsp;<span class="math inline">\(p\)</span>.</p>
<p>Given:&nbsp;An&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;for which&nbsp;<span class="math inline">\(A[k]\)</span>&nbsp;represents the proportion of&nbsp;<a href="https://rosalind.info/glossary/homozygous-recessive/">homozygous recessive</a>&nbsp;individuals for the&nbsp;<span class="math inline">\(k\)</span>-th Mendelian factor in a diploid population. Assume that the population is in genetic equilibrium for all factors.</p>
<p>Return:&nbsp;An array&nbsp;<span class="math inline">\(B\)</span>&nbsp;having the same length as&nbsp;<span class="math inline">\(A\)</span>&nbsp;in which&nbsp;<span class="math inline">\(B[k]\)</span>&nbsp;represents the&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;that a randomly selected individual carries at least one copy of the&nbsp;<a href="https://rosalind.info/glossary/recessive-allele/">recessive allele</a>&nbsp;for the&nbsp;<span class="math inline">\(k\)</span>-th factor.</p>
<section id="sample-dataset-64" class="level2" data-number="65.1">
<h2 data-number="65.1" class="anchored" data-anchor-id="sample-dataset-64"><span class="header-section-number">65.1</span> Sample Dataset</h2>
<pre><code>0.1 0.25 0.5</code></pre>
</section>
<section id="sample-output-65" class="level2" data-number="65.2">
<h2 data-number="65.2" class="anchored" data-anchor-id="sample-output-65"><span class="header-section-number">65.2</span> Sample Output</h2>
<pre><code>0.532 0.75 0.914</code></pre>
</section>
<section id="solution-61" class="level2" data-number="65.3">
<h2 data-number="65.3" class="anchored" data-anchor-id="solution-61"><span class="header-section-number">65.3</span> Solution</h2>
<p>To solve the problem of determining the probability that a randomly selected individual carries at least one copy of the recessive allele for each Mendelian factor, we need to work with the Hardy-Weinberg equilibrium principles.</p>
</section>
<section id="steps-to-solve" class="level2" data-number="65.4">
<h2 data-number="65.4" class="anchored" data-anchor-id="steps-to-solve"><span class="header-section-number">65.4</span> Steps to Solve</h2>
<ol type="1">
<li><strong>Given Data</strong>:
<ul>
<li>Array <span class="math inline">\(A\)</span> where <span class="math inline">\(A[k]\)</span> is the proportion of homozygous recessive individuals for the <span class="math inline">\(k\)</span>-th factor.</li>
<li>We need to find an array <span class="math inline">\(B\)</span> where <span class="math inline">\(B[k]\)</span> is the probability that a randomly selected individual carries at least one copy of the recessive allele for the <span class="math inline">\(k\)</span>-th factor.</li>
</ul></li>
<li><strong>Hardy-Weinberg Principle</strong>:
<ul>
<li>In genetic equilibrium, the proportion of homozygous recessive individuals (denoted <span class="math inline">\(q^2\)</span>) is <span class="math inline">\(A[k]\)</span>.</li>
<li>The recessive allele frequency <span class="math inline">\(q\)</span> is the square root of <span class="math inline">\(A[k]\)</span>, i.e., <span class="math inline">\(q = \sqrt{A[k]}\)</span>.</li>
<li>The dominant allele frequency <span class="math inline">\(p\)</span> is <span class="math inline">\(1 - q\)</span>.</li>
</ul></li>
<li><strong>Carrier Probability</strong>:
<ul>
<li>The probability that an individual carries at least one recessive allele (i.e., they are either heterozygous or homozygous recessive) is given by <span class="math inline">\(1 - p^2\)</span>.</li>
<li>Since <span class="math inline">\(p = 1 - q\)</span>, the carrier probability becomes <span class="math inline">\(1 - (1 - q)^2\)</span>.</li>
</ul></li>
<li><strong>Calculation</strong>:
<ul>
<li>For each <span class="math inline">\(k\)</span>: <span class="math display">\[ q = \sqrt{A[k]} \]</span> <span class="math display">\[ B[k] = 1 - (1 - q)^2 \]</span></li>
</ul></li>
</ol>
</section>
<section id="implementation-8" class="level2" data-number="65.5">
<h2 data-number="65.5" class="anchored" data-anchor-id="implementation-8"><span class="header-section-number">65.5</span> Implementation</h2>
<p>Here’s how you can implement this in Python:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_carrier_probability(A):</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> []</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> q_squared <span class="kw">in</span> A:</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> math.sqrt(q_squared)</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> q</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>        carrier_probability <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> p<span class="op">**</span><span class="dv">2</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>        B.append(carrier_probability)</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Dataset</span></span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a><span class="st">0.1 0.25 0.5"""</span></span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> sample_input.strip().split()]</span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-17"><a href="#cb195-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the carrier probabilities</span></span>
<span id="cb195-18"><a href="#cb195-18" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> calculate_carrier_probability(A)</span>
<span id="cb195-19"><a href="#cb195-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-20"><a href="#cb195-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results formatted to three decimal places</span></span>
<span id="cb195-21"><a href="#cb195-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>prob<span class="sc">:f}</span><span class="ss">"</span> <span class="cf">for</span> prob <span class="kw">in</span> B))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-34" class="level2" data-number="65.6">
<h2 data-number="65.6" class="anchored" data-anchor-id="explanation-34"><span class="header-section-number">65.6</span> Explanation</h2>
<ol type="1">
<li><strong>Function Definition</strong>:
<ul>
<li><code>calculate_carrier_probability</code> takes the array <span class="math inline">\(A\)</span> as input and returns the array <span class="math inline">\(B\)</span>.</li>
</ul></li>
<li><strong>Loop Through <span class="math inline">\(A\)</span></strong>:
<ul>
<li>For each element in <span class="math inline">\(A\)</span>:
<ul>
<li>Compute <span class="math inline">\(q\)</span> as the square root of the element.</li>
<li>Compute <span class="math inline">\(p\)</span> as <span class="math inline">\(1 - q\)</span>.</li>
<li>Compute the carrier probability using <span class="math inline">\(1 - p^2\)</span>.</li>
<li>Append the result to <span class="math inline">\(B\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>Format the output to three decimal places for better readability.</li>
</ul></li>
</ol>
</section>
</section>
<section id="creating-a-character-table-from-genetic-strings" class="level1" data-number="66">
<h1 data-number="66"><span class="header-section-number">66</span> Creating a Character Table from Genetic Strings</h1>
<p>A collection of&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;is&nbsp;<a href="https://rosalind.info/glossary/characterizable-strings/">characterizable</a>&nbsp;if there are at most two possible choices for the symbol at each&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;of the strings.</p>
<p>Given:&nbsp;A collection of at most 100 characterizable&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>, each of length at most 300 bp.</p>
<p>Return:&nbsp;A character table for which each nontrivial character encodes the symbol choice at a single position of the strings. (Note: the choice of assigning ‘1’ and ‘0’ to the two states of each SNP in the strings is arbitrary.)</p>
<section id="sample-dataset-65" class="level2" data-number="66.1">
<h2 data-number="66.1" class="anchored" data-anchor-id="sample-dataset-65"><span class="header-section-number">66.1</span> Sample Dataset</h2>
<pre><code>ATGCTACC
CGTTTACC
ATTCGACC
AGTCTCCC
CGTCTATC</code></pre>
</section>
<section id="sample-output-66" class="level2" data-number="66.2">
<h2 data-number="66.2" class="anchored" data-anchor-id="sample-output-66"><span class="header-section-number">66.2</span> Sample Output</h2>
<pre><code>10110
10100</code></pre>
</section>
<section id="solution-62" class="level2" data-number="66.3">
<h2 data-number="66.3" class="anchored" data-anchor-id="solution-62"><span class="header-section-number">66.3</span> Solution</h2>
<div class="sourceCode" id="cb198"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> char_table_from_strings(dna_list):</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Builds a character table from a given list of DNA strings.</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a><span class="co">    dna_list (list of str): A list of DNA strings.</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a><span class="co">    set of str: A set containing nontrivial character rows.</span></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>    character_table <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each position in the DNA strings</span></span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(dna_list[<span class="dv">0</span>])):</span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Determine the reference character at the current position from the first DNA string</span></span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a>        ref_char <span class="op">=</span> dna_list[<span class="dv">0</span>][pos]</span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a binary array indicating the presence of the reference character at the current position</span></span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a>        char_array <span class="op">=</span> [<span class="bu">int</span>(dna[pos] <span class="op">==</span> ref_char) <span class="cf">for</span> dna <span class="kw">in</span> dna_list]</span>
<span id="cb198-20"><a href="#cb198-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb198-21"><a href="#cb198-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if the character array is nontrivial (i.e., it has both 0s and 1s but not all 0s or all 1s)</span></span>
<span id="cb198-22"><a href="#cb198-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">sum</span>(char_array) <span class="op">&lt;</span> <span class="bu">len</span>(dna_list) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb198-23"><a href="#cb198-23" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Convert the binary array to a string and add it to the character table</span></span>
<span id="cb198-24"><a href="#cb198-24" aria-hidden="true" tabindex="-1"></a>            character_table.add(<span class="st">''</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, char_array)))</span>
<span id="cb198-25"><a href="#cb198-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb198-26"><a href="#cb198-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> character_table</span>
<span id="cb198-27"><a href="#cb198-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-28"><a href="#cb198-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb198-29"><a href="#cb198-29" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb198-30"><a href="#cb198-30" aria-hidden="true" tabindex="-1"></a><span class="st">ATGCTACC</span></span>
<span id="cb198-31"><a href="#cb198-31" aria-hidden="true" tabindex="-1"></a><span class="st">CGTTTACC</span></span>
<span id="cb198-32"><a href="#cb198-32" aria-hidden="true" tabindex="-1"></a><span class="st">ATTCGACC</span></span>
<span id="cb198-33"><a href="#cb198-33" aria-hidden="true" tabindex="-1"></a><span class="st">AGTCTCCC</span></span>
<span id="cb198-34"><a href="#cb198-34" aria-hidden="true" tabindex="-1"></a><span class="st">CGTCTATC</span></span>
<span id="cb198-35"><a href="#cb198-35" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb198-36"><a href="#cb198-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-37"><a href="#cb198-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the input string to a list of DNA strings</span></span>
<span id="cb198-38"><a href="#cb198-38" aria-hidden="true" tabindex="-1"></a>dna_list <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb198-39"><a href="#cb198-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-40"><a href="#cb198-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the character table</span></span>
<span id="cb198-41"><a href="#cb198-41" aria-hidden="true" tabindex="-1"></a>character_table <span class="op">=</span> char_table_from_strings(dna_list)</span>
<span id="cb198-42"><a href="#cb198-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-43"><a href="#cb198-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the character table</span></span>
<span id="cb198-44"><a href="#cb198-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> character_table:</span>
<span id="cb198-45"><a href="#cb198-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-35" class="level2" data-number="66.4">
<h2 data-number="66.4" class="anchored" data-anchor-id="explanation-35"><span class="header-section-number">66.4</span> Explanation</h2>
<ol type="1">
<li><p><strong>Function Definition</strong>: The function <code>char_table_from_strings</code> is defined to take a list of DNA strings and return a set of nontrivial character rows.</p></li>
<li><p><strong>Initialize Character Table</strong>: An empty set <code>character_table</code> is initialized to store the nontrivial character rows.</p></li>
<li><p><strong>Iterate Over Positions</strong>: A loop iterates over each position in the DNA strings. The length of the first string is used to determine the number of positions.</p></li>
<li><p><strong>Reference Character</strong>: For each position, the reference character <code>ref_char</code> is taken from the first DNA string.</p></li>
<li><p><strong>Create Binary Array</strong>: A binary array <code>char_array</code> is created using a list comprehension. For each DNA string, it checks if the character at the current position matches the reference character and records <code>1</code> if it does and <code>0</code> if it doesn’t.</p></li>
<li><p><strong>Check Nontrivial Condition</strong>: The array is considered nontrivial if it contains both <code>0s</code> and <code>1s</code> but is not all <code>0s</code> or all <code>1s</code>. This is checked using the condition <code>1 &lt; sum(char_array) &lt; len(dna_list) - 1</code>.</p></li>
<li><p><strong>Add to Character Table</strong>: If the binary array is nontrivial, it is converted to a string and added to the <code>character_table</code> set.</p></li>
<li><p><strong>Return Character Table</strong>: The function returns the <code>character_table</code> set containing all nontrivial character rows.</p></li>
<li><p><strong>Sample Input</strong>: The sample input is given as a multiline string, which is converted to a list of DNA strings by stripping and splitting by newline characters.</p></li>
<li><p><strong>Generate and Print Character Table</strong>: The character table is generated by calling the function and printed row by row.</p></li>
</ol>
</section>
</section>
<section id="counting-optimal-alignments" class="level1" data-number="67">
<h1 data-number="67"><span class="header-section-number">67</span> Counting Optimal Alignments</h1>
<p>Recall from&nbsp;<a href="https://rosalind.info/problems/edta/">“Edit Distance Alignment”</a>&nbsp;that if&nbsp;<span class="math inline">\(s′\)</span>&nbsp;and&nbsp;<span class="math inline">\(t′\)</span>&nbsp;are the&nbsp;<a href="https://rosalind.info/glossary/augmented-string/">augmented strings</a>&nbsp;corresponding to an alignment of strings&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, then the&nbsp;<a href="https://rosalind.info/glossary/edit-alignment-score/">edit alignment score</a>&nbsp;of&nbsp;<span class="math inline">\(s′\)</span>&nbsp;and&nbsp;<span class="math inline">\(t′\)</span>&nbsp;was given by the&nbsp;<a href="https://rosalind.info/glossary/hamming-distance/">Hamming distance</a>&nbsp;<span class="math inline">\(dH(s′,t′)\)</span>&nbsp;(because&nbsp;<span class="math inline">\(s′\)</span>&nbsp;and&nbsp;<span class="math inline">\(t′\)</span>&nbsp;have the same length and already include&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbols</a>&nbsp;to denote insertions/deletions).</p>
<p>As a result, we obtain&nbsp;<span class="math inline">\(d_E(s,t)=min_{s′,t′} dH(s′,t′)\)</span>, where the minimum is taken over all alignments of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. Strings&nbsp;<span class="math inline">\(s′\)</span>&nbsp;and&nbsp;<span class="math inline">\(t′\)</span>&nbsp;achieving this minimum correspond to an optimal alignment with respect to edit alignment score.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>, each of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>.</p>
<p>Return:&nbsp;The total number of optimal alignments of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;with respect to edit alignment score,&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;<span class="math inline">\(134,217,727 (2^{27}-1)\)</span>.</p>
<section id="sample-dataset-66" class="level2" data-number="67.1">
<h2 data-number="67.1" class="anchored" data-anchor-id="sample-dataset-66"><span class="header-section-number">67.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_78
PLEASANTLY
&gt;Rosalind_33
MEANLY</code></pre>
</section>
<section id="sample-output-67" class="level2" data-number="67.2">
<h2 data-number="67.2" class="anchored" data-anchor-id="sample-output-67"><span class="header-section-number">67.2</span> Sample Output</h2>
<pre><code>4</code></pre>
</section>
<section id="solution-63" class="level2" data-number="67.3">
<h2 data-number="67.3" class="anchored" data-anchor-id="solution-63"><span class="header-section-number">67.3</span> Solution</h2>
<div class="sourceCode" id="cb201"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_string):</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Parses a FASTA format string and returns the sequences in a list.'''</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> []</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sequence:</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(sequence))</span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>                sequence <span class="op">=</span> []</span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>            sequence.append(line.strip())</span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sequence:</span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(sequence))</span>
<span id="cb201-16"><a href="#cb201-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-17"><a href="#cb201-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb201-18"><a href="#cb201-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-19"><a href="#cb201-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_optimal_alignments(s, t):</span>
<span id="cb201-20"><a href="#cb201-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Counts the total number of optimal alignments of s and t with respect to edit alignment score.'''</span></span>
<span id="cb201-21"><a href="#cb201-21" aria-hidden="true" tabindex="-1"></a>    MOD <span class="op">=</span> <span class="dv">134217727</span>  <span class="co"># Modulo value to prevent overflow</span></span>
<span id="cb201-22"><a href="#cb201-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-23"><a href="#cb201-23" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb201-24"><a href="#cb201-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-25"><a href="#cb201-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP tables</span></span>
<span id="cb201-26"><a href="#cb201-26" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]  <span class="co"># Table for edit distances</span></span>
<span id="cb201-27"><a href="#cb201-27" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]  <span class="co"># Table for counting optimal alignments</span></span>
<span id="cb201-28"><a href="#cb201-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-29"><a href="#cb201-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base cases: edit distance and count for aligning to empty string</span></span>
<span id="cb201-30"><a href="#cb201-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb201-31"><a href="#cb201-31" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb201-32"><a href="#cb201-32" aria-hidden="true" tabindex="-1"></a>        count[i][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb201-33"><a href="#cb201-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-34"><a href="#cb201-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb201-35"><a href="#cb201-35" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb201-36"><a href="#cb201-36" aria-hidden="true" tabindex="-1"></a>        count[<span class="dv">0</span>][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb201-37"><a href="#cb201-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-38"><a href="#cb201-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP tables</span></span>
<span id="cb201-39"><a href="#cb201-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb201-40"><a href="#cb201-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb201-41"><a href="#cb201-41" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate the cost of insert, delete, and replace operations</span></span>
<span id="cb201-42"><a href="#cb201-42" aria-hidden="true" tabindex="-1"></a>            insert_cost <span class="op">=</span> dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb201-43"><a href="#cb201-43" aria-hidden="true" tabindex="-1"></a>            delete_cost <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb201-44"><a href="#cb201-44" aria-hidden="true" tabindex="-1"></a>            replace_cost <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> (<span class="dv">0</span> <span class="cf">if</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span>)</span>
<span id="cb201-45"><a href="#cb201-45" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb201-46"><a href="#cb201-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Find the minimum cost among the three operations</span></span>
<span id="cb201-47"><a href="#cb201-47" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(insert_cost, delete_cost, replace_cost)</span>
<span id="cb201-48"><a href="#cb201-48" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb201-49"><a href="#cb201-49" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Count the number of ways to achieve this minimum cost</span></span>
<span id="cb201-50"><a href="#cb201-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[i][j] <span class="op">==</span> insert_cost:</span>
<span id="cb201-51"><a href="#cb201-51" aria-hidden="true" tabindex="-1"></a>                count[i][j] <span class="op">+=</span> count[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb201-52"><a href="#cb201-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[i][j] <span class="op">==</span> delete_cost:</span>
<span id="cb201-53"><a href="#cb201-53" aria-hidden="true" tabindex="-1"></a>                count[i][j] <span class="op">+=</span> count[i<span class="op">-</span><span class="dv">1</span>][j]</span>
<span id="cb201-54"><a href="#cb201-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[i][j] <span class="op">==</span> replace_cost:</span>
<span id="cb201-55"><a href="#cb201-55" aria-hidden="true" tabindex="-1"></a>                count[i][j] <span class="op">+=</span> count[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb201-56"><a href="#cb201-56" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb201-57"><a href="#cb201-57" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply the modulo to keep the count manageable</span></span>
<span id="cb201-58"><a href="#cb201-58" aria-hidden="true" tabindex="-1"></a>            count[i][j] <span class="op">%=</span> MOD</span>
<span id="cb201-59"><a href="#cb201-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb201-60"><a href="#cb201-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count[m][n]</span>
<span id="cb201-61"><a href="#cb201-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-62"><a href="#cb201-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset in FASTA format</span></span>
<span id="cb201-63"><a href="#cb201-63" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb201-64"><a href="#cb201-64" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_78</span></span>
<span id="cb201-65"><a href="#cb201-65" aria-hidden="true" tabindex="-1"></a><span class="st">PLEASANTLY</span></span>
<span id="cb201-66"><a href="#cb201-66" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_33</span></span>
<span id="cb201-67"><a href="#cb201-67" aria-hidden="true" tabindex="-1"></a><span class="st">MEANLY</span></span>
<span id="cb201-68"><a href="#cb201-68" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb201-69"><a href="#cb201-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-70"><a href="#cb201-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the FASTA input to get the sequences</span></span>
<span id="cb201-71"><a href="#cb201-71" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb201-72"><a href="#cb201-72" aria-hidden="true" tabindex="-1"></a>s, t <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb201-73"><a href="#cb201-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-74"><a href="#cb201-74" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the number of optimal alignments</span></span>
<span id="cb201-75"><a href="#cb201-75" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_optimal_alignments(s, t)</span>
<span id="cb201-76"><a href="#cb201-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-77"><a href="#cb201-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb201-78"><a href="#cb201-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-36" class="level2" data-number="67.4">
<h2 data-number="67.4" class="anchored" data-anchor-id="explanation-36"><span class="header-section-number">67.4</span> Explanation</h2>
<ol type="1">
<li><strong>FASTA Parsing (<code>parse_fasta</code>)</strong>:
<ul>
<li>This function reads a FASTA formatted string and extracts sequences.</li>
<li>It initializes an empty list <code>sequences</code> to store the parsed sequences and another list <code>sequence</code> to build each sequence.</li>
<li>It iterates over each line of the input string:
<ul>
<li>If a line starts with <code>&gt;</code>, it indicates a new sequence header. If <code>sequence</code> is not empty, it joins its elements into a single string and adds it to <code>sequences</code>.</li>
<li>If a line does not start with <code>&gt;</code>, it is part of a sequence, so it is added to <code>sequence</code>.</li>
</ul></li>
<li>After the loop, any remaining sequence is added to <code>sequences</code>.</li>
<li>The function returns the list of sequences.</li>
</ul></li>
<li><strong>Counting Optimal Alignments (<code>count_optimal_alignments</code>)</strong>:
<ul>
<li>This function calculates the number of optimal alignments between two strings <code>s</code> and <code>t</code>.</li>
<li><code>MOD</code> is a large prime number used to keep the counts within manageable limits.</li>
<li><code>dp</code> is a table where <code>dp[i][j]</code> stores the minimum edit distance between the first <code>i</code> characters of <code>s</code> and the first <code>j</code> characters of <code>t</code>.</li>
<li><code>count</code> is a table where <code>count[i][j]</code> stores the number of optimal alignments that result in the minimum edit distance for the first <code>i</code> characters of <code>s</code> and the first <code>j</code> characters of <code>t</code>.</li>
<li>The base cases initialize the first row and first column of <code>dp</code> and <code>count</code> to represent alignments with an empty string.</li>
<li>The nested loops fill in the <code>dp</code> and <code>count</code> tables by considering insertion, deletion, and replacement operations.</li>
<li>The minimum cost operation is selected, and the number of ways to achieve this cost is counted.</li>
<li>The result is the number of optimal alignments for the entire strings <code>s</code> and <code>t</code>, stored in <code>count[m][n]</code>.</li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li>The sample input is given in FASTA format.</li>
<li>The <code>parse_fasta</code> function is called to extract the sequences.</li>
<li>The <code>count_optimal_alignments</code> function is called with the parsed sequences to get the number of optimal alignments.</li>
<li>The result is printed.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-unrooted-binary-trees" class="level1" data-number="68">
<h1 data-number="68"><span class="header-section-number">68</span> Counting Unrooted Binary Trees</h1>
<p>Two&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary trees</a>&nbsp;<span class="math inline">\(T_1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T_2\)</span>&nbsp;having the same&nbsp;n labeled&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>&nbsp;are considered to be equivalent if there is some assignment of labels to the internal nodes of&nbsp;<span class="math inline">\(T_1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T_2\)</span>&nbsp;so that the&nbsp;<a href="https://rosalind.info/glossary/adjacency-list/">adjacency lists</a>&nbsp;of the two trees coincide. As a result, note that&nbsp;<span class="math inline">\(T_1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T_2\)</span>&nbsp;must have the same splits; conversely, if the two trees do not have the same splits, then they are considered&nbsp;<a href="https://rosalind.info/glossary/distinct/">distinct</a>.</p>
<p>Let&nbsp;<span class="math inline">\(b(n)\)</span>&nbsp;denote the total number of distinct unrooted binary trees having&nbsp;n labeled leaves.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤1000\)</span>).</p>
<p>Return:&nbsp;The value of&nbsp;<span class="math inline">\(b(n)\)</span>&nbsp;modulo 1,000,000.</p>
<section id="sample-dataset-67" class="level2" data-number="68.1">
<h2 data-number="68.1" class="anchored" data-anchor-id="sample-dataset-67"><span class="header-section-number">68.1</span> Sample Dataset</h2>
<pre><code>5</code></pre>
</section>
<section id="sample-output-68" class="level2" data-number="68.2">
<h2 data-number="68.2" class="anchored" data-anchor-id="sample-output-68"><span class="header-section-number">68.2</span> Sample Output</h2>
<pre><code>15</code></pre>
</section>
<section id="solution-64" class="level2" data-number="68.3">
<h2 data-number="68.3" class="anchored" data-anchor-id="solution-64"><span class="header-section-number">68.3</span> Solution</h2>
<div class="sourceCode" id="cb204"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_unrooted_binary_trees(num_leaves: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the number of unrooted binary trees with num_leaves leaves, </span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a><span class="co">    modulo 1,000,000.</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    MODULO <span class="op">=</span> <span class="dv">10</span><span class="op">**</span><span class="dv">6</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> double_factorial(n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>):</span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> (result <span class="op">*</span> i) <span class="op">%</span> MODULO</span>
<span id="cb204-14"><a href="#cb204-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb204-15"><a href="#cb204-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-16"><a href="#cb204-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> double_factorial(<span class="dv">2</span> <span class="op">*</span> num_leaves <span class="op">-</span> <span class="dv">5</span>)</span>
<span id="cb204-17"><a href="#cb204-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-18"><a href="#cb204-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb204-19"><a href="#cb204-19" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"5"</span></span>
<span id="cb204-20"><a href="#cb204-20" aria-hidden="true" tabindex="-1"></a>num_leaves <span class="op">=</span> <span class="bu">int</span>(sample_input.strip())</span>
<span id="cb204-21"><a href="#cb204-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-22"><a href="#cb204-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the number of unrooted binary trees</span></span>
<span id="cb204-23"><a href="#cb204-23" aria-hidden="true" tabindex="-1"></a>tree_count <span class="op">=</span> count_unrooted_binary_trees(num_leaves)</span>
<span id="cb204-24"><a href="#cb204-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-25"><a href="#cb204-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb204-26"><a href="#cb204-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tree_count)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>##$ Explanation</p>
<ol type="1">
<li><strong>Double Factorial Calculation without Lambda:</strong>
<ul>
<li>The <code>double_factorial</code> function is now implemented using a simple <code>for</code> loop.</li>
<li>The loop iterates over the range from <code>n</code> down to 1, stepping by -2 (to get only odd numbers).</li>
<li>In each iteration, the current <code>result</code> is multiplied by <code>i</code> and taken modulo (10^6).</li>
<li>This avoids the use of a lambda function and <code>functools.reduce</code>.</li>
</ul></li>
<li><strong>Rest of the Code:</strong>
<ul>
<li>The rest of the code remains unchanged.</li>
<li>The <code>count_unrooted_binary_trees</code> function calls <code>double_factorial</code> with <code>2 * num_leaves - 5</code> to compute the number of unrooted binary trees.</li>
<li>The result is printed after parsing the sample input.</li>
</ul></li>
</ol>
</section>
</section>
<section id="global-alignment-with-scoring-matrix" class="level1" data-number="69">
<h1 data-number="69"><span class="header-section-number">69</span> Global Alignment with Scoring Matrix</h1>
<p>To penalize symbol substitutions differently depending on which two symbols are involved in the substitution, we obtain a&nbsp;<a href="https://rosalind.info/glossary/scoring-matrix/">scoring matrix</a>&nbsp;<span class="math inline">\(S\)</span>&nbsp;in which&nbsp;<span class="math inline">\(S_{i,j}\)</span>&nbsp;represents the (negative) score assigned to a substitution of the&nbsp;iith symbol of our&nbsp;<a href="https://rosalind.info/glossary/alphabet/">alphabet</a>&nbsp;<span class="math inline">\(𝒜\)</span>&nbsp;with the&nbsp;<span class="math inline">\(j\)</span>th symbol of&nbsp;<span class="math inline">\(𝒜\)</span>.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/gap-penalty/">gap penalty</a>&nbsp;is the component deducted from alignment score due to the presence of a&nbsp;<a href="https://rosalind.info/glossary/gap/">gap</a>. A gap penalty may be a function of the length of the gap; for example, a&nbsp;<a href="https://rosalind.info/glossary/linear-gap-penalty/">linear gap penalty</a>&nbsp;is a constant&nbsp;<span class="math inline">\(g\)</span>&nbsp;such that each inserted or deleted symbol is charged&nbsp;<span class="math inline">\(g\)</span>; as a result, the cost of a gap of length&nbsp;<span class="math inline">\(L\)</span>&nbsp;is equal to&nbsp;<span class="math inline">\(gL\)</span>.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The maximum alignment score between&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. Use:</p>
<ul>
<li>The&nbsp;<a href="https://rosalind.info/glossary/blosum62/">BLOSUM62</a>&nbsp;scoring matrix.</li>
<li><a href="https://rosalind.info/glossary/linear-gap-penalty/">Linear gap penalty</a>&nbsp;equal to 5 (i.e., a cost of -5 is assessed for each&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbol</a>).</li>
</ul>
<section id="sample-dataset-68" class="level2" data-number="69.1">
<h2 data-number="69.1" class="anchored" data-anchor-id="sample-dataset-68"><span class="header-section-number">69.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_67
PLEASANTLY
&gt;Rosalind_17
MEANLY</code></pre>
</section>
<section id="sample-output-69" class="level2" data-number="69.2">
<h2 data-number="69.2" class="anchored" data-anchor-id="sample-output-69"><span class="header-section-number">69.2</span> Sample Output</h2>
<pre><code>8</code></pre>
</section>
<section id="solution-65" class="level2" data-number="69.3">
<h2 data-number="69.3" class="anchored" data-anchor-id="solution-65"><span class="header-section-number">69.3</span> Solution</h2>
<p>To solve the problem of finding the maximum alignment score between two protein strings using the BLOSUM62 scoring matrix and a linear gap penalty of 5, we need to implement the Needleman-Wunsch algorithm for global sequence alignment. This involves dynamic programming to compute the optimal alignment score.</p>
<p>Here is the step-by-step explanation of the solution along with the Python code implementation:</p>
<ol type="1">
<li><strong>Parse the FASTA input to extract the two protein sequences</strong>.</li>
<li><strong>Set up the BLOSUM62 scoring matrix</strong>.</li>
<li><strong>Implement the Needleman-Wunsch algorithm</strong> to compute the alignment score using the given scoring matrix and gap penalty.</li>
</ol>
<div class="sourceCode" id="cb207"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_string):</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Parses a FASTA format string and returns the sequences in a list.'''</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> []</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sequence:</span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(sequence))</span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>                sequence <span class="op">=</span> []</span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>            sequence.append(line.strip())</span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sequence:</span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(sequence))</span>
<span id="cb207-14"><a href="#cb207-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb207-15"><a href="#cb207-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-16"><a href="#cb207-16" aria-hidden="true" tabindex="-1"></a><span class="co"># BLOSUM62 matrix</span></span>
<span id="cb207-17"><a href="#cb207-17" aria-hidden="true" tabindex="-1"></a>blosum62_str <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb207-18"><a href="#cb207-18" aria-hidden="true" tabindex="-1"></a><span class="st">A  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y</span></span>
<span id="cb207-19"><a href="#cb207-19" aria-hidden="true" tabindex="-1"></a><span class="st">A  4  0 -2 -1 -2  0 -2 -1 -1 -1 -1 -2 -1 -1 -1  1  0  0 -3 -2</span></span>
<span id="cb207-20"><a href="#cb207-20" aria-hidden="true" tabindex="-1"></a><span class="st">C  0  9 -3 -4 -2 -3 -3 -1 -3 -1 -1 -3 -3 -3 -3 -1 -1 -1 -2 -2</span></span>
<span id="cb207-21"><a href="#cb207-21" aria-hidden="true" tabindex="-1"></a><span class="st">D -2 -3  6  2 -3 -1 -1 -3 -1 -4 -3  1 -1  0 -2  0 -1 -3 -4 -3</span></span>
<span id="cb207-22"><a href="#cb207-22" aria-hidden="true" tabindex="-1"></a><span class="st">E -1 -4  2  5 -3 -2  0 -3  1 -2 -2  0 -1  2  0  0 -1 -2 -3 -2</span></span>
<span id="cb207-23"><a href="#cb207-23" aria-hidden="true" tabindex="-1"></a><span class="st">F -2 -2 -3 -3  6 -3 -1  0 -3  0  0 -3 -4 -3 -3 -2 -2 -1  1  3</span></span>
<span id="cb207-24"><a href="#cb207-24" aria-hidden="true" tabindex="-1"></a><span class="st">G  0 -3 -1 -2 -3  6 -2 -4 -2 -4 -3  0 -2 -2 -3  0 -2 -3 -2 -3</span></span>
<span id="cb207-25"><a href="#cb207-25" aria-hidden="true" tabindex="-1"></a><span class="st">H -2 -3 -1  0 -1 -2  8 -3 -1 -3 -2  1 -2  0  0 -1 -2 -3 -2  2</span></span>
<span id="cb207-26"><a href="#cb207-26" aria-hidden="true" tabindex="-1"></a><span class="st">I -1 -1 -3 -3  0 -4 -3  4 -3  2  1 -3 -3 -3 -3 -2 -1  3 -3 -1</span></span>
<span id="cb207-27"><a href="#cb207-27" aria-hidden="true" tabindex="-1"></a><span class="st">K -1 -3 -1  1 -3 -2 -1 -3  5 -2 -1  0 -1  1  2  0 -1 -2 -3 -2</span></span>
<span id="cb207-28"><a href="#cb207-28" aria-hidden="true" tabindex="-1"></a><span class="st">L -1 -1 -4 -2  0 -4 -3  2 -2  4  2 -3 -3 -2 -2 -2 -1  1 -2 -1</span></span>
<span id="cb207-29"><a href="#cb207-29" aria-hidden="true" tabindex="-1"></a><span class="st">M -1 -1 -3 -2  0 -3 -2  1 -1  2  5 -2 -2  0 -1 -1 -1  1 -1 -1</span></span>
<span id="cb207-30"><a href="#cb207-30" aria-hidden="true" tabindex="-1"></a><span class="st">N -2 -3  1  0 -3  0  1 -3  0 -3 -2  6 -2  0  0  1  0 -3 -4 -2</span></span>
<span id="cb207-31"><a href="#cb207-31" aria-hidden="true" tabindex="-1"></a><span class="st">P -1 -3 -1 -1 -4 -2 -2 -3 -1 -3 -2 -2  7 -1 -2 -1 -1 -3 -4 -3</span></span>
<span id="cb207-32"><a href="#cb207-32" aria-hidden="true" tabindex="-1"></a><span class="st">Q -1 -3  0  2 -3 -2  0 -3  1 -2  0  0 -1  5  1  0 -1 -2 -2 -1</span></span>
<span id="cb207-33"><a href="#cb207-33" aria-hidden="true" tabindex="-1"></a><span class="st">R -1 -3 -2  0 -3 -3  0 -3  2 -2 -1  0 -2  1  5 -1 -1 -3 -3 -2</span></span>
<span id="cb207-34"><a href="#cb207-34" aria-hidden="true" tabindex="-1"></a><span class="st">S  1 -1  0  0 -2  0 -1 -2  0 -2 -1  1 -1  0 -1  4  1 -2 -3 -2</span></span>
<span id="cb207-35"><a href="#cb207-35" aria-hidden="true" tabindex="-1"></a><span class="st">T  0 -1 -1 -1 -2 -2 -2 -1 -1 -1 -1  0 -1 -1 -1  1  5  0 -2 -2</span></span>
<span id="cb207-36"><a href="#cb207-36" aria-hidden="true" tabindex="-1"></a><span class="st">V  0 -1 -3 -2 -1 -3 -3  3 -2  1  1 -3 -3 -2 -3 -2  0  4 -3 -1</span></span>
<span id="cb207-37"><a href="#cb207-37" aria-hidden="true" tabindex="-1"></a><span class="st">W -3 -2 -4 -3  1 -2 -2 -3 -3 -2 -1 -4 -4 -2 -3 -3 -2 -3 11  2</span></span>
<span id="cb207-38"><a href="#cb207-38" aria-hidden="true" tabindex="-1"></a><span class="st">Y -2 -2 -3 -2  3 -3  2 -1 -2 -1 -1 -2 -3 -1 -2 -2 -2 -1  2  7</span></span>
<span id="cb207-39"><a href="#cb207-39" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb207-40"><a href="#cb207-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-41"><a href="#cb207-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_blosum62(matrix_str):</span>
<span id="cb207-42"><a href="#cb207-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse the BLOSUM62 matrix from a string."""</span></span>
<span id="cb207-43"><a href="#cb207-43" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> matrix_str.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb207-44"><a href="#cb207-44" aria-hidden="true" tabindex="-1"></a>    headers <span class="op">=</span> lines[<span class="dv">0</span>].split()</span>
<span id="cb207-45"><a href="#cb207-45" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> {}</span>
<span id="cb207-46"><a href="#cb207-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines[<span class="dv">1</span>:]:</span>
<span id="cb207-47"><a href="#cb207-47" aria-hidden="true" tabindex="-1"></a>        values <span class="op">=</span> line.split()</span>
<span id="cb207-48"><a href="#cb207-48" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> values[<span class="dv">0</span>]</span>
<span id="cb207-49"><a href="#cb207-49" aria-hidden="true" tabindex="-1"></a>        scores <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, values[<span class="dv">1</span>:]))</span>
<span id="cb207-50"><a href="#cb207-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, score <span class="kw">in</span> <span class="bu">zip</span>(headers, scores):</span>
<span id="cb207-51"><a href="#cb207-51" aria-hidden="true" tabindex="-1"></a>            matrix[(row, col)] <span class="op">=</span> score</span>
<span id="cb207-52"><a href="#cb207-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb207-53"><a href="#cb207-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-54"><a href="#cb207-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> needleman_wunsch(s, t, blosum62, gap_penalty):</span>
<span id="cb207-55"><a href="#cb207-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Perform the Needleman-Wunsch algorithm for global alignment."""</span></span>
<span id="cb207-56"><a href="#cb207-56" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb207-57"><a href="#cb207-57" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb207-58"><a href="#cb207-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-59"><a href="#cb207-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize dp table with gap penalties</span></span>
<span id="cb207-60"><a href="#cb207-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb207-61"><a href="#cb207-61" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> gap_penalty</span>
<span id="cb207-62"><a href="#cb207-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb207-63"><a href="#cb207-63" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> gap_penalty</span>
<span id="cb207-64"><a href="#cb207-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-65"><a href="#cb207-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table</span></span>
<span id="cb207-66"><a href="#cb207-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb207-67"><a href="#cb207-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb207-68"><a href="#cb207-68" aria-hidden="true" tabindex="-1"></a>            match <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> blosum62[(s[i <span class="op">-</span> <span class="dv">1</span>], t[j <span class="op">-</span> <span class="dv">1</span>])]</span>
<span id="cb207-69"><a href="#cb207-69" aria-hidden="true" tabindex="-1"></a>            delete <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> gap_penalty</span>
<span id="cb207-70"><a href="#cb207-70" aria-hidden="true" tabindex="-1"></a>            insert <span class="op">=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> gap_penalty</span>
<span id="cb207-71"><a href="#cb207-71" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(match, delete, insert)</span>
<span id="cb207-72"><a href="#cb207-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-73"><a href="#cb207-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb207-74"><a href="#cb207-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-75"><a href="#cb207-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset in FASTA format</span></span>
<span id="cb207-76"><a href="#cb207-76" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb207-77"><a href="#cb207-77" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_67</span></span>
<span id="cb207-78"><a href="#cb207-78" aria-hidden="true" tabindex="-1"></a><span class="st">PLEASANTLY</span></span>
<span id="cb207-79"><a href="#cb207-79" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_17</span></span>
<span id="cb207-80"><a href="#cb207-80" aria-hidden="true" tabindex="-1"></a><span class="st">MEANLY</span></span>
<span id="cb207-81"><a href="#cb207-81" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb207-82"><a href="#cb207-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-83"><a href="#cb207-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the FASTA input to get the sequences</span></span>
<span id="cb207-84"><a href="#cb207-84" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb207-85"><a href="#cb207-85" aria-hidden="true" tabindex="-1"></a>s, t <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb207-86"><a href="#cb207-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-87"><a href="#cb207-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the BLOSUM62 matrix</span></span>
<span id="cb207-88"><a href="#cb207-88" aria-hidden="true" tabindex="-1"></a>blosum62 <span class="op">=</span> parse_blosum62(blosum62_str)</span>
<span id="cb207-89"><a href="#cb207-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-90"><a href="#cb207-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the gap penalty</span></span>
<span id="cb207-91"><a href="#cb207-91" aria-hidden="true" tabindex="-1"></a>gap_penalty <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb207-92"><a href="#cb207-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-93"><a href="#cb207-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the maximum alignment score using Needleman-Wunsch algorithm</span></span>
<span id="cb207-94"><a href="#cb207-94" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> needleman_wunsch(s, t, blosum62, gap_penalty)</span>
<span id="cb207-95"><a href="#cb207-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-96"><a href="#cb207-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb207-97"><a href="#cb207-97" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-11" class="level2" data-number="69.4">
<h2 data-number="69.4" class="anchored" data-anchor-id="explanation-of-the-code-11"><span class="header-section-number">69.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Parsing FASTA Input</strong>:
<ul>
<li><code>parse_fasta</code> function reads the input in FASTA format and returns the sequences in a list.</li>
</ul></li>
<li><strong>BLOSUM62 Scoring Matrix</strong>:
<ul>
<li><code>parse_blosum62</code> function parses the BLOSUM62 matrix string and stores the scores in a dictionary for easy lookup.</li>
</ul></li>
<li><strong>Needleman-Wunsch Algorithm</strong>:
<ul>
<li><code>needleman_wunsch</code> function implements the dynamic programming algorithm to compute the global alignment score.</li>
<li>The <code>dp</code> table is initialized with gap penalties.</li>
<li>The table is filled based on the scores for matches, insertions, and deletions.</li>
<li>The final alignment score is found in <code>dp[m][n]</code>.</li>
</ul></li>
<li><strong>Execution</strong>:
<ul>
<li>The sequences are parsed, the scoring matrix is loaded, and the alignment score is computed using the Needleman-Wunsch algorithm.</li>
<li>The result is printed as the maximum alignment score.</li>
</ul></li>
</ol>
<p>This implementation ensures the alignment score is computed efficiently even for long protein sequences, utilizing the scoring matrix and gap penalties correctly.</p>
</section>
</section>
<section id="genome-assembly-with-perfect-coverage" class="level1" data-number="70">
<h1 data-number="70"><span class="header-section-number">70</span> Genome Assembly with Perfect Coverage</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/circular-string/">circular string</a>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/string/">string</a>&nbsp;that does not have an initial or terminal element; instead, the string is viewed as a necklace of symbols. We can represent a circular string as a string enclosed in parentheses. For example, consider the circular DNA string (ACGTAC), and note that because the string “wraps around” at the end, this circular string can equally be represented by (CGTACA), (GTACAC), (TACACG), (ACACGT), and (CACGTA). The definitions of substrings and superstrings are easy to generalize to the case of circular strings (keeping in mind that substrings are allowed to wrap around).</p>
<p>Given:&nbsp;A collection of (error-free)&nbsp;<a href="https://rosalind.info/glossary/dna/">DNA</a>&nbsp;<span class="math inline">\(k\)</span>-mers (<span class="math inline">\(k≤50\)</span>) taken from the same strand of a circular chromosome. In this dataset, all&nbsp;<span class="math inline">\(k\)</span>-mers from this strand of the chromosome are present, and their&nbsp;<a href="https://rosalind.info/glossary/de-bruijn-graph/">de Bruijn graph</a>&nbsp;consists of exactly one&nbsp;<a href="https://rosalind.info/glossary/simple-cycle/">simple cycle</a>.</p>
<p>Return:&nbsp;A cyclic superstring of minimal length containing the reads (thus corresponding to a candidate cyclic chromosome).</p>
<section id="sample-dataset-69" class="level2" data-number="70.1">
<h2 data-number="70.1" class="anchored" data-anchor-id="sample-dataset-69"><span class="header-section-number">70.1</span> Sample Dataset</h2>
<pre><code>ATTAC
TACAG
GATTA
ACAGA
CAGAT
TTACA
AGATT</code></pre>
</section>
<section id="sample-output-70" class="level2" data-number="70.2">
<h2 data-number="70.2" class="anchored" data-anchor-id="sample-output-70"><span class="header-section-number">70.2</span> Sample Output</h2>
<pre><code>ATTACAG</code></pre>
</section>
<section id="solution-66" class="level2" data-number="70.3">
<h2 data-number="70.3" class="anchored" data-anchor-id="solution-66"><span class="header-section-number">70.3</span> Solution</h2>
<div class="sourceCode" id="cb210"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_coverings(current_string, edges, k):</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate all possible complete cycle coverings from the given edges.</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - current_string: The current string being formed as part of the cycle.</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - edges: Remaining edges in the De Bruijn graph to be used.</span></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a><span class="co">    - k: Length of the k-mers.</span></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - A list of possible cycle coverings as strings.</span></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the indices of edges that can be added next based on the current string.</span></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a>    next_edges_indices <span class="op">=</span> [i <span class="cf">for</span> i, edge <span class="kw">in</span> <span class="bu">enumerate</span>(edges) <span class="cf">if</span> edge[<span class="dv">0</span>] <span class="op">==</span> current_string[<span class="op">-</span>k<span class="op">+</span><span class="dv">1</span>:]]</span>
<span id="cb210-15"><a href="#cb210-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-16"><a href="#cb210-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If no more edges can be added:</span></span>
<span id="cb210-17"><a href="#cb210-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> next_edges_indices:</span>
<span id="cb210-18"><a href="#cb210-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return the current string if all edges have been used (perfect covering).</span></span>
<span id="cb210-19"><a href="#cb210-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [current_string] <span class="cf">if</span> <span class="kw">not</span> edges <span class="cf">else</span> []</span>
<span id="cb210-20"><a href="#cb210-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-21"><a href="#cb210-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, recursively generate coverings with each possible next edge.</span></span>
<span id="cb210-22"><a href="#cb210-22" aria-hidden="true" tabindex="-1"></a>    possible_coverings <span class="op">=</span> []</span>
<span id="cb210-23"><a href="#cb210-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> next_edges_indices:</span>
<span id="cb210-24"><a href="#cb210-24" aria-hidden="true" tabindex="-1"></a>        next_string <span class="op">=</span> current_string <span class="op">+</span> edges[i][<span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb210-25"><a href="#cb210-25" aria-hidden="true" tabindex="-1"></a>        remaining_edges <span class="op">=</span> edges[:i] <span class="op">+</span> edges[i<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb210-26"><a href="#cb210-26" aria-hidden="true" tabindex="-1"></a>        possible_coverings.append(generate_coverings(next_string, remaining_edges, k))</span>
<span id="cb210-27"><a href="#cb210-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-28"><a href="#cb210-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> possible_coverings</span>
<span id="cb210-29"><a href="#cb210-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-30"><a href="#cb210-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flatten(nested_list):</span>
<span id="cb210-31"><a href="#cb210-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb210-32"><a href="#cb210-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Flattens a nested list into a single list.</span></span>
<span id="cb210-33"><a href="#cb210-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-34"><a href="#cb210-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb210-35"><a href="#cb210-35" aria-hidden="true" tabindex="-1"></a><span class="co">    - nested_list: A list that may contain other nested lists.</span></span>
<span id="cb210-36"><a href="#cb210-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-37"><a href="#cb210-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Yields:</span></span>
<span id="cb210-38"><a href="#cb210-38" aria-hidden="true" tabindex="-1"></a><span class="co">    - Individual elements from the nested list, flattened.</span></span>
<span id="cb210-39"><a href="#cb210-39" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb210-40"><a href="#cb210-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> nested_list:</span>
<span id="cb210-41"><a href="#cb210-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>):</span>
<span id="cb210-42"><a href="#cb210-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> flatten(item)</span>
<span id="cb210-43"><a href="#cb210-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb210-44"><a href="#cb210-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> item</span>
<span id="cb210-45"><a href="#cb210-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-46"><a href="#cb210-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input data</span></span>
<span id="cb210-47"><a href="#cb210-47" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb210-48"><a href="#cb210-48" aria-hidden="true" tabindex="-1"></a><span class="st">ATTAC</span></span>
<span id="cb210-49"><a href="#cb210-49" aria-hidden="true" tabindex="-1"></a><span class="st">TACAG</span></span>
<span id="cb210-50"><a href="#cb210-50" aria-hidden="true" tabindex="-1"></a><span class="st">GATTA</span></span>
<span id="cb210-51"><a href="#cb210-51" aria-hidden="true" tabindex="-1"></a><span class="st">ACAGA</span></span>
<span id="cb210-52"><a href="#cb210-52" aria-hidden="true" tabindex="-1"></a><span class="st">CAGAT</span></span>
<span id="cb210-53"><a href="#cb210-53" aria-hidden="true" tabindex="-1"></a><span class="st">TTACA</span></span>
<span id="cb210-54"><a href="#cb210-54" aria-hidden="true" tabindex="-1"></a><span class="st">AGATT"""</span></span>
<span id="cb210-55"><a href="#cb210-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-56"><a href="#cb210-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Split input into k-mers</span></span>
<span id="cb210-57"><a href="#cb210-57" aria-hidden="true" tabindex="-1"></a>k_mers <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb210-58"><a href="#cb210-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-59"><a href="#cb210-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Create edges of the De Bruijn graph from the k-mers</span></span>
<span id="cb210-60"><a href="#cb210-60" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="bu">len</span>(k_mers[<span class="dv">0</span>])</span>
<span id="cb210-61"><a href="#cb210-61" aria-hidden="true" tabindex="-1"></a>create_edge <span class="op">=</span> <span class="kw">lambda</span> k_mer: [k_mer[:k<span class="op">-</span><span class="dv">1</span>], k_mer[<span class="dv">1</span>:]]</span>
<span id="cb210-62"><a href="#cb210-62" aria-hidden="true" tabindex="-1"></a>de_bruijn_edges <span class="op">=</span> [create_edge(k_mer) <span class="cf">for</span> k_mer <span class="kw">in</span> k_mers[<span class="dv">1</span>:]]</span>
<span id="cb210-63"><a href="#cb210-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-64"><a href="#cb210-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate all possible circular strings</span></span>
<span id="cb210-65"><a href="#cb210-65" aria-hidden="true" tabindex="-1"></a>circular_strings <span class="op">=</span> <span class="bu">set</span>(flatten(generate_coverings(k_mers[<span class="dv">0</span>], de_bruijn_edges, k)))</span>
<span id="cb210-66"><a href="#cb210-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-67"><a href="#cb210-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Trim each circular string to the appropriate length (number of k-mers)</span></span>
<span id="cb210-68"><a href="#cb210-68" aria-hidden="true" tabindex="-1"></a>circular_strings <span class="op">=</span> [cycle[:<span class="bu">len</span>(k_mers)] <span class="cf">for</span> cycle <span class="kw">in</span> circular_strings]</span>
<span id="cb210-69"><a href="#cb210-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-70"><a href="#cb210-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the resulting circular strings</span></span>
<span id="cb210-71"><a href="#cb210-71" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(circular_strings))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-12" class="level2" data-number="70.4">
<h2 data-number="70.4" class="anchored" data-anchor-id="explanation-of-the-code-12"><span class="header-section-number">70.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>generate_coverings Function</strong>:
<ul>
<li><strong>Purpose</strong>: This function recursively generates all possible cycle coverings (i.e., circular strings) by extending the current string with valid edges from the De Bruijn graph.</li>
<li><strong>How it works</strong>:
<ul>
<li>It looks for edges that can be appended to the current string (based on the last <span class="math inline">\(k-1\)</span> characters of the string).</li>
<li>If no valid edges are left, it checks if all edges have been used (indicating a perfect covering). If so, it returns the current string.</li>
<li>If there are valid edges, it recursively tries to extend the string with each possible edge and collects all possible coverings.</li>
</ul></li>
</ul></li>
<li><strong>flatten Function</strong>:
<ul>
<li><strong>Purpose</strong>: This helper function is used to flatten a nested list into a single-level list.</li>
<li><strong>How it works</strong>: It recursively traverses the nested list and yields individual elements, effectively flattening the list.</li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li><strong>k_mers</strong>: The input strings are split into individual <span class="math inline">\(k\)</span>-mers.</li>
<li><strong>de_bruijn_edges</strong>: This creates the edges of the De Bruijn graph. Each <span class="math inline">\(k\)</span>-mer is split into its prefix and suffix of length <span class="math inline">\(k-1\)</span>.</li>
<li><strong>generate_coverings</strong>: This function is called with the first <span class="math inline">\(k\)</span>-mer as the starting point, and it generates all possible circular strings by finding all Eulerian cycles in the graph.</li>
<li><strong>circular_strings</strong>: The resulting strings are then trimmed to the length of the input (number of <span class="math inline">\(k\)</span>-mers) to ensure that only the desired cyclic superstrings are printed.</li>
</ul></li>
</ol>
</section>
</section>
<section id="matching-a-spectrum-to-a-protein" class="level1" data-number="71">
<h1 data-number="71"><span class="header-section-number">71</span> Matching a Spectrum to a Protein</h1>
<p>The&nbsp;<a href="https://rosalind.info/glossary/complete-spectrum/">complete spectrum</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/weighted-string/">weighted string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;is the&nbsp;<a href="https://rosalind.info/glossary/multiset/">multiset</a>&nbsp;<span class="math inline">\(S[s]\)</span>&nbsp;containing the&nbsp;<a href="https://rosalind.info/glossary/string-weight/">weights</a>&nbsp;of every&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefix</a>&nbsp;and&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;followed by a collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s_1\)</span>,&nbsp;<span class="math inline">\(s_2\)</span>, <span class="math inline">\(...\)</span>,&nbsp;<span class="math inline">\(s_n\)</span>&nbsp;and a multiset&nbsp;<span class="math inline">\(R\)</span>&nbsp;of positive numbers (corresponding to the complete spectrum of some unknown protein string).</p>
<p>Return:&nbsp;The maximum&nbsp;<a href="https://rosalind.info/glossary/multiplicity/">multiplicity</a>&nbsp;of&nbsp;<span class="math inline">\(R⊖S[s_k]\)</span>&nbsp;taken over all strings&nbsp;<span class="math inline">\(s_k\)</span>, followed by the string&nbsp;<span class="math inline">\(s_k\)</span>&nbsp;for which this maximum multiplicity occurs (you may output any such value if multiple solutions exist).</p>
<section id="sample-dataset-70" class="level2" data-number="71.1">
<h2 data-number="71.1" class="anchored" data-anchor-id="sample-dataset-70"><span class="header-section-number">71.1</span> Sample Dataset</h2>
<pre><code>4
GSDMQS
VWICN
IASWMQS
PVSMGAD
445.17838
115.02694
186.07931
314.13789
317.1198
215.09061</code></pre>
</section>
<section id="sample-output-71" class="level2" data-number="71.2">
<h2 data-number="71.2" class="anchored" data-anchor-id="sample-output-71"><span class="header-section-number">71.2</span> Sample Output</h2>
<pre><code>3
IASWMQS</code></pre>
</section>
<section id="solution-67" class="level2" data-number="71.3">
<h2 data-number="71.3" class="anchored" data-anchor-id="solution-67"><span class="header-section-number">71.3</span> Solution</h2>
<div class="sourceCode" id="cb213"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> decimal <span class="im">import</span> Decimal</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_protein_weights():</span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Returns a dictionary mapping amino acids to their weights."""</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'G'</span>: Decimal(<span class="st">'57.02146'</span>), <span class="st">'A'</span>: Decimal(<span class="st">'71.03711'</span>), <span class="st">'S'</span>: Decimal(<span class="st">'87.03203'</span>), </span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'P'</span>: Decimal(<span class="st">'97.05276'</span>), <span class="st">'V'</span>: Decimal(<span class="st">'99.06841'</span>), <span class="st">'T'</span>: Decimal(<span class="st">'101.04768'</span>), </span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">'C'</span>: Decimal(<span class="st">'103.00919'</span>), <span class="st">'I'</span>: Decimal(<span class="st">'113.08406'</span>), <span class="st">'L'</span>: Decimal(<span class="st">'113.08406'</span>), </span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">'N'</span>: Decimal(<span class="st">'114.04293'</span>), <span class="st">'D'</span>: Decimal(<span class="st">'115.02694'</span>), <span class="st">'Q'</span>: Decimal(<span class="st">'128.05858'</span>), </span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'K'</span>: Decimal(<span class="st">'128.09496'</span>), <span class="st">'E'</span>: Decimal(<span class="st">'129.04259'</span>), <span class="st">'M'</span>: Decimal(<span class="st">'131.04049'</span>), </span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'H'</span>: Decimal(<span class="st">'137.05891'</span>), <span class="st">'F'</span>: Decimal(<span class="st">'147.06841'</span>), <span class="st">'R'</span>: Decimal(<span class="st">'156.10111'</span>), </span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Y'</span>: Decimal(<span class="st">'163.06333'</span>), <span class="st">'W'</span>: Decimal(<span class="st">'186.07931'</span>)</span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_weight(protein_sequence):</span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculates the total weight of a given protein sequence based on amino acid weights."""</span></span>
<span id="cb213-18"><a href="#cb213-18" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> get_protein_weights()</span>
<span id="cb213-19"><a href="#cb213-19" aria-hidden="true" tabindex="-1"></a>    total_weight <span class="op">=</span> Decimal(<span class="st">'0.0'</span>)</span>
<span id="cb213-20"><a href="#cb213-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> amino_acid <span class="kw">in</span> protein_sequence:</span>
<span id="cb213-21"><a href="#cb213-21" aria-hidden="true" tabindex="-1"></a>        total_weight <span class="op">+=</span> weights[amino_acid]</span>
<span id="cb213-22"><a href="#cb213-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_weight</span>
<span id="cb213-23"><a href="#cb213-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-24"><a href="#cb213-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_multiplicity(proteins, spectrum_weights):</span>
<span id="cb213-25"><a href="#cb213-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb213-26"><a href="#cb213-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the maximum multiplicity of spectrum weights for each protein</span></span>
<span id="cb213-27"><a href="#cb213-27" aria-hidden="true" tabindex="-1"></a><span class="co">    and identifies the protein with the highest multiplicity.</span></span>
<span id="cb213-28"><a href="#cb213-28" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb213-29"><a href="#cb213-29" aria-hidden="true" tabindex="-1"></a>    max_multiplicity <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb213-30"><a href="#cb213-30" aria-hidden="true" tabindex="-1"></a>    best_protein <span class="op">=</span> <span class="va">None</span></span>
<span id="cb213-31"><a href="#cb213-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb213-32"><a href="#cb213-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> protein <span class="kw">in</span> proteins:</span>
<span id="cb213-33"><a href="#cb213-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute the spectrum weights for all prefixes and suffixes of the protein</span></span>
<span id="cb213-34"><a href="#cb213-34" aria-hidden="true" tabindex="-1"></a>        spectrum <span class="op">=</span> []</span>
<span id="cb213-35"><a href="#cb213-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(protein) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb213-36"><a href="#cb213-36" aria-hidden="true" tabindex="-1"></a>            spectrum.append(calculate_weight(protein[:i]))</span>
<span id="cb213-37"><a href="#cb213-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(protein)):</span>
<span id="cb213-38"><a href="#cb213-38" aria-hidden="true" tabindex="-1"></a>            spectrum.append(calculate_weight(protein[i:]))</span>
<span id="cb213-39"><a href="#cb213-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb213-40"><a href="#cb213-40" aria-hidden="true" tabindex="-1"></a>        spectrum_weights_count <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb213-41"><a href="#cb213-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb213-42"><a href="#cb213-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count the differences between the spectrum weights and given weights</span></span>
<span id="cb213-43"><a href="#cb213-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> protein_weight <span class="kw">in</span> spectrum:</span>
<span id="cb213-44"><a href="#cb213-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> given_weight <span class="kw">in</span> spectrum_weights:</span>
<span id="cb213-45"><a href="#cb213-45" aria-hidden="true" tabindex="-1"></a>                diff <span class="op">=</span> <span class="bu">round</span>(protein_weight <span class="op">-</span> given_weight, <span class="dv">3</span>)</span>
<span id="cb213-46"><a href="#cb213-46" aria-hidden="true" tabindex="-1"></a>                spectrum_weights_count[diff] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb213-47"><a href="#cb213-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb213-48"><a href="#cb213-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Determine the maximum multiplicity for the current protein</span></span>
<span id="cb213-49"><a href="#cb213-49" aria-hidden="true" tabindex="-1"></a>        current_multiplicity <span class="op">=</span> <span class="bu">max</span>(spectrum_weights_count.values(), default<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb213-50"><a href="#cb213-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb213-51"><a href="#cb213-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_multiplicity <span class="op">&gt;</span> max_multiplicity:</span>
<span id="cb213-52"><a href="#cb213-52" aria-hidden="true" tabindex="-1"></a>            max_multiplicity <span class="op">=</span> current_multiplicity</span>
<span id="cb213-53"><a href="#cb213-53" aria-hidden="true" tabindex="-1"></a>            best_protein <span class="op">=</span> protein</span>
<span id="cb213-54"><a href="#cb213-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb213-55"><a href="#cb213-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_multiplicity, best_protein</span>
<span id="cb213-56"><a href="#cb213-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-57"><a href="#cb213-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input (for demonstration purposes)</span></span>
<span id="cb213-58"><a href="#cb213-58" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb213-59"><a href="#cb213-59" aria-hidden="true" tabindex="-1"></a><span class="st">4</span></span>
<span id="cb213-60"><a href="#cb213-60" aria-hidden="true" tabindex="-1"></a><span class="st">GSDMQS</span></span>
<span id="cb213-61"><a href="#cb213-61" aria-hidden="true" tabindex="-1"></a><span class="st">VWICN</span></span>
<span id="cb213-62"><a href="#cb213-62" aria-hidden="true" tabindex="-1"></a><span class="st">IASWMQS</span></span>
<span id="cb213-63"><a href="#cb213-63" aria-hidden="true" tabindex="-1"></a><span class="st">PVSMGAD</span></span>
<span id="cb213-64"><a href="#cb213-64" aria-hidden="true" tabindex="-1"></a><span class="st">445.17838</span></span>
<span id="cb213-65"><a href="#cb213-65" aria-hidden="true" tabindex="-1"></a><span class="st">115.02694</span></span>
<span id="cb213-66"><a href="#cb213-66" aria-hidden="true" tabindex="-1"></a><span class="st">186.07931</span></span>
<span id="cb213-67"><a href="#cb213-67" aria-hidden="true" tabindex="-1"></a><span class="st">314.13789</span></span>
<span id="cb213-68"><a href="#cb213-68" aria-hidden="true" tabindex="-1"></a><span class="st">317.1198</span></span>
<span id="cb213-69"><a href="#cb213-69" aria-hidden="true" tabindex="-1"></a><span class="st">215.09061</span></span>
<span id="cb213-70"><a href="#cb213-70" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb213-71"><a href="#cb213-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-72"><a href="#cb213-72" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the input</span></span>
<span id="cb213-73"><a href="#cb213-73" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb213-74"><a href="#cb213-74" aria-hidden="true" tabindex="-1"></a>number_of_proteins <span class="op">=</span> <span class="bu">int</span>(lines[<span class="dv">0</span>])</span>
<span id="cb213-75"><a href="#cb213-75" aria-hidden="true" tabindex="-1"></a>protein_sequences <span class="op">=</span> lines[<span class="dv">1</span>:number_of_proteins <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb213-76"><a href="#cb213-76" aria-hidden="true" tabindex="-1"></a>spectrum_weights <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">map</span>(Decimal, lines[number_of_proteins <span class="op">+</span> <span class="dv">1</span>:]))</span>
<span id="cb213-77"><a href="#cb213-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-78"><a href="#cb213-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the maximum multiplicity and the corresponding protein</span></span>
<span id="cb213-79"><a href="#cb213-79" aria-hidden="true" tabindex="-1"></a>max_multiplicity, best_protein <span class="op">=</span> calculate_multiplicity(protein_sequences, spectrum_weights)</span>
<span id="cb213-80"><a href="#cb213-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-81"><a href="#cb213-81" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb213-82"><a href="#cb213-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_multiplicity)</span>
<span id="cb213-83"><a href="#cb213-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(best_protein)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-13" class="level2" data-number="71.4">
<h2 data-number="71.4" class="anchored" data-anchor-id="explanation-of-the-code-13"><span class="header-section-number">71.4</span> Explanation of the Code</h2>
<ol type="1">
<li><p><strong><code>get_protein_weights()</code></strong>: Returns a dictionary mapping each amino acid to its corresponding weight using the <code>Decimal</code> type for precision.</p></li>
<li><p><strong><code>calculate_weight(protein_sequence)</code></strong>: Computes the total weight of a protein sequence by summing the weights of its amino acids.</p></li>
<li><p><strong><code>calculate_multiplicity(proteins, spectrum_weights)</code></strong>:</p>
<ul>
<li>Iterates through each protein sequence to compute the weights of all possible prefixes and suffixes.</li>
<li>Uses a <code>defaultdict</code> to count how often the difference between each protein weight and given spectrum weight appears.</li>
<li>Finds and returns the protein with the highest multiplicity of such differences.</li>
</ul></li>
<li><p><strong>Input Parsing</strong>:</p>
<ul>
<li>Reads and parses the sample input to extract the number of proteins, the list of protein sequences, and the list of spectrum weights.</li>
</ul></li>
<li><p><strong>Results</strong>:</p>
<ul>
<li>Calls <code>calculate_multiplicity</code> to get the protein with the maximum multiplicity and prints the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="quartets" class="level1" data-number="72">
<h1 data-number="72"><span class="header-section-number">72</span> Quartets</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/partial-split/">partial split</a>&nbsp;of a set&nbsp;<span class="math inline">\(S\)</span>&nbsp;of&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa models a partial character and is denoted by&nbsp;<span class="math inline">\(A∣B\)</span>, where&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>&nbsp;are still the two&nbsp;<a href="https://rosalind.info/glossary/disjoint-sets/">disjoint</a>&nbsp;<a href="https://rosalind.info/glossary/subset/">subsets</a>&nbsp;of taxa divided by the character. Unlike in the case of splits, we do not necessarily require that&nbsp;<span class="math inline">\(A∪B=S\)</span>;&nbsp;<span class="math inline">\((A∪B)c\)</span>&nbsp;corresponds to those taxa for which we lack conclusive evidence regarding the character.</p>
<p>We can assemble a collection of partial characters into a generalized&nbsp;<a href="https://rosalind.info/glossary/partial-character-table/">partial character table</a>&nbsp;<span class="math inline">\(C\)</span>&nbsp;in which the symbol&nbsp;<span class="math inline">\(x\)</span>&nbsp;is placed in&nbsp;<span class="math inline">\(C_{i,j}\)</span>&nbsp;if we do not have conclusive evidence regarding the&nbsp;<span class="math inline">\(j\)</span>th taxon with respect to the&nbsp;<span class="math inline">\(i\)</span>th partial character.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/quartet/">quartet</a>&nbsp;is a partial split&nbsp;<span class="math inline">\(A∣B\)</span> in which both&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>&nbsp;contain precisely two elements. For the sake of simplicity, we often will consider quartets instead of partial characters. We say that a quartet&nbsp;<span class="math inline">\(A∣B\)</span>&nbsp;is inferred from a partial split&nbsp;<span class="math inline">\(C∣D\)</span>&nbsp;if&nbsp;<span class="math inline">\(A⊆C\)</span>&nbsp;and&nbsp;<span class="math inline">\(B⊆D\)</span>&nbsp;(or equivalently&nbsp;<span class="math inline">\(A⊆D\)</span> and&nbsp;<span class="math inline">\(B⊆C\)</span>. For example,&nbsp;<span class="math inline">\({1,3}∣{2,4}\)</span>&nbsp;and&nbsp;<span class="math inline">\({3,5}∣{2,4}\)</span>&nbsp;can be inferred from&nbsp;<span class="math inline">\({1,3,5}∣{2,4}\)</span>.</p>
<p>Given:&nbsp;A partial character table&nbsp;<span class="math inline">\(C\)</span>.</p>
<p>Return:&nbsp;The collection of all quartets that can be inferred from the splits corresponding to the underlying characters of&nbsp;<span class="math inline">\(C\)</span>.</p>
<section id="sample-dataset-71" class="level2" data-number="72.1">
<h2 data-number="72.1" class="anchored" data-anchor-id="sample-dataset-71"><span class="header-section-number">72.1</span> Sample Dataset</h2>
<pre><code>cat dog elephant ostrich mouse rabbit robot
01xxx00
x11xx00
111x00x</code></pre>
</section>
<section id="sample-output-72" class="level2" data-number="72.2">
<h2 data-number="72.2" class="anchored" data-anchor-id="sample-output-72"><span class="header-section-number">72.2</span> Sample Output</h2>
<pre><code>{cat, dog} {mouse, rabbit}
{dog, elephant} {rabbit, robot}
{cat, elephant} {mouse, rabbit}
{dog, elephant} {mouse, rabbit}</code></pre>
</section>
<section id="solution-68" class="level2" data-number="72.3">
<h2 data-number="72.3" class="anchored" data-anchor-id="solution-68"><span class="header-section-number">72.3</span> Solution</h2>
<div class="sourceCode" id="cb216"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input data</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a><span class="st">cat dog elephant ostrich mouse rabbit robot</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a><span class="st">01xxx00</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="st">x11xx00</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a><span class="st">111x00x</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the input data into lines</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> data.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract taxa (species) from the first line</span></span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a>taxa <span class="op">=</span> lines[<span class="dv">0</span>].strip().split(<span class="st">' '</span>)</span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a set to store unique quartets</span></span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a>unique_quartets <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Proces each line of the partial character table</span></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> lines[<span class="dv">1</span>:]:</span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize lists to hold taxa for two groups</span></span>
<span id="cb216-21"><a href="#cb216-21" aria-hidden="true" tabindex="-1"></a>    group_C <span class="op">=</span> []</span>
<span id="cb216-22"><a href="#cb216-22" aria-hidden="true" tabindex="-1"></a>    group_D <span class="op">=</span> []</span>
<span id="cb216-23"><a href="#cb216-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-24"><a href="#cb216-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Classify taxa based on the partial character table</span></span>
<span id="cb216-25"><a href="#cb216-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(line)):</span>
<span id="cb216-26"><a href="#cb216-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line[i] <span class="op">==</span> <span class="st">'1'</span>:</span>
<span id="cb216-27"><a href="#cb216-27" aria-hidden="true" tabindex="-1"></a>            group_C.append(taxa[i])</span>
<span id="cb216-28"><a href="#cb216-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> line[i] <span class="op">==</span> <span class="st">'0'</span>:</span>
<span id="cb216-29"><a href="#cb216-29" aria-hidden="true" tabindex="-1"></a>            group_D.append(taxa[i])</span>
<span id="cb216-30"><a href="#cb216-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb216-31"><a href="#cb216-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure each group has at least two taxa to form a quartet</span></span>
<span id="cb216-32"><a href="#cb216-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(group_C) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> <span class="bu">len</span>(group_D) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb216-33"><a href="#cb216-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate all possible pairs for group C and group D</span></span>
<span id="cb216-34"><a href="#cb216-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(group_C) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb216-35"><a href="#cb216-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(group_C)):</span>
<span id="cb216-36"><a href="#cb216-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(group_D) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb216-37"><a href="#cb216-37" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(group_D)):</span>
<span id="cb216-38"><a href="#cb216-38" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Form pairs (A, B) from group_C and (C, D) from group_D</span></span>
<span id="cb216-39"><a href="#cb216-39" aria-hidden="true" tabindex="-1"></a>                        pair_A <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>([group_C[i], group_C[j]]))</span>
<span id="cb216-40"><a href="#cb216-40" aria-hidden="true" tabindex="-1"></a>                        pair_B <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>([group_D[k], group_D[l]]))</span>
<span id="cb216-41"><a href="#cb216-41" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb216-42"><a href="#cb216-42" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Add the sorted quartet to the set</span></span>
<span id="cb216-43"><a href="#cb216-43" aria-hidden="true" tabindex="-1"></a>                        sorted_quartet <span class="op">=</span> (pair_A, pair_B) <span class="cf">if</span> pair_A <span class="op">&lt;</span> pair_B <span class="cf">else</span> (pair_B, pair_A)</span>
<span id="cb216-44"><a href="#cb216-44" aria-hidden="true" tabindex="-1"></a>                        unique_quartets.add(sorted_quartet)</span>
<span id="cb216-45"><a href="#cb216-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-46"><a href="#cb216-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Print each unique quartet in the required format</span></span>
<span id="cb216-47"><a href="#cb216-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> quartet <span class="kw">in</span> unique_quartets:</span>
<span id="cb216-48"><a href="#cb216-48" aria-hidden="true" tabindex="-1"></a>    pair_A, pair_B <span class="op">=</span> quartet</span>
<span id="cb216-49"><a href="#cb216-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'</span><span class="sc">{{{}</span><span class="st">, </span><span class="sc">{}}}</span><span class="st"> </span><span class="sc">{{{}</span><span class="st">, </span><span class="sc">{}}}</span><span class="st">'</span>.<span class="bu">format</span>(pair_A[<span class="dv">0</span>], pair_A[<span class="dv">1</span>], pair_B[<span class="dv">0</span>], pair_B[<span class="dv">1</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-14" class="level2" data-number="72.4">
<h2 data-number="72.4" class="anchored" data-anchor-id="explanation-of-the-code-14"><span class="header-section-number">72.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Input Data Handling</strong>:
<ul>
<li><code>data.strip().split("\n")</code>: Split the input data into lines. The first line contains taxa names, and the subsequent lines contain the partial character table.</li>
</ul></li>
<li><strong>Extracting Taxa</strong>:
<ul>
<li><code>taxa = lines[0].strip().split(' ')</code>: The first line is split into individual taxa names.</li>
</ul></li>
<li><strong>Initialize Set for Quartets</strong>:
<ul>
<li><code>unique_quartets = set()</code>: This set will store unique quartets to avoid duplicates.</li>
</ul></li>
<li><strong>Processing Each Partial Character Table Line</strong>:
<ul>
<li>For each line after the first one, initialize <code>group_C</code> and <code>group_D</code> to store taxa based on the partial character table values (<code>1</code> and <code>0</code> respectively).</li>
<li>Populate <code>group_C</code> and <code>group_D</code> based on whether the character is <code>1</code> or <code>0</code>.</li>
</ul></li>
<li><strong>Forming Quartets</strong>:
<ul>
<li>Ensure each group has at least two taxa to form pairs.</li>
<li>Generate all possible pairs from <code>group_C</code> and <code>group_D</code>.</li>
<li>Sort pairs and add them to the <code>unique_quartets</code> set, ensuring that each quartet is stored in a canonical (sorted) form to avoid duplicates.</li>
</ul></li>
<li><strong>Output Results</strong>:
<ul>
<li>For each unique quartet, format and print the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="using-the-spectrum-graph-to-infer-peptides" class="level1" data-number="73">
<h1 data-number="73"><span class="header-section-number">73</span> Using the Spectrum Graph to Infer Peptides</h1>
<p>For a weighted alphabet&nbsp;<span class="math inline">\(𝒜\)</span>&nbsp;and a collection&nbsp;<span class="math inline">\(L\)</span>&nbsp;of positive real numbers, the&nbsp;<a href="https://rosalind.info/glossary/spectrum-graph/">spectrum graph</a>&nbsp;of&nbsp;<span class="math inline">\(L\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">digraph</a>&nbsp;constructed in the following way. First, create a&nbsp;<a href="https://rosalind.info/glossary/node/">node</a>&nbsp;for every real number in&nbsp;<span class="math inline">\(L\)</span>. Then, connect a pair of nodes with a&nbsp;<a href="https://rosalind.info/glossary/directed-edge/">directed edge</a>&nbsp;<span class="math inline">\((u,v)\)</span> if&nbsp;<span class="math inline">\(v&gt;u\)</span>&nbsp;and&nbsp;<span class="math inline">\(v−u\)</span>&nbsp;is equal to the&nbsp;<a href="https://rosalind.info/glossary/symbol-weight/">weight</a>&nbsp;of a single symbol in&nbsp;<span class="math inline">\(𝒜\)</span>. We may then label the edge with this symbol.</p>
<p>In this problem, we say that a weighted string&nbsp;<span class="math inline">\(s=s_1s_2⋯s_n\)</span>&nbsp;matches&nbsp;<span class="math inline">\(L\)</span>&nbsp;if there is some increasing sequence of positive real numbers&nbsp;<span class="math inline">\((w1,w2,…,wn+1)\)</span>&nbsp;in&nbsp;<span class="math inline">\(L\)</span>&nbsp;such that&nbsp;<span class="math inline">\(w(s1)=w2−w1\)</span>,&nbsp;<span class="math inline">\(w(s2)=w3−w2\)</span>, …, and&nbsp;<span class="math inline">\(w(sn)=wn+1−wn\)</span>.</p>
<p>Given:&nbsp;A list&nbsp;<span class="math inline">\(L\)</span>&nbsp;(of length at most 100) containing positive real numbers.</p>
<p>Return:&nbsp;The longest&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein string</a>&nbsp;that matches the spectrum graph of&nbsp;<span class="math inline">\(L\)</span>&nbsp;(if multiple solutions exist, you may output any one of them). Consult the&nbsp;<a href="https://rosalind.info/glossary/monoisotopic-mass-table/">monoisotopic mas table</a>.</p>
<section id="sample-dataset-72" class="level2" data-number="73.1">
<h2 data-number="73.1" class="anchored" data-anchor-id="sample-dataset-72"><span class="header-section-number">73.1</span> Sample Dataset</h2>
<pre><code>3524.8542
3623.5245
3710.9335
3841.974
3929.00603
3970.0326
4026.05879
4057.0646
4083.08025</code></pre>
</section>
<section id="sample-output-73" class="level2" data-number="73.2">
<h2 data-number="73.2" class="anchored" data-anchor-id="sample-output-73"><span class="header-section-number">73.2</span> Sample Output</h2>
<pre><code>SPG</code></pre>
</section>
<section id="solution-69" class="level2" data-number="73.3">
<h2 data-number="73.3" class="anchored" data-anchor-id="solution-69"><span class="header-section-number">73.3</span> Solution</h2>
<div class="sourceCode" id="cb219"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Monoisotopic mas table for amino acids</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>mass_table <span class="op">=</span> {</span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: <span class="fl">71.03711</span>, <span class="st">'C'</span>: <span class="fl">103.00919</span>, <span class="st">'D'</span>: <span class="fl">115.02694</span>, <span class="st">'E'</span>: <span class="fl">129.04259</span>,</span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'F'</span>: <span class="fl">147.06841</span>, <span class="st">'G'</span>: <span class="fl">57.02146</span>, <span class="st">'H'</span>: <span class="fl">137.05891</span>, <span class="st">'I'</span>: <span class="fl">113.08406</span>,</span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'K'</span>: <span class="fl">128.09496</span>, <span class="st">'L'</span>: <span class="fl">113.08406</span>, <span class="st">'M'</span>: <span class="fl">131.04049</span>, <span class="st">'N'</span>: <span class="fl">114.04293</span>,</span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'P'</span>: <span class="fl">97.05276</span>, <span class="st">'Q'</span>: <span class="fl">128.05858</span>, <span class="st">'R'</span>: <span class="fl">156.10111</span>, <span class="st">'S'</span>: <span class="fl">87.03203</span>,</span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'T'</span>: <span class="fl">101.04768</span>, <span class="st">'V'</span>: <span class="fl">99.06841</span>, <span class="st">'W'</span>: <span class="fl">186.07931</span>, <span class="st">'Y'</span>: <span class="fl">163.06333</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_spectrum_graph(L, mass_table):</span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Create a graph where each node represents a number in L.</span></span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Add a directed edge from u to v if v &gt; u and the weight difference</span></span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a><span class="co">    matches any amino acid's mas in the mass_table.</span></span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb219-18"><a href="#cb219-18" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb219-19"><a href="#cb219-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-20"><a href="#cb219-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each pair of nodes (u, v) where v &gt; u</span></span>
<span id="cb219-21"><a href="#cb219-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, u <span class="kw">in</span> <span class="bu">enumerate</span>(L):</span>
<span id="cb219-22"><a href="#cb219-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j, v <span class="kw">in</span> <span class="bu">enumerate</span>(L):</span>
<span id="cb219-23"><a href="#cb219-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="op">&gt;</span> u:</span>
<span id="cb219-24"><a href="#cb219-24" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Calculate the weight difference between v and u</span></span>
<span id="cb219-25"><a href="#cb219-25" aria-hidden="true" tabindex="-1"></a>                weight_diff <span class="op">=</span> v <span class="op">-</span> u</span>
<span id="cb219-26"><a href="#cb219-26" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb219-27"><a href="#cb219-27" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Check if this weight difference matches any amino acid mass</span></span>
<span id="cb219-28"><a href="#cb219-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> symbol, mas <span class="kw">in</span> mass_table.items():</span>
<span id="cb219-29"><a href="#cb219-29" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="bu">abs</span>(weight_diff <span class="op">-</span> mass) <span class="op">&lt;</span> <span class="fl">1e-5</span>:</span>
<span id="cb219-30"><a href="#cb219-30" aria-hidden="true" tabindex="-1"></a>                        graph[u].append((v, symbol))</span>
<span id="cb219-31"><a href="#cb219-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-32"><a href="#cb219-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> graph</span>
<span id="cb219-33"><a href="#cb219-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-34"><a href="#cb219-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_longest_path(graph, start):</span>
<span id="cb219-35"><a href="#cb219-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb219-36"><a href="#cb219-36" aria-hidden="true" tabindex="-1"></a><span class="co">    Use depth-first search to find the longest path in the graph starting from 'start'.</span></span>
<span id="cb219-37"><a href="#cb219-37" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb219-38"><a href="#cb219-38" aria-hidden="true" tabindex="-1"></a>    stack <span class="op">=</span> [(start, <span class="st">''</span>)]  <span class="co"># Stack for DFS: (current_node, path_string)</span></span>
<span id="cb219-39"><a href="#cb219-39" aria-hidden="true" tabindex="-1"></a>    longest_path <span class="op">=</span> <span class="st">''</span></span>
<span id="cb219-40"><a href="#cb219-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-41"><a href="#cb219-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the longest path ending at each node</span></span>
<span id="cb219-42"><a href="#cb219-42" aria-hidden="true" tabindex="-1"></a>    path_map <span class="op">=</span> defaultdict(<span class="bu">str</span>)</span>
<span id="cb219-43"><a href="#cb219-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-44"><a href="#cb219-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack:</span>
<span id="cb219-45"><a href="#cb219-45" aria-hidden="true" tabindex="-1"></a>        node, path <span class="op">=</span> stack.pop()</span>
<span id="cb219-46"><a href="#cb219-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb219-47"><a href="#cb219-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the longest path for the current node</span></span>
<span id="cb219-48"><a href="#cb219-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(path) <span class="op">&gt;</span> <span class="bu">len</span>(path_map[node]):</span>
<span id="cb219-49"><a href="#cb219-49" aria-hidden="true" tabindex="-1"></a>            path_map[node] <span class="op">=</span> path</span>
<span id="cb219-50"><a href="#cb219-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb219-51"><a href="#cb219-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Traverse neighbors</span></span>
<span id="cb219-52"><a href="#cb219-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor, symbol <span class="kw">in</span> graph[node]:</span>
<span id="cb219-53"><a href="#cb219-53" aria-hidden="true" tabindex="-1"></a>            stack.append((neighbor, path <span class="op">+</span> symbol))</span>
<span id="cb219-54"><a href="#cb219-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-55"><a href="#cb219-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the longest path found</span></span>
<span id="cb219-56"><a href="#cb219-56" aria-hidden="true" tabindex="-1"></a>    longest_path <span class="op">=</span> <span class="bu">max</span>(path_map.values(), key<span class="op">=</span><span class="bu">len</span>)</span>
<span id="cb219-57"><a href="#cb219-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> longest_path</span>
<span id="cb219-58"><a href="#cb219-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-59"><a href="#cb219-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_longest_protein_string(L, mass_table):</span>
<span id="cb219-60"><a href="#cb219-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb219-61"><a href="#cb219-61" aria-hidden="true" tabindex="-1"></a><span class="co">    Build the spectrum graph and find the longest protein string.</span></span>
<span id="cb219-62"><a href="#cb219-62" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb219-63"><a href="#cb219-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create the spectrum graph from the list L</span></span>
<span id="cb219-64"><a href="#cb219-64" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> build_spectrum_graph(L, mass_table)</span>
<span id="cb219-65"><a href="#cb219-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-66"><a href="#cb219-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the longest path starting from each node in L</span></span>
<span id="cb219-67"><a href="#cb219-67" aria-hidden="true" tabindex="-1"></a>    longest_protein <span class="op">=</span> <span class="st">''</span></span>
<span id="cb219-68"><a href="#cb219-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> L:</span>
<span id="cb219-69"><a href="#cb219-69" aria-hidden="true" tabindex="-1"></a>        current_protein <span class="op">=</span> find_longest_path(graph, node)</span>
<span id="cb219-70"><a href="#cb219-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(current_protein) <span class="op">&gt;</span> <span class="bu">len</span>(longest_protein):</span>
<span id="cb219-71"><a href="#cb219-71" aria-hidden="true" tabindex="-1"></a>            longest_protein <span class="op">=</span> current_protein</span>
<span id="cb219-72"><a href="#cb219-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb219-73"><a href="#cb219-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> longest_protein</span>
<span id="cb219-74"><a href="#cb219-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-75"><a href="#cb219-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb219-76"><a href="#cb219-76" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb219-77"><a href="#cb219-77" aria-hidden="true" tabindex="-1"></a><span class="st">3524.8542</span></span>
<span id="cb219-78"><a href="#cb219-78" aria-hidden="true" tabindex="-1"></a><span class="st">3623.5245</span></span>
<span id="cb219-79"><a href="#cb219-79" aria-hidden="true" tabindex="-1"></a><span class="st">3710.9335</span></span>
<span id="cb219-80"><a href="#cb219-80" aria-hidden="true" tabindex="-1"></a><span class="st">3841.974</span></span>
<span id="cb219-81"><a href="#cb219-81" aria-hidden="true" tabindex="-1"></a><span class="st">3929.00603</span></span>
<span id="cb219-82"><a href="#cb219-82" aria-hidden="true" tabindex="-1"></a><span class="st">3970.0326</span></span>
<span id="cb219-83"><a href="#cb219-83" aria-hidden="true" tabindex="-1"></a><span class="st">4026.05879</span></span>
<span id="cb219-84"><a href="#cb219-84" aria-hidden="true" tabindex="-1"></a><span class="st">4057.0646</span></span>
<span id="cb219-85"><a href="#cb219-85" aria-hidden="true" tabindex="-1"></a><span class="st">4083.08025"""</span></span>
<span id="cb219-86"><a href="#cb219-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-87"><a href="#cb219-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the sample input into a list of floats</span></span>
<span id="cb219-88"><a href="#cb219-88" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)]</span>
<span id="cb219-89"><a href="#cb219-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-90"><a href="#cb219-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Find and print the longest protein string</span></span>
<span id="cb219-91"><a href="#cb219-91" aria-hidden="true" tabindex="-1"></a>longest_protein <span class="op">=</span> find_longest_protein_string(L, mass_table)</span>
<span id="cb219-92"><a href="#cb219-92" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_protein)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-37" class="level2" data-number="73.4">
<h2 data-number="73.4" class="anchored" data-anchor-id="explanation-37"><span class="header-section-number">73.4</span> Explanation</h2>
<ol type="1">
<li><strong>Monoisotopic Mas Table</strong>:
<ul>
<li><code>mass_table</code> maps each amino acid to its mass.</li>
</ul></li>
<li><strong>Graph Construction (<code>build_spectrum_graph</code>)</strong>:
<ul>
<li><strong>Purpose</strong>: Create a directed graph where each node is a number from <span class="math inline">\(L\)</span>, and edges are added if the difference between nodes corresponds to the mas of an amino acid.</li>
<li><strong>Process</strong>:
<ul>
<li>Iterate through each pair of numbers in <span class="math inline">\(L\)</span> where the second number is greater than the first.</li>
<li>Calculate the weight difference and check if it matches any mas in the <code>mass_table</code>.</li>
<li>Add a directed edge between these nodes labeled with the corresponding amino acid.</li>
</ul></li>
</ul></li>
<li><strong>Finding the Longest Path (<code>find_longest_path</code>)</strong>:
<ul>
<li><strong>Purpose</strong>: Determine the longest path in the graph starting from a given node using depth-first search (DFS).</li>
<li><strong>Process</strong>:
<ul>
<li>Use a stack to explore nodes.</li>
<li>Track the longest path ending at each node.</li>
<li>Update the longest path found during traversal.</li>
</ul></li>
</ul></li>
<li><strong>Main Function (<code>find_longest_protein_string</code>)</strong>:
<ul>
<li><strong>Purpose</strong>: Integrates the graph construction and longest path finding to return the longest protein string.</li>
<li><strong>Process</strong>:
<ul>
<li>Build the spectrum graph.</li>
<li>For each node, find the longest path starting from that node.</li>
<li>Return the longest path found.</li>
</ul></li>
</ul></li>
<li><strong>Execution</strong>:
<ul>
<li><strong>Sample Input</strong>: Represents a list of mas values.</li>
<li><strong>Processing</strong>: Converts the sample input into a list of floats, finds the longest protein string, and prints it.</li>
</ul></li>
</ol>
</section>
</section>
<section id="encoding-suffix-trees" class="level1" data-number="74">
<h1 data-number="74"><span class="header-section-number">74</span> Encoding Suffix Trees</h1>
<p>Given a string&nbsp;s having length&nbsp;<span class="math inline">\(n\)</span>, recall that its suffix tree&nbsp;<span class="math inline">\(T(s)\)</span>&nbsp;is defined by the following properties:</p>
<ul>
<li><span class="math inline">\(T(s)\)</span> is a&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;having exactly&nbsp;n <a href="https://rosalind.info/glossary/leaf/">leaves</a>.</li>
<li>Every&nbsp;<a href="https://rosalind.info/glossary/edge/">edge</a>&nbsp;of&nbsp;<span class="math inline">\(T(s)\)</span>&nbsp;is labeled with a substring of&nbsp;<span class="math inline">\(s∗\)</span>, where&nbsp;<span class="math inline">\(s∗\)</span>&nbsp;is the string formed by adding a placeholder symbol&nbsp;<code>$</code>&nbsp;to the end of&nbsp;<span class="math inline">\(s\)</span>.</li>
<li>Every&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal node</a>&nbsp;of&nbsp;<span class="math inline">\(T(s)\)</span>&nbsp;other than the root has at least two&nbsp;<a href="https://rosalind.info/glossary/child/">children</a>; i.e., it has&nbsp;<a href="https://rosalind.info/glossary/degree/">degree</a>&nbsp;at least 3.</li>
<li>The substring labels for the edges leading down from a node to its children must begin with different symbols.</li>
<li>By concatenating the substrings along edges, each path from the root to a leaf corresponds to a unique&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s∗\)</span>.</li>
</ul>
<p>Given:&nbsp;A DNA string&nbsp;s of length at most 1<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;The substrings of&nbsp;<span class="math inline">\(s∗\)</span>&nbsp;encoding the edges of the suffix tree for&nbsp;<span class="math inline">\(s\)</span>. You may list these substrings in any order.</p>
<section id="sample-dataset-73" class="level2" data-number="74.1">
<h2 data-number="74.1" class="anchored" data-anchor-id="sample-dataset-73"><span class="header-section-number">74.1</span> Sample Dataset</h2>
<pre><code>ATAAATG$</code></pre>
</section>
<section id="sample-output-74" class="level2" data-number="74.2">
<h2 data-number="74.2" class="anchored" data-anchor-id="sample-output-74"><span class="header-section-number">74.2</span> Sample Output</h2>
<pre><code>A
A
ATG$
TG$
T
AAATG$
G$
T
AAATG$
G$
G$
$</code></pre>
</section>
<section id="solution-70" class="level2" data-number="74.3">
<h2 data-number="74.3" class="anchored" data-anchor-id="solution-70"><span class="header-section-number">74.3</span> Solution</h2>
<div class="sourceCode" id="cb222"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>clas SuffixTree:</span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Creates a suffix tree for the provided word."""</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, word):</span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Initializes the suffix tree."""</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> [<span class="va">self</span>.Node(<span class="va">None</span>, <span class="dv">0</span>)]  <span class="co"># Initialize with root node.</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> <span class="bu">dict</span>()  <span class="co"># Dictionary to store edges.</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.descendants_count <span class="op">=</span> <span class="bu">dict</span>()  <span class="co"># Cache for the number of descendants of nodes.</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(word, <span class="bu">str</span>):  <span class="co"># Check if the input is a string.</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._build_suffix_tree(word)</span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a>    clas Node:</span>
<span id="cb222-15"><a href="#cb222-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Represents a node in the suffix tree."""</span></span>
<span id="cb222-16"><a href="#cb222-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, parent, node_id):</span>
<span id="cb222-17"><a href="#cb222-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb222-18"><a href="#cb222-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.node_id <span class="op">=</span> node_id</span>
<span id="cb222-19"><a href="#cb222-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb222-20"><a href="#cb222-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-21"><a href="#cb222-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> add_child(<span class="va">self</span>, child_node):</span>
<span id="cb222-22"><a href="#cb222-22" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.append(child_node)</span>
<span id="cb222-23"><a href="#cb222-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-24"><a href="#cb222-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> remove_child(<span class="va">self</span>, child_node):</span>
<span id="cb222-25"><a href="#cb222-25" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.remove(child_node)</span>
<span id="cb222-26"><a href="#cb222-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-27"><a href="#cb222-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> update_parent(<span class="va">self</span>, new_parent):</span>
<span id="cb222-28"><a href="#cb222-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> new_parent</span>
<span id="cb222-29"><a href="#cb222-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-30"><a href="#cb222-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build_suffix_tree(<span class="va">self</span>, word):</span>
<span id="cb222-31"><a href="#cb222-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Builds the suffix tree by adding each suffix of the word."""</span></span>
<span id="cb222-32"><a href="#cb222-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> word[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> <span class="st">'$'</span>:</span>
<span id="cb222-33"><a href="#cb222-33" aria-hidden="true" tabindex="-1"></a>            word <span class="op">+=</span> <span class="st">'$'</span>  <span class="co"># Ensure the word ends with the terminal symbol '$'.</span></span>
<span id="cb222-34"><a href="#cb222-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.word <span class="op">=</span> word</span>
<span id="cb222-35"><a href="#cb222-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.length <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.word)</span>
<span id="cb222-36"><a href="#cb222-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-37"><a href="#cb222-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.length):</span>
<span id="cb222-38"><a href="#cb222-38" aria-hidden="true" tabindex="-1"></a>            parent_node, edge_start, has_overlap <span class="op">=</span> <span class="va">self</span>._find_insertion_point(i, <span class="va">self</span>.nodes[<span class="dv">0</span>])</span>
<span id="cb222-39"><a href="#cb222-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-40"><a href="#cb222-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> has_overlap:</span>
<span id="cb222-41"><a href="#cb222-41" aria-hidden="true" tabindex="-1"></a>                existing_start, existing_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.parent.node_id, parent_node.node_id)]</span>
<span id="cb222-42"><a href="#cb222-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-43"><a href="#cb222-43" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Determine the length of the overlap.</span></span>
<span id="cb222-44"><a href="#cb222-44" aria-hidden="true" tabindex="-1"></a>                overlap_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb222-45"><a href="#cb222-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> <span class="va">self</span>.word[edge_start:edge_start <span class="op">+</span> overlap_length] <span class="op">==</span> <span class="va">self</span>.word[existing_start:existing_start <span class="op">+</span> overlap_length]:</span>
<span id="cb222-46"><a href="#cb222-46" aria-hidden="true" tabindex="-1"></a>                    overlap_length <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb222-47"><a href="#cb222-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-48"><a href="#cb222-48" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create a new internal node at the point of insertion.</span></span>
<span id="cb222-49"><a href="#cb222-49" aria-hidden="true" tabindex="-1"></a>                new_internal_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node.parent, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb222-50"><a href="#cb222-50" aria-hidden="true" tabindex="-1"></a>                new_internal_node.add_child(parent_node)</span>
<span id="cb222-51"><a href="#cb222-51" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._add_edge_and_node(parent_node.parent, existing_start, existing_start <span class="op">+</span> overlap_length <span class="op">-</span> <span class="dv">1</span>, new_internal_node)</span>
<span id="cb222-52"><a href="#cb222-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-53"><a href="#cb222-53" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update the edge and parent relationship for the original child node.</span></span>
<span id="cb222-54"><a href="#cb222-54" aria-hidden="true" tabindex="-1"></a>                <span class="kw">del</span> <span class="va">self</span>.edges[(parent_node.parent.node_id, parent_node.node_id)]</span>
<span id="cb222-55"><a href="#cb222-55" aria-hidden="true" tabindex="-1"></a>                parent_node.parent.remove_child(parent_node)</span>
<span id="cb222-56"><a href="#cb222-56" aria-hidden="true" tabindex="-1"></a>                parent_node.update_parent(new_internal_node)</span>
<span id="cb222-57"><a href="#cb222-57" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges[(new_internal_node.node_id, parent_node.node_id)] <span class="op">=</span> [existing_start <span class="op">+</span> overlap_length <span class="op">-</span> <span class="dv">1</span>, existing_end]</span>
<span id="cb222-58"><a href="#cb222-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-59"><a href="#cb222-59" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add the remaining suffix as a new child node.</span></span>
<span id="cb222-60"><a href="#cb222-60" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._add_edge_and_node(new_internal_node, edge_start <span class="op">+</span> overlap_length <span class="op">-</span> <span class="dv">1</span>, <span class="va">self</span>.length)</span>
<span id="cb222-61"><a href="#cb222-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-62"><a href="#cb222-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb222-63"><a href="#cb222-63" aria-hidden="true" tabindex="-1"></a>                <span class="co"># No overlap, simply add the entire suffix as a new edge.</span></span>
<span id="cb222-64"><a href="#cb222-64" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._add_edge_and_node(parent_node, edge_start, <span class="va">self</span>.length)</span>
<span id="cb222-65"><a href="#cb222-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-66"><a href="#cb222-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _find_insertion_point(<span class="va">self</span>, start_index, parent_node):</span>
<span id="cb222-67"><a href="#cb222-67" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Determines where to insert a suffix into the tree."""</span></span>
<span id="cb222-68"><a href="#cb222-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child_node <span class="kw">in</span> parent_node.children:</span>
<span id="cb222-69"><a href="#cb222-69" aria-hidden="true" tabindex="-1"></a>            edge_start, edge_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.node_id, child_node.node_id)]</span>
<span id="cb222-70"><a href="#cb222-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.word[start_index:start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start] <span class="op">==</span> <span class="va">self</span>.word[edge_start:edge_end]:</span>
<span id="cb222-71"><a href="#cb222-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">self</span>._find_insertion_point(start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start, child_node)</span>
<span id="cb222-72"><a href="#cb222-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="va">self</span>.word[edge_start] <span class="op">==</span> <span class="va">self</span>.word[start_index]:</span>
<span id="cb222-73"><a href="#cb222-73" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> child_node, start_index, <span class="va">True</span></span>
<span id="cb222-74"><a href="#cb222-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent_node, start_index, <span class="va">False</span></span>
<span id="cb222-75"><a href="#cb222-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-76"><a href="#cb222-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _add_edge_and_node(<span class="va">self</span>, parent_node, edge_start, edge_end, child_node<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb222-77"><a href="#cb222-77" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Adds a node and the corresponding edge to the suffix tree."""</span></span>
<span id="cb222-78"><a href="#cb222-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> child_node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb222-79"><a href="#cb222-79" aria-hidden="true" tabindex="-1"></a>            child_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb222-80"><a href="#cb222-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-81"><a href="#cb222-81" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes.append(child_node)</span>
<span id="cb222-82"><a href="#cb222-82" aria-hidden="true" tabindex="-1"></a>        parent_node.add_child(child_node)</span>
<span id="cb222-83"><a href="#cb222-83" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges[(parent_node.node_id, child_node.node_id)] <span class="op">=</span> [edge_start, edge_end]</span>
<span id="cb222-84"><a href="#cb222-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-85"><a href="#cb222-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_edge_labels(<span class="va">self</span>):</span>
<span id="cb222-86"><a href="#cb222-86" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Returns the substrings representing the edges of the suffix tree."""</span></span>
<span id="cb222-87"><a href="#cb222-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="va">self</span>.word[start:end] <span class="cf">for</span> start, end <span class="kw">in</span> <span class="va">self</span>.edges.values()]</span>
<span id="cb222-88"><a href="#cb222-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-89"><a href="#cb222-89" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> count_total_descendants(<span class="va">self</span>, node):</span>
<span id="cb222-90"><a href="#cb222-90" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Calculates the total number of descendants of a given node."""</span></span>
<span id="cb222-91"><a href="#cb222-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.descendants_count:</span>
<span id="cb222-92"><a href="#cb222-92" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.descendants_count[node] <span class="op">=</span> <span class="bu">len</span>(node.children) <span class="op">+</span> <span class="bu">sum</span>(<span class="va">self</span>.count_total_descendants(child) <span class="cf">for</span> child <span class="kw">in</span> node.children)</span>
<span id="cb222-93"><a href="#cb222-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.descendants_count[node]</span>
<span id="cb222-94"><a href="#cb222-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-95"><a href="#cb222-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_node_label(<span class="va">self</span>, node):</span>
<span id="cb222-96"><a href="#cb222-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Returns the string represented by the path from the root to a given node."""</span></span>
<span id="cb222-97"><a href="#cb222-97" aria-hidden="true" tabindex="-1"></a>        label <span class="op">=</span> <span class="st">''</span></span>
<span id="cb222-98"><a href="#cb222-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node.node_id <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb222-99"><a href="#cb222-99" aria-hidden="true" tabindex="-1"></a>            start, end <span class="op">=</span> <span class="va">self</span>.edges[(node.parent.node_id, node.node_id)]</span>
<span id="cb222-100"><a href="#cb222-100" aria-hidden="true" tabindex="-1"></a>            label <span class="op">=</span> <span class="va">self</span>.word[start:end] <span class="op">+</span> label</span>
<span id="cb222-101"><a href="#cb222-101" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.parent</span>
<span id="cb222-102"><a href="#cb222-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> label.strip(<span class="st">'$'</span>)</span>
<span id="cb222-103"><a href="#cb222-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-104"><a href="#cb222-104" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb222-105"><a href="#cb222-105" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"ATAAATG$"</span></span>
<span id="cb222-106"><a href="#cb222-106" aria-hidden="true" tabindex="-1"></a>suffix_tree <span class="op">=</span> SuffixTree(sample_input)</span>
<span id="cb222-107"><a href="#cb222-107" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(suffix_tree.get_edge_labels())</span>
<span id="cb222-108"><a href="#cb222-108" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-15" class="level2" data-number="74.4">
<h2 data-number="74.4" class="anchored" data-anchor-id="explanation-of-the-code-15"><span class="header-section-number">74.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Clas Structure</strong>:
<ul>
<li><code>SuffixTree</code> class: Manages the construction and representation of the suffix tree.</li>
<li><code>Node</code> clas (nested within <code>SuffixTree</code>): Represents each node in the suffix tree. Each node has a parent, a unique identifier (<code>node_id</code>), and a list of child nodes.</li>
</ul></li>
<li><strong>Initialization</strong>:
<ul>
<li>The <code>SuffixTree</code> is initialized with a root node (with <code>node_id = 0</code>).</li>
<li>The <code>_build_suffix_tree</code> method ensures the input word ends with the terminal symbol <code>$</code> and then processes each suffix of the word to build the tree.</li>
</ul></li>
<li><strong>Building the Tree</strong>:
<ul>
<li>For each suffix, <code>_find_insertion_point</code> is called to determine where in the tree the suffix should be inserted.</li>
<li>If there’s an overlap with an existing edge, a new internal node is created, and the tree is split at the point of overlap.</li>
<li>Otherwise, a new edge representing the suffix is added directly.</li>
</ul></li>
<li><strong>Edge and Node Management</strong>:
<ul>
<li>The <code>_add_edge_and_node</code> method handles the actual insertion of edges and nodes into the tree structure.</li>
<li>The <code>edges</code> dictionary maps parent-child relationships to the start and end indices of the corresponding substring in the word.</li>
</ul></li>
<li><strong>Retrieving Results</strong>:
<ul>
<li><code>get_edge_labels</code>: Returns the list of substrings corresponding to all edges in the tree.</li>
<li><code>count_total_descendants</code>: Computes the number of descendants for any given node in the tree (cached to optimize repeated queries).</li>
<li><code>get_node_label</code>: Recovers the substring represented by a path from the root to a specific node.</li>
</ul></li>
</ol>
</section>
</section>
<section id="character-based-phylogeny" class="level1" data-number="75">
<h1 data-number="75"><span class="header-section-number">75</span> Character-Based Phylogeny</h1>
<p>Because a&nbsp;<a href="https://rosalind.info/glossary/tree/">tree</a>&nbsp;having&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/node/">nodes</a>&nbsp;has&nbsp;<span class="math inline">\(n−1\)</span>&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/tree/">“Completing a Tree”</a>), removing a single edge from a tree will produce two smaller,&nbsp;<a href="https://rosalind.info/glossary/disjoint-sets/">disjoint</a>&nbsp;trees. Recall from&nbsp;<a href="https://rosalind.info/problems/ctbl/">“Creating a Character Table”</a>&nbsp;that for this reason, each edge of an&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary tree</a>&nbsp;corresponds to a&nbsp;<a href="https://rosalind.info/glossary/split/">split</a>&nbsp;<span class="math inline">\(S∣S^c\)</span>, where&nbsp;<span class="math inline">\(S\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/subset/">subset</a>&nbsp;of the&nbsp;<a href="https://rosalind.info/glossary/taxon/">taxa</a>.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/consistent-character-table/">consistent character table</a>&nbsp;is one whose characters’ splits do not conflict with the edge splits of some unrooted binary tree&nbsp;<span class="math inline">\(T\)</span>&nbsp;on the&nbsp;n taxa. More precisely,&nbsp;<span class="math inline">\(S_1∣S^c_1\)</span>&nbsp;conflicts with&nbsp;<span class="math inline">\(S_2∣S^c_2\)</span>&nbsp;if all four&nbsp;<a href="https://rosalind.info/glossary/intersection/">intersections</a>&nbsp;<span class="math inline">\(S_1∩S_2\)</span>,&nbsp;<span class="math inline">\(S_1∩S^c_2\)</span>,&nbsp;<span class="math inline">\(S^c_1∩S_2\)</span>, and&nbsp;<span class="math inline">\(S^c_1∩S^c_2\)</span>&nbsp;are nonempty. As a simple example, consider the conflicting splits&nbsp;<span class="math inline">\(\{a,b\}∣\{c,d\}\)</span>&nbsp;and&nbsp;<span class="math inline">\(\{a,c\}∣\{b,d\}\)</span>.</p>
<p>More generally, given a&nbsp;<a href="https://rosalind.info/glossary/consistent-character-table/">consistent character table</a>&nbsp;<span class="math inline">\(C\)</span>, an unrooted binary tree&nbsp;<span class="math inline">\(T\)</span>&nbsp;“models”&nbsp;<span class="math inline">\(C\)</span>&nbsp;if the edge splits of&nbsp;<span class="math inline">\(T\)</span>&nbsp;agree with the splits induced from the&nbsp;<a href="https://rosalind.info/glossary/character/">characters</a>&nbsp;of&nbsp;<span class="math inline">\(C\)</span>.</p>
<p>Given:&nbsp;A list of&nbsp;n species (<span class="math inline">\(n≤80\)</span>) and an&nbsp;<span class="math inline">\(n\)</span>-column character table&nbsp;<span class="math inline">\(C\)</span>&nbsp;in which the&nbsp;<span class="math inline">\(j\)</span>th column denotes the&nbsp;<span class="math inline">\(j\)</span>th species.</p>
<p>Return:&nbsp;An unrooted binary tree in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;that models&nbsp;<span class="math inline">\(C\)</span>.</p>
<section id="sample-dataset-74" class="level2" data-number="75.1">
<h2 data-number="75.1" class="anchored" data-anchor-id="sample-dataset-74"><span class="header-section-number">75.1</span> Sample Dataset</h2>
<pre><code>cat dog elephant mouse rabbit rat
011101
001101
001100</code></pre>
</section>
<section id="sample-output-75" class="level2" data-number="75.2">
<h2 data-number="75.2" class="anchored" data-anchor-id="sample-output-75"><span class="header-section-number">75.2</span> Sample Output</h2>
<pre><code>(((cat,rabbit),dog),(elephant,mouse),rat);</code></pre>
</section>
<section id="solution-71" class="level2" data-number="75.3">
<h2 data-number="75.3" class="anchored" data-anchor-id="solution-71"><span class="header-section-number">75.3</span> Solution</h2>
<div class="sourceCode" id="cb225"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Bio <span class="im">import</span> Phylo</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_columns_to_unify(splits):</span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Finds two columns in the split matrix that should be unified into a single clade."""</span></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> split <span class="kw">in</span> splits:</span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>        sum_split <span class="op">=</span> <span class="bu">sum</span>(split)</span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sum_split <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Find the pair of columns where the sum is exactly 2.</span></span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">tuple</span>(i <span class="cf">for</span> i, value <span class="kw">in</span> <span class="bu">enumerate</span>(split) <span class="cf">if</span> value <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> sum_split <span class="op">==</span> <span class="bu">len</span>(split) <span class="op">-</span> <span class="dv">2</span>:</span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Find the pair of columns where the sum is all but 2.</span></span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">tuple</span>(i <span class="cf">for</span> i, value <span class="kw">in</span> <span class="bu">enumerate</span>(split) <span class="cf">if</span> value <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb225-14"><a href="#cb225-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">'No columns to unify found!'</span>, splits)</span>
<span id="cb225-15"><a href="#cb225-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-16"><a href="#cb225-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_clade_trees(clades):</span>
<span id="cb225-17"><a href="#cb225-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Prints the clades as Newick formatted trees."""</span></span>
<span id="cb225-18"><a href="#cb225-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> clade <span class="kw">in</span> clades:</span>
<span id="cb225-19"><a href="#cb225-19" aria-hidden="true" tabindex="-1"></a>        tree <span class="op">=</span> Phylo.BaseTree.Tree.from_clade(clade)</span>
<span id="cb225-20"><a href="#cb225-20" aria-hidden="true" tabindex="-1"></a>        Phylo.write(tree, sys.stdout, <span class="st">'newick'</span>, plain<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb225-21"><a href="#cb225-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-22"><a href="#cb225-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_phylogenetic_tree(input_lines):</span>
<span id="cb225-23"><a href="#cb225-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Builds a phylogenetic tree based on the input split matrix."""</span></span>
<span id="cb225-24"><a href="#cb225-24" aria-hidden="true" tabindex="-1"></a>    clades <span class="op">=</span> [Phylo.BaseTree.Clade(name<span class="op">=</span>name) <span class="cf">for</span> name <span class="kw">in</span> input_lines[<span class="dv">0</span>].split()]</span>
<span id="cb225-25"><a href="#cb225-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-26"><a href="#cb225-26" aria-hidden="true" tabindex="-1"></a>    splits <span class="op">=</span> []</span>
<span id="cb225-27"><a href="#cb225-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> input_lines[<span class="dv">1</span>:]:</span>
<span id="cb225-28"><a href="#cb225-28" aria-hidden="true" tabindex="-1"></a>        splits.append([<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> line])</span>
<span id="cb225-29"><a href="#cb225-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-30"><a href="#cb225-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> splits:</span>
<span id="cb225-31"><a href="#cb225-31" aria-hidden="true" tabindex="-1"></a>        col1, col2 <span class="op">=</span> find_columns_to_unify(splits)</span>
<span id="cb225-32"><a href="#cb225-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-33"><a href="#cb225-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove the second of the unified columns from the splits</span></span>
<span id="cb225-34"><a href="#cb225-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> split <span class="kw">in</span> splits:</span>
<span id="cb225-35"><a href="#cb225-35" aria-hidden="true" tabindex="-1"></a>            split.pop(col2)</span>
<span id="cb225-36"><a href="#cb225-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-37"><a href="#cb225-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove trivial splits where all entries are 1 or all but one are 1</span></span>
<span id="cb225-38"><a href="#cb225-38" aria-hidden="true" tabindex="-1"></a>        splits <span class="op">=</span> [split <span class="cf">for</span> split <span class="kw">in</span> splits <span class="cf">if</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">sum</span>(split) <span class="op">&lt;</span> <span class="bu">len</span>(split) <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb225-39"><a href="#cb225-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-40"><a href="#cb225-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Unify the clades corresponding to the selected columns</span></span>
<span id="cb225-41"><a href="#cb225-41" aria-hidden="true" tabindex="-1"></a>        clades[col1] <span class="op">=</span> Phylo.BaseTree.Clade(clades<span class="op">=</span>[clades[col1], clades[col2]])</span>
<span id="cb225-42"><a href="#cb225-42" aria-hidden="true" tabindex="-1"></a>        clades.pop(col2)</span>
<span id="cb225-43"><a href="#cb225-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-44"><a href="#cb225-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Final clade to represent the complete phylogenetic tree</span></span>
<span id="cb225-45"><a href="#cb225-45" aria-hidden="true" tabindex="-1"></a>    final_clade <span class="op">=</span> Phylo.BaseTree.Clade(clades<span class="op">=</span>clades)</span>
<span id="cb225-46"><a href="#cb225-46" aria-hidden="true" tabindex="-1"></a>    print_clade_trees([final_clade])</span>
<span id="cb225-47"><a href="#cb225-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-48"><a href="#cb225-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb225-49"><a href="#cb225-49" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb225-50"><a href="#cb225-50" aria-hidden="true" tabindex="-1"></a><span class="st">cat dog elephant mouse rabbit rat</span></span>
<span id="cb225-51"><a href="#cb225-51" aria-hidden="true" tabindex="-1"></a><span class="st">011101</span></span>
<span id="cb225-52"><a href="#cb225-52" aria-hidden="true" tabindex="-1"></a><span class="st">001101</span></span>
<span id="cb225-53"><a href="#cb225-53" aria-hidden="true" tabindex="-1"></a><span class="st">001100</span></span>
<span id="cb225-54"><a href="#cb225-54" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb225-55"><a href="#cb225-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-56"><a href="#cb225-56" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb225-57"><a href="#cb225-57" aria-hidden="true" tabindex="-1"></a>build_phylogenetic_tree(input_lines)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-16" class="level2" data-number="75.4">
<h2 data-number="75.4" class="anchored" data-anchor-id="explanation-of-the-code-16"><span class="header-section-number">75.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong>Purpose</strong>:
<ul>
<li>The code is designed to build a phylogenetic tree based on a set of species (or objects) and their binary split representations. The input consists of species names followed by rows of binary digits representing splits between species.</li>
</ul></li>
<li><strong>Functions</strong>:
<ul>
<li><strong><code>find_columns_to_unify(splits)</code></strong>:
<ul>
<li>This function identifies two columns in the split matrix that can be unified into a single clade.</li>
<li>It looks for a pair of columns where the sum of the values in the columns equals 2 (indicating that exactly two species share a common clade) or equals the number of species minus 2 (indicating all but two species share a clade).</li>
</ul></li>
<li><strong><code>print_clade_trees(clades)</code></strong>:
<ul>
<li>This function prints the clades in Newick format, which is a common format for representing phylogenetic trees.</li>
</ul></li>
<li><strong><code>build_phylogenetic_tree(input_lines)</code></strong>:
<ul>
<li>This is the main function that constructs the phylogenetic tree.</li>
<li>It first parses the input to create a list of clades, one for each species.</li>
<li>Then it iterates through the split matrix, repeatedly unifying clades based on the identified columns until only one clade (the final tree) remains.</li>
</ul></li>
</ul></li>
<li><strong>Process</strong>:
<ul>
<li><strong>Input Parsing</strong>:
<ul>
<li>The input string is split into lines, with the first line containing species names and the subsequent lines containing binary splits.</li>
</ul></li>
<li><strong>Tree Construction</strong>:
<ul>
<li>The code processes the splits by repeatedly identifying pairs of species to unify (using the <code>find_columns_to_unify</code> function).</li>
<li>After unifying species into clades, it modifies the split matrix by removing the unified columns and trivial splits.</li>
<li>This continues until only one clade remains, representing the complete phylogenetic tree.</li>
</ul></li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>The resulting phylogenetic tree is printed in Newick format, which can be visualized or further analyzed using tools that support this format.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-quartets" class="level1" data-number="76">
<h1 data-number="76"><span class="header-section-number">76</span> Counting Quartets</h1>
<p>A quartet&nbsp;<span class="math inline">\(AB∣CD\)</span>&nbsp;is&nbsp;<a href="https://rosalind.info/glossary/consistent-quartet/">consistent</a>&nbsp;with a&nbsp;<a href="https://rosalind.info/glossary/binary-tree/">binary tree</a>&nbsp;<span class="math inline">\(T\)</span>&nbsp;if the quartet can be inferred from one of the&nbsp;<a href="https://rosalind.info/glossary/split/">splits</a>&nbsp;of&nbsp;<span class="math inline">\(T\)</span>&nbsp;(see&nbsp;<a href="https://rosalind.info/problems/qrt/">“Quartets”</a>&nbsp;for a description of inferring quartets from splits).</p>
<p>Let&nbsp;<span class="math inline">\(q(T)\)</span>&nbsp;denote the total number of quartets that are consistent with&nbsp;<span class="math inline">\(T\)</span>.</p>
<p>Given:&nbsp;A positive integer&nbsp;n&nbsp;(<span class="math inline">\(4≤n≤5000\)</span>), followed by an&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary tree</a>&nbsp;<span class="math inline">\(T\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;on&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa.</p>
<p>Return:&nbsp;The value of&nbsp;<span class="math inline">\(q(T)\)</span>&nbsp;<a href="https://rosalind.info/glossary/modular-arithmetic/">modulo</a>&nbsp;1,000,000.</p>
<section id="sample-dataset-75" class="level2" data-number="76.1">
<h2 data-number="76.1" class="anchored" data-anchor-id="sample-dataset-75"><span class="header-section-number">76.1</span> Sample Dataset</h2>
<pre><code>6
(lobster,(cat,dog),(caterpillar,(elephant,mouse)));</code></pre>
</section>
<section id="sample-output-76" class="level2" data-number="76.2">
<h2 data-number="76.2" class="anchored" data-anchor-id="sample-output-76"><span class="header-section-number">76.2</span> Sample Output</h2>
<pre><code>15</code></pre>
</section>
<section id="solution-72" class="level2" data-number="76.3">
<h2 data-number="76.3" class="anchored" data-anchor-id="solution-72"><span class="header-section-number">76.3</span> Solution</h2>
<div class="sourceCode" id="cb228"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a><span class="st">6</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a><span class="st">(lobster,(cat,dog),(caterpillar,(elephant,mouse)));</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input lines</span></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(input_lines[<span class="dv">0</span>])</span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize a memoization list to store factorials</span></span>
<span id="cb228-12"><a href="#cb228-12" aria-hidden="true" tabindex="-1"></a>factorials <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># Initialize with 1 for factorial(0)</span></span>
<span id="cb228-13"><a href="#cb228-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-14"><a href="#cb228-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate all factorials from 1 to n and store in the list</span></span>
<span id="cb228-15"><a href="#cb228-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb228-16"><a href="#cb228-16" aria-hidden="true" tabindex="-1"></a>    factorials[i] <span class="op">=</span> i <span class="op">*</span> factorials[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb228-17"><a href="#cb228-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-18"><a href="#cb228-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the number of possible quartets using the combination formula</span></span>
<span id="cb228-19"><a href="#cb228-19" aria-hidden="true" tabindex="-1"></a><span class="co"># C(n, 4) = n! / ((n-4)! * 4!)</span></span>
<span id="cb228-20"><a href="#cb228-20" aria-hidden="true" tabindex="-1"></a>num_quartets <span class="op">=</span> (factorials[n] <span class="op">//</span> (factorials[n <span class="op">-</span> <span class="dv">4</span>] <span class="op">*</span> factorials[<span class="dv">4</span>])) <span class="op">%</span> <span class="dv">1000000</span></span>
<span id="cb228-21"><a href="#cb228-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-22"><a href="#cb228-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the result</span></span>
<span id="cb228-23"><a href="#cb228-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(num_quartets)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-38" class="level2" data-number="76.4">
<h2 data-number="76.4" class="anchored" data-anchor-id="explanation-38"><span class="header-section-number">76.4</span> Explanation</h2>
<ol type="1">
<li><strong>Input Parsing</strong>:
<ul>
<li>The input is a string representing the number of taxa <code>n</code> and a Newick formatted tree. The first line is split to extract <code>n</code>.</li>
</ul></li>
<li><strong>Factorial Calculation</strong>:
<ul>
<li>We need to calculate the number of quartets possible, which involves computing combinations. The combination formula <code>C(n, 4)</code> is used to calculate how many ways we can choose 4 taxa from <code>n</code>, and it requires calculating factorials.</li>
<li>We initialize a list <code>factorials</code> with <code>n+1</code> elements, all set to <code>1</code>. This list will store factorial values from <code>0!</code> to <code>n!</code>.</li>
<li>A loop is used to calculate each factorial iteratively and store it in the list.</li>
</ul></li>
<li><strong>Combination Calculation</strong>:
<ul>
<li>The number of quartets is calculated using the formula <code>C(n, 4) = n! / ((n-4)! * 4!)</code>.</li>
<li>The combination result is then taken modulo <code>1,000,000</code> to meet the problem’s requirement.</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>The final result is printed.</li>
</ul></li>
</ol>
</section>
<section id="key-concepts-1" class="level2" data-number="76.5">
<h2 data-number="76.5" class="anchored" data-anchor-id="key-concepts-1"><span class="header-section-number">76.5</span> Key Concepts</h2>
<ul>
<li><strong>Factorials</strong>: Factorials are calculated iteratively and stored in a list to avoid recalculating the same value multiple times.</li>
<li><strong>Combinations</strong>: The formula for combinations <code>C(n, 4)</code> is used to find out how many quartets can be formed from <code>n</code> taxa.</li>
<li><strong>Modulo Operation</strong>: Since the number of quartets can be large, the result is taken modulo <code>1,000,000</code>.</li>
</ul>
</section>
</section>
<section id="enumerating-unrooted-binary-trees" class="level1" data-number="77">
<h1 data-number="77"><span class="header-section-number">77</span> Enumerating Unrooted Binary Trees</h1>
<p>Recall the definition of&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;from&nbsp;<a href="https://rosalind.info/problems/nwck/">“Distances in Trees”</a>&nbsp;as a way of encoding&nbsp;<a href="https://rosalind.info/glossary/tree/">trees</a>.</p>
<p>Given:&nbsp;A collection of species names representing&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa.</p>
<p>Return:&nbsp;A list containing all unrooted binary trees whose leaves are these&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa. Trees should be given in Newick format, with one tree on each line; the order of the trees is unimportant.</p>
<section id="sample-dataset-76" class="level2" data-number="77.1">
<h2 data-number="77.1" class="anchored" data-anchor-id="sample-dataset-76"><span class="header-section-number">77.1</span> Sample Dataset</h2>
<pre><code>dog cat mouse elephant</code></pre>
</section>
<section id="sample-output-77" class="level2" data-number="77.2">
<h2 data-number="77.2" class="anchored" data-anchor-id="sample-output-77"><span class="header-section-number">77.2</span> Sample Output</h2>
<pre><code>((cat,(mouse,elephant)))dog
((mouse,(cat,elephant)))dog
((elephant,(cat,mouse)))dog</code></pre>
</section>
<section id="solution-73" class="level2" data-number="77.3">
<h2 data-number="77.3" class="anchored" data-anchor-id="solution-73"><span class="header-section-number">77.3</span> Solution</h2>
<div class="sourceCode" id="cb231"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_combinations(n, items):</span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates all combinations of `n` elements from the list `items`.</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [[]]</span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> items:</span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>    head, <span class="op">*</span>tail <span class="op">=</span> items</span>
<span id="cb231-13"><a href="#cb231-13" aria-hidden="true" tabindex="-1"></a>    with_head <span class="op">=</span> [[head] <span class="op">+</span> rest <span class="cf">for</span> rest <span class="kw">in</span> generate_combinations(n<span class="op">-</span><span class="dv">1</span>, tail)]</span>
<span id="cb231-14"><a href="#cb231-14" aria-hidden="true" tabindex="-1"></a>    without_head <span class="op">=</span> generate_combinations(n, tail)</span>
<span id="cb231-15"><a href="#cb231-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb231-16"><a href="#cb231-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> with_head <span class="op">+</span> without_head</span>
<span id="cb231-17"><a href="#cb231-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-18"><a href="#cb231-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> memoized_combinations(n, k):</span>
<span id="cb231-19"><a href="#cb231-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb231-20"><a href="#cb231-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns all `k`-combinations of `n` items using memoization.</span></span>
<span id="cb231-21"><a href="#cb231-21" aria-hidden="true" tabindex="-1"></a><span class="co">    This prevents redundant computation of the same combination.</span></span>
<span id="cb231-22"><a href="#cb231-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb231-23"><a href="#cb231-23" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> memoized_combinations.cache</span>
<span id="cb231-24"><a href="#cb231-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> memo:</span>
<span id="cb231-25"><a href="#cb231-25" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> {}</span>
<span id="cb231-26"><a href="#cb231-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="kw">not</span> <span class="kw">in</span> memo[n]:</span>
<span id="cb231-27"><a href="#cb231-27" aria-hidden="true" tabindex="-1"></a>        memo[n][k] <span class="op">=</span> generate_combinations(k, <span class="bu">list</span>(<span class="bu">range</span>(n)))</span>
<span id="cb231-28"><a href="#cb231-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n][k]</span>
<span id="cb231-29"><a href="#cb231-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-30"><a href="#cb231-30" aria-hidden="true" tabindex="-1"></a>memoized_combinations.cache <span class="op">=</span> {}</span>
<span id="cb231-31"><a href="#cb231-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-32"><a href="#cb231-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_unrooted_binary_trees(species):</span>
<span id="cb231-33"><a href="#cb231-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb231-34"><a href="#cb231-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Generates all possible unrooted binary trees in Newick format for a given list of species.</span></span>
<span id="cb231-35"><a href="#cb231-35" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb231-36"><a href="#cb231-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(species) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb231-37"><a href="#cb231-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> species</span>
<span id="cb231-38"><a href="#cb231-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">len</span>(species) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb231-39"><a href="#cb231-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="ss">f"(</span><span class="sc">{</span>species[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>species[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">)"</span>]</span>
<span id="cb231-40"><a href="#cb231-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">len</span>(species) <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb231-41"><a href="#cb231-41" aria-hidden="true" tabindex="-1"></a>        trees <span class="op">=</span> []</span>
<span id="cb231-42"><a href="#cb231-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, (<span class="bu">len</span>(species) <span class="op">//</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb231-43"><a href="#cb231-43" aria-hidden="true" tabindex="-1"></a>            seen_combinations <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb231-44"><a href="#cb231-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> selected_indices <span class="kw">in</span> memoized_combinations(<span class="bu">len</span>(species), k):</span>
<span id="cb231-45"><a href="#cb231-45" aria-hidden="true" tabindex="-1"></a>                selected_species <span class="op">=</span> [species[i] <span class="cf">for</span> i <span class="kw">in</span> selected_indices]</span>
<span id="cb231-46"><a href="#cb231-46" aria-hidden="true" tabindex="-1"></a>                selected_key <span class="op">=</span> <span class="st">':'</span>.join(<span class="bu">sorted</span>(selected_species))</span>
<span id="cb231-47"><a href="#cb231-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> selected_key <span class="kw">in</span> seen_combinations:</span>
<span id="cb231-48"><a href="#cb231-48" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb231-49"><a href="#cb231-49" aria-hidden="true" tabindex="-1"></a>                seen_combinations.add(selected_key)</span>
<span id="cb231-50"><a href="#cb231-50" aria-hidden="true" tabindex="-1"></a>                remaining_species <span class="op">=</span> [sp <span class="cf">for</span> sp <span class="kw">in</span> species <span class="cf">if</span> sp <span class="kw">not</span> <span class="kw">in</span> selected_species]</span>
<span id="cb231-51"><a href="#cb231-51" aria-hidden="true" tabindex="-1"></a>                remaining_key <span class="op">=</span> <span class="st">':'</span>.join(<span class="bu">sorted</span>(remaining_species))</span>
<span id="cb231-52"><a href="#cb231-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> remaining_key <span class="kw">in</span> seen_combinations:</span>
<span id="cb231-53"><a href="#cb231-53" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb231-54"><a href="#cb231-54" aria-hidden="true" tabindex="-1"></a>                seen_combinations.add(remaining_key)</span>
<span id="cb231-55"><a href="#cb231-55" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb231-56"><a href="#cb231-56" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> left_tree <span class="kw">in</span> generate_unrooted_binary_trees(remaining_species):</span>
<span id="cb231-57"><a href="#cb231-57" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> right_tree <span class="kw">in</span> generate_unrooted_binary_trees(selected_species):</span>
<span id="cb231-58"><a href="#cb231-58" aria-hidden="true" tabindex="-1"></a>                        trees.append(<span class="ss">f"(</span><span class="sc">{</span>right_tree<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>left_tree<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb231-59"><a href="#cb231-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> trees</span>
<span id="cb231-60"><a href="#cb231-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb231-61"><a href="#cb231-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Unexpected number of species"</span>)</span>
<span id="cb231-62"><a href="#cb231-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-63"><a href="#cb231-63" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"dog cat mouse elephant"</span></span>
<span id="cb231-64"><a href="#cb231-64" aria-hidden="true" tabindex="-1"></a>species_list <span class="op">=</span> input_data.split()</span>
<span id="cb231-65"><a href="#cb231-65" aria-hidden="true" tabindex="-1"></a>root_species <span class="op">=</span> species_list.pop(<span class="dv">0</span>)</span>
<span id="cb231-66"><a href="#cb231-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-67"><a href="#cb231-67" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tree <span class="kw">in</span> generate_unrooted_binary_trees(species_list):</span>
<span id="cb231-68"><a href="#cb231-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"(</span><span class="sc">{</span>tree<span class="sc">}</span><span class="ss">)</span><span class="sc">{</span>root_species<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-the-code-17" class="level2" data-number="77.4">
<h2 data-number="77.4" class="anchored" data-anchor-id="explanation-of-the-code-17"><span class="header-section-number">77.4</span> Explanation of the Code</h2>
<ol type="1">
<li><strong><code>generate_combinations</code> Function</strong>:
<ul>
<li>This function is a recursive implementation to generate all possible combinations of <code>n</code> elements from the given list <code>items</code>.</li>
<li>It works by considering each element (<code>head</code>) and recursively generating combinations with (<code>with_head</code>) and without (<code>without_head</code>) that element.</li>
</ul></li>
<li><strong><code>memoized_combinations</code> Function</strong>:
<ul>
<li>This function leverages memoization to store previously computed combinations to avoid redundant calculations.</li>
<li>It checks if the combination of <code>n</code> and <code>k</code> has already been computed and stored in the <code>cache</code> (a dictionary attached to the function).</li>
<li>If not, it computes the combination using <code>generate_combinations</code> and stores it for future use.</li>
</ul></li>
<li><strong><code>generate_unrooted_binary_trees</code> Function</strong>:
<ul>
<li>This function generates all possible unrooted binary trees for the provided list of species in Newick format.</li>
<li>It uses a recursive approach:
<ul>
<li>If there’s only one species, it simply returns it.</li>
<li>If there are two species, it returns them in a pair.</li>
<li>If there are three or more species, it splits them into subgroups and recursively generates trees for each subgroup, ensuring that each possible tree structure is considered without duplicates.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="genome-assembly-using-reads" class="level1" data-number="78">
<h1 data-number="78"><span class="header-section-number">78</span> Genome Assembly Using Reads</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/directed-cycle/">directed cycle</a>&nbsp;is simply a&nbsp;<a href="https://rosalind.info/glossary/cycle/">cycle</a>&nbsp;in a&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">directed graph</a>&nbsp;in which the&nbsp;<a href="https://rosalind.info/glossary/head/">head</a>&nbsp;of one&nbsp;<a href="https://rosalind.info/glossary/edge/">edge</a>&nbsp;is equal to the&nbsp;<a href="https://rosalind.info/glossary/tail/">tail</a>&nbsp;of the next (so that every edge in the cycle is traversed in the same direction).</p>
<p>For a&nbsp;<a href="https://rosalind.info/glossary/set/">set</a>&nbsp;of&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(S\)</span>&nbsp;and a positive integer&nbsp;<span class="math inline">\(k\)</span>, let&nbsp;<span class="math inline">\(Sk\)</span>&nbsp;denote the collection of all possible&nbsp;<span class="math inline">\(k\)</span>-mers of the strings in&nbsp;<span class="math inline">\(S\)</span>.</p>
<p>Given:&nbsp;A collection&nbsp;<span class="math inline">\(S\)</span>&nbsp;of (error-free)&nbsp;<a href="https://rosalind.info/glossary/read/">reads</a>&nbsp;of equal length (not exceeding 50&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>). In this dataset, for some positive integer&nbsp;<span class="math inline">\(k\)</span>, the&nbsp;<a href="https://rosalind.info/glossary/de-bruijn-graph/">de Bruijn graph</a>&nbsp;<span class="math inline">\(Bk\)</span>&nbsp;on&nbsp;<span class="math inline">\(S_{k+1}∪S^rc_{k+1}\)</span>&nbsp;consists of exactly two&nbsp;<a href="https://rosalind.info/glossary/directed-cycle/">directed cycles</a>.</p>
<p>Return:&nbsp;A cyclic&nbsp;<a href="https://rosalind.info/glossary/superstring/">superstring</a>&nbsp;of minimal length containing every read or its reverse complement.</p>
<section id="sample-dataset-77" class="level2" data-number="78.1">
<h2 data-number="78.1" class="anchored" data-anchor-id="sample-dataset-77"><span class="header-section-number">78.1</span> Sample Dataset</h2>
<pre><code>AATCT
TGTAA
GATTA
ACAGA</code></pre>
</section>
<section id="sample-output-78" class="level2" data-number="78.2">
<h2 data-number="78.2" class="anchored" data-anchor-id="sample-output-78"><span class="header-section-number">78.2</span> Sample Output</h2>
<pre><code>TGTAATC</code></pre>
</section>
<section id="solution-74" class="level2" data-number="78.3">
<h2 data-number="78.3" class="anchored" data-anchor-id="solution-74"><span class="header-section-number">78.3</span> Solution</h2>
<div class="sourceCode" id="cb234"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> chain</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_complement(dna):</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Returns the reverse complement of a given DNA strand."""</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>    translation_table <span class="op">=</span> <span class="bu">str</span>.maketrans(<span class="st">'ATCG'</span>, <span class="st">'TAGC'</span>)</span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dna.translate(translation_table)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_cyclic_superstring(dna_strings):</span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Finds the cyclic superstring from a list of DNA strings and their reverse complements."""</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> flatten_list_of_lists(list_of_lists):</span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Flattens one level of nesting in a list of lists."""</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> chain.from_iterable(list_of_lists)</span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true" tabindex="-1"></a>    num_strings <span class="op">=</span> <span class="bu">len</span>(dna_strings)</span>
<span id="cb234-15"><a href="#cb234-15" aria-hidden="true" tabindex="-1"></a>    string_length <span class="op">=</span> <span class="bu">len</span>(dna_strings[<span class="dv">0</span>])  <span class="co"># Assumes all strings have the same length</span></span>
<span id="cb234-16"><a href="#cb234-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb234-17"><a href="#cb234-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(string_length <span class="op">-</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb234-18"><a href="#cb234-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create adjacency list of k-mers</span></span>
<span id="cb234-19"><a href="#cb234-19" aria-hidden="true" tabindex="-1"></a>        adj_list <span class="op">=</span> <span class="bu">dict</span>(flatten_list_of_lists([</span>
<span id="cb234-20"><a href="#cb234-20" aria-hidden="true" tabindex="-1"></a>            [(dna[i:i<span class="op">+</span>k], dna[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>k<span class="op">+</span><span class="dv">1</span>]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(string_length <span class="op">-</span> k)] </span>
<span id="cb234-21"><a href="#cb234-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> dna <span class="kw">in</span> dna_strings</span>
<span id="cb234-22"><a href="#cb234-22" aria-hidden="true" tabindex="-1"></a>        ]))</span>
<span id="cb234-23"><a href="#cb234-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb234-24"><a href="#cb234-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Start with an arbitrary k-mer and initialize the superstring</span></span>
<span id="cb234-25"><a href="#cb234-25" aria-hidden="true" tabindex="-1"></a>        first_kmer <span class="op">=</span> kmer <span class="op">=</span> <span class="bu">next</span>(<span class="bu">iter</span>(adj_list))</span>
<span id="cb234-26"><a href="#cb234-26" aria-hidden="true" tabindex="-1"></a>        superstring <span class="op">=</span> <span class="st">''</span></span>
<span id="cb234-27"><a href="#cb234-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb234-28"><a href="#cb234-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb234-29"><a href="#cb234-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> kmer <span class="kw">in</span> adj_list:</span>
<span id="cb234-30"><a href="#cb234-30" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add the last character of the k-mer to the superstring</span></span>
<span id="cb234-31"><a href="#cb234-31" aria-hidden="true" tabindex="-1"></a>                superstring <span class="op">+=</span> kmer[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb234-32"><a href="#cb234-32" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Move to the next k-mer in the path</span></span>
<span id="cb234-33"><a href="#cb234-33" aria-hidden="true" tabindex="-1"></a>                kmer <span class="op">=</span> adj_list.pop(kmer)</span>
<span id="cb234-34"><a href="#cb234-34" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If we have returned to the start, we have completed a cycle</span></span>
<span id="cb234-35"><a href="#cb234-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> kmer <span class="op">==</span> first_kmer:</span>
<span id="cb234-36"><a href="#cb234-36" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> superstring</span>
<span id="cb234-37"><a href="#cb234-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb234-38"><a href="#cb234-38" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Exit if no continuation of the k-mer path is found</span></span>
<span id="cb234-39"><a href="#cb234-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb234-40"><a href="#cb234-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-41"><a href="#cb234-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Read and preproces input</span></span>
<span id="cb234-42"><a href="#cb234-42" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb234-43"><a href="#cb234-43" aria-hidden="true" tabindex="-1"></a><span class="st">AATCT</span></span>
<span id="cb234-44"><a href="#cb234-44" aria-hidden="true" tabindex="-1"></a><span class="st">TGTAA</span></span>
<span id="cb234-45"><a href="#cb234-45" aria-hidden="true" tabindex="-1"></a><span class="st">GATTA</span></span>
<span id="cb234-46"><a href="#cb234-46" aria-hidden="true" tabindex="-1"></a><span class="st">ACAGA</span></span>
<span id="cb234-47"><a href="#cb234-47" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb234-48"><a href="#cb234-48" aria-hidden="true" tabindex="-1"></a>dna_strings <span class="op">=</span> sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb234-49"><a href="#cb234-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Add reverse complements of the DNA strings</span></span>
<span id="cb234-50"><a href="#cb234-50" aria-hidden="true" tabindex="-1"></a>dna_strings <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(dna_strings <span class="op">+</span> [reverse_complement(dna) <span class="cf">for</span> dna <span class="kw">in</span> dna_strings]))</span>
<span id="cb234-51"><a href="#cb234-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-52"><a href="#cb234-52" aria-hidden="true" tabindex="-1"></a><span class="co"># Find and print the cyclic superstring</span></span>
<span id="cb234-53"><a href="#cb234-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(find_cyclic_superstring(dna_strings))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-39" class="level2" data-number="78.4">
<h2 data-number="78.4" class="anchored" data-anchor-id="explanation-39"><span class="header-section-number">78.4</span> Explanation</h2>
<ol type="1">
<li><strong>Reverse Complement Function</strong>:
<ul>
<li><code>reverse_complement(dna)</code>: Computes the reverse complement of a DNA sequence. It uses a translation table to map each nucleotide to its complement and then reverses the string.</li>
</ul></li>
<li><strong>Finding Cyclic Superstring</strong>:
<ul>
<li><code>find_cyclic_superstring(dna_strings)</code>: Finds a cyclic superstring from the given list of DNA strings. It:
<ul>
<li>Uses <code>flatten_list_of_lists</code> to flatten a list of lists into a single list.</li>
<li>Iterates over possible lengths of k-mers from the longest (one les than the length of the DNA strings) to 2.</li>
<li>Constructs a De Bruijn graph where edges are k-mers, and vertices are k-1-mers.</li>
<li>Tries to find a cyclic path in the graph that returns to the starting k-mer and constructs the superstring from this path.</li>
</ul></li>
</ul></li>
<li><strong>Input Processing</strong>:
<ul>
<li><code>sample_input</code>: Defines a sample input containing multiple DNA strings.</li>
<li><code>dna_strings</code>: Converts the input into a list of DNA strings and adds their reverse complements to handle both possible orientations.</li>
</ul></li>
<li><strong>Finding and Printing the Superstring</strong>:
<ul>
<li>Calls <code>find_cyclic_superstring</code> with the DNA strings (including their reverse complements) to find the cyclic superstring and prints the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="global-alignment-with-constant-gap-penalty" class="level1" data-number="79">
<h1 data-number="79"><span class="header-section-number">79</span> Global Alignment with Constant Gap Penalty</h1>
<p>In a&nbsp;<a href="https://rosalind.info/glossary/constant-gap-penalty/">constant gap penalty</a>, every gap receives some predetermined constant penalty, regardles of its length. Thus, the insertion or deletion of 1000 contiguous symbols is penalized equally to that of a single symbol.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each of length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The maximum alignment score between&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. Use:</p>
<ul>
<li>The&nbsp;<a href="https://rosalind.info/glossary/blosum62/">BLOSUM62</a>&nbsp;scoring matrix.</li>
<li><a href="https://rosalind.info/glossary/constant-gap-penalty/">Constant gap penalty</a>&nbsp;equal to 5.</li>
</ul>
<section id="sample-dataset-78" class="level2" data-number="79.1">
<h2 data-number="79.1" class="anchored" data-anchor-id="sample-dataset-78"><span class="header-section-number">79.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_79
PLEASANTLY
&gt;Rosalind_41
MEANLY</code></pre>
</section>
<section id="sample-output-79" class="level2" data-number="79.2">
<h2 data-number="79.2" class="anchored" data-anchor-id="sample-output-79"><span class="header-section-number">79.2</span> Sample Output</h2>
<pre><code>13</code></pre>
</section>
<section id="solution-75" class="level2" data-number="79.3">
<h2 data-number="79.3" class="anchored" data-anchor-id="solution-75"><span class="header-section-number">79.3</span> Solution</h2>
<div class="sourceCode" id="cb237"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>BLOSUM62 <span class="op">=</span> {</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'F'</span>): <span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'T'</span>): <span class="dv">0</span>,</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Q'</span>, <span class="st">'Q'</span>): <span class="dv">5</span>, (<span class="st">'N'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Q'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'H'</span>): <span class="dv">8</span>, (<span class="st">'S'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'H'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'B'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'Y'</span>): <span class="dv">7</span>,</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'Z'</span>): <span class="dv">4</span>,</span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'C'</span>, <span class="st">'C'</span>): <span class="dv">9</span>, (<span class="st">'M'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'P'</span>): <span class="dv">7</span>, (<span class="st">'V'</span>, <span class="st">'I'</span>): <span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'M'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'K'</span>): <span class="dv">5</span>, (<span class="st">'P'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'I'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'F'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-15"><a href="#cb237-15" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-16"><a href="#cb237-16" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'X'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'K'</span>): <span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-17"><a href="#cb237-17" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'D'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'K'</span>): <span class="dv">0</span>,</span>
<span id="cb237-18"><a href="#cb237-18" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'X'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'I'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'T'</span>): <span class="dv">0</span>,</span>
<span id="cb237-19"><a href="#cb237-19" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'M'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-20"><a href="#cb237-20" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'S'</span>): <span class="dv">4</span>, (<span class="st">'L'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Q'</span>, <span class="st">'R'</span>): <span class="dv">1</span>,</span>
<span id="cb237-21"><a href="#cb237-21" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'N'</span>, <span class="st">'N'</span>): <span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-22"><a href="#cb237-22" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'L'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-23"><a href="#cb237-23" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'Q'</span>, <span class="st">'N'</span>): <span class="dv">0</span>,</span>
<span id="cb237-24"><a href="#cb237-24" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'N'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-25"><a href="#cb237-25" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'F'</span>): <span class="dv">3</span>, (<span class="st">'C'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'V'</span>, <span class="st">'L'</span>): <span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-26"><a href="#cb237-26" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'R'</span>): <span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'D'</span>): <span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-27"><a href="#cb237-27" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'M'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'C'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-28"><a href="#cb237-28" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-29"><a href="#cb237-29" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'K'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-30"><a href="#cb237-30" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-31"><a href="#cb237-31" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'V'</span>): <span class="dv">4</span>, (<span class="st">'M'</span>, <span class="st">'I'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb237-32"><a href="#cb237-32" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'M'</span>): <span class="dv">5</span>, (<span class="st">'K'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-33"><a href="#cb237-33" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'D'</span>): <span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'D'</span>): <span class="dv">0</span>,</span>
<span id="cb237-34"><a href="#cb237-34" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'H'</span>): <span class="dv">0</span>,</span>
<span id="cb237-35"><a href="#cb237-35" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'B'</span>, <span class="st">'H'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'F'</span>): <span class="dv">6</span>, (<span class="st">'X'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-36"><a href="#cb237-36" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'D'</span>): <span class="dv">4</span>, (<span class="st">'D'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'S'</span>): <span class="dv">0</span>,</span>
<span id="cb237-37"><a href="#cb237-37" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'W'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'V'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-38"><a href="#cb237-38" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'W'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'N'</span>): <span class="dv">1</span>,</span>
<span id="cb237-39"><a href="#cb237-39" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'T'</span>): <span class="dv">5</span>, (<span class="st">'S'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb237-40"><a href="#cb237-40" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'B'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'N'</span>): <span class="dv">1</span>,</span>
<span id="cb237-41"><a href="#cb237-41" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'L'</span>): <span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'Q'</span>): <span class="dv">2</span>,</span>
<span id="cb237-42"><a href="#cb237-42" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-43"><a href="#cb237-43" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'W'</span>): <span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'E'</span>): <span class="dv">5</span>,</span>
<span id="cb237-44"><a href="#cb237-44" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-45"><a href="#cb237-45" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-46"><a href="#cb237-46" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'Q'</span>): <span class="dv">1</span>, (<span class="st">'R'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-47"><a href="#cb237-47" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'I'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-48"><a href="#cb237-48" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'W'</span>): <span class="dv">11</span>, (<span class="st">'M'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-49"><a href="#cb237-49" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'L'</span>): <span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'E'</span>): <span class="dv">4</span>,</span>
<span id="cb237-50"><a href="#cb237-50" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-51"><a href="#cb237-51" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'B'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-52"><a href="#cb237-52" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'Q'</span>): <span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'Z'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-53"><a href="#cb237-53" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-54"><a href="#cb237-54" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'D'</span>): <span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-55"><a href="#cb237-55" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'W'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'H'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>,</span>
<span id="cb237-56"><a href="#cb237-56" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'W'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'S'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb237-57"><a href="#cb237-57" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb237-58"><a href="#cb237-58" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'H'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'H'</span>): <span class="dv">2</span>,</span>
<span id="cb237-59"><a href="#cb237-59" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'G'</span>): <span class="dv">6</span>,</span>
<span id="cb237-60"><a href="#cb237-60" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-61"><a href="#cb237-61" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'A'</span>): <span class="dv">4</span>, (<span class="st">'P'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-62"><a href="#cb237-62" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-63"><a href="#cb237-63" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'C'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-64"><a href="#cb237-64" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'I'</span>, <span class="st">'I'</span>): <span class="dv">4</span>, (<span class="st">'P'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb237-65"><a href="#cb237-65" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-66"><a href="#cb237-66" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'I'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'R'</span>, <span class="st">'R'</span>): <span class="dv">5</span>, (<span class="st">'X'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-67"><a href="#cb237-67" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'I'</span>): <span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'B'</span>): <span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-68"><a href="#cb237-68" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'N'</span>): <span class="dv">3</span>,</span>
<span id="cb237-69"><a href="#cb237-69" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb237-70"><a href="#cb237-70" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'L'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'B'</span>): <span class="dv">4</span></span>
<span id="cb237-71"><a href="#cb237-71" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb237-72"><a href="#cb237-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-73"><a href="#cb237-73" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_string):</span>
<span id="cb237-74"><a href="#cb237-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse the input FASTA format string into individual sequences."""</span></span>
<span id="cb237-75"><a href="#cb237-75" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb237-76"><a href="#cb237-76" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> <span class="st">""</span></span>
<span id="cb237-77"><a href="#cb237-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb237-78"><a href="#cb237-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb237-79"><a href="#cb237-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sequence:</span>
<span id="cb237-80"><a href="#cb237-80" aria-hidden="true" tabindex="-1"></a>                sequences.append(current_sequence)</span>
<span id="cb237-81"><a href="#cb237-81" aria-hidden="true" tabindex="-1"></a>            current_sequence <span class="op">=</span> <span class="st">""</span></span>
<span id="cb237-82"><a href="#cb237-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb237-83"><a href="#cb237-83" aria-hidden="true" tabindex="-1"></a>            current_sequence <span class="op">+=</span> line.strip()</span>
<span id="cb237-84"><a href="#cb237-84" aria-hidden="true" tabindex="-1"></a>    sequences.append(current_sequence)  <span class="co"># Append the last sequence</span></span>
<span id="cb237-85"><a href="#cb237-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb237-86"><a href="#cb237-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-87"><a href="#cb237-87" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> global_alignment_with_gap_penalty(seq1, seq2):</span>
<span id="cb237-88"><a href="#cb237-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute the global alignment score between two sequences with gap penalties."""</span></span>
<span id="cb237-89"><a href="#cb237-89" aria-hidden="true" tabindex="-1"></a>    seq1 <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> seq1  <span class="co"># Add a leading gap for alignment</span></span>
<span id="cb237-90"><a href="#cb237-90" aria-hidden="true" tabindex="-1"></a>    seq2 <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> seq2  <span class="co"># Add a leading gap for alignment</span></span>
<span id="cb237-91"><a href="#cb237-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-92"><a href="#cb237-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize scoring matrices</span></span>
<span id="cb237-93"><a href="#cb237-93" aria-hidden="true" tabindex="-1"></a>    lower_matrix <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2))] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1))]</span>
<span id="cb237-94"><a href="#cb237-94" aria-hidden="true" tabindex="-1"></a>    middle_matrix <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2))] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1))]</span>
<span id="cb237-95"><a href="#cb237-95" aria-hidden="true" tabindex="-1"></a>    upper_matrix <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2))] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1))]</span>
<span id="cb237-96"><a href="#cb237-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-97"><a href="#cb237-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set gap penalties for the first row and column</span></span>
<span id="cb237-98"><a href="#cb237-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq2)):</span>
<span id="cb237-99"><a href="#cb237-99" aria-hidden="true" tabindex="-1"></a>        lower_matrix[<span class="dv">0</span>][col] <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb237-100"><a href="#cb237-100" aria-hidden="true" tabindex="-1"></a>        middle_matrix[<span class="dv">0</span>][col] <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb237-101"><a href="#cb237-101" aria-hidden="true" tabindex="-1"></a>        upper_matrix[<span class="dv">0</span>][col] <span class="op">=</span> <span class="op">-</span><span class="dv">50</span></span>
<span id="cb237-102"><a href="#cb237-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-103"><a href="#cb237-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq1)):</span>
<span id="cb237-104"><a href="#cb237-104" aria-hidden="true" tabindex="-1"></a>        lower_matrix[row][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb237-105"><a href="#cb237-105" aria-hidden="true" tabindex="-1"></a>        middle_matrix[row][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb237-106"><a href="#cb237-106" aria-hidden="true" tabindex="-1"></a>        upper_matrix[row][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">50</span></span>
<span id="cb237-107"><a href="#cb237-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-108"><a href="#cb237-108" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the scoring matrices</span></span>
<span id="cb237-109"><a href="#cb237-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq2)):</span>
<span id="cb237-110"><a href="#cb237-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq1)):</span>
<span id="cb237-111"><a href="#cb237-111" aria-hidden="true" tabindex="-1"></a>            lower_matrix[row][col] <span class="op">=</span> <span class="bu">max</span>(lower_matrix[row <span class="op">-</span> <span class="dv">1</span>][col], middle_matrix[row <span class="op">-</span> <span class="dv">1</span>][col] <span class="op">-</span> <span class="dv">5</span>)</span>
<span id="cb237-112"><a href="#cb237-112" aria-hidden="true" tabindex="-1"></a>            upper_matrix[row][col] <span class="op">=</span> <span class="bu">max</span>(upper_matrix[row][col <span class="op">-</span> <span class="dv">1</span>], middle_matrix[row][col <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> <span class="dv">5</span>)</span>
<span id="cb237-113"><a href="#cb237-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-114"><a href="#cb237-114" aria-hidden="true" tabindex="-1"></a>            pair <span class="op">=</span> (seq1[row], seq2[col])</span>
<span id="cb237-115"><a href="#cb237-115" aria-hidden="true" tabindex="-1"></a>            reverse_pair <span class="op">=</span> (seq2[col], seq1[row])</span>
<span id="cb237-116"><a href="#cb237-116" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> BLOSUM62.get(pair, BLOSUM62.get(reverse_pair, <span class="dv">0</span>))</span>
<span id="cb237-117"><a href="#cb237-117" aria-hidden="true" tabindex="-1"></a>            middle_matrix[row][col] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb237-118"><a href="#cb237-118" aria-hidden="true" tabindex="-1"></a>                lower_matrix[row][col],</span>
<span id="cb237-119"><a href="#cb237-119" aria-hidden="true" tabindex="-1"></a>                middle_matrix[row <span class="op">-</span> <span class="dv">1</span>][col <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb237-120"><a href="#cb237-120" aria-hidden="true" tabindex="-1"></a>                upper_matrix[row][col]</span>
<span id="cb237-121"><a href="#cb237-121" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb237-122"><a href="#cb237-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-123"><a href="#cb237-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> middle_matrix[<span class="bu">len</span>(seq1) <span class="op">-</span> <span class="dv">1</span>][<span class="bu">len</span>(seq2) <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb237-124"><a href="#cb237-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-125"><a href="#cb237-125" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb237-126"><a href="#cb237-126" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""&gt;Rosalind_79</span></span>
<span id="cb237-127"><a href="#cb237-127" aria-hidden="true" tabindex="-1"></a><span class="st">PLEASANTLY</span></span>
<span id="cb237-128"><a href="#cb237-128" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_41</span></span>
<span id="cb237-129"><a href="#cb237-129" aria-hidden="true" tabindex="-1"></a><span class="st">MEANLY</span></span>
<span id="cb237-130"><a href="#cb237-130" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb237-131"><a href="#cb237-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-132"><a href="#cb237-132" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input FASTA format data</span></span>
<span id="cb237-133"><a href="#cb237-133" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb237-134"><a href="#cb237-134" aria-hidden="true" tabindex="-1"></a>sequence1, sequence2 <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb237-135"><a href="#cb237-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-136"><a href="#cb237-136" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the global alignment score</span></span>
<span id="cb237-137"><a href="#cb237-137" aria-hidden="true" tabindex="-1"></a>alignment_score <span class="op">=</span> global_alignment_with_gap_penalty(sequence1, sequence2)</span>
<span id="cb237-138"><a href="#cb237-138" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(alignment_score)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The code computes the global alignment score between two sequences using a scoring matrix (BLOSUM62) and gap penalties. This involves parsing FASTA formatted sequence data, initializing scoring matrices for dynamic programming, and then filling these matrices to calculate the alignment score.</p>
</section>
<section id="parse_fastafasta_string" class="level2" data-number="79.4">
<h2 data-number="79.4" class="anchored" data-anchor-id="parse_fastafasta_string"><span class="header-section-number">79.4</span> 1. <code>parse_fasta(fasta_string)</code></h2>
<p><strong>Purpose</strong>: Parses a FASTA format string into individual sequences.</p>
<p><strong>How it works</strong>: - <strong>Input</strong>: A FASTA format string where sequences are prefixed with a <code>&gt;</code> character. - <strong>Output</strong>: A list of sequences.</p>
<p><strong>Steps</strong>: 1. Initialize an empty list <code>sequences</code> to store parsed sequences. 2. Initialize an empty string <code>current_sequence</code> to build sequences as you read the input. 3. Split the input string into lines and iterate through them: - If a line starts with <code>&gt;</code>, it indicates the start of a new sequence. Append the current sequence to <code>sequences</code> if it’s not empty, then reset <code>current_sequence</code>. - Otherwise, append the line (after stripping whitespace) to <code>current_sequence</code>. 4. Append the last sequence after exiting the loop. 5. Return the list of sequences.</p>
</section>
<section id="global_alignment_with_gap_penaltyseq1-seq2" class="level2" data-number="79.5">
<h2 data-number="79.5" class="anchored" data-anchor-id="global_alignment_with_gap_penaltyseq1-seq2"><span class="header-section-number">79.5</span> 2. <code>global_alignment_with_gap_penalty(seq1, seq2)</code></h2>
<p><strong>Purpose</strong>: Computes the global alignment score between two sequences using a dynamic programming approach with gap penalties.</p>
<p><strong>How it works</strong>: - <strong>Input</strong>: Two sequences, <code>seq1</code> and <code>seq2</code>. - <strong>Output</strong>: The alignment score for the sequences.</p>
<p><strong>Steps</strong>: 1. <strong>Initialize Sequences</strong>: - Prepend a gap (<code>-</code>) to both sequences to handle gaps at the start of alignments.</p>
<ol start="2" type="1">
<li><strong>Initialize Matrices</strong>:
<ul>
<li><code>lower_matrix</code>, <code>middle_matrix</code>, <code>upper_matrix</code> are 2D lists used to store scores during alignment:
<ul>
<li><code>lower_matrix</code> tracks scores when aligning with gaps in <code>seq2</code>.</li>
<li><code>upper_matrix</code> tracks scores when aligning with gaps in <code>seq1</code>.</li>
<li><code>middle_matrix</code> stores the scores for the current alignment considering both sequences.</li>
</ul></li>
</ul></li>
<li><strong>Set Initial Gap Penalties</strong>:
<ul>
<li>For the first row (aligning gaps in <code>seq1</code> with the second sequence), initialize with gap penalties of <code>-5</code> for <code>lower_matrix</code> and <code>middle_matrix</code>, and a larger penalty <code>-50</code> for <code>upper_matrix</code>.</li>
<li>For the first column (aligning gaps in <code>seq2</code> with the first sequence), use similar penalties.</li>
</ul></li>
<li><strong>Fill Matrices</strong>:
<ul>
<li>Use nested loops to fill the matrices:
<ul>
<li><strong>Lower Matrix</strong>: Computes scores for gaps in <code>seq2</code>.</li>
<li><strong>Upper Matrix</strong>: Computes scores for gaps in <code>seq1</code>.</li>
<li><strong>Middle Matrix</strong>: Computes scores for aligning characters in <code>seq1</code> and <code>seq2</code>.
<ul>
<li>Retrieve the score from <code>BLOSUM62</code> for the pair of characters.</li>
<li>Use the maximum of the scores from <code>lower_matrix</code>, <code>middle_matrix</code>, and <code>upper_matrix</code> to fill in <code>middle_matrix</code>.</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Retrieve Final Score</strong>:
<ul>
<li>The final alignment score is in <code>middle_matrix[len(seq1) - 1][len(seq2) - 1]</code>, which represents the best alignment score for the entire length of both sequences.</li>
</ul></li>
</ol>
</section>
</section>
<section id="inferring-genotype-from-a-pedigree" class="level1" data-number="80">
<h1 data-number="80"><span class="header-section-number">80</span> Inferring Genotype from a Pedigree</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/rooted-binary-tree/">rooted binary tree</a>&nbsp;can be used to model the pedigree of an individual. In this case, rather than time progressing from the&nbsp;<a href="https://rosalind.info/glossary/root/">root</a>&nbsp;to the&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>, the tree is viewed upside down with time progressing from an individual’s ancestors (at the leaves) to the individual (at the root).</p>
<p>An example of a pedigree for a single&nbsp;<a href="https://rosalind.info/glossary/factor/">factor</a>&nbsp;in which only the genotypes of ancestors are given.</p>
<p>Given:&nbsp;A rooted binary tree&nbsp;<span class="math inline">\(T\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>&nbsp;encoding an individual’s pedigree for a Mendelian factor whose alleles are A (dominant) and a (recessive).</p>
<p>Return:&nbsp;Three numbers between 0 and 1, corresponding to the respective probabilities that the individual at the root of&nbsp;<span class="math inline">\(T\)</span>&nbsp;will exhibit the “AA”, “Aa” and “aa” genotypes.</p>
<section id="sample-dataset-79" class="level2" data-number="80.1">
<h2 data-number="80.1" class="anchored" data-anchor-id="sample-dataset-79"><span class="header-section-number">80.1</span> Sample Dataset</h2>
<pre><code>((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);</code></pre>
</section>
<section id="sample-output-80" class="level2" data-number="80.2">
<h2 data-number="80.2" class="anchored" data-anchor-id="sample-output-80"><span class="header-section-number">80.2</span> Sample Output</h2>
<pre><code>0.156 0.5 0.344</code></pre>
</section>
<section id="solution-76" class="level2" data-number="80.3">
<h2 data-number="80.3" class="anchored" data-anchor-id="solution-76"><span class="header-section-number">80.3</span> Solution</h2>
<div class="sourceCode" id="cb240"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Probabilities from an individual's ancestors (based on Mendelian inheritance)</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>prob_dict <span class="op">=</span> {</span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"AA"</span>, <span class="st">"AA"</span>): (<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>),</span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"AA"</span>, <span class="st">"Aa"</span>): (<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.0</span>),</span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"AA"</span>, <span class="st">"aa"</span>): (<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>),</span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"Aa"</span>, <span class="st">"AA"</span>): (<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.0</span>),</span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"Aa"</span>, <span class="st">"Aa"</span>): (<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.25</span>),</span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"Aa"</span>, <span class="st">"aa"</span>): (<span class="fl">0.0</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>),</span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"aa"</span>, <span class="st">"AA"</span>): (<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>),</span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"aa"</span>, <span class="st">"Aa"</span>): (<span class="fl">0.0</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>),</span>
<span id="cb240-11"><a href="#cb240-11" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"aa"</span>, <span class="st">"aa"</span>): (<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb240-12"><a href="#cb240-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb240-13"><a href="#cb240-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-14"><a href="#cb240-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_child_probabilities(parent1, parent2):</span>
<span id="cb240-15"><a href="#cb240-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb240-16"><a href="#cb240-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Given the genotype probabilities of two parents, calculate the probabilities for the child.</span></span>
<span id="cb240-17"><a href="#cb240-17" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb240-18"><a href="#cb240-18" aria-hidden="true" tabindex="-1"></a><span class="co">    :param parent1: Dictionary containing the probabilities for the first parent (keys: 'AA', 'Aa', 'aa')</span></span>
<span id="cb240-19"><a href="#cb240-19" aria-hidden="true" tabindex="-1"></a><span class="co">    :param parent2: Dictionary containing the probabilities for the second parent (keys: 'AA', 'Aa', 'aa')</span></span>
<span id="cb240-20"><a href="#cb240-20" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Dictionary containing the probabilities for the child (keys: 'AA', 'Aa', 'aa')</span></span>
<span id="cb240-21"><a href="#cb240-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb240-22"><a href="#cb240-22" aria-hidden="true" tabindex="-1"></a>    child_prob <span class="op">=</span> {<span class="st">"AA"</span>: <span class="fl">0.0</span>, <span class="st">"Aa"</span>: <span class="fl">0.0</span>, <span class="st">"aa"</span>: <span class="fl">0.0</span>}</span>
<span id="cb240-23"><a href="#cb240-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb240-24"><a href="#cb240-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine the genotype probabilities from both parents using the Mendelian inheritance rules</span></span>
<span id="cb240-25"><a href="#cb240-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p1_genotype, p1_prob <span class="kw">in</span> parent1.items():</span>
<span id="cb240-26"><a href="#cb240-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p2_genotype, p2_prob <span class="kw">in</span> parent2.items():</span>
<span id="cb240-27"><a href="#cb240-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Look up the probability distribution for the child based on the parent genotypes</span></span>
<span id="cb240-28"><a href="#cb240-28" aria-hidden="true" tabindex="-1"></a>            child_distribution <span class="op">=</span> prob_dict[(p1_genotype, p2_genotype)]</span>
<span id="cb240-29"><a href="#cb240-29" aria-hidden="true" tabindex="-1"></a>            child_prob[<span class="st">"AA"</span>] <span class="op">+=</span> p1_prob <span class="op">*</span> p2_prob <span class="op">*</span> child_distribution[<span class="dv">0</span>]</span>
<span id="cb240-30"><a href="#cb240-30" aria-hidden="true" tabindex="-1"></a>            child_prob[<span class="st">"Aa"</span>] <span class="op">+=</span> p1_prob <span class="op">*</span> p2_prob <span class="op">*</span> child_distribution[<span class="dv">1</span>]</span>
<span id="cb240-31"><a href="#cb240-31" aria-hidden="true" tabindex="-1"></a>            child_prob[<span class="st">"aa"</span>] <span class="op">+=</span> p1_prob <span class="op">*</span> p2_prob <span class="op">*</span> child_distribution[<span class="dv">2</span>]</span>
<span id="cb240-32"><a href="#cb240-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb240-33"><a href="#cb240-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> child_prob</span>
<span id="cb240-34"><a href="#cb240-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-35"><a href="#cb240-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Known genotype probabilities for the leaves (ancestral individuals)</span></span>
<span id="cb240-36"><a href="#cb240-36" aria-hidden="true" tabindex="-1"></a>AA <span class="op">=</span> {<span class="st">"AA"</span>: <span class="fl">1.0</span>, <span class="st">"Aa"</span>: <span class="fl">0.0</span>, <span class="st">"aa"</span>: <span class="fl">0.0</span>}</span>
<span id="cb240-37"><a href="#cb240-37" aria-hidden="true" tabindex="-1"></a>Aa <span class="op">=</span> {<span class="st">"AA"</span>: <span class="fl">0.0</span>, <span class="st">"Aa"</span>: <span class="fl">1.0</span>, <span class="st">"aa"</span>: <span class="fl">0.0</span>}</span>
<span id="cb240-38"><a href="#cb240-38" aria-hidden="true" tabindex="-1"></a>aa <span class="op">=</span> {<span class="st">"AA"</span>: <span class="fl">0.0</span>, <span class="st">"Aa"</span>: <span class="fl">0.0</span>, <span class="st">"aa"</span>: <span class="fl">1.0</span>}</span>
<span id="cb240-39"><a href="#cb240-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-40"><a href="#cb240-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Pedigree input in Newick format</span></span>
<span id="cb240-41"><a href="#cb240-41" aria-hidden="true" tabindex="-1"></a>pedigree <span class="op">=</span> <span class="st">"((((Aa,aa),(Aa,Aa)),((aa,aa),(aa,AA))),Aa);"</span></span>
<span id="cb240-42"><a href="#cb240-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-43"><a href="#cb240-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Modify the Newick string to turn it into a Python expression using the `calculate_child_probabilities` function</span></span>
<span id="cb240-44"><a href="#cb240-44" aria-hidden="true" tabindex="-1"></a>pedigree_expression <span class="op">=</span> pedigree.replace(<span class="st">";"</span>, <span class="st">""</span>).replace(<span class="st">"("</span>, <span class="st">"calculate_child_probabilities("</span>)</span>
<span id="cb240-45"><a href="#cb240-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-46"><a href="#cb240-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate the expression to calculate the probabilities for the root individual</span></span>
<span id="cb240-47"><a href="#cb240-47" aria-hidden="true" tabindex="-1"></a>root_probabilities <span class="op">=</span> <span class="bu">eval</span>(pedigree_expression)</span>
<span id="cb240-48"><a href="#cb240-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-49"><a href="#cb240-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the final probabilities for the root individual</span></span>
<span id="cb240-50"><a href="#cb240-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>root_probabilities[<span class="st">'AA'</span>]<span class="sc">:f}</span><span class="ss"> </span><span class="sc">{</span>root_probabilities[<span class="st">'Aa'</span>]<span class="sc">:f}</span><span class="ss"> </span><span class="sc">{</span>root_probabilities[<span class="st">'aa'</span>]<span class="sc">:f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-40" class="level2" data-number="80.4">
<h2 data-number="80.4" class="anchored" data-anchor-id="explanation-40"><span class="header-section-number">80.4</span> Explanation</h2>
<ol type="1">
<li><strong><code>prob_dict</code></strong>:
<ul>
<li>This dictionary contains the Mendelian inheritance probabilities for a child given the genotypes of both parents. Each tuple of parent genotypes maps to a tuple of probabilities representing the likelihood of the child being <code>AA</code>, <code>Aa</code>, or <code>aa</code>.</li>
</ul></li>
<li><strong><code>calculate_child_probabilities</code></strong>:
<ul>
<li>This function calculates the probabilities for a child’s genotype based on the genotype probabilities of their two parents.</li>
<li>It iterates over all combinations of the parents’ genotypes, looks up the probabilities from <code>prob_dict</code>, and accumulates the resulting probabilities for the child.</li>
</ul></li>
<li><strong>Leaf Node Probabilities</strong>:
<ul>
<li>The genotype probabilities for the leaf nodes (the known ancestors) are defined:
<ul>
<li><code>AA</code>: 100% chance of being <code>AA</code></li>
<li><code>Aa</code>: 100% chance of being <code>Aa</code></li>
<li><code>aa</code>: 100% chance of being <code>aa</code></li>
</ul></li>
</ul></li>
<li><strong>Pedigree Parsing</strong>:
<ul>
<li>The input pedigree is provided in Newick format. This format is transformed into a Python expression that can be evaluated using <code>eval</code>. The key part of this transformation is replacing the <code>(</code> characters with calls to the <code>calculate_child_probabilities</code> function. This allows the pedigree to be evaluated as a nested set of function calls, starting from the leaves and working up to the root.</li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>The program evaluates the pedigree, calculating the probabilities of the root individual being <code>AA</code>, <code>Aa</code>, or <code>aa</code>. These probabilities are then printed to three decimal places.</li>
</ul></li>
</ol>
</section>
</section>
<section id="linguistic-complexity-of-a-genome" class="level1" data-number="81">
<h1 data-number="81"><span class="header-section-number">81</span> Linguistic Complexity of a Genome</h1>
<p>Given a length&nbsp;n&nbsp;string&nbsp;s formed over an&nbsp;<a href="https://rosalind.info/glossary/alphabet/">alphabet</a>&nbsp;<span class="math inline">\(𝒜\)</span>&nbsp;of size&nbsp;aa, let the “substring count”&nbsp;<span class="math inline">\(sub(s)\)</span>&nbsp;denote the total number of distinct substrings of&nbsp;<span class="math inline">\(s\)</span>. Furthermore, let the “maximum substring count”&nbsp;<span class="math inline">\(m(a,n)\)</span>&nbsp;denote the maximum number of distinct substrings that could appear in a string of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;formed over&nbsp;<span class="math inline">\(𝒜\)</span>.</p>
<p>The&nbsp;<a href="https://rosalind.info/glossary/linguistic-complexity/">linguistic complexity</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;(written&nbsp;<span class="math inline">\(lc(s)\)</span>) is equal to&nbsp;<span class="math inline">\(\frac{sub(s)}{m(a,n)}\)</span>; in other words,&nbsp;<span class="math inline">\(lc(s)\)</span>&nbsp;represents the percentage of observed substrings of&nbsp;s to the total number that are theoretically possible. Note that&nbsp;<span class="math inline">\(0&lt;lc(s)&lt;1\)</span>, with smaller values of&nbsp;<span class="math inline">\(lc(s)\)</span>&nbsp;indicating that&nbsp;s is more repetitive.</p>
<p>As an example, consider the&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;(<span class="math inline">\(a=4\)</span>)&nbsp;<span class="math inline">\(s=ATTTGGATT\)</span>. In the following table, we demonstrate that&nbsp;<span class="math inline">\(lc(s)=\frac{35}{40}=0.875\)</span>&nbsp;by considering the number of observed and possible length&nbsp;<span class="math inline">\(k\)</span>&nbsp;substrings of&nbsp;<span class="math inline">\(s\)</span>, which are denoted by&nbsp;<span class="math inline">\(subk(s)\)</span>&nbsp;and&nbsp;<span class="math inline">\(m(a,k,n)\)</span>, respectively. (Observe that&nbsp;<span class="math inline">\(m(a,n)=/sum^n_{k=1}m(a,k,n)=40\)</span>&nbsp;and&nbsp;<span class="math inline">\(sub(s)=/sum^n_{k=1}subk(s)=35\)</span>)</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>kk</td>
<td>subk(s)subk(s)</td>
<td>m(a,k,n)m(a,k,n)</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2</td>
<td>5</td>
<td>8</td>
</tr>
<tr class="even">
<td>3</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="odd">
<td>4</td>
<td>6</td>
<td>6</td>
</tr>
<tr class="even">
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="odd">
<td>6</td>
<td>4</td>
<td>4</td>
</tr>
<tr class="even">
<td>7</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>8</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>9</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>35</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>Given:&nbsp;A DNA string&nbsp;s of length at most 100&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;The linguistic complexity&nbsp;lc(s)lc(s).</p>
<section id="sample-dataset-80" class="level2" data-number="81.1">
<h2 data-number="81.1" class="anchored" data-anchor-id="sample-dataset-80"><span class="header-section-number">81.1</span> Sample Dataset</h2>
<pre><code>ATTTGGATT</code></pre>
</section>
<section id="sample-output-81" class="level2" data-number="81.2">
<h2 data-number="81.2" class="anchored" data-anchor-id="sample-output-81"><span class="header-section-number">81.2</span> Sample Output</h2>
<pre><code>0.875</code></pre>
</section>
<section id="solution-77" class="level2" data-number="81.3">
<h2 data-number="81.3" class="anchored" data-anchor-id="solution-77"><span class="header-section-number">81.3</span> Solution</h2>
<div class="sourceCode" id="cb243"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> log</span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>clas SuffixTree:</span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Creates a suffix tree for the provided word.'''</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_word):</span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Initializes the suffix tree.'''</span></span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> [<span class="va">self</span>.Node(<span class="va">None</span>, <span class="dv">0</span>)]</span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.descendants_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(input_word, <span class="bu">str</span>):</span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.build_suffix_tree(input_word)</span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true" tabindex="-1"></a>    clas Node(<span class="bu">object</span>):</span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Suffix tree node class.'''</span></span>
<span id="cb243-17"><a href="#cb243-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, parent_node, node_number):</span>
<span id="cb243-18"><a href="#cb243-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> parent_node</span>
<span id="cb243-19"><a href="#cb243-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.number <span class="op">=</span> node_number</span>
<span id="cb243-20"><a href="#cb243-20" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb243-21"><a href="#cb243-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-22"><a href="#cb243-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> add_child(<span class="va">self</span>, child_node):</span>
<span id="cb243-23"><a href="#cb243-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.append(child_node)</span>
<span id="cb243-24"><a href="#cb243-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-25"><a href="#cb243-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> remove_child(<span class="va">self</span>, child_node):</span>
<span id="cb243-26"><a href="#cb243-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.remove(child_node)</span>
<span id="cb243-27"><a href="#cb243-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-28"><a href="#cb243-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> update_parent(<span class="va">self</span>, new_parent):</span>
<span id="cb243-29"><a href="#cb243-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> new_parent</span>
<span id="cb243-30"><a href="#cb243-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-31"><a href="#cb243-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_suffix_tree(<span class="va">self</span>, input_word):</span>
<span id="cb243-32"><a href="#cb243-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Build the suffix tree from the input word.'''</span></span>
<span id="cb243-33"><a href="#cb243-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> input_word[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> <span class="st">'$'</span>:</span>
<span id="cb243-34"><a href="#cb243-34" aria-hidden="true" tabindex="-1"></a>            input_word <span class="op">+=</span> <span class="st">'$'</span></span>
<span id="cb243-35"><a href="#cb243-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.word <span class="op">=</span> input_word</span>
<span id="cb243-36"><a href="#cb243-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.length <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.word)</span>
<span id="cb243-37"><a href="#cb243-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-38"><a href="#cb243-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.length):</span>
<span id="cb243-39"><a href="#cb243-39" aria-hidden="true" tabindex="-1"></a>            parent_node, edge_start, overlap_exists <span class="op">=</span> <span class="va">self</span>.find_insert_position(i, <span class="va">self</span>.nodes[<span class="dv">0</span>])</span>
<span id="cb243-40"><a href="#cb243-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-41"><a href="#cb243-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> overlap_exists:</span>
<span id="cb243-42"><a href="#cb243-42" aria-hidden="true" tabindex="-1"></a>                old_edge_start, old_edge_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)]</span>
<span id="cb243-43"><a href="#cb243-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-44"><a href="#cb243-44" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Determine the length of the edge to be inserted</span></span>
<span id="cb243-45"><a href="#cb243-45" aria-hidden="true" tabindex="-1"></a>                insertion_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb243-46"><a href="#cb243-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> input_word[edge_start:edge_start <span class="op">+</span> insertion_length] <span class="op">==</span> input_word[old_edge_start:old_edge_start <span class="op">+</span> insertion_length]:</span>
<span id="cb243-47"><a href="#cb243-47" aria-hidden="true" tabindex="-1"></a>                    insertion_length <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb243-48"><a href="#cb243-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-49"><a href="#cb243-49" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create a new node for the insertion</span></span>
<span id="cb243-50"><a href="#cb243-50" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node.parent, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb243-51"><a href="#cb243-51" aria-hidden="true" tabindex="-1"></a>                new_node.add_child(parent_node)</span>
<span id="cb243-52"><a href="#cb243-52" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_edge(parent_node.parent, old_edge_start, old_edge_start <span class="op">+</span> insertion_length <span class="op">-</span> <span class="dv">1</span>, new_node)</span>
<span id="cb243-53"><a href="#cb243-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-54"><a href="#cb243-54" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update the parent node since a new node is inserted above it</span></span>
<span id="cb243-55"><a href="#cb243-55" aria-hidden="true" tabindex="-1"></a>                <span class="kw">del</span> <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)]</span>
<span id="cb243-56"><a href="#cb243-56" aria-hidden="true" tabindex="-1"></a>                parent_node.parent.remove_child(parent_node)</span>
<span id="cb243-57"><a href="#cb243-57" aria-hidden="true" tabindex="-1"></a>                parent_node.update_parent(new_node)</span>
<span id="cb243-58"><a href="#cb243-58" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)] <span class="op">=</span> [old_edge_start <span class="op">+</span> insertion_length <span class="op">-</span> <span class="dv">1</span>, old_edge_end]</span>
<span id="cb243-59"><a href="#cb243-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-60"><a href="#cb243-60" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add new child node</span></span>
<span id="cb243-61"><a href="#cb243-61" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_edge(new_node, edge_start <span class="op">+</span> insertion_length <span class="op">-</span> <span class="dv">1</span>, <span class="va">self</span>.length)</span>
<span id="cb243-62"><a href="#cb243-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-63"><a href="#cb243-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb243-64"><a href="#cb243-64" aria-hidden="true" tabindex="-1"></a>                <span class="co"># No insertion necessary, just append the new node</span></span>
<span id="cb243-65"><a href="#cb243-65" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_edge(parent_node, edge_start, <span class="va">self</span>.length)</span>
<span id="cb243-66"><a href="#cb243-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-67"><a href="#cb243-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_insert_position(<span class="va">self</span>, start_index, parent_node):</span>
<span id="cb243-68"><a href="#cb243-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Finds the appropriate position to insert a suffix into the suffix tree.'''</span></span>
<span id="cb243-69"><a href="#cb243-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child_node <span class="kw">in</span> parent_node.children:</span>
<span id="cb243-70"><a href="#cb243-70" aria-hidden="true" tabindex="-1"></a>            edge_start, edge_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.number, child_node.number)]</span>
<span id="cb243-71"><a href="#cb243-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.word[start_index:start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start] <span class="op">==</span> <span class="va">self</span>.word[edge_start:edge_end]:</span>
<span id="cb243-72"><a href="#cb243-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">self</span>.find_insert_position(start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start, child_node)</span>
<span id="cb243-73"><a href="#cb243-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-74"><a href="#cb243-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="va">self</span>.word[edge_start] <span class="op">==</span> <span class="va">self</span>.word[start_index]:</span>
<span id="cb243-75"><a href="#cb243-75" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> child_node, start_index, <span class="va">True</span></span>
<span id="cb243-76"><a href="#cb243-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-77"><a href="#cb243-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent_node, start_index, <span class="va">False</span></span>
<span id="cb243-78"><a href="#cb243-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-79"><a href="#cb243-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(<span class="va">self</span>, parent_node, edge_start, edge_end, child_node<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb243-80"><a href="#cb243-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Adds a node and the associated edge to the suffix tree.'''</span></span>
<span id="cb243-81"><a href="#cb243-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> child_node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb243-82"><a href="#cb243-82" aria-hidden="true" tabindex="-1"></a>            child_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb243-83"><a href="#cb243-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-84"><a href="#cb243-84" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes.append(child_node)</span>
<span id="cb243-85"><a href="#cb243-85" aria-hidden="true" tabindex="-1"></a>        parent_node.add_child(child_node)</span>
<span id="cb243-86"><a href="#cb243-86" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges[(parent_node.number, child_node.number)] <span class="op">=</span> [edge_start, edge_end]</span>
<span id="cb243-87"><a href="#cb243-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-88"><a href="#cb243-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_edge_strings(<span class="va">self</span>):</span>
<span id="cb243-89"><a href="#cb243-89" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the string representations of the edges.'''</span></span>
<span id="cb243-90"><a href="#cb243-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="va">self</span>.word[i:j] <span class="cf">for</span> i, j <span class="kw">in</span> <span class="va">self</span>.edges.values()]</span>
<span id="cb243-91"><a href="#cb243-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-92"><a href="#cb243-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_descendants(<span class="va">self</span>, base_node):</span>
<span id="cb243-93"><a href="#cb243-93" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Calculates the total number of descendants of a given node.'''</span></span>
<span id="cb243-94"><a href="#cb243-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> base_node <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.descendants_count:</span>
<span id="cb243-95"><a href="#cb243-95" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.descendants_count[base_node] <span class="op">=</span> <span class="bu">len</span>(base_node.children) <span class="op">+</span> <span class="bu">sum</span>([<span class="va">self</span>.calculate_descendants(c) <span class="cf">for</span> c <span class="kw">in</span> base_node.children])</span>
<span id="cb243-96"><a href="#cb243-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-97"><a href="#cb243-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.descendants_count[base_node]</span>
<span id="cb243-98"><a href="#cb243-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-99"><a href="#cb243-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_node_word(<span class="va">self</span>, end_node):</span>
<span id="cb243-100"><a href="#cb243-100" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the prefix of the suffix tree word up to a given node.'''</span></span>
<span id="cb243-101"><a href="#cb243-101" aria-hidden="true" tabindex="-1"></a>        accumulated_word <span class="op">=</span> <span class="st">''</span></span>
<span id="cb243-102"><a href="#cb243-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> end_node.number <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb243-103"><a href="#cb243-103" aria-hidden="true" tabindex="-1"></a>            edge_indices <span class="op">=</span> <span class="va">self</span>.edges[(end_node.parent.number, end_node.number)]</span>
<span id="cb243-104"><a href="#cb243-104" aria-hidden="true" tabindex="-1"></a>            accumulated_word <span class="op">=</span> <span class="va">self</span>.word[edge_indices[<span class="dv">0</span>]:edge_indices[<span class="dv">1</span>]] <span class="op">+</span> accumulated_word</span>
<span id="cb243-105"><a href="#cb243-105" aria-hidden="true" tabindex="-1"></a>            end_node <span class="op">=</span> end_node.parent</span>
<span id="cb243-106"><a href="#cb243-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-107"><a href="#cb243-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> accumulated_word.strip(<span class="st">'$'</span>)</span>
<span id="cb243-108"><a href="#cb243-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-109"><a href="#cb243-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-110"><a href="#cb243-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb243-111"><a href="#cb243-111" aria-hidden="true" tabindex="-1"></a>dna_sequence <span class="op">=</span> <span class="st">"ATTTGGATT"</span></span>
<span id="cb243-112"><a href="#cb243-112" aria-hidden="true" tabindex="-1"></a>sequence_length <span class="op">=</span> <span class="bu">len</span>(dna_sequence)</span>
<span id="cb243-113"><a href="#cb243-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-114"><a href="#cb243-114" aria-hidden="true" tabindex="-1"></a><span class="co"># After removing the termination symbol $, if necessary, each edge corresponds to len(edge) substrings</span></span>
<span id="cb243-115"><a href="#cb243-115" aria-hidden="true" tabindex="-1"></a>edge_lengths <span class="op">=</span> [edge <span class="cf">if</span> edge[<span class="dv">1</span>] <span class="op">!=</span> sequence_length <span class="op">+</span> <span class="dv">1</span> <span class="cf">else</span> [edge[<span class="dv">0</span>], sequence_length] <span class="cf">for</span> edge <span class="kw">in</span> SuffixTree(dna_sequence).edges.values()]</span>
<span id="cb243-116"><a href="#cb243-116" aria-hidden="true" tabindex="-1"></a>observed_substrings <span class="op">=</span> <span class="bu">float</span>(<span class="bu">sum</span>([edge[<span class="dv">1</span>] <span class="op">-</span> edge[<span class="dv">0</span>] <span class="cf">for</span> edge <span class="kw">in</span> edge_lengths]))</span>
<span id="cb243-117"><a href="#cb243-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-118"><a href="#cb243-118" aria-hidden="true" tabindex="-1"></a><span class="co"># The number of possible substrings of length k is min(4^k, n-k-1)</span></span>
<span id="cb243-119"><a href="#cb243-119" aria-hidden="true" tabindex="-1"></a>max_possible_substrings <span class="op">=</span> <span class="bu">float</span>(<span class="bu">sum</span>([sequence_length <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span> <span class="cf">if</span> k <span class="op">&gt;</span> log(sequence_length <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> log(<span class="dv">4</span>) <span class="cf">else</span> <span class="dv">4</span> <span class="op">**</span> k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, sequence_length <span class="op">+</span> <span class="dv">1</span>)]))</span>
<span id="cb243-120"><a href="#cb243-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-121"><a href="#cb243-121" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(observed_substrings <span class="op">/</span> max_possible_substrings)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-41" class="level2" data-number="81.4">
<h2 data-number="81.4" class="anchored" data-anchor-id="explanation-41"><span class="header-section-number">81.4</span> Explanation</h2>
<section id="suffixtree-class" class="level3" data-number="81.4.1">
<h3 data-number="81.4.1" class="anchored" data-anchor-id="suffixtree-class"><span class="header-section-number">81.4.1</span> 1. <strong>SuffixTree Class</strong></h3>
<ul>
<li><p><strong><code>__init__(self, input_word)</code></strong>: Initializes the suffix tree with the given word. It sets up initial structures and calls <code>build_suffix_tree</code> to construct the tree.</p></li>
<li><p><strong><code>Node</code> Class</strong>: Represents nodes in the suffix tree.</p>
<ul>
<li><strong><code>__init__(self, parent_node, node_number)</code></strong>: Initializes a node with a parent and a unique number.</li>
<li><strong><code>add_child(self, child_node)</code></strong>: Adds a child node.</li>
<li><strong><code>remove_child(self, child_node)</code></strong>: Removes a child node.</li>
<li><strong><code>update_parent(self, new_parent)</code></strong>: Updates the parent of the node.</li>
</ul></li>
<li><p><strong><code>build_suffix_tree(self, input_word)</code></strong>: Constructs the suffix tree for the given word. Adds a terminator character <code>$</code> if not already present.</p></li>
<li><p><strong><code>find_insert_position(self, start_index, parent_node)</code></strong>: Determines where to insert a suffix starting at <code>start_index</code> under <code>parent_node</code>. Handles edge splitting and suffix insertion.</p></li>
<li><p><strong><code>add_edge(self, parent_node, edge_start, edge_end, child_node=None)</code></strong>: Adds an edge between <code>parent_node</code> and <code>child_node</code> with start and end indices.</p></li>
<li><p><strong><code>get_edge_strings(self)</code></strong>: Returns the substrings represented by each edge in the suffix tree.</p></li>
<li><p><strong><code>calculate_descendants(self, base_node)</code></strong>: Computes the total number of descendants of <code>base_node</code>, caching results for efficiency.</p></li>
<li><p><strong><code>get_node_word(self, end_node)</code></strong>: Constructs the string from the root to <code>end_node</code>.</p></li>
</ul>
</section>
<section id="calculations" class="level3" data-number="81.4.2">
<h3 data-number="81.4.2" class="anchored" data-anchor-id="calculations"><span class="header-section-number">81.4.2</span> 2. <strong>Calculations</strong></h3>
<ul>
<li><p><strong><code>observed_substrings</code></strong>: Computes the total length of all distinct substrings from the suffix tree.</p></li>
<li><p><strong><code>max_possible_substrings</code></strong>: Calculates the maximum number of distinct substrings possible for a string of length <code>n</code> with an alphabet of size 4.</p></li>
<li><p><strong><code>print(observed_substrings / max_possible_substrings)</code></strong>: Outputs the linguistic complexity as the ratio of observed distinct substrings to the maximum possible distinct substrings.</p></li>
</ul>
</section>
</section>
</section>
<section id="local-alignment-with-scoring-matrix" class="level1" data-number="82">
<h1 data-number="82"><span class="header-section-number">82</span> Local Alignment with Scoring Matrix</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/local-alignment/">local alignment</a>&nbsp;of two&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;is an&nbsp;<a href="https://rosalind.info/glossary/alignment/">alignment</a>&nbsp;of substrings&nbsp;rr&nbsp;and&nbsp;uu&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, respectively. Let&nbsp;<span class="math inline">\(opt(r,u)\)</span>&nbsp;denote the score of an&nbsp;<a href="https://rosalind.info/glossary/optimal-alignment/">optimal alignment</a>&nbsp;of&nbsp;<span class="math inline">\(r\)</span>&nbsp;and&nbsp;<span class="math inline">\(u\)</span>&nbsp;with respect to some predetermined&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each having length at most 1000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;A maximum alignment score along with substrings&nbsp;<span class="math inline">\(r\)</span>&nbsp;and&nbsp;<span class="math inline">\(u\)</span>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, respectively, which produce this maximum alignment score (multiple solutions may exist, in which case you may output any one).</p>
<p>Use: - The&nbsp;<a href="https://rosalind.info/glossary/pam250/">PAM250</a>&nbsp;<a href="https://rosalind.info/glossary/scoring-matrix/">scoring matrix</a>. - <a href="https://rosalind.info/glossary/linear-gap-penalty/">Linear gap penalty</a>&nbsp;equal to 5.</p>
<section id="sample-dataset-81" class="level2" data-number="82.1">
<h2 data-number="82.1" class="anchored" data-anchor-id="sample-dataset-81"><span class="header-section-number">82.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_80
MEANLYPRTEINSTRING
&gt;Rosalind_21
PLEASANTLYEINSTEIN</code></pre>
</section>
<section id="sample-output-82" class="level2" data-number="82.2">
<h2 data-number="82.2" class="anchored" data-anchor-id="sample-output-82"><span class="header-section-number">82.2</span> Sample Output</h2>
<pre><code>23
LYPRTEINSTRIN
LYEINSTEIN</code></pre>
</section>
<section id="solution-78" class="level2" data-number="82.3">
<h2 data-number="82.3" class="anchored" data-anchor-id="solution-78"><span class="header-section-number">82.3</span> Solution</h2>
<div class="sourceCode" id="cb246"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>clas PAM250:</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""The PAM250 scoring matrix class."""</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Initialize the scoring matrix."""</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Manually define the PAM250 scoring matrix.</span></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scoring_matrix <span class="op">=</span> {</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'A'</span>, <span class="st">'A'</span>): <span class="dv">2</span>, (<span class="st">'A'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'A'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'A'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'A'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'A'</span>, <span class="st">'G'</span>): <span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'A'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'A'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'A'</span>, <span class="st">'P'</span>): <span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>,</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'A'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'A'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'T'</span>): <span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'V'</span>): <span class="dv">0</span>, (<span class="st">'A'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'A'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'C'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'C'</span>): <span class="dv">12</span>, (<span class="st">'C'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'C'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'C'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'C'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'C'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'C'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'C'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'C'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'C'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'C'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'C'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">5</span>,</span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'C'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'C'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'C'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">8</span>, (<span class="st">'C'</span>, <span class="st">'Y'</span>): <span class="dv">0</span>,</span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'D'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'D'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'D'</span>, <span class="st">'D'</span>): <span class="dv">4</span>, (<span class="st">'D'</span>, <span class="st">'E'</span>): <span class="dv">3</span>, (<span class="st">'D'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'D'</span>, <span class="st">'G'</span>): <span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'H'</span>): <span class="dv">1</span>,</span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'D'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'D'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'D'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'D'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'D'</span>, <span class="st">'N'</span>): <span class="dv">2</span>, (<span class="st">'D'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'Q'</span>): <span class="dv">2</span>,</span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'D'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'D'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'D'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'D'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'D'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'E'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'E'</span>, <span class="st">'D'</span>): <span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'E'</span>): <span class="dv">4</span>, (<span class="st">'E'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'E'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'H'</span>): <span class="dv">1</span>,</span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'E'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'E'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'E'</span>, <span class="st">'Q'</span>): <span class="dv">2</span>,</span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'E'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'E'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'E'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'F'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'F'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'F'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'F'</span>, <span class="st">'F'</span>): <span class="dv">9</span>, (<span class="st">'F'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'F'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-23"><a href="#cb246-23" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'F'</span>, <span class="st">'I'</span>): <span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'F'</span>, <span class="st">'L'</span>): <span class="dv">2</span>, (<span class="st">'F'</span>, <span class="st">'M'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'F'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">5</span>,</span>
<span id="cb246-24"><a href="#cb246-24" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'F'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'F'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'W'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'Y'</span>): <span class="dv">7</span>,</span>
<span id="cb246-25"><a href="#cb246-25" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'G'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'G'</span>, <span class="st">'D'</span>): <span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'G'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'G'</span>, <span class="st">'G'</span>): <span class="dv">5</span>, (<span class="st">'G'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-26"><a href="#cb246-26" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'G'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'G'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'G'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'G'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'G'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'G'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-27"><a href="#cb246-27" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'G'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'G'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'G'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'G'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">5</span>,</span>
<span id="cb246-28"><a href="#cb246-28" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'H'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'H'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'H'</span>, <span class="st">'D'</span>): <span class="dv">1</span>, (<span class="st">'H'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'H'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'H'</span>): <span class="dv">6</span>,</span>
<span id="cb246-29"><a href="#cb246-29" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'H'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'N'</span>): <span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'Q'</span>): <span class="dv">3</span>,</span>
<span id="cb246-30"><a href="#cb246-30" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'H'</span>, <span class="st">'R'</span>): <span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'H'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'H'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'H'</span>, <span class="st">'Y'</span>): <span class="dv">0</span>,</span>
<span id="cb246-31"><a href="#cb246-31" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'I'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'F'</span>): <span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'I'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-32"><a href="#cb246-32" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'I'</span>, <span class="st">'I'</span>): <span class="dv">5</span>, (<span class="st">'I'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'L'</span>): <span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'M'</span>): <span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-33"><a href="#cb246-33" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'I'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'I'</span>, <span class="st">'V'</span>): <span class="dv">4</span>, (<span class="st">'I'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'I'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-34"><a href="#cb246-34" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'K'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'K'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'K'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'K'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'H'</span>): <span class="dv">0</span>,</span>
<span id="cb246-35"><a href="#cb246-35" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'K'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'K'</span>): <span class="dv">5</span>, (<span class="st">'K'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'M'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'K'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'K'</span>, <span class="st">'Q'</span>): <span class="dv">1</span>,</span>
<span id="cb246-36"><a href="#cb246-36" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'K'</span>, <span class="st">'R'</span>): <span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-37"><a href="#cb246-37" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'L'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'L'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'L'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'F'</span>): <span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'L'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-38"><a href="#cb246-38" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'L'</span>, <span class="st">'I'</span>): <span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'L'</span>): <span class="dv">6</span>, (<span class="st">'L'</span>, <span class="st">'M'</span>): <span class="dv">4</span>, (<span class="st">'L'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-39"><a href="#cb246-39" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'L'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'V'</span>): <span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'L'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-40"><a href="#cb246-40" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'M'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'M'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'F'</span>): <span class="dv">0</span>, (<span class="st">'M'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-41"><a href="#cb246-41" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'M'</span>, <span class="st">'I'</span>): <span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'M'</span>, <span class="st">'L'</span>): <span class="dv">4</span>, (<span class="st">'M'</span>, <span class="st">'M'</span>): <span class="dv">6</span>, (<span class="st">'M'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-42"><a href="#cb246-42" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'M'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'M'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'V'</span>): <span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'M'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-43"><a href="#cb246-43" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'N'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'N'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'N'</span>, <span class="st">'D'</span>): <span class="dv">2</span>, (<span class="st">'N'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'N'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'N'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'N'</span>, <span class="st">'H'</span>): <span class="dv">2</span>,</span>
<span id="cb246-44"><a href="#cb246-44" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'N'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'N'</span>, <span class="st">'K'</span>): <span class="dv">1</span>, (<span class="st">'N'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'N'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'N'</span>, <span class="st">'N'</span>): <span class="dv">2</span>, (<span class="st">'N'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'N'</span>, <span class="st">'Q'</span>): <span class="dv">1</span>,</span>
<span id="cb246-45"><a href="#cb246-45" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'N'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'N'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'N'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'N'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'N'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'N'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-46"><a href="#cb246-46" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'P'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'P'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'H'</span>): <span class="dv">0</span>,</span>
<span id="cb246-47"><a href="#cb246-47" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'P'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'P'</span>): <span class="dv">6</span>, (<span class="st">'P'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>,</span>
<span id="cb246-48"><a href="#cb246-48" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'P'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'P'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">5</span>,</span>
<span id="cb246-49"><a href="#cb246-49" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Q'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'Q'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'Q'</span>, <span class="st">'D'</span>): <span class="dv">2</span>, (<span class="st">'Q'</span>, <span class="st">'E'</span>): <span class="dv">2</span>, (<span class="st">'Q'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'Q'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'H'</span>): <span class="dv">3</span>,</span>
<span id="cb246-50"><a href="#cb246-50" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Q'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Q'</span>, <span class="st">'K'</span>): <span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Q'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'Q'</span>, <span class="st">'Q'</span>): <span class="dv">4</span>,</span>
<span id="cb246-51"><a href="#cb246-51" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Q'</span>, <span class="st">'R'</span>): <span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Q'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'Q'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-52"><a href="#cb246-52" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'R'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'R'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'R'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'R'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'R'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'R'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'R'</span>, <span class="st">'H'</span>): <span class="dv">2</span>,</span>
<span id="cb246-53"><a href="#cb246-53" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'R'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'R'</span>, <span class="st">'K'</span>): <span class="dv">3</span>, (<span class="st">'R'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'R'</span>, <span class="st">'M'</span>): <span class="dv">0</span>, (<span class="st">'R'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'R'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'R'</span>, <span class="st">'Q'</span>): <span class="dv">1</span>,</span>
<span id="cb246-54"><a href="#cb246-54" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'R'</span>, <span class="st">'R'</span>): <span class="dv">6</span>, (<span class="st">'R'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'R'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'R'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'R'</span>, <span class="st">'W'</span>): <span class="dv">2</span>, (<span class="st">'R'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-55"><a href="#cb246-55" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'S'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'C'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'G'</span>): <span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-56"><a href="#cb246-56" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'S'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'P'</span>): <span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-57"><a href="#cb246-57" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'S'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'S'</span>): <span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'T'</span>): <span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb246-58"><a href="#cb246-58" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'T'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-59"><a href="#cb246-59" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'T'</span>, <span class="st">'I'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'P'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-60"><a href="#cb246-60" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'T'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'T'</span>): <span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'V'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'T'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb246-61"><a href="#cb246-61" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'V'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'V'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-62"><a href="#cb246-62" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'V'</span>, <span class="st">'I'</span>): <span class="dv">4</span>, (<span class="st">'V'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'L'</span>): <span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'M'</span>): <span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-63"><a href="#cb246-63" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'V'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'T'</span>): <span class="dv">0</span>, (<span class="st">'V'</span>, <span class="st">'V'</span>): <span class="dv">4</span>, (<span class="st">'V'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'V'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb246-64"><a href="#cb246-64" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'W'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">8</span>, (<span class="st">'W'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'W'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'W'</span>, <span class="st">'F'</span>): <span class="dv">0</span>, (<span class="st">'W'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">7</span>, (<span class="st">'W'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb246-65"><a href="#cb246-65" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'W'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'W'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'W'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'W'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">5</span>,</span>
<span id="cb246-66"><a href="#cb246-66" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'W'</span>, <span class="st">'R'</span>): <span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'W'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'W'</span>): <span class="dv">17</span>, (<span class="st">'W'</span>, <span class="st">'Y'</span>): <span class="dv">0</span>,</span>
<span id="cb246-67"><a href="#cb246-67" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Y'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'C'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'F'</span>): <span class="dv">7</span>, (<span class="st">'Y'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'Y'</span>, <span class="st">'H'</span>): <span class="dv">0</span>,</span>
<span id="cb246-68"><a href="#cb246-68" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Y'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">5</span>, (<span class="st">'Y'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb246-69"><a href="#cb246-69" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'Y'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'W'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'Y'</span>): <span class="dv">10</span></span>
<span id="cb246-70"><a href="#cb246-70" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb246-71"><a href="#cb246-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-72"><a href="#cb246-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, pair):</span>
<span id="cb246-73"><a href="#cb246-73" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Return the score for a given pair of amino acids."""</span></span>
<span id="cb246-74"><a href="#cb246-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.scoring_matrix[pair]</span>
<span id="cb246-75"><a href="#cb246-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-76"><a href="#cb246-76" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> local_alignment(v, w, scoring_matrix, sigma):</span>
<span id="cb246-77"><a href="#cb246-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Returns the score and local alignment with the given scoring matrix and indel penalty sigma for strings v, w."""</span></span>
<span id="cb246-78"><a href="#cb246-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb246-79"><a href="#cb246-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the matrices S (score) and backtrack.</span></span>
<span id="cb246-80"><a href="#cb246-80" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.zeros((<span class="bu">len</span>(v) <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(w) <span class="op">+</span> <span class="dv">1</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb246-81"><a href="#cb246-81" aria-hidden="true" tabindex="-1"></a>    backtrack <span class="op">=</span> np.zeros((<span class="bu">len</span>(v) <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(w) <span class="op">+</span> <span class="dv">1</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb246-82"><a href="#cb246-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-83"><a href="#cb246-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill in the score matrix S and the backtrack matrix.</span></span>
<span id="cb246-84"><a href="#cb246-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(v) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb246-85"><a href="#cb246-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(w) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb246-86"><a href="#cb246-86" aria-hidden="true" tabindex="-1"></a>            match_score <span class="op">=</span> scoring_matrix[v[i <span class="op">-</span> <span class="dv">1</span>], w[j <span class="op">-</span> <span class="dv">1</span>]]</span>
<span id="cb246-87"><a href="#cb246-87" aria-hidden="true" tabindex="-1"></a>            scores <span class="op">=</span> [</span>
<span id="cb246-88"><a href="#cb246-88" aria-hidden="true" tabindex="-1"></a>                S[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> sigma,          <span class="co"># Insertion</span></span>
<span id="cb246-89"><a href="#cb246-89" aria-hidden="true" tabindex="-1"></a>                S[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> sigma,          <span class="co"># Deletion</span></span>
<span id="cb246-90"><a href="#cb246-90" aria-hidden="true" tabindex="-1"></a>                S[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> match_score, <span class="co"># Match/Mismatch</span></span>
<span id="cb246-91"><a href="#cb246-91" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>                             <span class="co"># Local alignment can start anywhere, so 0 is a valid score.</span></span>
<span id="cb246-92"><a href="#cb246-92" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb246-93"><a href="#cb246-93" aria-hidden="true" tabindex="-1"></a>            S[i][j] <span class="op">=</span> <span class="bu">max</span>(scores)             <span class="co"># Maximum score for cell (i, j)</span></span>
<span id="cb246-94"><a href="#cb246-94" aria-hidden="true" tabindex="-1"></a>            backtrack[i][j] <span class="op">=</span> scores.index(S[i][j])  <span class="co"># Record which move was taken.</span></span>
<span id="cb246-95"><a href="#cb246-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-96"><a href="#cb246-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the position of the highest scoring cell in the matrix.</span></span>
<span id="cb246-97"><a href="#cb246-97" aria-hidden="true" tabindex="-1"></a>    max_pos <span class="op">=</span> np.unravel_index(np.argmax(S), S.shape)</span>
<span id="cb246-98"><a href="#cb246-98" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> <span class="bu">str</span>(S[max_pos])</span>
<span id="cb246-99"><a href="#cb246-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-100"><a href="#cb246-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Start backtracking from the position of the highest score.</span></span>
<span id="cb246-101"><a href="#cb246-101" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> max_pos</span>
<span id="cb246-102"><a href="#cb246-102" aria-hidden="true" tabindex="-1"></a>    v_aligned, w_aligned <span class="op">=</span> [], []</span>
<span id="cb246-103"><a href="#cb246-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-104"><a href="#cb246-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct the alignment.</span></span>
<span id="cb246-105"><a href="#cb246-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> S[i][j] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb246-106"><a href="#cb246-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> backtrack[i][j] <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># Insertion</span></span>
<span id="cb246-107"><a href="#cb246-107" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb246-108"><a href="#cb246-108" aria-hidden="true" tabindex="-1"></a>            v_aligned.append(v[i])</span>
<span id="cb246-109"><a href="#cb246-109" aria-hidden="true" tabindex="-1"></a>            w_aligned.append(<span class="st">'-'</span>)</span>
<span id="cb246-110"><a href="#cb246-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> backtrack[i][j] <span class="op">==</span> <span class="dv">1</span>:  <span class="co"># Deletion</span></span>
<span id="cb246-111"><a href="#cb246-111" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb246-112"><a href="#cb246-112" aria-hidden="true" tabindex="-1"></a>            v_aligned.append(<span class="st">'-'</span>)</span>
<span id="cb246-113"><a href="#cb246-113" aria-hidden="true" tabindex="-1"></a>            w_aligned.append(w[j])</span>
<span id="cb246-114"><a href="#cb246-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># Match or mismatch</span></span>
<span id="cb246-115"><a href="#cb246-115" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb246-116"><a href="#cb246-116" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb246-117"><a href="#cb246-117" aria-hidden="true" tabindex="-1"></a>            v_aligned.append(v[i])</span>
<span id="cb246-118"><a href="#cb246-118" aria-hidden="true" tabindex="-1"></a>            w_aligned.append(w[j])</span>
<span id="cb246-119"><a href="#cb246-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-120"><a href="#cb246-120" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reverse the aligned sequences since they were constructed backwards.</span></span>
<span id="cb246-121"><a href="#cb246-121" aria-hidden="true" tabindex="-1"></a>    v_aligned <span class="op">=</span> <span class="st">''</span>.join(v_aligned[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb246-122"><a href="#cb246-122" aria-hidden="true" tabindex="-1"></a>    w_aligned <span class="op">=</span> <span class="st">''</span>.join(w_aligned[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb246-123"><a href="#cb246-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-124"><a href="#cb246-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score, v_aligned, w_aligned</span>
<span id="cb246-125"><a href="#cb246-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-126"><a href="#cb246-126" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb246-127"><a href="#cb246-127" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""&gt;Rosalind_80</span></span>
<span id="cb246-128"><a href="#cb246-128" aria-hidden="true" tabindex="-1"></a><span class="st">MEANLYPRTEINSTRING</span></span>
<span id="cb246-129"><a href="#cb246-129" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_21</span></span>
<span id="cb246-130"><a href="#cb246-130" aria-hidden="true" tabindex="-1"></a><span class="st">PLEASANTLYEINSTEIN</span></span>
<span id="cb246-131"><a href="#cb246-131" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb246-132"><a href="#cb246-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-133"><a href="#cb246-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input FASTA format data</span></span>
<span id="cb246-134"><a href="#cb246-134" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb246-135"><a href="#cb246-135" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb246-136"><a href="#cb246-136" aria-hidden="true" tabindex="-1"></a>    parts <span class="op">=</span> data.strip().split(<span class="st">'&gt;'</span>)</span>
<span id="cb246-137"><a href="#cb246-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> part <span class="kw">in</span> parts:</span>
<span id="cb246-138"><a href="#cb246-138" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> part:</span>
<span id="cb246-139"><a href="#cb246-139" aria-hidden="true" tabindex="-1"></a>            lines <span class="op">=</span> part.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb246-140"><a href="#cb246-140" aria-hidden="true" tabindex="-1"></a>            sequence <span class="op">=</span> <span class="st">''</span>.join(lines[<span class="dv">1</span>:])</span>
<span id="cb246-141"><a href="#cb246-141" aria-hidden="true" tabindex="-1"></a>            sequences.append(sequence)</span>
<span id="cb246-142"><a href="#cb246-142" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb246-143"><a href="#cb246-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-144"><a href="#cb246-144" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb246-145"><a href="#cb246-145" aria-hidden="true" tabindex="-1"></a>seq1, seq2 <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb246-146"><a href="#cb246-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-147"><a href="#cb246-147" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the local alignment with sigma = 5.</span></span>
<span id="cb246-148"><a href="#cb246-148" aria-hidden="true" tabindex="-1"></a>alignment <span class="op">=</span> local_alignment(seq1, seq2, PAM250(), <span class="dv">5</span>)</span>
<span id="cb246-149"><a href="#cb246-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-150"><a href="#cb246-150" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the alignment.</span></span>
<span id="cb246-151"><a href="#cb246-151" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(alignment))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-42" class="level2" data-number="82.4">
<h2 data-number="82.4" class="anchored" data-anchor-id="explanation-42"><span class="header-section-number">82.4</span> Explanation</h2>
<ol type="1">
<li><strong>PAM250 Class</strong>:
<ul>
<li>The <code>PAM250</code> clas is defined to encapsulate the scoring matrix. The matrix is stored in a dictionary where the keys are tuples of amino acid pairs, and the values are their corresponding scores.</li>
<li>The <code>__getitem__</code> method allows easy acces to the matrix using tuple indexing, e.g., <code>scoring_matrix['A', 'A']</code>.</li>
</ul></li>
<li><strong>local_alignment Function</strong>:
<ul>
<li>The <code>local_alignment</code> function computes the local alignment using dynamic programming.</li>
<li><code>S</code> is the score matrix that keeps track of the best scores for subsequences of <code>v</code> and <code>w</code>.</li>
<li><code>backtrack</code> keeps track of the choices made to achieve the score in each cell (insertion, deletion, match/mismatch, or starting a new local alignment).</li>
<li>The function iterates over the strings <code>v</code> and <code>w</code>, filling the matrices according to the local alignment rules.</li>
<li>The backtracking step reconstructs the aligned sequences from the highest scoring position until a score of zero is encountered, indicating the start of the local alignment.</li>
</ul></li>
<li><strong>Backtracking and Alignment</strong>:
<ul>
<li>The backtracking loop constructs the aligned sequences by following the recorded moves in the <code>backtrack</code> matrix.</li>
<li>The sequences are built in reverse and then reversed at the end to give the correct alignment.</li>
</ul></li>
<li><strong>parse_fasta</strong>:
<ul>
<li>The <code>parse_fasta</code> function reads the input FASTA format data and extracts the sequences. It returns a list of sequences to be used in the alignment.</li>
</ul></li>
<li><strong>Execution</strong>:
<ul>
<li>The code parses the sample input, computes the local alignment, and prints the aligned sequences and the alignment score.</li>
</ul></li>
</ol>
</section>
</section>
<section id="maximizing-the-gap-symbols-of-an-optimal-alignment" class="level1" data-number="83">
<h1 data-number="83"><span class="header-section-number">83</span> Maximizing the Gap Symbols of an Optimal Alignment</h1>
<p>For the computation of an&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>&nbsp;generalizing the&nbsp;<a href="https://rosalind.info/glossary/edit-alignment-score/">edit alignment score</a>, let&nbsp;<span class="math inline">\(m\)</span>&nbsp;denote the score assigned to matched symbols,&nbsp;<span class="math inline">\(d\)</span>&nbsp;denote the score assigned to mismatched non-gap symbols, and&nbsp;<span class="math inline">\(g\)</span>&nbsp;denote the score assigned a symbol matched to a&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbol</a>&nbsp;‘-’ (i.e.,&nbsp;<span class="math inline">\(g\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/linear-gap-penalty/">linear gap penalty</a>).</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each of length at most 5000&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>).</p>
<p>Return:&nbsp;The maximum number of gap symbols that can appear in any maximum score alignment of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;with score parameters satisfying&nbsp;<span class="math inline">\(m&gt;0\)</span>,&nbsp;<span class="math inline">\(d&lt;0\)</span>, and&nbsp;<span class="math inline">\(g&lt;0\)</span>.</p>
<section id="sample-dataset-82" class="level2" data-number="83.1">
<h2 data-number="83.1" class="anchored" data-anchor-id="sample-dataset-82"><span class="header-section-number">83.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_92
AACGTA
&gt;Rosalind_47
ACACCTA</code></pre>
</section>
<section id="sample-output-83" class="level2" data-number="83.2">
<h2 data-number="83.2" class="anchored" data-anchor-id="sample-output-83"><span class="header-section-number">83.2</span> Sample Output</h2>
<pre><code>3</code></pre>
</section>
<section id="solution-79" class="level2" data-number="83.3">
<h2 data-number="83.3" class="anchored" data-anchor-id="solution-79"><span class="header-section-number">83.3</span> Solution</h2>
<div class="sourceCode" id="cb249"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximum_gap_symbols(v, w):</span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the maximum number of gap symbols in an optimal alignment of v and w.</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a><span class="co">    The maximum number of gaps is derived from the lengths of the input strings and the longest common subsequence (LCS) between them.</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize a matrix to store the lengths of the longest common subsequence</span></span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true" tabindex="-1"></a>    len_v, len_w <span class="op">=</span> <span class="bu">len</span>(v), <span class="bu">len</span>(w)</span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true" tabindex="-1"></a>    lcs_matrix <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (len_w <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(len_v <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-10"><a href="#cb249-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the matrix based on LCS dynamic programming</span></span>
<span id="cb249-11"><a href="#cb249-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, len_v <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb249-12"><a href="#cb249-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, len_w <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb249-13"><a href="#cb249-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> w[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb249-14"><a href="#cb249-14" aria-hidden="true" tabindex="-1"></a>                lcs_matrix[i][j] <span class="op">=</span> lcs_matrix[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb249-15"><a href="#cb249-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb249-16"><a href="#cb249-16" aria-hidden="true" tabindex="-1"></a>                lcs_matrix[i][j] <span class="op">=</span> <span class="bu">max</span>(lcs_matrix[i][j <span class="op">-</span> <span class="dv">1</span>], lcs_matrix[i <span class="op">-</span> <span class="dv">1</span>][j])</span>
<span id="cb249-17"><a href="#cb249-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-18"><a href="#cb249-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the maximum number of gap symbols</span></span>
<span id="cb249-19"><a href="#cb249-19" aria-hidden="true" tabindex="-1"></a>    lcs_length <span class="op">=</span> lcs_matrix[len_v][len_w]</span>
<span id="cb249-20"><a href="#cb249-20" aria-hidden="true" tabindex="-1"></a>    max_gaps <span class="op">=</span> len_v <span class="op">+</span> len_w <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> lcs_length</span>
<span id="cb249-21"><a href="#cb249-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-22"><a href="#cb249-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_gaps</span>
<span id="cb249-23"><a href="#cb249-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-24"><a href="#cb249-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb249-25"><a href="#cb249-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb249-26"><a href="#cb249-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses input FASTA format data and returns a list of sequences.</span></span>
<span id="cb249-27"><a href="#cb249-27" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb249-28"><a href="#cb249-28" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb249-29"><a href="#cb249-29" aria-hidden="true" tabindex="-1"></a>    entries <span class="op">=</span> data.strip().split(<span class="st">'&gt;'</span>)</span>
<span id="cb249-30"><a href="#cb249-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb249-31"><a href="#cb249-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> entries:</span>
<span id="cb249-32"><a href="#cb249-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> entry:</span>
<span id="cb249-33"><a href="#cb249-33" aria-hidden="true" tabindex="-1"></a>            lines <span class="op">=</span> entry.splitlines()</span>
<span id="cb249-34"><a href="#cb249-34" aria-hidden="true" tabindex="-1"></a>            sequence <span class="op">=</span> <span class="st">''</span>.join(lines[<span class="dv">1</span>:])</span>
<span id="cb249-35"><a href="#cb249-35" aria-hidden="true" tabindex="-1"></a>            sequences.append(sequence)</span>
<span id="cb249-36"><a href="#cb249-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb249-37"><a href="#cb249-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb249-38"><a href="#cb249-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-39"><a href="#cb249-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input in FASTA format</span></span>
<span id="cb249-40"><a href="#cb249-40" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb249-41"><a href="#cb249-41" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_92</span></span>
<span id="cb249-42"><a href="#cb249-42" aria-hidden="true" tabindex="-1"></a><span class="st">AACGTA</span></span>
<span id="cb249-43"><a href="#cb249-43" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_47</span></span>
<span id="cb249-44"><a href="#cb249-44" aria-hidden="true" tabindex="-1"></a><span class="st">ACACCTA</span></span>
<span id="cb249-45"><a href="#cb249-45" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb249-46"><a href="#cb249-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-47"><a href="#cb249-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the sequences from the sample input</span></span>
<span id="cb249-48"><a href="#cb249-48" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb249-49"><a href="#cb249-49" aria-hidden="true" tabindex="-1"></a>v, w <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb249-50"><a href="#cb249-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-51"><a href="#cb249-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the maximum number of gap symbols</span></span>
<span id="cb249-52"><a href="#cb249-52" aria-hidden="true" tabindex="-1"></a>max_gaps <span class="op">=</span> maximum_gap_symbols(v, w)</span>
<span id="cb249-53"><a href="#cb249-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-54"><a href="#cb249-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb249-55"><a href="#cb249-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_gaps)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-43" class="level2" data-number="83.4">
<h2 data-number="83.4" class="anchored" data-anchor-id="explanation-43"><span class="header-section-number">83.4</span> Explanation</h2>
<p><code>maximum_gap_symbols(v, w)</code> function calculates the maximum number of gap symbols that can appear in any optimal alignment of two DNA strings <code>v</code> and <code>w</code>. It does so by using the Longest Common Subsequence (LCS) method.</p>
<ul>
<li><p><strong>Initialization</strong>:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>len_v, len_w <span class="op">=</span> <span class="bu">len</span>(v), <span class="bu">len</span>(w)</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>lcs_matrix <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (len_w <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(len_v <span class="op">+</span> <span class="dv">1</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, the lengths of the input strings <code>v</code> and <code>w</code> are stored in <code>len_v</code> and <code>len_w</code>. Then, a 2D matrix <code>lcs_matrix</code> is initialized with all elements set to 0. The matrix has dimensions <code>(len_v + 1) x (len_w + 1)</code>.</p></li>
<li><p><strong>Filling the LCS Matrix</strong>:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, len_v <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, len_w <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> w[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>            lcs_matrix[i][j] <span class="op">=</span> lcs_matrix[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>            lcs_matrix[i][j] <span class="op">=</span> <span class="bu">max</span>(lcs_matrix[i][j <span class="op">-</span> <span class="dv">1</span>], lcs_matrix[i <span class="op">-</span> <span class="dv">1</span>][j])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This loop fills the <code>lcs_matrix</code> based on the LCS dynamic programming approach:</p>
<ul>
<li>If the characters <code>v[i-1]</code> and <code>w[j-1]</code> are equal, the value at <code>lcs_matrix[i][j]</code> is updated to <code>lcs_matrix[i-1][j-1] + 1</code>.</li>
<li>Otherwise, it takes the maximum of the values to the left (<code>lcs_matrix[i][j-1]</code>) and above (<code>lcs_matrix[i-1][j]</code>).</li>
</ul></li>
<li><p><strong>Calculating Maximum Number of Gaps</strong>:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>lcs_length <span class="op">=</span> lcs_matrix[len_v][len_w]</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a>max_gaps <span class="op">=</span> len_v <span class="op">+</span> len_w <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> lcs_length</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After filling the matrix, the length of the LCS is stored in <code>lcs_length</code>. The maximum number of gaps is then calculated using the formula <code>len(v) + len(w) - 2 * lcs_length</code>.</p></li>
</ul>
</section>
</section>
<section id="identifying-maximal-repeats" class="level1" data-number="84">
<h1 data-number="84"><span class="header-section-number">84</span> Identifying Maximal Repeats</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/maximal-repeat/">maximal repeat</a>&nbsp;of a&nbsp;<a href="https://rosalind.info/glossary/string/">string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;is a&nbsp;<a href="https://rosalind.info/glossary/repeated-substring/">repeated substring</a>&nbsp;<span class="math inline">\(t\)</span>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;having two occurrences&nbsp;<span class="math inline">\(t_1\)</span>&nbsp;and&nbsp;<span class="math inline">\(t_2\)</span>&nbsp;such that&nbsp;<span class="math inline">\(t_1\)</span>&nbsp;and&nbsp;<span class="math inline">\(t_2\)</span>&nbsp;cannot be extended by one symbol in either direction in&nbsp;<span class="math inline">\(s\)</span>&nbsp;and still agree.</p>
<p>For example, “<strong>AG</strong>” is a maximal repeat in “T<strong>AG</strong>TT<strong>AG</strong>CG<strong>AG</strong>A” because even though the first two occurrences of “AG” can be extended left into “TAG”, the first and third occurrences differ on both sides of the repeat; thus, we conclude that “AG” is a maximal repeat. Note that “<strong>TAG</strong>” is also a maximal repeat of “<strong>TAG</strong>T<strong>TAG</strong>CGAGA”, since its only two occurrences do not still match if we extend them in either direction.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;A list containing all maximal repeats of&nbsp;<span class="math inline">\(s\)</span>&nbsp;having length at least 20.</p>
<section id="sample-dataset-83" class="level2" data-number="84.1">
<h2 data-number="84.1" class="anchored" data-anchor-id="sample-dataset-83"><span class="header-section-number">84.1</span> Sample Dataset</h2>
<pre><code>TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT</code></pre>
</section>
<section id="sample-output-84" class="level2" data-number="84.2">
<h2 data-number="84.2" class="anchored" data-anchor-id="sample-output-84"><span class="header-section-number">84.2</span> Sample Output</h2>
<pre><code>ATGGGTCCAGAGTTTTGTAATTT
TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT</code></pre>
</section>
<section id="solution-80" class="level2" data-number="84.3">
<h2 data-number="84.3" class="anchored" data-anchor-id="solution-80"><span class="header-section-number">84.3</span> Solution</h2>
<div class="sourceCode" id="cb255"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> functools</span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>clas SuffixTree(<span class="bu">object</span>):</span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Creates a suffix tree for the provided word.'''</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, word):</span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Initializes the suffix tree.'''</span></span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> [<span class="va">self</span>.Node(<span class="va">None</span>, <span class="dv">0</span>)]</span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.descendants_dict <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(word) <span class="op">==</span> <span class="bu">str</span>:</span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.add_word(word)</span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-14"><a href="#cb255-14" aria-hidden="true" tabindex="-1"></a>    clas Node(<span class="bu">object</span>):</span>
<span id="cb255-15"><a href="#cb255-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Suffix tree node class.'''</span></span>
<span id="cb255-16"><a href="#cb255-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, parent, number):</span>
<span id="cb255-17"><a href="#cb255-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb255-18"><a href="#cb255-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.number <span class="op">=</span> number</span>
<span id="cb255-19"><a href="#cb255-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb255-20"><a href="#cb255-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-21"><a href="#cb255-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> add_child(<span class="va">self</span>, child):</span>
<span id="cb255-22"><a href="#cb255-22" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.append(child)</span>
<span id="cb255-23"><a href="#cb255-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-24"><a href="#cb255-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> remove_child(<span class="va">self</span>, child):</span>
<span id="cb255-25"><a href="#cb255-25" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.children.remove(child)</span>
<span id="cb255-26"><a href="#cb255-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-27"><a href="#cb255-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> update_parent(<span class="va">self</span>, parent):</span>
<span id="cb255-28"><a href="#cb255-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb255-29"><a href="#cb255-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-30"><a href="#cb255-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_word(<span class="va">self</span>, word):</span>
<span id="cb255-31"><a href="#cb255-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Add a word to the suffix tree.'''</span></span>
<span id="cb255-32"><a href="#cb255-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check to make sure word ends in '$'.</span></span>
<span id="cb255-33"><a href="#cb255-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> word[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> <span class="st">'$'</span>:</span>
<span id="cb255-34"><a href="#cb255-34" aria-hidden="true" tabindex="-1"></a>            word <span class="op">+=</span> <span class="st">'$'</span></span>
<span id="cb255-35"><a href="#cb255-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.word <span class="op">=</span> word</span>
<span id="cb255-36"><a href="#cb255-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.word)</span>
<span id="cb255-37"><a href="#cb255-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-38"><a href="#cb255-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n):</span>
<span id="cb255-39"><a href="#cb255-39" aria-hidden="true" tabindex="-1"></a>            parent_node, edge_start, overlap <span class="op">=</span> <span class="va">self</span>.insert_position(i, <span class="va">self</span>.nodes[<span class="dv">0</span>])</span>
<span id="cb255-40"><a href="#cb255-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-41"><a href="#cb255-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> overlap:</span>
<span id="cb255-42"><a href="#cb255-42" aria-hidden="true" tabindex="-1"></a>                p_edge_start, p_edge_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)]</span>
<span id="cb255-43"><a href="#cb255-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-44"><a href="#cb255-44" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get the edge to insert</span></span>
<span id="cb255-45"><a href="#cb255-45" aria-hidden="true" tabindex="-1"></a>                insert_len <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb255-46"><a href="#cb255-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> word[edge_start:edge_start <span class="op">+</span> insert_len] <span class="op">==</span> word[p_edge_start:p_edge_start <span class="op">+</span> insert_len]:</span>
<span id="cb255-47"><a href="#cb255-47" aria-hidden="true" tabindex="-1"></a>                    insert_len <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb255-48"><a href="#cb255-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-49"><a href="#cb255-49" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create a new node for insertion</span></span>
<span id="cb255-50"><a href="#cb255-50" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node.parent, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb255-51"><a href="#cb255-51" aria-hidden="true" tabindex="-1"></a>                new_node.add_child(parent_node)</span>
<span id="cb255-52"><a href="#cb255-52" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_node(parent_node.parent, p_edge_start, p_edge_start <span class="op">+</span> insert_len <span class="op">-</span> <span class="dv">1</span>, new_node)</span>
<span id="cb255-53"><a href="#cb255-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-54"><a href="#cb255-54" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update the parent node since a new node is inserted above it</span></span>
<span id="cb255-55"><a href="#cb255-55" aria-hidden="true" tabindex="-1"></a>                <span class="kw">del</span> <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)]</span>
<span id="cb255-56"><a href="#cb255-56" aria-hidden="true" tabindex="-1"></a>                parent_node.parent.remove_child(parent_node)</span>
<span id="cb255-57"><a href="#cb255-57" aria-hidden="true" tabindex="-1"></a>                parent_node.update_parent(new_node)</span>
<span id="cb255-58"><a href="#cb255-58" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges[(parent_node.parent.number, parent_node.number)] <span class="op">=</span> [p_edge_start <span class="op">+</span> insert_len <span class="op">-</span> <span class="dv">1</span>, p_edge_end]</span>
<span id="cb255-59"><a href="#cb255-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-60"><a href="#cb255-60" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add new child node</span></span>
<span id="cb255-61"><a href="#cb255-61" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_node(new_node, edge_start <span class="op">+</span> insert_len <span class="op">-</span> <span class="dv">1</span>, <span class="va">self</span>.n)</span>
<span id="cb255-62"><a href="#cb255-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-63"><a href="#cb255-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb255-64"><a href="#cb255-64" aria-hidden="true" tabindex="-1"></a>                <span class="co"># No insertion necessary, just append the new node.</span></span>
<span id="cb255-65"><a href="#cb255-65" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_node(parent_node, edge_start, <span class="va">self</span>.n)</span>
<span id="cb255-66"><a href="#cb255-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-67"><a href="#cb255-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert_position(<span class="va">self</span>, start_index, parent_node):</span>
<span id="cb255-68"><a href="#cb255-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Determine the location and method to insert a suffix into the suffix tree.'''</span></span>
<span id="cb255-69"><a href="#cb255-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child_node <span class="kw">in</span> parent_node.children:</span>
<span id="cb255-70"><a href="#cb255-70" aria-hidden="true" tabindex="-1"></a>            edge_start, edge_end <span class="op">=</span> <span class="va">self</span>.edges[(parent_node.number, child_node.number)]</span>
<span id="cb255-71"><a href="#cb255-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.word[start_index:start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start] <span class="op">==</span> <span class="va">self</span>.word[edge_start:edge_end]:</span>
<span id="cb255-72"><a href="#cb255-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">self</span>.insert_position(start_index <span class="op">+</span> edge_end <span class="op">-</span> edge_start, child_node)</span>
<span id="cb255-73"><a href="#cb255-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-74"><a href="#cb255-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="va">self</span>.word[edge_start] <span class="op">==</span> <span class="va">self</span>.word[start_index]:</span>
<span id="cb255-75"><a href="#cb255-75" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> child_node, start_index,  <span class="va">True</span></span>
<span id="cb255-76"><a href="#cb255-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-77"><a href="#cb255-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent_node, start_index, <span class="va">False</span></span>
<span id="cb255-78"><a href="#cb255-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-79"><a href="#cb255-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_node(<span class="va">self</span>, parent_node, edge_start, edge_end, child_node<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb255-80"><a href="#cb255-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Adds a node and the associated edge to the suffix tree.'''</span></span>
<span id="cb255-81"><a href="#cb255-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-82"><a href="#cb255-82" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create child node, if necessary</span></span>
<span id="cb255-83"><a href="#cb255-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> child_node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb255-84"><a href="#cb255-84" aria-hidden="true" tabindex="-1"></a>            child_node <span class="op">=</span> <span class="va">self</span>.Node(parent_node, <span class="bu">len</span>(<span class="va">self</span>.nodes))</span>
<span id="cb255-85"><a href="#cb255-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-86"><a href="#cb255-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add node to node list</span></span>
<span id="cb255-87"><a href="#cb255-87" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes.append(child_node)</span>
<span id="cb255-88"><a href="#cb255-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-89"><a href="#cb255-89" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add child to parent</span></span>
<span id="cb255-90"><a href="#cb255-90" aria-hidden="true" tabindex="-1"></a>        parent_node.add_child(child_node)</span>
<span id="cb255-91"><a href="#cb255-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-92"><a href="#cb255-92" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add edge to edge dict</span></span>
<span id="cb255-93"><a href="#cb255-93" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges[(parent_node.number, child_node.number)] <span class="op">=</span> [</span>
<span id="cb255-94"><a href="#cb255-94" aria-hidden="true" tabindex="-1"></a>            edge_start, edge_end]</span>
<span id="cb255-95"><a href="#cb255-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-96"><a href="#cb255-96" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> print_edges(<span class="va">self</span>):</span>
<span id="cb255-97"><a href="#cb255-97" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the string representations of the edges.'''</span></span>
<span id="cb255-98"><a href="#cb255-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="va">self</span>.word[i:j] <span class="cf">for</span> i, j <span class="kw">in</span> <span class="va">self</span>.edges.values()]</span>
<span id="cb255-99"><a href="#cb255-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-100"><a href="#cb255-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> total_descendants(<span class="va">self</span>, base_node):</span>
<span id="cb255-101"><a href="#cb255-101" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the total number of descendants of a given node.'''</span></span>
<span id="cb255-102"><a href="#cb255-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> base_node <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.descendants_dict:</span>
<span id="cb255-103"><a href="#cb255-103" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.descendants_dict[base_node] <span class="op">=</span> <span class="bu">len</span>(base_node.children) <span class="op">+</span> <span class="bu">sum</span>([<span class="va">self</span>.total_descendants(c) <span class="cf">for</span> c <span class="kw">in</span> base_node.children])</span>
<span id="cb255-104"><a href="#cb255-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-105"><a href="#cb255-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.descendants_dict[base_node]</span>
<span id="cb255-106"><a href="#cb255-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-107"><a href="#cb255-107" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> node_word(<span class="va">self</span>, end_node):</span>
<span id="cb255-108"><a href="#cb255-108" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the prefix of the suffix tree word up to a given node.'''</span></span>
<span id="cb255-109"><a href="#cb255-109" aria-hidden="true" tabindex="-1"></a>        current_word <span class="op">=</span> <span class="st">''</span></span>
<span id="cb255-110"><a href="#cb255-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> end_node.number <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb255-111"><a href="#cb255-111" aria-hidden="true" tabindex="-1"></a>            temp_indices <span class="op">=</span> <span class="va">self</span>.edges[(end_node.parent.number, end_node.number)]</span>
<span id="cb255-112"><a href="#cb255-112" aria-hidden="true" tabindex="-1"></a>            current_word <span class="op">=</span> <span class="va">self</span>.word[temp_indices[<span class="dv">0</span>]:temp_indices[<span class="dv">1</span>]] <span class="op">+</span> current_word</span>
<span id="cb255-113"><a href="#cb255-113" aria-hidden="true" tabindex="-1"></a>            end_node <span class="op">=</span> end_node.parent</span>
<span id="cb255-114"><a href="#cb255-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-115"><a href="#cb255-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current_word.strip(<span class="st">'$'</span>)</span>
<span id="cb255-116"><a href="#cb255-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-117"><a href="#cb255-117" aria-hidden="true" tabindex="-1"></a>clas Trie(<span class="bu">object</span>):</span>
<span id="cb255-118"><a href="#cb255-118" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Constructs a trie.'''</span></span>
<span id="cb255-119"><a href="#cb255-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-120"><a href="#cb255-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, word<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb255-121"><a href="#cb255-121" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> [[<span class="va">self</span>.Node(<span class="st">''</span>, <span class="dv">1</span>)]]</span>
<span id="cb255-122"><a href="#cb255-122" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> []</span>
<span id="cb255-123"><a href="#cb255-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> word <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb255-124"><a href="#cb255-124" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.add_word(word)</span>
<span id="cb255-125"><a href="#cb255-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-126"><a href="#cb255-126" aria-hidden="true" tabindex="-1"></a>    clas Node(<span class="bu">object</span>):</span>
<span id="cb255-127"><a href="#cb255-127" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Trie node class.'''</span></span>
<span id="cb255-128"><a href="#cb255-128" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, prefix, number):</span>
<span id="cb255-129"><a href="#cb255-129" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.prefix <span class="op">=</span> prefix</span>
<span id="cb255-130"><a href="#cb255-130" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.number <span class="op">=</span> number</span>
<span id="cb255-131"><a href="#cb255-131" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.depth <span class="op">=</span> <span class="bu">len</span>(prefix)</span>
<span id="cb255-132"><a href="#cb255-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-133"><a href="#cb255-133" aria-hidden="true" tabindex="-1"></a>    clas Edge(<span class="bu">object</span>):</span>
<span id="cb255-134"><a href="#cb255-134" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Trie edge class.'''</span></span>
<span id="cb255-135"><a href="#cb255-135" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, letter, par_node, chi_node):</span>
<span id="cb255-136"><a href="#cb255-136" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.letter <span class="op">=</span> letter</span>
<span id="cb255-137"><a href="#cb255-137" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent_node <span class="op">=</span> par_node</span>
<span id="cb255-138"><a href="#cb255-138" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.child_node <span class="op">=</span> chi_node</span>
<span id="cb255-139"><a href="#cb255-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-140"><a href="#cb255-140" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> get_info(<span class="va">self</span>):</span>
<span id="cb255-141"><a href="#cb255-141" aria-hidden="true" tabindex="-1"></a>            <span class="co">'''Return the edge information compactly.'''</span></span>
<span id="cb255-142"><a href="#cb255-142" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, [<span class="va">self</span>.parent_node, <span class="va">self</span>.child_node, <span class="va">self</span>.letter]))</span>
<span id="cb255-143"><a href="#cb255-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-144"><a href="#cb255-144" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_word(<span class="va">self</span>, word):</span>
<span id="cb255-145"><a href="#cb255-145" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Adds a word to the trie.'''</span></span>
<span id="cb255-146"><a href="#cb255-146" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(word) <span class="op">==</span> <span class="bu">list</span>:</span>
<span id="cb255-147"><a href="#cb255-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> w <span class="kw">in</span> word:</span>
<span id="cb255-148"><a href="#cb255-148" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.add_word(w)</span>
<span id="cb255-149"><a href="#cb255-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb255-150"><a href="#cb255-150" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> <span class="va">self</span>.find_parent(word)</span>
<span id="cb255-151"><a href="#cb255-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(parent.prefix), <span class="bu">len</span>(word)):</span>
<span id="cb255-152"><a href="#cb255-152" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> <span class="va">self</span>.Node(word[:i <span class="op">+</span> <span class="dv">1</span>], <span class="va">self</span>.node_count() <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb255-153"><a href="#cb255-153" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges.append(<span class="va">self</span>.Edge(word[i], parent.number, <span class="va">self</span>.node_count() <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb255-154"><a href="#cb255-154" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.insert_node(new_node)</span>
<span id="cb255-155"><a href="#cb255-155" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">=</span> new_node</span>
<span id="cb255-156"><a href="#cb255-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-157"><a href="#cb255-157" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert_node(<span class="va">self</span>, node):</span>
<span id="cb255-158"><a href="#cb255-158" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Determine the location to insert the current node.'''</span></span>
<span id="cb255-159"><a href="#cb255-159" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.depth <span class="op">&gt;</span> <span class="va">self</span>.depth():</span>
<span id="cb255-160"><a href="#cb255-160" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.nodes.append([node])</span>
<span id="cb255-161"><a href="#cb255-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb255-162"><a href="#cb255-162" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.nodes[node.depth].append(node)</span>
<span id="cb255-163"><a href="#cb255-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-164"><a href="#cb255-164" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> depth(<span class="va">self</span>):</span>
<span id="cb255-165"><a href="#cb255-165" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the depth of the trie.'''</span></span>
<span id="cb255-166"><a href="#cb255-166" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.nodes) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb255-167"><a href="#cb255-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-168"><a href="#cb255-168" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> node_count(<span class="va">self</span>):</span>
<span id="cb255-169"><a href="#cb255-169" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Returns the total number of nodes.'''</span></span>
<span id="cb255-170"><a href="#cb255-170" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb255-171"><a href="#cb255-171" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> trie_depth <span class="kw">in</span> <span class="va">self</span>.nodes:</span>
<span id="cb255-172"><a href="#cb255-172" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="bu">len</span>(trie_depth)</span>
<span id="cb255-173"><a href="#cb255-173" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count</span>
<span id="cb255-174"><a href="#cb255-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-175"><a href="#cb255-175" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_parent(<span class="va">self</span>, word):</span>
<span id="cb255-176"><a href="#cb255-176" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''Return the parent node of the word to be inserted.'''</span></span>
<span id="cb255-177"><a href="#cb255-177" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="bu">len</span>(word), <span class="va">self</span>.depth()), <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb255-178"><a href="#cb255-178" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes[i]:</span>
<span id="cb255-179"><a href="#cb255-179" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> word[:i] <span class="op">==</span> node.prefix:</span>
<span id="cb255-180"><a href="#cb255-180" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> node</span>
<span id="cb255-181"><a href="#cb255-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-182"><a href="#cb255-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.nodes[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb255-183"><a href="#cb255-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-184"><a href="#cb255-184" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the input data.</span></span>
<span id="cb255-185"><a href="#cb255-185" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb255-186"><a href="#cb255-186" aria-hidden="true" tabindex="-1"></a><span class="st">TAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTATTATATAGAGATAGAATGGGTCCAGAGTTTTGTAATTTCCATGGGTCCAGAGTTTTGTAATTTAT</span></span>
<span id="cb255-187"><a href="#cb255-187" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb255-188"><a href="#cb255-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-189"><a href="#cb255-189" aria-hidden="true" tabindex="-1"></a>dna <span class="op">=</span> sample_input.strip()</span>
<span id="cb255-190"><a href="#cb255-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-191"><a href="#cb255-191" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the Suffix Tree.</span></span>
<span id="cb255-192"><a href="#cb255-192" aria-hidden="true" tabindex="-1"></a>suff <span class="op">=</span> SuffixTree(dna)</span>
<span id="cb255-193"><a href="#cb255-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-194"><a href="#cb255-194" aria-hidden="true" tabindex="-1"></a><span class="co"># Store all multiple repeats of length at least 20 in a dictionary keyed on number of appearances.</span></span>
<span id="cb255-195"><a href="#cb255-195" aria-hidden="true" tabindex="-1"></a>repeat_dict <span class="op">=</span> {}</span>
<span id="cb255-196"><a href="#cb255-196" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> suff.nodes[<span class="dv">1</span>:]:</span>
<span id="cb255-197"><a href="#cb255-197" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> suff.total_descendants(node) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> <span class="bu">len</span>(suff.node_word(node)) <span class="op">&gt;=</span> <span class="dv">20</span>:</span>
<span id="cb255-198"><a href="#cb255-198" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> suff.total_descendants(node) <span class="kw">not</span> <span class="kw">in</span> repeat_dict:</span>
<span id="cb255-199"><a href="#cb255-199" aria-hidden="true" tabindex="-1"></a>            repeat_dict[suff.total_descendants(node)] <span class="op">=</span> [suff.node_word(node)]</span>
<span id="cb255-200"><a href="#cb255-200" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb255-201"><a href="#cb255-201" aria-hidden="true" tabindex="-1"></a>            repeat_dict[suff.total_descendants(node)].append(suff.node_word(node))</span>
<span id="cb255-202"><a href="#cb255-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-203"><a href="#cb255-203" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter out non-maximal repeats.</span></span>
<span id="cb255-204"><a href="#cb255-204" aria-hidden="true" tabindex="-1"></a>repeats <span class="op">=</span> []</span>
<span id="cb255-205"><a href="#cb255-205" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> values <span class="kw">in</span> repeat_dict.values():</span>
<span id="cb255-206"><a href="#cb255-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(values) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb255-207"><a href="#cb255-207" aria-hidden="true" tabindex="-1"></a>        repeats <span class="op">+=</span> values</span>
<span id="cb255-208"><a href="#cb255-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb255-209"><a href="#cb255-209" aria-hidden="true" tabindex="-1"></a>        repeats <span class="op">+=</span> <span class="bu">filter</span>(<span class="kw">lambda</span> v: <span class="bu">all</span>(v <span class="kw">not</span> <span class="kw">in</span> word <span class="cf">for</span> word <span class="kw">in</span> values <span class="cf">if</span> word <span class="op">!=</span> v), values)</span>
<span id="cb255-210"><a href="#cb255-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-211"><a href="#cb255-211" aria-hidden="true" tabindex="-1"></a><span class="co"># Print and save the answer.</span></span>
<span id="cb255-212"><a href="#cb255-212" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(repeats))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="detailed-breakdown-of-the-code" class="level2" data-number="84.4">
<h2 data-number="84.4" class="anchored" data-anchor-id="detailed-breakdown-of-the-code"><span class="header-section-number">84.4</span> Detailed Breakdown of the Code</h2>
<ol type="1">
<li><p><strong><code>suff = SuffixTree(dna)</code></strong>:</p>
<ul>
<li>Constructs a suffix tree for the DNA sequence.</li>
</ul></li>
<li><p><strong>Building <code>repeat_dict</code></strong>:</p>
<ul>
<li>Collects all repeats that appear at least twice and are at least 20 characters long.</li>
<li>Uses the <code>total_descendants</code> method to count occurrences.</li>
</ul></li>
<li><p><strong>Filtering Non-Maximal Repeats</strong>:</p>
<ul>
<li>Ensures that each repeat is maximal by checking if it is not a substring of any other repeat in the same list.</li>
</ul></li>
<li><p><strong>Printing Results</strong>:</p>
<ul>
<li>Prints the filtered list of maximal repeats.</li>
</ul></li>
</ol>
</section>
</section>
<section id="multiple-alignment" class="level1" data-number="85">
<h1 data-number="85"><span class="header-section-number">85</span> Multiple Alignment</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/multiple-alignment/">multiple alignment</a>&nbsp;of a collection of three or more strings is formed by adding&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbols</a>&nbsp;to the strings to produce a collection of&nbsp;<a href="https://rosalind.info/glossary/augmented-string/">augmented strings</a>&nbsp;all having the same length.</p>
<p>A&nbsp;<a href="https://rosalind.info/glossary/multiple-alignment-score/">multiple alignment score</a>&nbsp;is obtained by taking the sum of an&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>&nbsp;over all possible pairs of augmented strings. The only difference in scoring the alignment of two strings is that two gap symbols may be aligned for a given pair (requiring us to specify a score for matched gap symbols).</p>
<p>Given:&nbsp;A collection of four&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;of length at most 10&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>.</p>
<p>Return:&nbsp;A multiple alignment of the strings having maximum score, where we score matched symbols 0 (including matched gap symbols) and all mismatched symbols -1 (thus incorporating a&nbsp;<a href="https://rosalind.info/glossary/linear-gap-penalty/">linear gap penalty</a>&nbsp;of 1).</p>
<section id="sample-dataset-84" class="level2" data-number="85.1">
<h2 data-number="85.1" class="anchored" data-anchor-id="sample-dataset-84"><span class="header-section-number">85.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_7
ATATCCG
&gt;Rosalind_35
TCCG
&gt;Rosalind_23
ATGTACTG
&gt;Rosalind_44
ATGTCTG</code></pre>
</section>
<section id="sample-output-85" class="level2" data-number="85.2">
<h2 data-number="85.2" class="anchored" data-anchor-id="sample-output-85"><span class="header-section-number">85.2</span> Sample Output</h2>
<pre><code>-18
ATAT-CCG
-T---CCG
ATGTACTG
ATGT-CTG</code></pre>
</section>
<section id="solution-81" class="level2" data-number="85.3">
<h2 data-number="85.3" class="anchored" data-anchor-id="solution-81"><span class="header-section-number">85.3</span> Solution</h2>
<div class="sourceCode" id="cb258"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score(chars, match<span class="op">=</span><span class="dv">0</span>, mismatch<span class="op">=-</span><span class="dv">1</span>):</span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the alignment score for a list of characters.</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a><span class="co">    :param chars: List of characters.</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a><span class="co">    :param match: Score for matching characters.</span></span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true" tabindex="-1"></a><span class="co">    :param mismatch: Score for mismatching characters.</span></span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Total alignment score.</span></span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-11"><a href="#cb258-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(match <span class="cf">if</span> chars[i] <span class="op">==</span> chars[j] <span class="cf">else</span> mismatch <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(chars)) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(chars)))</span>
<span id="cb258-12"><a href="#cb258-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-13"><a href="#cb258-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-14"><a href="#cb258-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_indices(dimensions):</span>
<span id="cb258-15"><a href="#cb258-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-16"><a href="#cb258-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate all possible indices for the given dimensions.</span></span>
<span id="cb258-17"><a href="#cb258-17" aria-hidden="true" tabindex="-1"></a><span class="co">    :param dimensions: List of dimensions for each sequence.</span></span>
<span id="cb258-18"><a href="#cb258-18" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Generator yielding tuples of indices.</span></span>
<span id="cb258-19"><a href="#cb258-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-20"><a href="#cb258-20" aria-hidden="true" tabindex="-1"></a>    total_combinations <span class="op">=</span> np.prod(dimensions)</span>
<span id="cb258-21"><a href="#cb258-21" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(dimensions)</span>
<span id="cb258-22"><a href="#cb258-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(total_combinations):</span>
<span id="cb258-23"><a href="#cb258-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> <span class="bu">tuple</span>(indices)</span>
<span id="cb258-24"><a href="#cb258-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(dimensions))):</span>
<span id="cb258-25"><a href="#cb258-25" aria-hidden="true" tabindex="-1"></a>            indices[j] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb258-26"><a href="#cb258-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> indices[j] <span class="op">&lt;</span> dimensions[j]:</span>
<span id="cb258-27"><a href="#cb258-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb258-28"><a href="#cb258-28" aria-hidden="true" tabindex="-1"></a>            indices[j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb258-29"><a href="#cb258-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-30"><a href="#cb258-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-31"><a href="#cb258-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_moves(num_sequences, options<span class="op">=</span>[<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb258-32"><a href="#cb258-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-33"><a href="#cb258-33" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate all valid move combinations.</span></span>
<span id="cb258-34"><a href="#cb258-34" aria-hidden="true" tabindex="-1"></a><span class="co">    :param num_sequences: Number of sequences.</span></span>
<span id="cb258-35"><a href="#cb258-35" aria-hidden="true" tabindex="-1"></a><span class="co">    :param options: Possible move options (0 for match, -1 for gap).</span></span>
<span id="cb258-36"><a href="#cb258-36" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: List of valid move combinations.</span></span>
<span id="cb258-37"><a href="#cb258-37" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-38"><a href="#cb258-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recursive_moves(m):</span>
<span id="cb258-39"><a href="#cb258-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> m <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb258-40"><a href="#cb258-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [[o] <span class="cf">for</span> o <span class="kw">in</span> options]</span>
<span id="cb258-41"><a href="#cb258-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [[o] <span class="op">+</span> rest <span class="cf">for</span> o <span class="kw">in</span> options <span class="cf">for</span> rest <span class="kw">in</span> recursive_moves(m <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb258-42"><a href="#cb258-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-43"><a href="#cb258-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [move <span class="cf">for</span> move <span class="kw">in</span> recursive_moves(num_sequences) <span class="cf">if</span> <span class="bu">any</span>(x <span class="op">!=</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> move)]</span>
<span id="cb258-44"><a href="#cb258-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-45"><a href="#cb258-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-46"><a href="#cb258-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_tuples(u, v):</span>
<span id="cb258-47"><a href="#cb258-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-48"><a href="#cb258-48" aria-hidden="true" tabindex="-1"></a><span class="co">    Add two tuples element-wise.</span></span>
<span id="cb258-49"><a href="#cb258-49" aria-hidden="true" tabindex="-1"></a><span class="co">    :param u: First tuple.</span></span>
<span id="cb258-50"><a href="#cb258-50" aria-hidden="true" tabindex="-1"></a><span class="co">    :param v: Second tuple.</span></span>
<span id="cb258-51"><a href="#cb258-51" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Element-wise sum of the tuples.</span></span>
<span id="cb258-52"><a href="#cb258-52" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-53"><a href="#cb258-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(a <span class="op">+</span> b <span class="cf">for</span> a, b <span class="kw">in</span> <span class="bu">zip</span>(u, v))</span>
<span id="cb258-54"><a href="#cb258-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-55"><a href="#cb258-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-56"><a href="#cb258-56" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_scoring_matrix(Strings, score_function<span class="op">=</span>score):</span>
<span id="cb258-57"><a href="#cb258-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-58"><a href="#cb258-58" aria-hidden="true" tabindex="-1"></a><span class="co">    Build the scoring matrix for the alignment.</span></span>
<span id="cb258-59"><a href="#cb258-59" aria-hidden="true" tabindex="-1"></a><span class="co">    :param Strings: List of sequences to align.</span></span>
<span id="cb258-60"><a href="#cb258-60" aria-hidden="true" tabindex="-1"></a><span class="co">    :param score_function: Function to calculate alignment score.</span></span>
<span id="cb258-61"><a href="#cb258-61" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Scoring matrix, path dictionary, and move list.</span></span>
<span id="cb258-62"><a href="#cb258-62" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-63"><a href="#cb258-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_scores(index):</span>
<span id="cb258-64"><a href="#cb258-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> get_score(move):</span>
<span id="cb258-65"><a href="#cb258-65" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> add_tuples(index, move)</span>
<span id="cb258-66"><a href="#cb258-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">any</span>(p <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">for</span> p <span class="kw">in</span> previous):</span>
<span id="cb258-67"><a href="#cb258-67" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb258-68"><a href="#cb258-68" aria-hidden="true" tabindex="-1"></a>            scorable <span class="op">=</span> [Strings[j][previous[j]] <span class="cf">if</span> move[j] <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">'-'</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(move))]</span>
<span id="cb258-69"><a href="#cb258-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> scoring_matrix[previous] <span class="op">+</span> score_function(scorable)</span>
<span id="cb258-70"><a href="#cb258-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-71"><a href="#cb258-71" aria-hidden="true" tabindex="-1"></a>        raw_scores <span class="op">=</span> [(get_score(move), move) <span class="cf">for</span> move <span class="kw">in</span> available_moves]</span>
<span id="cb258-72"><a href="#cb258-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [(score, move) <span class="cf">for</span> score, move <span class="kw">in</span> raw_scores <span class="cf">if</span> score <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>]</span>
<span id="cb258-73"><a href="#cb258-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-74"><a href="#cb258-74" aria-hidden="true" tabindex="-1"></a>    dimensions <span class="op">=</span> [<span class="bu">len</span>(S) <span class="op">+</span> <span class="dv">1</span> <span class="cf">for</span> S <span class="kw">in</span> Strings]</span>
<span id="cb258-75"><a href="#cb258-75" aria-hidden="true" tabindex="-1"></a>    scoring_matrix <span class="op">=</span> np.zeros(dimensions, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb258-76"><a href="#cb258-76" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> {}</span>
<span id="cb258-77"><a href="#cb258-77" aria-hidden="true" tabindex="-1"></a>    available_moves <span class="op">=</span> generate_moves(<span class="bu">len</span>(Strings))</span>
<span id="cb258-78"><a href="#cb258-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-79"><a href="#cb258-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index_set <span class="kw">in</span> generate_indices(dimensions):</span>
<span id="cb258-80"><a href="#cb258-80" aria-hidden="true" tabindex="-1"></a>        scores_moves <span class="op">=</span> calculate_scores(index_set)</span>
<span id="cb258-81"><a href="#cb258-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> scores_moves:</span>
<span id="cb258-82"><a href="#cb258-82" aria-hidden="true" tabindex="-1"></a>            scores, moves <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>scores_moves)</span>
<span id="cb258-83"><a href="#cb258-83" aria-hidden="true" tabindex="-1"></a>            best_index <span class="op">=</span> np.argmax(scores)</span>
<span id="cb258-84"><a href="#cb258-84" aria-hidden="true" tabindex="-1"></a>            scoring_matrix[index_set] <span class="op">=</span> scores[best_index]</span>
<span id="cb258-85"><a href="#cb258-85" aria-hidden="true" tabindex="-1"></a>            path[index_set] <span class="op">=</span> moves[best_index]</span>
<span id="cb258-86"><a href="#cb258-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-87"><a href="#cb258-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scoring_matrix, path, available_moves</span>
<span id="cb258-88"><a href="#cb258-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-89"><a href="#cb258-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-90"><a href="#cb258-90" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtrack_alignment(scoring_matrix, path, Strings):</span>
<span id="cb258-91"><a href="#cb258-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-92"><a href="#cb258-92" aria-hidden="true" tabindex="-1"></a><span class="co">    Perform backtracking to retrieve the optimal alignment.</span></span>
<span id="cb258-93"><a href="#cb258-93" aria-hidden="true" tabindex="-1"></a><span class="co">    :param scoring_matrix: Scoring matrix.</span></span>
<span id="cb258-94"><a href="#cb258-94" aria-hidden="true" tabindex="-1"></a><span class="co">    :param path: Path dictionary for moves.</span></span>
<span id="cb258-95"><a href="#cb258-95" aria-hidden="true" tabindex="-1"></a><span class="co">    :param Strings: List of sequences to align.</span></span>
<span id="cb258-96"><a href="#cb258-96" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Alignment score and aligned sequences.</span></span>
<span id="cb258-97"><a href="#cb258-97" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-98"><a href="#cb258-98" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reverse_string(s):</span>
<span id="cb258-99"><a href="#cb258-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">''</span>.join(<span class="bu">reversed</span>(s))</span>
<span id="cb258-100"><a href="#cb258-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-101"><a href="#cb258-101" aria-hidden="true" tabindex="-1"></a>    position <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">len</span>(S) <span class="cf">for</span> S <span class="kw">in</span> Strings)</span>
<span id="cb258-102"><a href="#cb258-102" aria-hidden="true" tabindex="-1"></a>    alignment_score <span class="op">=</span> scoring_matrix[position]</span>
<span id="cb258-103"><a href="#cb258-103" aria-hidden="true" tabindex="-1"></a>    alignments <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> Strings]</span>
<span id="cb258-104"><a href="#cb258-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-105"><a href="#cb258-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">any</span>(p <span class="op">!=</span> <span class="dv">0</span> <span class="cf">for</span> p <span class="kw">in</span> position):</span>
<span id="cb258-106"><a href="#cb258-106" aria-hidden="true" tabindex="-1"></a>        move <span class="op">=</span> path[position]</span>
<span id="cb258-107"><a href="#cb258-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, m <span class="kw">in</span> <span class="bu">enumerate</span>(move):</span>
<span id="cb258-108"><a href="#cb258-108" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb258-109"><a href="#cb258-109" aria-hidden="true" tabindex="-1"></a>                alignments[i].append(<span class="st">'-'</span>)</span>
<span id="cb258-110"><a href="#cb258-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb258-111"><a href="#cb258-111" aria-hidden="true" tabindex="-1"></a>                alignments[i].append(Strings[i][position[i] <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb258-112"><a href="#cb258-112" aria-hidden="true" tabindex="-1"></a>        position <span class="op">=</span> add_tuples(position, move)</span>
<span id="cb258-113"><a href="#cb258-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-114"><a href="#cb258-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alignment_score, [reverse_string(s) <span class="cf">for</span> s <span class="kw">in</span> alignments]</span>
<span id="cb258-115"><a href="#cb258-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-116"><a href="#cb258-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-117"><a href="#cb258-117" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> FindHighestScoringMultipleSequenceAlignment(Strings, score_function<span class="op">=</span>score):</span>
<span id="cb258-118"><a href="#cb258-118" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-119"><a href="#cb258-119" aria-hidden="true" tabindex="-1"></a><span class="co">    Find the highest scoring multiple sequence alignment.</span></span>
<span id="cb258-120"><a href="#cb258-120" aria-hidden="true" tabindex="-1"></a><span class="co">    :param Strings: List of sequences to align.</span></span>
<span id="cb258-121"><a href="#cb258-121" aria-hidden="true" tabindex="-1"></a><span class="co">    :param score_function: Function to calculate alignment score.</span></span>
<span id="cb258-122"><a href="#cb258-122" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Alignment score and aligned sequences.</span></span>
<span id="cb258-123"><a href="#cb258-123" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-124"><a href="#cb258-124" aria-hidden="true" tabindex="-1"></a>    scoring_matrix, path, _ <span class="op">=</span> build_scoring_matrix(Strings, score_function)</span>
<span id="cb258-125"><a href="#cb258-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> backtrack_alignment(scoring_matrix, path, Strings)</span>
<span id="cb258-126"><a href="#cb258-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-127"><a href="#cb258-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-128"><a href="#cb258-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb258-129"><a href="#cb258-129" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb258-130"><a href="#cb258-130" aria-hidden="true" tabindex="-1"></a><span class="co">    Parse FASTA format data into a list of sequences.</span></span>
<span id="cb258-131"><a href="#cb258-131" aria-hidden="true" tabindex="-1"></a><span class="co">    :param data: FASTA format input data.</span></span>
<span id="cb258-132"><a href="#cb258-132" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: List of sequences.</span></span>
<span id="cb258-133"><a href="#cb258-133" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb258-134"><a href="#cb258-134" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb258-135"><a href="#cb258-135" aria-hidden="true" tabindex="-1"></a>    entries <span class="op">=</span> data.strip().split(<span class="st">'&gt;'</span>)</span>
<span id="cb258-136"><a href="#cb258-136" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> entries:</span>
<span id="cb258-137"><a href="#cb258-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> entry:</span>
<span id="cb258-138"><a href="#cb258-138" aria-hidden="true" tabindex="-1"></a>            lines <span class="op">=</span> entry.splitlines()</span>
<span id="cb258-139"><a href="#cb258-139" aria-hidden="true" tabindex="-1"></a>            sequence <span class="op">=</span> <span class="st">''</span>.join(lines[<span class="dv">1</span>:])</span>
<span id="cb258-140"><a href="#cb258-140" aria-hidden="true" tabindex="-1"></a>            sequences.append(sequence)</span>
<span id="cb258-141"><a href="#cb258-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb258-142"><a href="#cb258-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-143"><a href="#cb258-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-144"><a href="#cb258-144" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input in FASTA format</span></span>
<span id="cb258-145"><a href="#cb258-145" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb258-146"><a href="#cb258-146" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_7</span></span>
<span id="cb258-147"><a href="#cb258-147" aria-hidden="true" tabindex="-1"></a><span class="st">ATATCCG</span></span>
<span id="cb258-148"><a href="#cb258-148" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_35</span></span>
<span id="cb258-149"><a href="#cb258-149" aria-hidden="true" tabindex="-1"></a><span class="st">TCCG</span></span>
<span id="cb258-150"><a href="#cb258-150" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_23</span></span>
<span id="cb258-151"><a href="#cb258-151" aria-hidden="true" tabindex="-1"></a><span class="st">ATGTACTG</span></span>
<span id="cb258-152"><a href="#cb258-152" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_44</span></span>
<span id="cb258-153"><a href="#cb258-153" aria-hidden="true" tabindex="-1"></a><span class="st">ATGTCTG</span></span>
<span id="cb258-154"><a href="#cb258-154" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb258-155"><a href="#cb258-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-156"><a href="#cb258-156" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the sequences from the sample input</span></span>
<span id="cb258-157"><a href="#cb258-157" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb258-158"><a href="#cb258-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-159"><a href="#cb258-159" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the alignment.</span></span>
<span id="cb258-160"><a href="#cb258-160" aria-hidden="true" tabindex="-1"></a>score, alignment <span class="op">=</span> FindHighestScoringMultipleSequenceAlignment(words)</span>
<span id="cb258-161"><a href="#cb258-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-162"><a href="#cb258-162" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the alignment score and sequences.</span></span>
<span id="cb258-163"><a href="#cb258-163" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(score)</span>
<span id="cb258-164"><a href="#cb258-164" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> alignment:</span>
<span id="cb258-165"><a href="#cb258-165" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(line)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explain-the-code" class="level2" data-number="85.4">
<h2 data-number="85.4" class="anchored" data-anchor-id="explain-the-code"><span class="header-section-number">85.4</span> Explain the code</h2>
<ol type="1">
<li><strong><code>score(chars, match, mismatch)</code></strong>:
<ul>
<li>This function computes the alignment score based on matches and mismatches.</li>
</ul></li>
<li><strong><code>generate_indices(dimensions)</code></strong>:
<ul>
<li>Generates all possible index tuples for alignment, given the sequence lengths.</li>
</ul></li>
<li><strong><code>generate_moves(num_sequences, options)</code></strong>:
<ul>
<li>Generates valid move combinations for alignment, ensuring at least one non-gap move.</li>
</ul></li>
<li><strong><code>add_tuples(u, v)</code></strong>:
<ul>
<li>Element-wise addition of two tuples.</li>
</ul></li>
<li><strong><code>build_scoring_matrix(Strings, score_function)</code></strong>:
<ul>
<li>Constructs the scoring matrix and paths for backtracking.</li>
</ul></li>
<li><strong><code>backtrack_alignment(scoring_matrix, path, Strings)</code></strong>:
<ul>
<li>Reconstructs the alignment based on the scoring matrix and path.</li>
</ul></li>
<li><strong><code>parse_fasta(data)</code></strong>:
<ul>
<li>Parses FASTA format data into a list of sequences.</li>
</ul></li>
</ol>
</section>
</section>
<section id="creating-a-restriction-map" class="level1" data-number="86">
<h1 data-number="86"><span class="header-section-number">86</span> Creating a Restriction Map</h1>
<p>For a&nbsp;<a href="https://rosalind.info/glossary/set/">set</a> <span class="math inline">\(X\)</span>&nbsp;containing numbers, the&nbsp;<a href="https://rosalind.info/glossary/difference-multiset/">difference multiset</a>&nbsp;of&nbsp;<span class="math inline">\(X\)</span> is the&nbsp;<a href="https://rosalind.info/glossary/multiset/">multiset</a>&nbsp;<span class="math inline">\(ΔX\)</span>&nbsp;defined as the collection of all&nbsp;positive&nbsp;differences between elements of&nbsp;<span class="math inline">\(X\)</span>. As a quick example, if&nbsp;<span class="math inline">\(X={2,4,7}\)</span>, then we will have that&nbsp;<span class="math inline">\(ΔX={2,3,5}\)</span>.</p>
<p>If&nbsp;<span class="math inline">\(X\)</span>&nbsp;contains&nbsp;n&nbsp;elements, then&nbsp;<span class="math inline">\(ΔX\)</span>&nbsp;will contain one element for each pair of elements from&nbsp;<span class="math inline">\(X\)</span>, so that&nbsp;<span class="math inline">\(ΔX\)</span>&nbsp;contains&nbsp;<span class="math inline">\((n2)\)</span>&nbsp;elements (see&nbsp;<a href="https://rosalind.info/glossary/combination/">combination statistic</a>). You may note the similarity between the difference multiset and the&nbsp;<a href="https://rosalind.info/glossary/minkowski-difference/">Minkowski difference</a>&nbsp;<span class="math inline">\(X⊖X\)</span>, which contains the elements of&nbsp;<span class="math inline">\(ΔX\)</span>&nbsp;and their negatives. For the above set&nbsp;<span class="math inline">\(X\)</span>,&nbsp;<span class="math inline">\(X⊖X\)</span>&nbsp;is&nbsp;<span class="math inline">\({−5,−3,−2,2,3,5}\)</span>.</p>
<p>In practical terms, we can easily obtain a multiset&nbsp;<span class="math inline">\(L\)</span>&nbsp;corresponding to the distances between restriction sites on a chromosome. If we can find a set&nbsp;<span class="math inline">\(X\)</span>&nbsp;whose difference multiset&nbsp;<span class="math inline">\(ΔX\)</span> is equal to&nbsp;<span class="math inline">\(L\)</span>, then&nbsp;<span class="math inline">\(X\)</span>&nbsp;will represent possible locations of these restriction sites.</p>
<p>Given:&nbsp;A multiset&nbsp;<span class="math inline">\(L\)</span>&nbsp;containing&nbsp;<span class="math inline">\((n2)\)</span>&nbsp;positive integers for some positive integer&nbsp;<span class="math inline">\(n\)</span>.</p>
<p>Return:&nbsp;A set&nbsp;<span class="math inline">\(X\)</span>&nbsp;containing&nbsp;n&nbsp;nonnegative integers such that&nbsp;<span class="math inline">\(ΔX=L\)</span>.</p>
<section id="sample-dataset-85" class="level2" data-number="86.1">
<h2 data-number="86.1" class="anchored" data-anchor-id="sample-dataset-85"><span class="header-section-number">86.1</span> Sample Dataset</h2>
<pre><code>2 2 3 3 4 5 6 7 8 10</code></pre>
</section>
<section id="sample-output-86" class="level2" data-number="86.2">
<h2 data-number="86.2" class="anchored" data-anchor-id="sample-output-86"><span class="header-section-number">86.2</span> Sample Output</h2>
<pre><code>0 2 4 7 10</code></pre>
</section>
<section id="solution-82" class="level2" data-number="86.3">
<h2 data-number="86.3" class="anchored" data-anchor-id="solution-82"><span class="header-section-number">86.3</span> Solution</h2>
<div class="sourceCode" id="cb261"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct_set(input_data):</span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Reconstruct the original set from the given differences.</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a><span class="co">    :param input_data: A string containing space-separated integers representing the differences</span></span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: A list of integers representing the reconstructed set</span></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert input string to list of integers</span></span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a>    differences <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, input_data.strip().split()))</span>
<span id="cb261-12"><a href="#cb261-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-13"><a href="#cb261-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the number of elements in the original set</span></span>
<span id="cb261-14"><a href="#cb261-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using the quadratic formula: n(n-1)/2 = len(differences)</span></span>
<span id="cb261-15"><a href="#cb261-15" aria-hidden="true" tabindex="-1"></a>    set_size <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sqrt(<span class="fl">8.0</span> <span class="op">*</span> <span class="bu">len</span>(differences) <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb261-16"><a href="#cb261-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-17"><a href="#cb261-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the result set with 0</span></span>
<span id="cb261-18"><a href="#cb261-18" aria-hidden="true" tabindex="-1"></a>    result_set <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb261-19"><a href="#cb261-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-20"><a href="#cb261-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the largest difference to the result set</span></span>
<span id="cb261-21"><a href="#cb261-21" aria-hidden="true" tabindex="-1"></a>    largest_difference <span class="op">=</span> <span class="bu">max</span>(differences)</span>
<span id="cb261-22"><a href="#cb261-22" aria-hidden="true" tabindex="-1"></a>    result_set.append(largest_difference)</span>
<span id="cb261-23"><a href="#cb261-23" aria-hidden="true" tabindex="-1"></a>    differences.remove(largest_difference)</span>
<span id="cb261-24"><a href="#cb261-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-25"><a href="#cb261-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a set of unique differences</span></span>
<span id="cb261-26"><a href="#cb261-26" aria-hidden="true" tabindex="-1"></a>    unique_differences <span class="op">=</span> <span class="bu">set</span>(differences)</span>
<span id="cb261-27"><a href="#cb261-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-28"><a href="#cb261-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> candidate <span class="kw">in</span> unique_differences:</span>
<span id="cb261-29"><a href="#cb261-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if the candidate fits with all existing elements in the result set</span></span>
<span id="cb261-30"><a href="#cb261-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">sum</span>([(<span class="bu">abs</span>(candidate <span class="op">-</span> element) <span class="kw">in</span> differences) <span class="cf">for</span> element <span class="kw">in</span> result_set]) <span class="op">==</span> <span class="bu">len</span>(result_set):</span>
<span id="cb261-31"><a href="#cb261-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> element <span class="kw">in</span> result_set:</span>
<span id="cb261-32"><a href="#cb261-32" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Remove the differences we've already accounted for</span></span>
<span id="cb261-33"><a href="#cb261-33" aria-hidden="true" tabindex="-1"></a>                differences.remove(<span class="bu">abs</span>(candidate <span class="op">-</span> element))</span>
<span id="cb261-34"><a href="#cb261-34" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add the new element to the result set</span></span>
<span id="cb261-35"><a href="#cb261-35" aria-hidden="true" tabindex="-1"></a>            result_set.append(candidate)</span>
<span id="cb261-36"><a href="#cb261-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(result_set) <span class="op">==</span> set_size:</span>
<span id="cb261-37"><a href="#cb261-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb261-38"><a href="#cb261-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-39"><a href="#cb261-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(result_set)</span>
<span id="cb261-40"><a href="#cb261-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-41"><a href="#cb261-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb261-42"><a href="#cb261-42" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb261-43"><a href="#cb261-43" aria-hidden="true" tabindex="-1"></a><span class="st">2 2 3 3 4 5 6 7 8 10</span></span>
<span id="cb261-44"><a href="#cb261-44" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb261-45"><a href="#cb261-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-46"><a href="#cb261-46" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> reconstruct_set(input_data)</span>
<span id="cb261-47"><a href="#cb261-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, result)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="step-by-step-explanation" class="level2" data-number="86.4">
<h2 data-number="86.4" class="anchored" data-anchor-id="step-by-step-explanation"><span class="header-section-number">86.4</span> Step-by-Step Explanation</h2>
<ol type="1">
<li><strong>Convert Input to a List</strong>:
<ul>
<li>The input string is converted into a list of integers. These integers represent the differences between every pair of elements in the original set.</li>
</ul></li>
<li><strong>Determine the Number of Elements</strong>:
<ul>
<li>The code calculates how many numbers were in the original set using a mathematical formula related to the number of differences.</li>
</ul></li>
<li><strong>Start with the Smallest Element</strong>:
<ul>
<li>The code assumes the smallest number in the set is <code>0</code> and starts the <code>result_set</code> with <code>[0]</code>.</li>
</ul></li>
<li><strong>Add the Largest Difference</strong>:
<ul>
<li>The largest number in the original set is found by taking the largest difference from the list. This number is added to the <code>result_set</code>.</li>
</ul></li>
<li><strong>Reconstruct the Remaining Numbers</strong>:
<ul>
<li>The code checks each remaining difference to see if it can be used to find other numbers in the set. It does this by ensuring that each candidate number fits with all previously found numbers (i.e., the differences match).</li>
</ul></li>
<li><strong>Build the Set</strong>:
<ul>
<li>As valid numbers are found, they are added to the <code>result_set</code>, and the corresponding differences are removed from the list.</li>
</ul></li>
<li><strong>Return the Sorted Set</strong>:
<ul>
<li>The <code>result_set</code> is sorted and returned, which is the reconstructed original set.</li>
</ul></li>
</ol>
</section>
</section>
<section id="counting-rooted-binary-trees" class="level1" data-number="87">
<h1 data-number="87"><span class="header-section-number">87</span> Counting Rooted Binary Trees</h1>
<p>As in the case of unrooted trees, say that we have a fixed collection of&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/taxon/">taxa</a>&nbsp;labeling the&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>&nbsp;of a rooted binary tree&nbsp;<span class="math inline">\(T\)</span>. You may like to verify that (by extension of&nbsp;<a href="https://rosalind.info/problems/inod/">“Counting Phylogenetic Ancestors”</a>) such a tree will contain&nbsp;<span class="math inline">\(n−1\)</span>&nbsp;internal nodes and&nbsp;<span class="math inline">\(2n−2\)</span>&nbsp;total&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a>. Any edge will still encode a&nbsp;<a href="https://rosalind.info/glossary/split/">split</a>&nbsp;of taxa; however, the two splits corresponding to the edges&nbsp;<a href="https://rosalind.info/glossary/incident/">incident</a>&nbsp;to the root of&nbsp;<span class="math inline">\(T\)</span>&nbsp;will be equal. We still consider two trees to be equivalent if they have the same splits (which requires that they must also share the same duplicated split to be equal).</p>
<p>Let&nbsp;<span class="math inline">\(B(n)\)</span>&nbsp;represent the total number of&nbsp;<a href="https://rosalind.info/glossary/distinct/">distinct</a>&nbsp;rooted binary trees on&nbsp;n&nbsp;labeled taxa.</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n&nbsp;(n≤1000)\)</span>.</p>
<p>Return:&nbsp;The value of&nbsp;<span class="math inline">\(B(n)\)</span>&nbsp;modulo 1,000,000.</p>
<section id="sample-dataset-86" class="level2" data-number="87.1">
<h2 data-number="87.1" class="anchored" data-anchor-id="sample-dataset-86"><span class="header-section-number">87.1</span> Sample Dataset</h2>
<pre><code>4</code></pre>
</section>
<section id="sample-output-87" class="level2" data-number="87.2">
<h2 data-number="87.2" class="anchored" data-anchor-id="sample-output-87"><span class="header-section-number">87.2</span> Sample Output</h2>
<pre><code>15</code></pre>
</section>
<section id="solution-83" class="level2" data-number="87.3">
<h2 data-number="87.3" class="anchored" data-anchor-id="solution-83"><span class="header-section-number">87.3</span> Solution</h2>
<div class="sourceCode" id="cb264"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_unrooted_binary_trees(n):</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Returns the number of unrooted binary trees with n leaves.'''</span></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The total number is just the double factorial (2n - 5)!!</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">5</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>):</span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> (result <span class="op">*</span> i) <span class="op">%</span> <span class="dv">10</span><span class="op">**</span><span class="dv">6</span></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_rooted_binary_trees(n):</span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''Returns the number of rooted binary trees with n leaves.'''</span></span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Can transform an unrooted binary tree into a rooted binary tree by inserting</span></span>
<span id="cb264-12"><a href="#cb264-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># a node into any of its 2*n - 3 edges.</span></span>
<span id="cb264-13"><a href="#cb264-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (count_unrooted_binary_trees(n) <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">3</span>)) <span class="op">%</span> <span class="dv">10</span><span class="op">**</span><span class="dv">6</span></span>
<span id="cb264-14"><a href="#cb264-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-15"><a href="#cb264-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the input data.</span></span>
<span id="cb264-16"><a href="#cb264-16" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb264-17"><a href="#cb264-17" aria-hidden="true" tabindex="-1"></a><span class="st">4</span></span>
<span id="cb264-18"><a href="#cb264-18" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb264-19"><a href="#cb264-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-20"><a href="#cb264-20" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(input_data.strip())</span>
<span id="cb264-21"><a href="#cb264-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-22"><a href="#cb264-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the number of unrooted binary trees.</span></span>
<span id="cb264-23"><a href="#cb264-23" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> count_rooted_binary_trees(n)</span>
<span id="cb264-24"><a href="#cb264-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-25"><a href="#cb264-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the answer.</span></span>
<span id="cb264-26"><a href="#cb264-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="count_unrooted_binary_treesn" class="level2" data-number="87.4">
<h2 data-number="87.4" class="anchored" data-anchor-id="count_unrooted_binary_treesn"><span class="header-section-number">87.4</span> <strong><code>count_unrooted_binary_trees(n)</code></strong></h2>
<ul>
<li><strong>Purpose:</strong> This function calculates the number of possible unrooted binary trees with <code>n</code> leaves.</li>
<li><strong>Logic:</strong>
<ul>
<li>The number of unrooted binary trees with <code>n</code> leaves is given by the double factorial of <code>(2n - 5)</code>, which is denoted as <code>(2n - 5)!!</code>.</li>
<li>The double factorial of a number is the product of all integers down to <code>1</code> that have the same parity (odd/even) as the starting number.</li>
<li>For example, if <code>n = 4</code>, <code>(2n - 5) = 3</code>, and the double factorial would be <code>3!! = 3</code>.</li>
<li>The loop multiplies all odd numbers from <code>2n - 5</code> down to <code>3</code>.</li>
<li>The result is taken modulo <code>10^6</code> to keep the number manageable and avoid overflow.</li>
</ul></li>
</ul>
</section>
<section id="count_rooted_binary_treesn" class="level2" data-number="87.5">
<h2 data-number="87.5" class="anchored" data-anchor-id="count_rooted_binary_treesn"><span class="header-section-number">87.5</span> <strong><code>count_rooted_binary_trees(n)</code></strong></h2>
<ul>
<li><strong>Purpose:</strong> This function calculates the number of possible rooted binary trees with <code>n</code> leaves.</li>
<li><strong>Logic:</strong>
<ul>
<li>A rooted binary tree can be derived from an unrooted binary tree by adding a root to any of the <code>2n - 3</code> edges of the unrooted tree.</li>
<li>Therefore, the number of rooted binary trees is the number of unrooted binary trees multiplied by <code>(2n - 3)</code>.</li>
<li>Again, the result is taken modulo <code>10^6</code>.</li>
</ul></li>
</ul>
</section>
<section id="how-it-works" class="level2" data-number="87.6">
<h2 data-number="87.6" class="anchored" data-anchor-id="how-it-works"><span class="header-section-number">87.6</span> How It Works</h2>
<ul>
<li><p><strong>Input:</strong> The code reads the input value <code>n</code> from the string <code>input_data</code>. For example, if <code>n = 4</code>, the code calculates the number of binary trees for <code>n = 4</code>.</p></li>
<li><p><strong>Execution Flow:</strong></p>
<ol type="1">
<li><code>count_rooted_binary_trees(n)</code> is called with <code>n = 4</code>.</li>
<li>Inside this function, <code>count_unrooted_binary_trees(n)</code> is called.</li>
<li>The <code>count_unrooted_binary_trees(n)</code> function computes the product <code>(2n - 5)!!</code> modulo <code>10^6</code>:
<ul>
<li>For <code>n = 4</code>, <code>(2n - 5) = 3</code>.</li>
<li>The loop runs from <code>3</code> to <code>1</code> (odd numbers only), resulting in <code>3!! = 3</code>.</li>
</ul></li>
<li>The result (<code>3</code> in this case) is multiplied by <code>(2 * n - 3) = 5</code>, giving <code>3 * 5 = 15</code>.</li>
<li>The final result is <code>15 % 10^6 = 15</code>, which is returned and printed.</li>
</ol></li>
</ul>
</section>
</section>
<section id="sex-linked-inheritance" class="level1" data-number="88">
<h1 data-number="88"><span class="header-section-number">88</span> Sex-Linked Inheritance</h1>
<p>The&nbsp;<a href="https://rosalind.info/glossary/conditional-probability/">conditional probability</a>&nbsp;of an&nbsp;<a href="https://rosalind.info/glossary/probabilistic-event/">event</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;given another event&nbsp;<span class="math inline">\(B\)</span>, written&nbsp;<span class="math inline">\(Pr(A∣B)\)</span>, is equal to&nbsp;<span class="math inline">\(Pr(A&nbsp;and&nbsp;B)\)</span>&nbsp;divided by&nbsp;<span class="math inline">\(Pr(B)\)</span>.</p>
<p>Note that if&nbsp;<span class="math inline">\(A\)</span>&nbsp;and&nbsp;<span class="math inline">\(B\)</span>&nbsp;are&nbsp;<a href="https://rosalind.info/glossary/independent-events/">independent</a>, then&nbsp;<span class="math inline">\(Pr(A&nbsp;and&nbsp;B)\)</span>&nbsp;must be equal to&nbsp;<span class="math inline">\(Pr(A)×Pr(B)\)</span>, which results in&nbsp;<span class="math inline">\(Pr(A∣B)=Pr(A)\)</span>. This equation offers an intuitive view of independence: the probability of&nbsp;<span class="math inline">\(A\)</span>, given the occurrence of event&nbsp;<span class="math inline">\(B\)</span>, is simply the probability of&nbsp;<span class="math inline">\(A\)</span>&nbsp;(which does not depend on&nbsp;<span class="math inline">\(B\)</span>).</p>
<p>In the context of sex-linked traits,&nbsp;<a href="https://rosalind.info/glossary/genetic-equilibrium/">genetic equilibrium</a>&nbsp;requires that the alleles for a gene&nbsp;<span class="math inline">\(k\)</span>&nbsp;are uniformly distributed over the males and females of a population. In other words, the distribution of alleles is&nbsp;independent&nbsp;of sex.</p>
<p>Given:&nbsp;An&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;for which&nbsp;<span class="math inline">\(A[k]\)</span>&nbsp;represents the proportion of males in a population exhibiting the&nbsp;<span class="math inline">\(k\)</span>-th of&nbsp;<span class="math inline">\(n\)</span>&nbsp;total recessive X-linked genes. Assume that the population is in&nbsp;<a href="https://rosalind.info/glossary/genetic-equilibrium/">genetic equilibrium</a>&nbsp;for all&nbsp;<span class="math inline">\(n\)</span>&nbsp;genes.</p>
<p>Return:&nbsp;An array&nbsp;<span class="math inline">\(B\)</span>&nbsp;of length&nbsp;<span class="math inline">\(n\)</span>&nbsp;in which&nbsp;<span class="math inline">\(B[k]\)</span>&nbsp;equals the probability that a randomly selected female will be a&nbsp;<a href="https://rosalind.info/glossary/genetic-carrier/">carrier</a>&nbsp;for the&nbsp;<span class="math inline">\(k\)</span>-th gene.</p>
<section id="sample-dataset-87" class="level2" data-number="88.1">
<h2 data-number="88.1" class="anchored" data-anchor-id="sample-dataset-87"><span class="header-section-number">88.1</span> Sample Dataset</h2>
<pre><code>0.1 0.5 0.8</code></pre>
</section>
<section id="sample-output-88" class="level2" data-number="88.2">
<h2 data-number="88.2" class="anchored" data-anchor-id="sample-output-88"><span class="header-section-number">88.2</span> Sample Output</h2>
<pre><code>0.18 0.5 0.32</code></pre>
</section>
<section id="solution-84" class="level2" data-number="88.3">
<h2 data-number="88.3" class="anchored" data-anchor-id="solution-84"><span class="header-section-number">88.3</span> Solution</h2>
<div class="sourceCode" id="cb267"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the input data.</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>input_data <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a><span class="st">0.1 0.5 0.8</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert input data to a list of floats.</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> input_data.strip().split()]</span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the desired values.</span></span>
<span id="cb267-10"><a href="#cb267-10" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> [<span class="dv">2</span> <span class="op">*</span> (x <span class="op">-</span> x<span class="op">**</span><span class="dv">2</span>) <span class="cf">for</span> x <span class="kw">in</span> numbers]</span>
<span id="cb267-11"><a href="#cb267-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-12"><a href="#cb267-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Format the results to two decimal places and print.</span></span>
<span id="cb267-13"><a href="#cb267-13" aria-hidden="true" tabindex="-1"></a>formatted_results <span class="op">=</span> <span class="st">' '</span>.join(<span class="ss">f"</span><span class="sc">{</span>result<span class="sc">:f}</span><span class="ss">"</span> <span class="cf">for</span> result <span class="kw">in</span> results)</span>
<span id="cb267-14"><a href="#cb267-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(formatted_results)</span>
<span id="cb267-15"><a href="#cb267-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-16"><a href="#cb267-16" aria-hidden="true" tabindex="-1"></a>unformatted_results <span class="op">=</span> <span class="st">' '</span>.join(<span class="ss">f"</span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> result <span class="kw">in</span> results)</span>
<span id="cb267-17"><a href="#cb267-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(unformatted_results) <span class="co"># only unformatted_results accepted to answer</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Calculate Results</strong>: - For each number in <code>numbers</code>, the code calculates a new value using the formula <code>2 * (x - x**2)</code>. This formula computes the difference between a number and its square, doubles it, and stores it in the <code>results</code> list. - The calculations for each number would be: - For <code>0.1</code>: <code>2 * (0.1 - 0.1**2) = 0.18</code> - For <code>0.5</code>: <code>2 * (0.5 - 0.5**2) = 0.50</code> - For <code>0.8</code>: <code>2 * (0.8 - 0.8**2) = 0.32</code> - The resulting list is: <code>[0.18, 0.50, 0.32]</code>.</p>
</section>
</section>
<section id="phylogeny-comparison-with-split-distance" class="level1" data-number="89">
<h1 data-number="89"><span class="header-section-number">89</span> Phylogeny Comparison with Split Distance</h1>
<p>Define the&nbsp;<a href="https://rosalind.info/glossary/split-distance/">split distance</a>&nbsp;between two unrooted binary trees as the number of nontrivial splits contained in one tree but not the other.</p>
<p>Formally, if&nbsp;<span class="math inline">\(s(T1,T2)\)</span>&nbsp;denotes the number of nontrivial splits shared by unrooted binary trees&nbsp;<span class="math inline">\(T1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T2\)</span>, Then their split distance is&nbsp;<span class="math inline">\(d_{split}(T1,T2)=2(n−3)−2s(T1,T2)\)</span>.</p>
<p>Given:&nbsp;A collection of at most 3,000 species taxa and two unrooted binary trees&nbsp;<span class="math inline">\(T1\)</span> and&nbsp;<span class="math inline">\(T2\)</span>on these taxa in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>.</p>
<p>Return:&nbsp;The split distance&nbsp;<span class="math inline">\(d_{split}(T1,T2)\)</span>.</p>
<section id="sample-dataset-88" class="level2" data-number="89.1">
<h2 data-number="89.1" class="anchored" data-anchor-id="sample-dataset-88"><span class="header-section-number">89.1</span> Sample Dataset</h2>
<pre><code>dog rat elephant mouse cat rabbit
(rat,(dog,cat),(rabbit,(elephant,mouse)));
(rat,(cat,dog),(elephant,(mouse,rabbit)));</code></pre>
</section>
<section id="sample-output-89" class="level2" data-number="89.2">
<h2 data-number="89.2" class="anchored" data-anchor-id="sample-output-89"><span class="header-section-number">89.2</span> Sample Output</h2>
<pre><code>2</code></pre>
</section>
<section id="solution-85" class="level2" data-number="89.3">
<h2 data-number="89.3" class="anchored" data-anchor-id="solution-85"><span class="header-section-number">89.3</span> Solution</h2>
<div class="sourceCode" id="cb270"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_fingerprints_list(taxa_dict, tree):</span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a>    last_char <span class="op">=</span> <span class="st">''</span></span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>    taxon <span class="op">=</span> <span class="st">''</span></span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a>    taxa_stack <span class="op">=</span> []</span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> char <span class="kw">in</span> tree:</span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> char <span class="kw">in</span> (<span class="st">'('</span>, <span class="st">','</span>, <span class="st">')'</span>):</span>
<span id="cb270-11"><a href="#cb270-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> last_char <span class="kw">in</span> (<span class="st">'('</span>, <span class="st">','</span>):</span>
<span id="cb270-12"><a href="#cb270-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> taxon:</span>
<span id="cb270-13"><a href="#cb270-13" aria-hidden="true" tabindex="-1"></a>                    taxa_stack.append(taxa_dict[taxon])</span>
<span id="cb270-14"><a href="#cb270-14" aria-hidden="true" tabindex="-1"></a>                    taxon <span class="op">=</span> <span class="st">''</span></span>
<span id="cb270-15"><a href="#cb270-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> last_char <span class="op">==</span> <span class="st">')'</span>:</span>
<span id="cb270-16"><a href="#cb270-16" aria-hidden="true" tabindex="-1"></a>                t1 <span class="op">=</span> taxa_stack.pop()</span>
<span id="cb270-17"><a href="#cb270-17" aria-hidden="true" tabindex="-1"></a>                t2 <span class="op">=</span> taxa_stack.pop()</span>
<span id="cb270-18"><a href="#cb270-18" aria-hidden="true" tabindex="-1"></a>                result.append(t1 <span class="op">^</span> t2)</span>
<span id="cb270-19"><a href="#cb270-19" aria-hidden="true" tabindex="-1"></a>                taxa_stack.append(t1 <span class="op">^</span> t2)</span>
<span id="cb270-20"><a href="#cb270-20" aria-hidden="true" tabindex="-1"></a>            last_char <span class="op">=</span> char</span>
<span id="cb270-21"><a href="#cb270-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb270-22"><a href="#cb270-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> char <span class="op">!=</span> <span class="st">' '</span>:</span>
<span id="cb270-23"><a href="#cb270-23" aria-hidden="true" tabindex="-1"></a>                taxon <span class="op">+=</span> char</span>
<span id="cb270-24"><a href="#cb270-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb270-25"><a href="#cb270-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb270-26"><a href="#cb270-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-27"><a href="#cb270-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_split_distance(taxa, tree1, tree2):</span>
<span id="cb270-28"><a href="#cb270-28" aria-hidden="true" tabindex="-1"></a>    random.seed()  <span class="co"># Initialize random number generator</span></span>
<span id="cb270-29"><a href="#cb270-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb270-30"><a href="#cb270-30" aria-hidden="true" tabindex="-1"></a>    taxa_dict <span class="op">=</span> {taxon: random.randint(<span class="dv">0</span>, <span class="dv">2</span><span class="op">**</span><span class="dv">12</span>) <span class="cf">for</span> taxon <span class="kw">in</span> taxa}  <span class="co"># Adjusted bit range for randomness</span></span>
<span id="cb270-31"><a href="#cb270-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-32"><a href="#cb270-32" aria-hidden="true" tabindex="-1"></a>    fingerprints1 <span class="op">=</span> <span class="bu">sorted</span>(get_fingerprints_list(taxa_dict, tree1))</span>
<span id="cb270-33"><a href="#cb270-33" aria-hidden="true" tabindex="-1"></a>    fingerprints2 <span class="op">=</span> <span class="bu">sorted</span>(get_fingerprints_list(taxa_dict, tree2))</span>
<span id="cb270-34"><a href="#cb270-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-35"><a href="#cb270-35" aria-hidden="true" tabindex="-1"></a>    shared_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb270-36"><a href="#cb270-36" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> <span class="bu">len</span>(fingerprints1) <span class="op">-</span> <span class="dv">1</span>, <span class="bu">len</span>(fingerprints2) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb270-37"><a href="#cb270-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-38"><a href="#cb270-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb270-39"><a href="#cb270-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fingerprints1[i] <span class="op">==</span> fingerprints2[j]:</span>
<span id="cb270-40"><a href="#cb270-40" aria-hidden="true" tabindex="-1"></a>            shared_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb270-41"><a href="#cb270-41" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb270-42"><a href="#cb270-42" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb270-43"><a href="#cb270-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> fingerprints1[i] <span class="op">&gt;</span> fingerprints2[j]:</span>
<span id="cb270-44"><a href="#cb270-44" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb270-45"><a href="#cb270-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb270-46"><a href="#cb270-46" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb270-47"><a href="#cb270-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-48"><a href="#cb270-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> (<span class="bu">len</span>(taxa) <span class="op">-</span> <span class="dv">3</span>) <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> shared_count</span>
<span id="cb270-49"><a href="#cb270-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-50"><a href="#cb270-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Input data</span></span>
<span id="cb270-51"><a href="#cb270-51" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb270-52"><a href="#cb270-52" aria-hidden="true" tabindex="-1"></a><span class="st">dog rat elephant mouse cat rabbit</span></span>
<span id="cb270-53"><a href="#cb270-53" aria-hidden="true" tabindex="-1"></a><span class="st">(rat,(dog,cat),(rabbit,(elephant,mouse)));</span></span>
<span id="cb270-54"><a href="#cb270-54" aria-hidden="true" tabindex="-1"></a><span class="st">(rat,(cat,dog),(elephant,(mouse,rabbit)));</span></span>
<span id="cb270-55"><a href="#cb270-55" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb270-56"><a href="#cb270-56" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb270-57"><a href="#cb270-57" aria-hidden="true" tabindex="-1"></a>taxa <span class="op">=</span> input_lines[<span class="dv">0</span>].split()</span>
<span id="cb270-58"><a href="#cb270-58" aria-hidden="true" tabindex="-1"></a>tree1 <span class="op">=</span> input_lines[<span class="dv">1</span>]</span>
<span id="cb270-59"><a href="#cb270-59" aria-hidden="true" tabindex="-1"></a>tree2 <span class="op">=</span> input_lines[<span class="dv">2</span>]</span>
<span id="cb270-60"><a href="#cb270-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-61"><a href="#cb270-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the maximum split distance over 500 iterations</span></span>
<span id="cb270-62"><a href="#cb270-62" aria-hidden="true" tabindex="-1"></a>max_distance <span class="op">=</span> <span class="bu">max</span>(find_split_distance(taxa, tree1, tree2) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">500</span>))</span>
<span id="cb270-63"><a href="#cb270-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-64"><a href="#cb270-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_distance)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-44" class="level2" data-number="89.4">
<h2 data-number="89.4" class="anchored" data-anchor-id="explanation-44"><span class="header-section-number">89.4</span> Explanation</h2>
<ol type="1">
<li><strong>Function <code>get_fingerprints_list(taxa_dict, tree)</code></strong>:
<ul>
<li><strong>Purpose</strong>: Converts a tree in Newick format into a list of fingerprints based on a dictionary of taxon identifiers.</li>
<li><strong>How It Works</strong>:
<ul>
<li>Iterates through characters in the tree string.</li>
<li>Handles tree structure symbols <code>(</code>, <code>,</code>, <code>)</code> and taxon names.</li>
<li>Uses a stack (<code>taxa_stack</code>) to keep track of taxon fingerprints.</li>
<li>When encountering <code>)</code>, it combines the fingerprints of the last two taxa in the stack using the XOR operation (<code>^</code>), which is a common way to handle such trees.</li>
</ul></li>
</ul></li>
<li><strong>Function <code>find_split_distance(taxa, tree1, tree2)</code></strong>:
<ul>
<li><strong>Purpose</strong>: Computes the split distance between two trees.</li>
<li><strong>How It Works</strong>:
<ul>
<li>Generates a random dictionary mapping taxa to unique integer fingerprints.</li>
<li>Calculates fingerprints for both trees and sorts them.</li>
<li>Finds the number of shared fingerprints between the two trees.</li>
<li>Computes the split distance using the formula <code>2 * (n - 3) - 2 * shared_count</code>, where <code>n</code> is the number of taxa.</li>
</ul></li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li><strong>Input Handling</strong>: Reads and parses input data.</li>
<li><strong>Computation</strong>: Runs the <code>find_split_distance</code> function 500 times with random initialization to determine the maximum split distance.</li>
<li><strong>Output</strong>: Prints the maximum split distance found.</li>
</ul></li>
</ol>
</section>
</section>
<section id="the-wright-fisher-model-of-genetic-drift" class="level1" data-number="90">
<h1 data-number="90"><span class="header-section-number">90</span> The Wright-Fisher Model of Genetic Drift</h1>
<p>Consider flipping a weighted coin that gives “heads” with some fixed&nbsp;<a href="https://rosalind.info/glossary/probability/">probability</a>&nbsp;pp&nbsp;(i.e.,&nbsp;<span class="math inline">\(p\)</span>&nbsp;is not necessarily equal to 1/2).</p>
<p>We generalize the notion of&nbsp;<a href="https://rosalind.info/glossary/binomial-random-variable/">binomial random variable</a>&nbsp;from&nbsp;<a href="https://rosalind.info/problems/indc/">“Independent Segregation of Chromosomes”</a>&nbsp;to quantify the sum of the weighted coin flips. Such a&nbsp;<a href="https://rosalind.info/glossary/random-variable/">random variable</a>&nbsp;<span class="math inline">\(X\)</span>&nbsp;takes a value of&nbsp;<span class="math inline">\(k\)</span>&nbsp;if a sequence of&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/independent-random-variables/">independent</a>&nbsp;“weighted coin flips” yields&nbsp;<span class="math inline">\(k\)</span>&nbsp;“heads” and&nbsp;<span class="math inline">\(n−k\)</span>&nbsp;“tails.” We write that&nbsp;<span class="math inline">\(X∈Bin(n,p)\)</span>.</p>
<p>To quantify the Wright-Fisher Model of genetic drift, consider a population of&nbsp;<span class="math inline">\(N\)</span>&nbsp;<a href="https://rosalind.info/glossary/diploid-cell/">diploid</a>&nbsp;individuals, whose&nbsp;<span class="math inline">\(2N\)</span>&nbsp;chromosomes posses mm&nbsp;copies of the dominant allele. As in&nbsp;<a href="https://rosalind.info/problems/afrq/">“Counting Disease Carriers”</a>, set&nbsp;<span class="math inline">\(p= \frac{m}{2N}\)</span>. Next, recall that the next generation must contain exactly&nbsp;<span class="math inline">\(N\)</span>&nbsp;individuals. These individuals’&nbsp;<span class="math inline">\(2N\)</span> alleles are selected independently: a&nbsp;<a href="https://rosalind.info/glossary/dominant-allele/">dominant allele</a>&nbsp;is chosen with probability&nbsp;pp, and a&nbsp;<a href="https://rosalind.info/glossary/recessive-allele/">recessive allele</a>&nbsp;is chosen with probability&nbsp;<span class="math inline">\(1−p\)</span>.</p>
<p>Given:&nbsp;Positive integers&nbsp;<span class="math inline">\(N\)</span>&nbsp;(<span class="math inline">\(N≤7\)</span>),&nbsp;<span class="math inline">\(m\)</span>&nbsp;(<span class="math inline">\(m≤2N\)</span>),&nbsp;<span class="math inline">\(g\)</span>&nbsp;(<span class="math inline">\(g≤6\)</span>) and&nbsp;<span class="math inline">\(k\)</span>&nbsp;(<span class="math inline">\(k≤2N\)</span>).</p>
<p>Return:&nbsp;The probability that in a population of&nbsp;<span class="math inline">\(N\)</span>&nbsp;diploid individuals initially possessing&nbsp;mm&nbsp;copies of a dominant allele, we will observe after&nbsp;<span class="math inline">\(g\)</span>&nbsp;generations at least&nbsp;<span class="math inline">\(k\)</span>&nbsp;copies of a recessive allele. Assume the Wright-Fisher model.</p>
<section id="sample-dataset-89" class="level2" data-number="90.1">
<h2 data-number="90.1" class="anchored" data-anchor-id="sample-dataset-89"><span class="header-section-number">90.1</span> Sample Dataset</h2>
<pre><code>4 6 2 1</code></pre>
</section>
<section id="sample-output-90" class="level2" data-number="90.2">
<h2 data-number="90.2" class="anchored" data-anchor-id="sample-output-90"><span class="header-section-number">90.2</span> Sample Output</h2>
<pre><code>0.772</code></pre>
</section>
<section id="solution-86" class="level2" data-number="90.3">
<h2 data-number="90.3" class="anchored" data-anchor-id="solution-86"><span class="header-section-number">90.3</span> Solution</h2>
<div class="sourceCode" id="cb273"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> comb</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_initial_probabilities(N, m):</span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the probabilities of having a given number of recessive alleles in the first generation.</span></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a>    p_rec <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> m <span class="op">/</span> (<span class="fl">2.0</span> <span class="op">*</span> N)</span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [comb(<span class="dv">2</span> <span class="op">*</span> N, i) <span class="op">*</span> p_rec <span class="op">**</span> i <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> p_rec) <span class="op">**</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">-</span> i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_probabilities(previous_p, N):</span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Update the probabilities of recessive alleles for the next generation.</span></span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb273-14"><a href="#cb273-14" aria-hidden="true" tabindex="-1"></a>    new_p <span class="op">=</span> []</span>
<span id="cb273-15"><a href="#cb273-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb273-16"><a href="#cb273-16" aria-hidden="true" tabindex="-1"></a>        temp <span class="op">=</span> [comb(<span class="dv">2</span> <span class="op">*</span> N, j) <span class="op">*</span> (x <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N)) <span class="op">**</span> j <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> x <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N)) <span class="op">**</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">-</span> j) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb273-17"><a href="#cb273-17" aria-hidden="true" tabindex="-1"></a>        new_p.append(<span class="bu">sum</span>(temp[i] <span class="op">*</span> previous_p[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(temp))))</span>
<span id="cb273-18"><a href="#cb273-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_p</span>
<span id="cb273-19"><a href="#cb273-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-20"><a href="#cb273-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_final_probability(N, m, g, k):</span>
<span id="cb273-21"><a href="#cb273-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb273-22"><a href="#cb273-22" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the probability of observing at least k recessive alleles after g generations.</span></span>
<span id="cb273-23"><a href="#cb273-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb273-24"><a href="#cb273-24" aria-hidden="true" tabindex="-1"></a>    previous_p <span class="op">=</span> calculate_initial_probabilities(N, m)</span>
<span id="cb273-25"><a href="#cb273-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb273-26"><a href="#cb273-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, g <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb273-27"><a href="#cb273-27" aria-hidden="true" tabindex="-1"></a>        previous_p <span class="op">=</span> update_probabilities(previous_p, N)</span>
<span id="cb273-28"><a href="#cb273-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb273-29"><a href="#cb273-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(previous_p[k <span class="op">-</span> <span class="dv">1</span>:])</span>
<span id="cb273-30"><a href="#cb273-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-31"><a href="#cb273-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb273-32"><a href="#cb273-32" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb273-33"><a href="#cb273-33" aria-hidden="true" tabindex="-1"></a><span class="st">4 6 2 1</span></span>
<span id="cb273-34"><a href="#cb273-34" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb273-35"><a href="#cb273-35" aria-hidden="true" tabindex="-1"></a>input_lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb273-36"><a href="#cb273-36" aria-hidden="true" tabindex="-1"></a>N, m, g, k <span class="op">=</span> [<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> input_lines[<span class="dv">0</span>].split()]</span>
<span id="cb273-37"><a href="#cb273-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-38"><a href="#cb273-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and print the final probability</span></span>
<span id="cb273-39"><a href="#cb273-39" aria-hidden="true" tabindex="-1"></a>final_prob <span class="op">=</span> calculate_final_probability(N, m, g, k)</span>
<span id="cb273-40"><a href="#cb273-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_prob)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-45" class="level2" data-number="90.4">
<h2 data-number="90.4" class="anchored" data-anchor-id="explanation-45"><span class="header-section-number">90.4</span> Explanation</h2>
<ol type="1">
<li><strong>Function <code>calculate_initial_probabilities(N, m)</code></strong>:
<ul>
<li><strong>Purpose</strong>: Computes the probabilities of having different numbers of recessive alleles in the first generation.</li>
<li><strong>How It Works</strong>: Uses the <code>comb</code> function to calculate binomial probabilities based on the initial proportion of recessive alleles.</li>
</ul></li>
<li><strong>Function <code>update_probabilities(previous_p, N)</code></strong>:
<ul>
<li><strong>Purpose</strong>: Updates the probabilities for subsequent generations.</li>
<li><strong>How It Works</strong>: For each possible number of recessive alleles, calculates the new probabilities based on the previous generation’s probabilities and the binomial distribution.</li>
</ul></li>
<li><strong>Function <code>calculate_final_probability(N, m, g, k)</code></strong>:
<ul>
<li><strong>Purpose</strong>: Computes the final probability of observing at least <code>k</code> recessive alleles after <code>g</code> generations.</li>
<li><strong>How It Works</strong>: Iterates through generations, updating probabilities each time. After <code>g</code> generations, it sums up the probabilities for having at least <code>k</code> recessive alleles.</li>
</ul></li>
<li><strong>Main Execution</strong>:
<ul>
<li><strong>Input Handling</strong>: Reads and parses input data.</li>
<li><strong>Computation</strong>: Uses the functions to calculate the final probability.</li>
<li><strong>Output</strong>: Prints the result.</li>
</ul></li>
</ol>
</section>
</section>
<section id="alignment-based-phylogeny" class="level1" data-number="91">
<h1 data-number="91"><span class="header-section-number">91</span> Alignment-Based Phylogeny</h1>
<p>Say that we have&nbsp;<span class="math inline">\(n\)</span>&nbsp;<a href="https://rosalind.info/glossary/taxon/">taxa</a>&nbsp;represented by&nbsp;<a href="https://rosalind.info/glossary/string/">strings</a>&nbsp;<span class="math inline">\(s_1,s_2,…,s_n\)</span>&nbsp;with a multiple alignment inducing corresponding&nbsp;<a href="https://rosalind.info/glossary/augmented-string/">augmented strings</a>&nbsp;<span class="math inline">\(\hat s_1, \hat s_2,…, \hat s_n\)</span>.</p>
<p>Recall that the number of single-symbol substitutions required to transform one string into another is the&nbsp;<a href="https://rosalind.info/glossary/hamming-distance/">Hamming distance</a>&nbsp;between the strings (see&nbsp;<a href="https://rosalind.info/problems/hamm/">“Counting Point Mutations”</a>). Say that we have a&nbsp;<a href="https://rosalind.info/glossary/rooted-binary-tree/">rooted binary tree</a>&nbsp;<span class="math inline">\(T\)</span>&nbsp;containing&nbsp;<span class="math inline">\(\hat s_1, \hat s_2,…, \hat s_n\)</span>&nbsp;at its&nbsp;<a href="https://rosalind.info/glossary/leaf/">leaves</a>&nbsp;and additional strings&nbsp;<span class="math inline">\(\hat s_{n+1}, \hat s_{n+2),…, \hat s_{2n-1}\)</span>.&nbsp;at its internal nodes, including the root (the number of internal nodes is&nbsp;<span class="math inline">\(n−1\)</span>&nbsp;by extension of&nbsp;<a href="https://rosalind.info/problems/inod/">“Counting Phylogenetic Ancestors”</a>). Define&nbsp;<span class="math inline">\(d_H(T)\)</span>&nbsp;as the sum of&nbsp;<span class="math inline">\(dH(\hat s_i, \hat s_j)\)</span> over all&nbsp;<a href="https://rosalind.info/glossary/edge/">edges</a> <span class="math inline">\((\hat s_i, \hat s_j)\)</span> &nbsp;in&nbsp;<span class="math inline">\(T\)</span>:</p>
<p><span class="math display">\[d_H(T)= \sum _{{ \hat s_i, \hat s_j} ∈E (T)} dH(\hat s_i, \hat s_j)\]</span></p>
<p>Thus, our aim is to minimize&nbsp;<span class="math inline">\(d_H(T)\)</span>.</p>
<p>Given:&nbsp;A rooted binary tree&nbsp;<span class="math inline">\(T\)</span>&nbsp;on&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤500\)</span>) species, given in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>, followed by a multiple alignment of&nbsp;<span class="math inline">\(m\)</span>&nbsp;(<span class="math inline">\(m≤n\)</span>) augmented&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;having the same length (at most 300&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>) corresponding to the species and given in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA</a>&nbsp;format.</p>
<p>Return:&nbsp;The minimum possible value of&nbsp;<span class="math inline">\(dH(T)\)</span>, followed by a collection of DNA strings to be assigned to the&nbsp;<a href="https://rosalind.info/glossary/internal-node/">internal nodes</a>&nbsp;of&nbsp;<span class="math inline">\(T\)</span>&nbsp;that will minimize&nbsp;<span class="math inline">\(dH(T)\)</span>&nbsp;(multiple solutions will exist, but you need only output one).</p>
<section id="sample-dataset-90" class="level2" data-number="91.1">
<h2 data-number="91.1" class="anchored" data-anchor-id="sample-dataset-90"><span class="header-section-number">91.1</span> Sample Dataset</h2>
<pre><code>(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;
&gt;ostrich
AC
&gt;cat
CA
&gt;duck
T-
&gt;fly
GC
&gt;elephant
-T
&gt;pikachu
AA</code></pre>
</section>
<section id="sample-output-91" class="level2" data-number="91.2">
<h2 data-number="91.2" class="anchored" data-anchor-id="sample-output-91"><span class="header-section-number">91.2</span> Sample Output</h2>
<pre><code>8
&gt;rat
AC
&gt;mouse
TC
&gt;dog
AC
&gt;hamster
AT
&gt;robot
AC</code></pre>
</section>
<section id="solution-87" class="level2" data-number="91.3">
<h2 data-number="91.3" class="anchored" data-anchor-id="solution-87"><span class="header-section-number">91.3</span> Solution</h2>
<div class="sourceCode" id="cb276"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> inf</span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_newick(newick, directed<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>    newick <span class="op">=</span> re.sub(<span class="st">",,"</span>, <span class="st">",.,"</span>, newick)</span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a>    newick <span class="op">=</span> re.sub(<span class="vs">r"\(,"</span>, <span class="st">"(.,"</span>, newick)</span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a>    newick <span class="op">=</span> re.sub(<span class="vs">r",\)"</span>, <span class="st">",.)"</span>, newick)</span>
<span id="cb276-9"><a href="#cb276-9" aria-hidden="true" tabindex="-1"></a>    newick <span class="op">=</span> re.sub(<span class="vs">r"\(\)"</span>, <span class="st">"(.)"</span>, newick)</span>
<span id="cb276-10"><a href="#cb276-10" aria-hidden="true" tabindex="-1"></a>    newick <span class="op">=</span> re.sub(<span class="vs">r"^\((.+)\);"</span>, <span class="vs">r"\1"</span>, newick)</span>
<span id="cb276-11"><a href="#cb276-11" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> re.finditer(<span class="vs">r"(\(|[A-z_.]+|,|\))"</span>, newick)</span>
<span id="cb276-12"><a href="#cb276-12" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> [x.group() <span class="cf">for</span> x <span class="kw">in</span> m]</span>
<span id="cb276-13"><a href="#cb276-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-14"><a href="#cb276-14" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb276-15"><a href="#cb276-15" aria-hidden="true" tabindex="-1"></a>    node_stack <span class="op">=</span> [<span class="st">"0"</span>]</span>
<span id="cb276-16"><a href="#cb276-16" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb276-17"><a href="#cb276-17" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="bu">len</span>(tokens) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb276-18"><a href="#cb276-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb276-19"><a href="#cb276-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tokens[i] <span class="op">==</span> <span class="st">"("</span>:</span>
<span id="cb276-20"><a href="#cb276-20" aria-hidden="true" tabindex="-1"></a>            node_stack <span class="op">=</span> node_stack[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb276-21"><a href="#cb276-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tokens[i] <span class="op">==</span> <span class="st">")"</span>:</span>
<span id="cb276-22"><a href="#cb276-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(tokens) <span class="kw">and</span> tokens[i <span class="op">+</span> <span class="dv">1</span>] <span class="kw">not</span> <span class="kw">in</span> <span class="st">",)"</span>:</span>
<span id="cb276-23"><a href="#cb276-23" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> tokens[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb276-24"><a href="#cb276-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb276-25"><a href="#cb276-25" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb276-26"><a href="#cb276-26" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="bu">str</span>(count)</span>
<span id="cb276-27"><a href="#cb276-27" aria-hidden="true" tabindex="-1"></a>            g[node_stack[<span class="op">-</span><span class="dv">1</span>]].append({<span class="st">"n"</span>: node, <span class="st">"w"</span>: <span class="dv">1</span>})</span>
<span id="cb276-28"><a href="#cb276-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> directed:</span>
<span id="cb276-29"><a href="#cb276-29" aria-hidden="true" tabindex="-1"></a>                g[node].append({<span class="st">"n"</span>: node_stack[<span class="op">-</span><span class="dv">1</span>], <span class="st">"w"</span>: <span class="dv">1</span>})</span>
<span id="cb276-30"><a href="#cb276-30" aria-hidden="true" tabindex="-1"></a>            node_stack <span class="op">+=</span> [node]</span>
<span id="cb276-31"><a href="#cb276-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tokens[i] <span class="op">!=</span> <span class="st">","</span> <span class="kw">and</span> (i <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> tokens[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">!=</span> <span class="st">")"</span>):</span>
<span id="cb276-32"><a href="#cb276-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tokens[i] <span class="op">==</span> <span class="st">"."</span>:</span>
<span id="cb276-33"><a href="#cb276-33" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb276-34"><a href="#cb276-34" aria-hidden="true" tabindex="-1"></a>                tokens[i] <span class="op">=</span> <span class="bu">str</span>(count)</span>
<span id="cb276-35"><a href="#cb276-35" aria-hidden="true" tabindex="-1"></a>            g[node_stack[<span class="op">-</span><span class="dv">1</span>]].append({<span class="st">"n"</span>: tokens[i], <span class="st">"w"</span>: <span class="dv">1</span>})</span>
<span id="cb276-36"><a href="#cb276-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> directed:</span>
<span id="cb276-37"><a href="#cb276-37" aria-hidden="true" tabindex="-1"></a>                g[tokens[i]].append({<span class="st">"n"</span>: node_stack[<span class="op">-</span><span class="dv">1</span>], <span class="st">"w"</span>: <span class="dv">1</span>})</span>
<span id="cb276-38"><a href="#cb276-38" aria-hidden="true" tabindex="-1"></a>        i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb276-39"><a href="#cb276-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb276-40"><a href="#cb276-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-41"><a href="#cb276-41" aria-hidden="true" tabindex="-1"></a>clas Rec:</span>
<span id="cb276-42"><a href="#cb276-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A simple FASTA record"""</span></span>
<span id="cb276-43"><a href="#cb276-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-44"><a href="#cb276-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="bu">id</span>, seq):</span>
<span id="cb276-45"><a href="#cb276-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">id</span> <span class="op">=</span> <span class="bu">id</span></span>
<span id="cb276-46"><a href="#cb276-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.seq <span class="op">=</span> seq</span>
<span id="cb276-47"><a href="#cb276-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-48"><a href="#cb276-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb276-49"><a href="#cb276-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.seq)</span>
<span id="cb276-50"><a href="#cb276-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-51"><a href="#cb276-51" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_fasta(input_string):</span>
<span id="cb276-52"><a href="#cb276-52" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> input_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb276-53"><a href="#cb276-53" aria-hidden="true" tabindex="-1"></a>    header, sequence <span class="op">=</span> <span class="st">""</span>, []</span>
<span id="cb276-54"><a href="#cb276-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb276-55"><a href="#cb276-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb276-56"><a href="#cb276-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sequence:</span>
<span id="cb276-57"><a href="#cb276-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> Rec(header, <span class="st">""</span>.join(sequence))</span>
<span id="cb276-58"><a href="#cb276-58" aria-hidden="true" tabindex="-1"></a>            header, sequence <span class="op">=</span> line[<span class="dv">1</span>:], []</span>
<span id="cb276-59"><a href="#cb276-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> line.strip():  <span class="co"># 빈 줄 무시</span></span>
<span id="cb276-60"><a href="#cb276-60" aria-hidden="true" tabindex="-1"></a>            sequence.append(line.strip())</span>
<span id="cb276-61"><a href="#cb276-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sequence:</span>
<span id="cb276-62"><a href="#cb276-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> Rec(header, <span class="st">""</span>.join(sequence))</span>
<span id="cb276-63"><a href="#cb276-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-64"><a href="#cb276-64" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nodes(graph):</span>
<span id="cb276-65"><a href="#cb276-65" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">list</span>(graph.keys())</span>
<span id="cb276-66"><a href="#cb276-66" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> [y <span class="cf">for</span> v <span class="kw">in</span> graph.values() <span class="cf">for</span> y <span class="kw">in</span> v]</span>
<span id="cb276-67"><a href="#cb276-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">set</span>(s) <span class="op">|</span> <span class="bu">set</span>(e)</span>
<span id="cb276-68"><a href="#cb276-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-69"><a href="#cb276-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-70"><a href="#cb276-70" aria-hidden="true" tabindex="-1"></a><span class="co"># return all leaves of a simple graph</span></span>
<span id="cb276-71"><a href="#cb276-71" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leaves(graph):</span>
<span id="cb276-72"><a href="#cb276-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nodes(graph) <span class="op">-</span> <span class="bu">set</span>(graph.keys())</span>
<span id="cb276-73"><a href="#cb276-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-74"><a href="#cb276-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-75"><a href="#cb276-75" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_position(graph, seqs, pos):</span>
<span id="cb276-76"><a href="#cb276-76" aria-hidden="true" tabindex="-1"></a>    chars <span class="op">=</span> {}</span>
<span id="cb276-77"><a href="#cb276-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> nodes(graph) <span class="op">-</span> leaves(graph):</span>
<span id="cb276-78"><a href="#cb276-78" aria-hidden="true" tabindex="-1"></a>        chars[n] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb276-79"><a href="#cb276-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> leaf <span class="kw">in</span> leaves(graph):</span>
<span id="cb276-80"><a href="#cb276-80" aria-hidden="true" tabindex="-1"></a>        chars[leaf] <span class="op">=</span> seqs[leaf][pos]</span>
<span id="cb276-81"><a href="#cb276-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> chars</span>
<span id="cb276-82"><a href="#cb276-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-83"><a href="#cb276-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-84"><a href="#cb276-84" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> traceback(skp, node, ind):</span>
<span id="cb276-85"><a href="#cb276-85" aria-hidden="true" tabindex="-1"></a>    bases <span class="op">=</span> [<span class="st">"A"</span>, <span class="st">"C"</span>, <span class="st">"T"</span>, <span class="st">"G"</span>, <span class="st">"-"</span>]</span>
<span id="cb276-86"><a href="#cb276-86" aria-hidden="true" tabindex="-1"></a>    chars <span class="op">=</span> {}</span>
<span id="cb276-87"><a href="#cb276-87" aria-hidden="true" tabindex="-1"></a>    chars[node] <span class="op">=</span> bases[ind]</span>
<span id="cb276-88"><a href="#cb276-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k, v <span class="kw">in</span> skp[node][ind].items():</span>
<span id="cb276-89"><a href="#cb276-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k <span class="kw">in</span> skp:</span>
<span id="cb276-90"><a href="#cb276-90" aria-hidden="true" tabindex="-1"></a>            chars <span class="op">=</span> chars <span class="op">|</span> traceback(skp, k, v)</span>
<span id="cb276-91"><a href="#cb276-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> chars</span>
<span id="cb276-92"><a href="#cb276-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-93"><a href="#cb276-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-94"><a href="#cb276-94" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> small_parsimony(graph, chars):</span>
<span id="cb276-95"><a href="#cb276-95" aria-hidden="true" tabindex="-1"></a>    bases <span class="op">=</span> [<span class="st">"A"</span>, <span class="st">"C"</span>, <span class="st">"T"</span>, <span class="st">"G"</span>, <span class="st">"-"</span>]</span>
<span id="cb276-96"><a href="#cb276-96" aria-hidden="true" tabindex="-1"></a>    sk <span class="op">=</span> {}  <span class="co"># minimum parsimony score of the subtree over possible labels</span></span>
<span id="cb276-97"><a href="#cb276-97" aria-hidden="true" tabindex="-1"></a>    skp <span class="op">=</span> {}  <span class="co"># pointer to selected base for each child over possible labels</span></span>
<span id="cb276-98"><a href="#cb276-98" aria-hidden="true" tabindex="-1"></a>    to_proces <span class="op">=</span> nodes(graph)</span>
<span id="cb276-99"><a href="#cb276-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-100"><a href="#cb276-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># # initialise leaves</span></span>
<span id="cb276-101"><a href="#cb276-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> leaf <span class="kw">in</span> leaves(graph):</span>
<span id="cb276-102"><a href="#cb276-102" aria-hidden="true" tabindex="-1"></a>        sk[leaf] <span class="op">=</span> [<span class="dv">0</span> <span class="cf">if</span> chars[leaf] <span class="op">==</span> c <span class="cf">else</span> inf <span class="cf">for</span> c <span class="kw">in</span> bases]</span>
<span id="cb276-103"><a href="#cb276-103" aria-hidden="true" tabindex="-1"></a>        to_process.remove(leaf)</span>
<span id="cb276-104"><a href="#cb276-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-105"><a href="#cb276-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># iterate over available nodes till all are processed</span></span>
<span id="cb276-106"><a href="#cb276-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> to_process:</span>
<span id="cb276-107"><a href="#cb276-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">list</span>(to_process):</span>
<span id="cb276-108"><a href="#cb276-108" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">all</span>(v <span class="kw">in</span> sk <span class="cf">for</span> v <span class="kw">in</span> graph[n]):</span>
<span id="cb276-109"><a href="#cb276-109" aria-hidden="true" tabindex="-1"></a>                sk[n], skp[n] <span class="op">=</span> [], []</span>
<span id="cb276-110"><a href="#cb276-110" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> bases:</span>
<span id="cb276-111"><a href="#cb276-111" aria-hidden="true" tabindex="-1"></a>                    tot <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb276-112"><a href="#cb276-112" aria-hidden="true" tabindex="-1"></a>                    ptr <span class="op">=</span> {}</span>
<span id="cb276-113"><a href="#cb276-113" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> d, sk_child <span class="kw">in</span> [(d, sk[d]) <span class="cf">for</span> d <span class="kw">in</span> graph[n]]:</span>
<span id="cb276-114"><a href="#cb276-114" aria-hidden="true" tabindex="-1"></a>                        score <span class="op">=</span> []</span>
<span id="cb276-115"><a href="#cb276-115" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(bases):</span>
<span id="cb276-116"><a href="#cb276-116" aria-hidden="true" tabindex="-1"></a>                            score <span class="op">+=</span> [sk_child[i] <span class="op">+</span> (<span class="dv">0</span> <span class="cf">if</span> c <span class="op">==</span> k <span class="cf">else</span> <span class="dv">1</span>)]</span>
<span id="cb276-117"><a href="#cb276-117" aria-hidden="true" tabindex="-1"></a>                        tot <span class="op">+=</span> <span class="bu">min</span>(score)</span>
<span id="cb276-118"><a href="#cb276-118" aria-hidden="true" tabindex="-1"></a>                        ptr[d] <span class="op">=</span> score.index(<span class="bu">min</span>(score))</span>
<span id="cb276-119"><a href="#cb276-119" aria-hidden="true" tabindex="-1"></a>                    skp[n] <span class="op">+=</span> [ptr]</span>
<span id="cb276-120"><a href="#cb276-120" aria-hidden="true" tabindex="-1"></a>                    sk[n] <span class="op">+=</span> [tot]</span>
<span id="cb276-121"><a href="#cb276-121" aria-hidden="true" tabindex="-1"></a>                to_process.remove(n)</span>
<span id="cb276-122"><a href="#cb276-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-123"><a href="#cb276-123" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recover sequence</span></span>
<span id="cb276-124"><a href="#cb276-124" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="st">"0"</span></span>
<span id="cb276-125"><a href="#cb276-125" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> <span class="bu">min</span>(sk[node])</span>
<span id="cb276-126"><a href="#cb276-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> score, traceback(skp, node, sk[node].index(score))</span>
<span id="cb276-127"><a href="#cb276-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-128"><a href="#cb276-128" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> alph(tree, seqs, i):</span>
<span id="cb276-129"><a href="#cb276-129" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialise sequences</span></span>
<span id="cb276-130"><a href="#cb276-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> nodes(tree) <span class="op">-</span> leaves(tree):</span>
<span id="cb276-131"><a href="#cb276-131" aria-hidden="true" tabindex="-1"></a>        seqs[n] <span class="op">=</span> <span class="st">""</span></span>
<span id="cb276-132"><a href="#cb276-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-133"><a href="#cb276-133" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(seqs[<span class="bu">list</span>(leaves(tree))[<span class="dv">0</span>]])</span>
<span id="cb276-134"><a href="#cb276-134" aria-hidden="true" tabindex="-1"></a>    total_score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb276-135"><a href="#cb276-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb276-136"><a href="#cb276-136" aria-hidden="true" tabindex="-1"></a>        chars <span class="op">=</span> extract_position(tree, seqs, pos)</span>
<span id="cb276-137"><a href="#cb276-137" aria-hidden="true" tabindex="-1"></a>        score, tbchars <span class="op">=</span> small_parsimony(tree, chars)</span>
<span id="cb276-138"><a href="#cb276-138" aria-hidden="true" tabindex="-1"></a>        total_score <span class="op">+=</span> score</span>
<span id="cb276-139"><a href="#cb276-139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k, v <span class="kw">in</span> tbchars.items():</span>
<span id="cb276-140"><a href="#cb276-140" aria-hidden="true" tabindex="-1"></a>            seqs[k] <span class="op">+=</span> v</span>
<span id="cb276-141"><a href="#cb276-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-142"><a href="#cb276-142" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_score, seqs</span>
<span id="cb276-143"><a href="#cb276-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-144"><a href="#cb276-144" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simplify_tree(graph):</span>
<span id="cb276-145"><a href="#cb276-145" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {k: [x[<span class="st">"n"</span>] <span class="cf">for</span> x <span class="kw">in</span> v] <span class="cf">for</span> k, v <span class="kw">in</span> graph.items()}</span>
<span id="cb276-146"><a href="#cb276-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-147"><a href="#cb276-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-148"><a href="#cb276-148" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb276-149"><a href="#cb276-149" aria-hidden="true" tabindex="-1"></a><span class="st">(((ostrich,cat)rat,(duck,fly)mouse)dog,(elephant,pikachu)hamster)robot;</span></span>
<span id="cb276-150"><a href="#cb276-150" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;ostrich</span></span>
<span id="cb276-151"><a href="#cb276-151" aria-hidden="true" tabindex="-1"></a><span class="st">AC</span></span>
<span id="cb276-152"><a href="#cb276-152" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;cat</span></span>
<span id="cb276-153"><a href="#cb276-153" aria-hidden="true" tabindex="-1"></a><span class="st">CA</span></span>
<span id="cb276-154"><a href="#cb276-154" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;duck</span></span>
<span id="cb276-155"><a href="#cb276-155" aria-hidden="true" tabindex="-1"></a><span class="st">T-</span></span>
<span id="cb276-156"><a href="#cb276-156" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;fly</span></span>
<span id="cb276-157"><a href="#cb276-157" aria-hidden="true" tabindex="-1"></a><span class="st">GC</span></span>
<span id="cb276-158"><a href="#cb276-158" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;elephant</span></span>
<span id="cb276-159"><a href="#cb276-159" aria-hidden="true" tabindex="-1"></a><span class="st">-T</span></span>
<span id="cb276-160"><a href="#cb276-160" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;pikachu</span></span>
<span id="cb276-161"><a href="#cb276-161" aria-hidden="true" tabindex="-1"></a><span class="st">AA</span></span>
<span id="cb276-162"><a href="#cb276-162" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb276-163"><a href="#cb276-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-164"><a href="#cb276-164" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> parse_newick(sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)[<span class="dv">0</span>])</span>
<span id="cb276-165"><a href="#cb276-165" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> simplify_tree(tree)</span>
<span id="cb276-166"><a href="#cb276-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-167"><a href="#cb276-167" aria-hidden="true" tabindex="-1"></a>seqs <span class="op">=</span> read_fasta(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)[<span class="dv">1</span>:]))</span>
<span id="cb276-168"><a href="#cb276-168" aria-hidden="true" tabindex="-1"></a>seqs <span class="op">=</span> {x.<span class="bu">id</span>: x.seq <span class="cf">for</span> x <span class="kw">in</span> seqs}</span>
<span id="cb276-169"><a href="#cb276-169" aria-hidden="true" tabindex="-1"></a>total_score, seqs <span class="op">=</span> alph(tree, seqs, <span class="dv">1</span>)</span>
<span id="cb276-170"><a href="#cb276-170" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total_score)</span>
<span id="cb276-171"><a href="#cb276-171" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> tree.keys():</span>
<span id="cb276-172"><a href="#cb276-172" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node <span class="op">!=</span> <span class="st">"0"</span>:</span>
<span id="cb276-173"><a href="#cb276-173" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"&gt;</span><span class="sc">{</span>node<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb276-174"><a href="#cb276-174" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(seqs[node])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="working-principle" class="level2" data-number="91.4">
<h2 data-number="91.4" class="anchored" data-anchor-id="working-principle"><span class="header-section-number">91.4</span> Working Principle</h2>
<ol type="1">
<li><p>The code implements the Small Parsimony algorithm for phylogenetic tree reconstruction.</p></li>
<li><p>It starts by parsing a Newick format string representation of a tree using the <code>parse_newick</code> function. This function creates a graph representation of the tree.</p></li>
<li><p>The <code>small_parsimony</code> function is the core of the algorithm. It calculates the most parsimonious ancestral sequences for internal nodes of the tree.</p></li>
<li><p>The algorithm works bottom-up, starting from the leaves and moving towards the root:</p>
<ul>
<li>For leaves, it initializes scores based on their known character states.</li>
<li>For internal nodes, it calculates scores for each possible base by considering the scores of its children.</li>
</ul></li>
<li><p>The <code>traceback</code> function is used to reconstruct the most parsimonious ancestral sequences by traversing the tree from root to leaves.</p></li>
<li><p>The <code>alph</code> function applies the Small Parsimony algorithm to each position in the sequences, building up the full ancestral sequences.</p></li>
<li><p>Finally, the code reads a sample input (in FASTA format), constructs the tree, applies the algorithm, and prints the results.</p></li>
</ol>
<p>This algorithm aims to find the ancestral sequences that minimize the total number of mutations (changes) along the branches of the phylogenetic tree, based on the principle of maximum parsimony.</p>
</section>
</section>
<section id="assessing-assembly-quality-with-n50-and-n75" class="level1" data-number="92">
<h1 data-number="92"><span class="header-section-number">92</span> Assessing Assembly Quality with N50 and N75</h1>
<p>Given a collection of&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;representing contigs, we use the&nbsp;<a href="https://rosalind.info/glossary/n-statistic/">N statistic</a>&nbsp;NXX (where XX ranges from 01 to 99) to represent the maximum positive integer&nbsp;<span class="math inline">\(L\)</span>&nbsp;such that the total number of nucleotides of all contigs having length&nbsp;<span class="math inline">\(≥L\)</span>&nbsp;is at least XX% of the sum of contig lengths. The most commonly used such statistic is&nbsp;<a href="https://rosalind.info/glossary/n-statistic/">N50</a>, although N75 is also worth mentioning.</p>
<p>Given:&nbsp;A collection of at most 1000 DNA strings (whose combined length does not exceed 50&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>).</p>
<p>Return:&nbsp;N50 and N75 for this collection of strings.</p>
<section id="sample-dataset-91" class="level2" data-number="92.1">
<h2 data-number="92.1" class="anchored" data-anchor-id="sample-dataset-91"><span class="header-section-number">92.1</span> Sample Dataset</h2>
<pre><code>GATTACA
TACTACTAC
ATTGAT
GAAGA</code></pre>
</section>
<section id="sample-output-92" class="level2" data-number="92.2">
<h2 data-number="92.2" class="anchored" data-anchor-id="sample-output-92"><span class="header-section-number">92.2</span> Sample Output</h2>
<pre><code>7 6</code></pre>
</section>
<section id="solution-88" class="level2" data-number="92.3">
<h2 data-number="92.3" class="anchored" data-anchor-id="solution-88"><span class="header-section-number">92.3</span> Solution</h2>
<div class="sourceCode" id="cb279"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_nxx(contigs, xx):</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a>    total_length <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">len</span>(contig) <span class="cf">for</span> contig <span class="kw">in</span> contigs)</span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>    target_length <span class="op">=</span> total_length <span class="op">*</span> xx <span class="op">/</span> <span class="dv">100</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a>    sorted_contigs <span class="op">=</span> <span class="bu">sorted</span>(contigs, key<span class="op">=</span><span class="bu">len</span>, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>    cumulative_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> contig <span class="kw">in</span> sorted_contigs:</span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a>        cumulative_length <span class="op">+=</span> <span class="bu">len</span>(contig)</span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cumulative_length <span class="op">&gt;=</span> target_length:</span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">len</span>(contig)</span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Read input</span></span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb279-17"><a href="#cb279-17" aria-hidden="true" tabindex="-1"></a><span class="st">GATTACA</span></span>
<span id="cb279-18"><a href="#cb279-18" aria-hidden="true" tabindex="-1"></a><span class="st">TACTACTAC</span></span>
<span id="cb279-19"><a href="#cb279-19" aria-hidden="true" tabindex="-1"></a><span class="st">ATTGAT</span></span>
<span id="cb279-20"><a href="#cb279-20" aria-hidden="true" tabindex="-1"></a><span class="st">GAAGA</span></span>
<span id="cb279-21"><a href="#cb279-21" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb279-22"><a href="#cb279-22" aria-hidden="true" tabindex="-1"></a>contigs <span class="op">=</span> [line.strip() <span class="cf">for</span> line <span class="kw">in</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)]</span>
<span id="cb279-23"><a href="#cb279-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-24"><a href="#cb279-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate N50 and N75</span></span>
<span id="cb279-25"><a href="#cb279-25" aria-hidden="true" tabindex="-1"></a>n50 <span class="op">=</span> calculate_nxx(contigs, <span class="dv">50</span>)</span>
<span id="cb279-26"><a href="#cb279-26" aria-hidden="true" tabindex="-1"></a>n75 <span class="op">=</span> calculate_nxx(contigs, <span class="dv">75</span>)</span>
<span id="cb279-27"><a href="#cb279-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-28"><a href="#cb279-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Print results</span></span>
<span id="cb279-29"><a href="#cb279-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>n50<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>n75<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The code calculates <strong>N50</strong> and <strong>N75</strong> values, which are measures used to asses the quality of DNA sequence assemblies.</p>
</section>
<section id="breaking-down-the-steps" class="level2" data-number="92.4">
<h2 data-number="92.4" class="anchored" data-anchor-id="breaking-down-the-steps"><span class="header-section-number">92.4</span> <strong>Breaking Down the Steps:</strong></h2>
<ol type="1">
<li><strong><code>calculate_nxx(contigs, xx)</code> Function:</strong>
<ul>
<li><strong>Input:</strong> A list of DNA sequences (<code>contigs</code>) and a percentage (<code>xx</code> like 50 for N50).</li>
<li><strong>Output:</strong> The length of the sequence (contig) where the cumulative length reaches the specified percentage of the total length.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Step 1:</strong> Add up the lengths of all sequences to get the total length.</li>
<li><strong>Step 2:</strong> Sort the sequences from longest to shortest.</li>
<li><strong>Step 3:</strong> Add lengths one by one from the sorted list until the sum reaches the specified percentage of the total length. The length of the last added sequence is the NXX value.</li>
</ul></li>
</ul></li>
<li><strong>Main Code:</strong>
<ul>
<li>The sample input is split into individual DNA sequences.</li>
<li>The code then calculates:
<ul>
<li><strong>N50:</strong> The sequence length where 50% of the total length is reached.</li>
<li><strong>N75:</strong> The sequence length where 75% of the total length is reached.</li>
</ul></li>
<li>Finally, it prints these N50 and N75 values.</li>
</ul></li>
</ol>
</section>
</section>
<section id="fixing-an-inconsistent-character-set" class="level1" data-number="93">
<h1 data-number="93"><span class="header-section-number">93</span> Fixing an Inconsistent Character Set</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/submatrix/">submatrix</a>&nbsp;of a matrix&nbsp;<span class="math inline">\(M\)</span>&nbsp;is a matrix formed by selecting rows and columns from&nbsp;<span class="math inline">\(M\)</span>&nbsp;and taking only those entries found at the intersections of the selected rows and columns. We may also think of a submatrix as formed by deleting the remaining rows and columns from&nbsp;<span class="math inline">\(M\)</span>.</p>
<p>Given:&nbsp;An&nbsp;<a href="https://rosalind.info/glossary/consistent-character-table/">inconsistent character table</a>&nbsp;<span class="math inline">\(C\)</span>&nbsp;on at most 100 taxa.</p>
<p>Return:&nbsp;A submatrix of&nbsp;<span class="math inline">\(C′\)</span>&nbsp;representing a consistent character table on the same taxa and formed by deleting a single row of&nbsp;<span class="math inline">\(C\)</span>. (If multiple solutions exist, you may return any one.)</p>
<section id="sample-dataset-92" class="level2" data-number="93.1">
<h2 data-number="93.1" class="anchored" data-anchor-id="sample-dataset-92"><span class="header-section-number">93.1</span> Sample Dataset</h2>
<pre><code>100001
000110
111000
100111</code></pre>
</section>
<section id="sample-output-93" class="level2" data-number="93.2">
<h2 data-number="93.2" class="anchored" data-anchor-id="sample-output-93"><span class="header-section-number">93.2</span> Sample Output</h2>
<pre><code>000110
100001
100111</code></pre>
</section>
<section id="solution-89" class="level2" data-number="93.3">
<h2 data-number="93.3" class="anchored" data-anchor-id="solution-89"><span class="header-section-number">93.3</span> Solution</h2>
<div class="sourceCode" id="cb282"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conflict(c1, c2):</span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 모든 인덱스에 대해 한 번에 비교하여 충돌 여부 확인</span></span>
<span id="cb282-6"><a href="#cb282-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">any</span>((c1[i] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> c2[i] <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> (c1[i] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> c2[i] <span class="op">==</span> <span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(c1)))</span>
<span id="cb282-7"><a href="#cb282-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-8"><a href="#cb282-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-9"><a href="#cb282-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conflicts(characters):</span>
<span id="cb282-10"><a href="#cb282-10" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb282-11"><a href="#cb282-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(characters)):</span>
<span id="cb282-12"><a href="#cb282-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(characters)):</span>
<span id="cb282-13"><a href="#cb282-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> conflict(characters[i], characters[j]):</span>
<span id="cb282-14"><a href="#cb282-14" aria-hidden="true" tabindex="-1"></a>                count[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb282-15"><a href="#cb282-15" aria-hidden="true" tabindex="-1"></a>                count[j] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb282-16"><a href="#cb282-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb282-17"><a href="#cb282-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-18"><a href="#cb282-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-19"><a href="#cb282-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 입력 처리</span></span>
<span id="cb282-20"><a href="#cb282-20" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb282-21"><a href="#cb282-21" aria-hidden="true" tabindex="-1"></a><span class="st">100001</span></span>
<span id="cb282-22"><a href="#cb282-22" aria-hidden="true" tabindex="-1"></a><span class="st">000110</span></span>
<span id="cb282-23"><a href="#cb282-23" aria-hidden="true" tabindex="-1"></a><span class="st">111000</span></span>
<span id="cb282-24"><a href="#cb282-24" aria-hidden="true" tabindex="-1"></a><span class="st">100111</span></span>
<span id="cb282-25"><a href="#cb282-25" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb282-26"><a href="#cb282-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-27"><a href="#cb282-27" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb282-28"><a href="#cb282-28" aria-hidden="true" tabindex="-1"></a>characters <span class="op">=</span> [[<span class="bu">int</span>(x) <span class="cf">for</span> x <span class="kw">in</span> ch] <span class="cf">for</span> ch <span class="kw">in</span> lines]</span>
<span id="cb282-29"><a href="#cb282-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-30"><a href="#cb282-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 충돌 계산</span></span>
<span id="cb282-31"><a href="#cb282-31" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> conflicts(characters)</span>
<span id="cb282-32"><a href="#cb282-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-33"><a href="#cb282-33" aria-hidden="true" tabindex="-1"></a><span class="co"># 가장 많은 충돌을 가진 행 제거</span></span>
<span id="cb282-34"><a href="#cb282-34" aria-hidden="true" tabindex="-1"></a>rm <span class="op">=</span> <span class="bu">max</span>(count, key<span class="op">=</span>count.get)</span>
<span id="cb282-35"><a href="#cb282-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-36"><a href="#cb282-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb282-37"><a href="#cb282-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="op">*</span>lines[:rm], <span class="op">*</span>lines[rm <span class="op">+</span> <span class="dv">1</span>:], sep<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The code identifies and removes the row from a set of binary sequences (like <code>100001</code>) that has the most conflicts with other rows. A “conflict” is defined as one sequence having a <code>1</code> where another has a <code>0</code>, and vice versa.</p>
</section>
<section id="breaking-down-the-steps-1" class="level2" data-number="93.4">
<h2 data-number="93.4" class="anchored" data-anchor-id="breaking-down-the-steps-1"><span class="header-section-number">93.4</span> <strong>Breaking Down the Steps:</strong></h2>
<ol type="1">
<li><strong><code>conflict(c1, c2)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Check if two sequences (<code>c1</code> and <code>c2</code>) conflict with each other.</li>
<li><strong>How It Works:</strong>
<ul>
<li>It compares the two sequences at each index.</li>
<li>If at any index, one sequence has <code>1</code> and the other has <code>0</code>, they are in conflict.</li>
<li>The function returns <code>True</code> if there is any conflict; otherwise, it returns <code>False</code>.</li>
</ul></li>
</ul></li>
<li><strong><code>conflicts(characters)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Count how many conflicts each sequence has with all other sequences.</li>
<li><strong>How It Works:</strong>
<ul>
<li>It compares each sequence with every other sequence.</li>
<li>If two sequences conflict, it increments a conflict counter for both sequences.</li>
<li>It returns a dictionary where the key is the sequence index, and the value is the number of conflicts that sequence has.</li>
</ul></li>
</ul></li>
<li><strong>Main Code:</strong>
<ul>
<li><strong>Input Processing:</strong>
<ul>
<li>The binary sequences are read and converted into lists of integers.</li>
</ul></li>
<li><strong>Conflict Counting:</strong>
<ul>
<li>The code uses the <code>conflicts</code> function to count how many conflicts each sequence has.</li>
</ul></li>
<li><strong>Removing the Most Conflicting Sequence:</strong>
<ul>
<li>The sequence with the highest number of conflicts is identified.</li>
<li>This sequence is then removed from the list.</li>
</ul></li>
<li><strong>Output:</strong>
<ul>
<li>The remaining sequences (with the most conflicting one removed) are printed.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="wright-fishers-expected-behavior" class="level1" data-number="94">
<h1 data-number="94"><span class="header-section-number">94</span> Wright-Fisher’s Expected Behavior</h1>
<p>In&nbsp;<a href="https://rosalind.info/problems/wfmd/">“The Wright-Fisher Model of Genetic Drift”</a>, we generalized the concept of a&nbsp;<a href="https://rosalind.info/glossary/binomial-random-variable/">binomial random variable</a>&nbsp;<span class="math inline">\(Bin(n,p)\)</span>&nbsp;as a “weighted coin flip.” It is only natural to calculate the&nbsp;<a href="https://rosalind.info/glossary/expected-value/">expected value</a>&nbsp;of such a random variable.</p>
<p>For example, in the case of unweighted coin flips (i.e.,&nbsp;<span class="math inline">\(p=1/2\)</span>), our intuition would indicate that&nbsp;<span class="math inline">\(E(Bin(n/2))\)</span>&nbsp;is&nbsp;<span class="math inline">\(n/2\)</span>; what should be the expected value of a binomial random variable?</p>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(n\)</span>&nbsp;(<span class="math inline">\(n≤1000000\)</span>) followed by an&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(P\)</span>&nbsp;of length&nbsp;mm&nbsp;(<span class="math inline">\(m≤20\)</span>) containing numbers between&nbsp;0&nbsp;and&nbsp;1. Each element of&nbsp;<span class="math inline">\(P\)</span>&nbsp;can be seen as representing a probability corresponding to an allele frequency.</p>
<p>Return:&nbsp;An array&nbsp;<span class="math inline">\(B\)</span>&nbsp;of length&nbsp;mm&nbsp;for which&nbsp;<span class="math inline">\(B[k]\)</span>&nbsp;is the expected value of&nbsp;<span class="math inline">\(Bin(n,P[k])\)</span>; in terms of Wright-Fisher, it represents the expected allele frequency of the next generation.</p>
<section id="sample-dataset-93" class="level2" data-number="94.1">
<h2 data-number="94.1" class="anchored" data-anchor-id="sample-dataset-93"><span class="header-section-number">94.1</span> Sample Dataset</h2>
<pre><code>17
0.1 0.2 0.3</code></pre>
</section>
<section id="sample-output-94" class="level2" data-number="94.2">
<h2 data-number="94.2" class="anchored" data-anchor-id="sample-output-94"><span class="header-section-number">94.2</span> Sample Output</h2>
<pre><code>1.7 3.4 5.1</code></pre>
</section>
<section id="solution-90" class="level2" data-number="94.3">
<h2 data-number="94.3" class="anchored" data-anchor-id="solution-90"><span class="header-section-number">94.3</span> Solution</h2>
<p>The problem asks us to calculate the expected value of a binomial random variable given a population size <span class="math inline">\(n\)</span> and an array <span class="math inline">\(P\)</span> of allele frequencies. For each element <span class="math inline">\(p\)</span> in the array <span class="math inline">\(P\)</span>, we need to compute the expected value <span class="math inline">\(E(Bin(n, p))\)</span>.</p>
<p>For a binomial random variable <span class="math inline">\(Bin(n, p)\)</span>, where: - <span class="math inline">\(n\)</span> is the number of trials (in this case, the number of individuals in the population), - <span class="math inline">\(p\)</span> is the probability of succes (or the allele frequency),</p>
<p>The expected value <span class="math inline">\(E(Bin(n, p))\)</span> is calculated as:</p>
<p>[ E(Bin(n, p)) = n p ]</p>
<p>Given that, the task is to compute this value for each probability in the array <span class="math inline">\(P\)</span>.We can implement this in Python as follows:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a><span class="st">17</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a><span class="st">0.1 0.2 0.3</span></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input</span></span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(lines[<span class="dv">0</span>])</span>
<span id="cb285-10"><a href="#cb285-10" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, lines[<span class="dv">1</span>].split()))</span>
<span id="cb285-11"><a href="#cb285-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-12"><a href="#cb285-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the expected values</span></span>
<span id="cb285-13"><a href="#cb285-13" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [n <span class="op">*</span> p <span class="cf">for</span> p <span class="kw">in</span> P]</span>
<span id="cb285-14"><a href="#cb285-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-15"><a href="#cb285-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb285-16"><a href="#cb285-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, B)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-46" class="level2" data-number="94.4">
<h2 data-number="94.4" class="anchored" data-anchor-id="explanation-46"><span class="header-section-number">94.4</span> Explanation</h2>
<ol type="1">
<li><strong>Input Parsing</strong>: We read the population size <span class="math inline">\(n\)</span> and the array <span class="math inline">\(P\)</span> of allele frequencies.</li>
<li><strong>Computation</strong>: For each <span class="math inline">\(p\)</span> in <span class="math inline">\(P\)</span>, we compute <span class="math inline">\(n \times p\)</span> and store it in array <span class="math inline">\(B\)</span>.</li>
<li><strong>Output</strong>: Finally, we print the values in <span class="math inline">\(B\)</span> as a space-separated string.</li>
</ol>
</section>
</section>
<section id="the-founder-effect-and-genetic-drift" class="level1" data-number="95">
<h1 data-number="95"><span class="header-section-number">95</span> The Founder Effect and Genetic Drift</h1>
<p>Given:&nbsp;Two positive integers&nbsp;<span class="math inline">\(N\)</span>&nbsp;and&nbsp;<span class="math inline">\(m\)</span>, followed by an&nbsp;<a href="https://rosalind.info/glossary/array/">array</a>&nbsp;<span class="math inline">\(A\)</span>&nbsp;containing&nbsp;<span class="math inline">\(k\)</span>&nbsp;integers between 0 and&nbsp;<span class="math inline">\(2N\)</span>.&nbsp;<span class="math inline">\(A[j]\)</span>&nbsp;represents the number of&nbsp;<a href="https://rosalind.info/glossary/recessive-allele/">recessive alleles</a>&nbsp;for the&nbsp;<span class="math inline">\(j\)</span>-th factor in a population of&nbsp;<span class="math inline">\(N\)</span>&nbsp;<a href="https://rosalind.info/glossary/diploid-cell/">diploid</a>&nbsp;individuals.</p>
<p>Return:&nbsp;An&nbsp;<span class="math inline">\(m×k\)</span>&nbsp;<a href="https://rosalind.info/glossary/matrix/">matrix</a>&nbsp;<span class="math inline">\(B\)</span>&nbsp;for which&nbsp;<span class="math inline">\(B_{i,j}\)</span>&nbsp;represents the&nbsp;<a href="https://rosalind.info/glossary/common-logarithm/">common logarithm</a>&nbsp;of the probability that after&nbsp;<span class="math inline">\(i\)</span>&nbsp;generations, no copies of the recessive allele for the&nbsp;<span class="math inline">\(j\)</span>-th factor will remain in the population. Apply the Wright-Fisher model.</p>
<section id="sample-dataset-94" class="level2" data-number="95.1">
<h2 data-number="95.1" class="anchored" data-anchor-id="sample-dataset-94"><span class="header-section-number">95.1</span> Sample Dataset</h2>
<pre><code>4 3
0 1 2</code></pre>
</section>
<section id="sample-output-95" class="level2" data-number="95.2">
<h2 data-number="95.2" class="anchored" data-anchor-id="sample-output-95"><span class="header-section-number">95.2</span> Sample Output</h2>
<pre><code>0.0 -0.463935575821 -0.999509892866
0.0 -0.301424998891 -0.641668367342
0.0 -0.229066698008 -0.485798552456</code></pre>
</section>
<section id="solution-91" class="level2" data-number="95.3">
<h2 data-number="95.3" class="anchored" data-anchor-id="solution-91"><span class="header-section-number">95.3</span> Solution</h2>
<div class="sourceCode" id="cb288"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> comb</span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wright_fisher_genetic_drift(N, m, g):</span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the log10 of the probability that no copies of the recessive allele remain in the population</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a><span class="co">    after g generations, given an initial count of m recessive alleles.</span></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> m <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N)  <span class="co"># Initial dominant allele frequency</span></span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> q  <span class="co"># Initial recessive allele frequency</span></span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize probability of exactly t recessive alleles in the first generation</span></span>
<span id="cb288-13"><a href="#cb288-13" aria-hidden="true" tabindex="-1"></a>    prob <span class="op">=</span> np.array([comb(<span class="dv">2</span> <span class="op">*</span> N, i) <span class="op">*</span> (q <span class="op">**</span> i) <span class="op">*</span> (p <span class="op">**</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">-</span> i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>)])</span>
<span id="cb288-14"><a href="#cb288-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-15"><a href="#cb288-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate through generations</span></span>
<span id="cb288-16"><a href="#cb288-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, g):</span>
<span id="cb288-17"><a href="#cb288-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate probabilities for the next generation</span></span>
<span id="cb288-18"><a href="#cb288-18" aria-hidden="true" tabindex="-1"></a>        next_prob <span class="op">=</span> np.zeros(<span class="dv">2</span> <span class="op">*</span> N)</span>
<span id="cb288-19"><a href="#cb288-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb288-20"><a href="#cb288-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate probability of having exactly t recessive alleles in the current generation</span></span>
<span id="cb288-21"><a href="#cb288-21" aria-hidden="true" tabindex="-1"></a>            prob_t <span class="op">=</span> np.array([comb(<span class="dv">2</span> <span class="op">*</span> N, t) <span class="op">*</span> ((i <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N)) <span class="op">**</span> t) <span class="op">*</span> ((<span class="dv">1</span> <span class="op">-</span> (i <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N))) <span class="op">**</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">-</span> t)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>)])</span>
<span id="cb288-22"><a href="#cb288-22" aria-hidden="true" tabindex="-1"></a>            next_prob[t <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> np.<span class="bu">sum</span>(prob_t <span class="op">*</span> prob)</span>
<span id="cb288-23"><a href="#cb288-23" aria-hidden="true" tabindex="-1"></a>        prob <span class="op">=</span> next_prob</span>
<span id="cb288-24"><a href="#cb288-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-25"><a href="#cb288-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the log10 of the probability of no recessive alleles remaining</span></span>
<span id="cb288-26"><a href="#cb288-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.log10(<span class="dv">1</span> <span class="op">-</span> np.<span class="bu">sum</span>(prob))</span>
<span id="cb288-27"><a href="#cb288-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-28"><a href="#cb288-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_genetic_drift_matrix(N, m, A):</span>
<span id="cb288-29"><a href="#cb288-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb288-30"><a href="#cb288-30" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate the matrix B where B[i, j] represents the common logarithm of the probability that after i generations,</span></span>
<span id="cb288-31"><a href="#cb288-31" aria-hidden="true" tabindex="-1"></a><span class="co">    no copies of the recessive allele for the j-th factor will remain in the population.</span></span>
<span id="cb288-32"><a href="#cb288-32" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb288-33"><a href="#cb288-33" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb288-34"><a href="#cb288-34" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.zeros((m, k))</span>
<span id="cb288-35"><a href="#cb288-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-36"><a href="#cb288-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb288-37"><a href="#cb288-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb288-38"><a href="#cb288-38" aria-hidden="true" tabindex="-1"></a>            B[i, j] <span class="op">=</span> wright_fisher_genetic_drift(N, A[j], i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb288-39"><a href="#cb288-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-40"><a href="#cb288-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span>
<span id="cb288-41"><a href="#cb288-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-42"><a href="#cb288-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample Input</span></span>
<span id="cb288-43"><a href="#cb288-43" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb288-44"><a href="#cb288-44" aria-hidden="true" tabindex="-1"></a><span class="st">4 3</span></span>
<span id="cb288-45"><a href="#cb288-45" aria-hidden="true" tabindex="-1"></a><span class="st">0 1 2</span></span>
<span id="cb288-46"><a href="#cb288-46" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb288-47"><a href="#cb288-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-48"><a href="#cb288-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse input</span></span>
<span id="cb288-49"><a href="#cb288-49" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> sample_input.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb288-50"><a href="#cb288-50" aria-hidden="true" tabindex="-1"></a>N, m <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, lines[<span class="dv">0</span>].split())</span>
<span id="cb288-51"><a href="#cb288-51" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, lines[<span class="dv">1</span>].split()))</span>
<span id="cb288-52"><a href="#cb288-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-53"><a href="#cb288-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the matrix B</span></span>
<span id="cb288-54"><a href="#cb288-54" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> calculate_genetic_drift_matrix(N, m, A)</span>
<span id="cb288-55"><a href="#cb288-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-56"><a href="#cb288-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb288-57"><a href="#cb288-57" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> B:</span>
<span id="cb288-58"><a href="#cb288-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">' '</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, row)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code calculates the probability of losing all copies of a recessive allele in a population over several generations, based on the Wright-Fisher model of genetic drift. The result is a matrix where each entry tells us the likelihood (in logarithmic form) that no recessive alleles remain after a given number of generations.</p>
</section>
<section id="functions-and-their-roles" class="level2" data-number="95.4">
<h2 data-number="95.4" class="anchored" data-anchor-id="functions-and-their-roles"><span class="header-section-number">95.4</span> Functions and Their Roles</h2>
<ol type="1">
<li><p><strong><code>wright_fisher_genetic_drift(N, m, g)</code></strong></p>
<p><strong>Purpose</strong>: Calculates the probability of losing all recessive alleles after <code>g</code> generations, starting with <code>m</code> recessive alleles in a population of size <code>N</code>.</p>
<p><strong>How It Works</strong>:</p>
<ul>
<li><strong>Initial Setup</strong>:
<ul>
<li><code>q</code> is the frequency of dominant alleles.</li>
<li><code>p</code> is the frequency of recessive alleles.</li>
</ul></li>
<li><strong>First Generation</strong>:
<ul>
<li>Calculate the probability of having exactly <code>t</code> recessive alleles in the first generation.</li>
</ul></li>
<li><strong>Subsequent Generations</strong>:
<ul>
<li>For each generation, update the probabilities based on the previous generation.</li>
</ul></li>
<li><strong>Final Calculation</strong>:
<ul>
<li>Compute the probability that no recessive alleles remain after <code>g</code> generations and return its log base 10.</li>
</ul></li>
</ul></li>
<li><p><strong><code>calculate_genetic_drift_matrix(N, m, A)</code></strong></p>
<p><strong>Purpose</strong>: Creates a matrix where each entry shows the log probability that no recessive alleles remain after a certain number of generations for various initial counts of recessive alleles.</p>
<p><strong>How It Works</strong>:</p>
<ul>
<li><strong>Matrix Initialization</strong>:
<ul>
<li><code>B</code> is initialized as a zero matrix.</li>
</ul></li>
<li><strong>Filling the Matrix</strong>:
<ul>
<li>For each possible number of generations and each initial count of recessive alleles, calculate the log probability using <code>wright_fisher_genetic_drift</code> and store it in the matrix <code>B</code>.</li>
</ul></li>
</ul></li>
</ol>
</section>
<section id="key-points-1" class="level2" data-number="95.5">
<h2 data-number="95.5" class="anchored" data-anchor-id="key-points-1"><span class="header-section-number">95.5</span> Key Points</h2>
<ul>
<li><strong><code>wright_fisher_genetic_drift</code></strong> focuses on updating probabilities generation by generation.</li>
<li><strong><code>calculate_genetic_drift_matrix</code></strong> builds a matrix from these probabilities for different scenarios.</li>
</ul>
</section>
</section>
<section id="global-alignment-with-scoring-matrix-and-affine-gap-penalty" class="level1" data-number="96">
<h1 data-number="96"><span class="header-section-number">96</span> Global Alignment with Scoring Matrix and Affine Gap Penalty</h1>
<p>An&nbsp;<a href="https://rosalind.info/glossary/affine-gap-penalty/">affine gap penalty</a>&nbsp;is written as&nbsp;<span class="math inline">\(a+b⋅(L−1)\)</span>, where&nbsp;<span class="math inline">\(L\)</span>&nbsp;is the length of the gap,&nbsp;aa&nbsp;is a positive constant called the&nbsp;<a href="https://rosalind.info/glossary/affine-gap-penalty/">gap opening penalty</a>, and&nbsp;<span class="math inline">\(b\)</span>&nbsp;is a positive constant called the&nbsp;<a href="https://rosalind.info/glossary/affine-gap-penalty/">gap extension penalty</a>.</p>
<p>We can view the gap opening penalty as charging for the first&nbsp;<a href="https://rosalind.info/glossary/gap-symbol/">gap symbol</a>, and the gap extension penalty as charging for each subsequent symbol added to the gap.</p>
<p>For example, if&nbsp;<span class="math inline">\(a=11\)</span>&nbsp;and&nbsp;<span class="math inline">\(b=1\)</span>, then a gap of length 1 would be penalized by 11 (for an average cost of 11 per gap symbol), whereas a gap of length 100 would have a score of 110 (for an average cost of 1.10 per gap symbol).</p>
<p>Consider the strings “PRTEINS” and “PRTWPSEIN”. If we use the&nbsp;<a href="https://rosalind.info/glossary/blosum62/">BLOSUM62</a>&nbsp;<a href="https://rosalind.info/glossary/scoring-matrix/">scoring matrix</a>&nbsp;and an affine gap penalty with&nbsp;<span class="math inline">\(a=11\)</span>&nbsp;and&nbsp;<span class="math inline">\(b=1\)</span>, then we obtain the following optimal alignment.</p>
<pre><code> PRT---EINS
 |||   |||
 PRTWPSEIN-</code></pre>
<p>Matched symbols contribute a total of 32 to the calculation of the alignment’s score, and the gaps cost 13 and 11 respectively, yielding a total score of 8.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each of length at most 100&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The maximum alignment score between&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, followed by two augmented strings&nbsp;<span class="math inline">\(s′\)</span>&nbsp;and&nbsp;<span class="math inline">\(t′\)</span>&nbsp;representing an optimal alignment of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. Use:</p>
<ul>
<li>The&nbsp;<a href="https://rosalind.info/glossary/blosum62/">BLOSUM62</a>&nbsp;<a href="https://rosalind.info/glossary/scoring-matrix/">scoring matrix</a>.</li>
<li>Gap opening penalty equal to 11.</li>
<li>Gap extension penalty equal to 1.</li>
</ul>
<section id="sample-dataset-95" class="level2" data-number="96.1">
<h2 data-number="96.1" class="anchored" data-anchor-id="sample-dataset-95"><span class="header-section-number">96.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_49
PRTEINS
&gt;Rosalind_47
PRTWPSEIN</code></pre>
</section>
<section id="sample-output-96" class="level2" data-number="96.2">
<h2 data-number="96.2" class="anchored" data-anchor-id="sample-output-96"><span class="header-section-number">96.2</span> Sample Output</h2>
<pre><code>8
PRT---EINS
PRTWPSEIN-</code></pre>
</section>
<section id="solution-92" class="level2" data-number="96.3">
<h2 data-number="96.3" class="anchored" data-anchor-id="solution-92"><span class="header-section-number">96.3</span> Solution</h2>
<div class="sourceCode" id="cb292"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="co"># BLOSUM62 matrix as a string</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a>blosum62_str <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a><span class="st">A  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a><span class="st">A  4  0 -2 -1 -2  0 -2 -1 -1 -1 -1 -2 -1 -1 -1  1  0  0 -3 -2</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a><span class="st">C  0  9 -3 -4 -2 -3 -3 -1 -3 -1 -1 -3 -3 -3 -3 -1 -1 -1 -2 -2</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a><span class="st">D -2 -3  6  2 -3 -1 -1 -3 -1 -4 -3  1 -1  0 -2  0 -1 -3 -4 -3</span></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a><span class="st">E -1 -4  2  5 -3 -2  0 -3  1 -2 -2  0 -1  2  0  0 -1 -2 -3 -2</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a><span class="st">F -2 -2 -3 -3  6 -3 -1  0 -3  0  0 -3 -4 -3 -3 -2 -2 -1  1  3</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a><span class="st">G  0 -3 -1 -2 -3  6 -2 -4 -2 -4 -3  0 -2 -2 -3  0 -2 -3 -2 -3</span></span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a><span class="st">H -2 -3 -1  0 -1 -2  8 -3 -1 -3 -2  1 -2  0  0 -1 -2 -3 -2  2</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a><span class="st">I -1 -1 -3 -3  0 -4 -3  4 -3  2  1 -3 -3 -3 -3 -2 -1  3 -3 -1</span></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a><span class="st">K -1 -3 -1  1 -3 -2 -1 -3  5 -2 -1  0 -1  1  2  0 -1 -2 -3 -2</span></span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a><span class="st">L -1 -1 -4 -2  0 -4 -3  2 -2  4  2 -3 -3 -2 -2 -2 -1  1 -2 -1</span></span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a><span class="st">M -1 -1 -3 -2  0 -3 -2  1 -1  2  5 -2 -2  0 -1 -1 -1  1 -1 -1</span></span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a><span class="st">N -2 -3  1  0 -3  0  1 -3  0 -3 -2  6 -2  0  0  1  0 -3 -4 -2</span></span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a><span class="st">P -1 -3 -1 -1 -4 -2 -2 -3 -1 -3 -2 -2  7 -1 -2 -1 -1 -3 -4 -3</span></span>
<span id="cb292-17"><a href="#cb292-17" aria-hidden="true" tabindex="-1"></a><span class="st">Q -1 -3  0  2 -3 -2  0 -3  1 -2  0  0 -1  5  1  0 -1 -2 -2 -1</span></span>
<span id="cb292-18"><a href="#cb292-18" aria-hidden="true" tabindex="-1"></a><span class="st">R -1 -3 -2  0 -3 -3  0 -3  2 -2 -1  0 -2  1  5 -1 -1 -3 -3 -2</span></span>
<span id="cb292-19"><a href="#cb292-19" aria-hidden="true" tabindex="-1"></a><span class="st">S  1 -1  0  0 -2  0 -1 -2  0 -2 -1  1 -1  0 -1  4  1 -2 -3 -2</span></span>
<span id="cb292-20"><a href="#cb292-20" aria-hidden="true" tabindex="-1"></a><span class="st">T  0 -1 -1 -1 -2 -2 -2 -1 -1 -1 -1  0 -1 -1 -1  1  5  0 -2 -2</span></span>
<span id="cb292-21"><a href="#cb292-21" aria-hidden="true" tabindex="-1"></a><span class="st">V  0 -1 -3 -2 -1 -3 -3  3 -2  1  1 -3 -3 -2 -3 -2  0  4 -3 -1</span></span>
<span id="cb292-22"><a href="#cb292-22" aria-hidden="true" tabindex="-1"></a><span class="st">W -3 -2 -4 -3  1 -2 -2 -3 -3 -2 -1 -4 -4 -2 -3 -3 -2 -3 11  2</span></span>
<span id="cb292-23"><a href="#cb292-23" aria-hidden="true" tabindex="-1"></a><span class="st">Y -2 -2 -3 -2  3 -3  2 -1 -2 -1 -1 -2 -3 -1 -2 -2 -2 -1  2  7</span></span>
<span id="cb292-24"><a href="#cb292-24" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb292-25"><a href="#cb292-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-26"><a href="#cb292-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_blosum62(matrix_str):</span>
<span id="cb292-27"><a href="#cb292-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse the BLOSUM62 matrix from a string into a dictionary."""</span></span>
<span id="cb292-28"><a href="#cb292-28" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> matrix_str.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb292-29"><a href="#cb292-29" aria-hidden="true" tabindex="-1"></a>    headers <span class="op">=</span> lines[<span class="dv">0</span>].split()</span>
<span id="cb292-30"><a href="#cb292-30" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> {}</span>
<span id="cb292-31"><a href="#cb292-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines[<span class="dv">1</span>:]:</span>
<span id="cb292-32"><a href="#cb292-32" aria-hidden="true" tabindex="-1"></a>        values <span class="op">=</span> line.split()</span>
<span id="cb292-33"><a href="#cb292-33" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> values[<span class="dv">0</span>]</span>
<span id="cb292-34"><a href="#cb292-34" aria-hidden="true" tabindex="-1"></a>        scores <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, values[<span class="dv">1</span>:]))</span>
<span id="cb292-35"><a href="#cb292-35" aria-hidden="true" tabindex="-1"></a>        matrix.update({(row, col): score <span class="cf">for</span> col, score <span class="kw">in</span> <span class="bu">zip</span>(headers, scores)})</span>
<span id="cb292-36"><a href="#cb292-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matrix</span>
<span id="cb292-37"><a href="#cb292-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-38"><a href="#cb292-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data):</span>
<span id="cb292-39"><a href="#cb292-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse FASTA format data into a list of sequences."""</span></span>
<span id="cb292-40"><a href="#cb292-40" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb292-41"><a href="#cb292-41" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> <span class="st">""</span></span>
<span id="cb292-42"><a href="#cb292-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb292-43"><a href="#cb292-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb292-44"><a href="#cb292-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> seq:</span>
<span id="cb292-45"><a href="#cb292-45" aria-hidden="true" tabindex="-1"></a>                sequences.append(seq)</span>
<span id="cb292-46"><a href="#cb292-46" aria-hidden="true" tabindex="-1"></a>                seq <span class="op">=</span> <span class="st">""</span></span>
<span id="cb292-47"><a href="#cb292-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb292-48"><a href="#cb292-48" aria-hidden="true" tabindex="-1"></a>            seq <span class="op">+=</span> line.strip()</span>
<span id="cb292-49"><a href="#cb292-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> seq:</span>
<span id="cb292-50"><a href="#cb292-50" aria-hidden="true" tabindex="-1"></a>        sequences.append(seq)</span>
<span id="cb292-51"><a href="#cb292-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb292-52"><a href="#cb292-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-53"><a href="#cb292-53" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> match_score(scoring_matrix, a, b):</span>
<span id="cb292-54"><a href="#cb292-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return the score from the scoring matrix, defaulting to 0 if not found."""</span></span>
<span id="cb292-55"><a href="#cb292-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scoring_matrix.get((a, b), <span class="dv">0</span>)</span>
<span id="cb292-56"><a href="#cb292-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-57"><a href="#cb292-57" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> global_align_with_affine(s, t, scores, gap, gap_e):</span>
<span id="cb292-58"><a href="#cb292-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Perform global alignment with affine gap penalties."""</span></span>
<span id="cb292-59"><a href="#cb292-59" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb292-60"><a href="#cb292-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize matrices</span></span>
<span id="cb292-61"><a href="#cb292-61" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-62"><a href="#cb292-62" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-63"><a href="#cb292-63" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-64"><a href="#cb292-64" aria-hidden="true" tabindex="-1"></a>    traceM <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-65"><a href="#cb292-65" aria-hidden="true" tabindex="-1"></a>    traceX <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-66"><a href="#cb292-66" aria-hidden="true" tabindex="-1"></a>    traceY <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb292-67"><a href="#cb292-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-68"><a href="#cb292-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize edges</span></span>
<span id="cb292-69"><a href="#cb292-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb292-70"><a href="#cb292-70" aria-hidden="true" tabindex="-1"></a>        M[i][<span class="dv">0</span>] <span class="op">=</span> gap <span class="op">+</span> gap_e <span class="op">*</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb292-71"><a href="#cb292-71" aria-hidden="true" tabindex="-1"></a>        X[i][<span class="dv">0</span>] <span class="op">=</span> Y[i][<span class="dv">0</span>] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb292-72"><a href="#cb292-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb292-73"><a href="#cb292-73" aria-hidden="true" tabindex="-1"></a>        M[<span class="dv">0</span>][j] <span class="op">=</span> gap <span class="op">+</span> gap_e <span class="op">*</span> (j <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb292-74"><a href="#cb292-74" aria-hidden="true" tabindex="-1"></a>        X[<span class="dv">0</span>][j] <span class="op">=</span> Y[<span class="dv">0</span>][j] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb292-75"><a href="#cb292-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-76"><a href="#cb292-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill matrices</span></span>
<span id="cb292-77"><a href="#cb292-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb292-78"><a href="#cb292-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb292-79"><a href="#cb292-79" aria-hidden="true" tabindex="-1"></a>            costX <span class="op">=</span> [M[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap, X[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap_e]</span>
<span id="cb292-80"><a href="#cb292-80" aria-hidden="true" tabindex="-1"></a>            X[i][j] <span class="op">=</span> <span class="bu">max</span>(costX)</span>
<span id="cb292-81"><a href="#cb292-81" aria-hidden="true" tabindex="-1"></a>            traceX[i][j] <span class="op">=</span> costX.index(X[i][j])</span>
<span id="cb292-82"><a href="#cb292-82" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb292-83"><a href="#cb292-83" aria-hidden="true" tabindex="-1"></a>            costY <span class="op">=</span> [M[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap, Y[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap_e]</span>
<span id="cb292-84"><a href="#cb292-84" aria-hidden="true" tabindex="-1"></a>            Y[i][j] <span class="op">=</span> <span class="bu">max</span>(costY)</span>
<span id="cb292-85"><a href="#cb292-85" aria-hidden="true" tabindex="-1"></a>            traceY[i][j] <span class="op">=</span> costY.index(Y[i][j])</span>
<span id="cb292-86"><a href="#cb292-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-87"><a href="#cb292-87" aria-hidden="true" tabindex="-1"></a>            costM <span class="op">=</span> [M[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> match_score(scores, s[i<span class="op">-</span><span class="dv">1</span>], t[j<span class="op">-</span><span class="dv">1</span>]), X[i][j], Y[i][j]]</span>
<span id="cb292-88"><a href="#cb292-88" aria-hidden="true" tabindex="-1"></a>            M[i][j] <span class="op">=</span> <span class="bu">max</span>(costM)</span>
<span id="cb292-89"><a href="#cb292-89" aria-hidden="true" tabindex="-1"></a>            traceM[i][j] <span class="op">=</span> costM.index(M[i][j])</span>
<span id="cb292-90"><a href="#cb292-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb292-91"><a href="#cb292-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get maximum score and initialize aligned strings</span></span>
<span id="cb292-92"><a href="#cb292-92" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> M[m][n]</span>
<span id="cb292-93"><a href="#cb292-93" aria-hidden="true" tabindex="-1"></a>    s_align, t_align <span class="op">=</span> s, t</span>
<span id="cb292-94"><a href="#cb292-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-95"><a href="#cb292-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Traceback</span></span>
<span id="cb292-96"><a href="#cb292-96" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> m, n</span>
<span id="cb292-97"><a href="#cb292-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb292-98"><a href="#cb292-98" aria-hidden="true" tabindex="-1"></a>        traceback <span class="op">=</span> <span class="bu">max</span>([(X[i][j], <span class="dv">0</span>), (Y[i][j], <span class="dv">1</span>), (M[i][j], <span class="dv">2</span>)], key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])[<span class="dv">1</span>]</span>
<span id="cb292-99"><a href="#cb292-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> traceback <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb292-100"><a href="#cb292-100" aria-hidden="true" tabindex="-1"></a>            t_align <span class="op">=</span> t_align[:j] <span class="op">+</span> <span class="st">'-'</span> <span class="op">+</span> t_align[j:]</span>
<span id="cb292-101"><a href="#cb292-101" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb292-102"><a href="#cb292-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> traceback <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb292-103"><a href="#cb292-103" aria-hidden="true" tabindex="-1"></a>            s_align <span class="op">=</span> s_align[:i] <span class="op">+</span> <span class="st">'-'</span> <span class="op">+</span> s_align[i:]</span>
<span id="cb292-104"><a href="#cb292-104" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb292-105"><a href="#cb292-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> traceback <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb292-106"><a href="#cb292-106" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> traceM[i][j] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb292-107"><a href="#cb292-107" aria-hidden="true" tabindex="-1"></a>                traceback <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb292-108"><a href="#cb292-108" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> traceM[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb292-109"><a href="#cb292-109" aria-hidden="true" tabindex="-1"></a>                traceback <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb292-110"><a href="#cb292-110" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb292-111"><a href="#cb292-111" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb292-112"><a href="#cb292-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-113"><a href="#cb292-113" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle leading gaps</span></span>
<span id="cb292-114"><a href="#cb292-114" aria-hidden="true" tabindex="-1"></a>    s_align <span class="op">=</span> <span class="st">'-'</span> <span class="op">*</span> j <span class="op">+</span> s_align</span>
<span id="cb292-115"><a href="#cb292-115" aria-hidden="true" tabindex="-1"></a>    t_align <span class="op">=</span> <span class="st">'-'</span> <span class="op">*</span> i <span class="op">+</span> t_align</span>
<span id="cb292-116"><a href="#cb292-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-117"><a href="#cb292-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">str</span>(max_score), s_align, t_align</span>
<span id="cb292-118"><a href="#cb292-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-119"><a href="#cb292-119" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample dataset in FASTA format</span></span>
<span id="cb292-120"><a href="#cb292-120" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb292-121"><a href="#cb292-121" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_49</span></span>
<span id="cb292-122"><a href="#cb292-122" aria-hidden="true" tabindex="-1"></a><span class="st">PRTEINS</span></span>
<span id="cb292-123"><a href="#cb292-123" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_47</span></span>
<span id="cb292-124"><a href="#cb292-124" aria-hidden="true" tabindex="-1"></a><span class="st">PRTWPSEIN</span></span>
<span id="cb292-125"><a href="#cb292-125" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb292-126"><a href="#cb292-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-127"><a href="#cb292-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the FASTA input to get the sequences</span></span>
<span id="cb292-128"><a href="#cb292-128" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb292-129"><a href="#cb292-129" aria-hidden="true" tabindex="-1"></a>s, t <span class="op">=</span> sequences[<span class="dv">0</span>], sequences[<span class="dv">1</span>]</span>
<span id="cb292-130"><a href="#cb292-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-131"><a href="#cb292-131" aria-hidden="true" tabindex="-1"></a><span class="co"># Parse the BLOSUM62 matrix</span></span>
<span id="cb292-132"><a href="#cb292-132" aria-hidden="true" tabindex="-1"></a>blosum62 <span class="op">=</span> parse_blosum62(blosum62_str)</span>
<span id="cb292-133"><a href="#cb292-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-134"><a href="#cb292-134" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform global alignment with affine gap penalties</span></span>
<span id="cb292-135"><a href="#cb292-135" aria-hidden="true" tabindex="-1"></a>alignment <span class="op">=</span> global_align_with_affine(s, t, blosum62, <span class="op">-</span><span class="dv">11</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb292-136"><a href="#cb292-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-137"><a href="#cb292-137" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(alignment))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This Python code performs global sequence alignment between two protein sequences using the BLOSUM62 substitution matrix and affine gap penalties. The alignment proces is a common technique in bioinformatics to compare two sequences and find the best way to align them by inserting gaps and matching characters.</p>
</section>
<section id="detailed-explanation-4" class="level2" data-number="96.4">
<h2 data-number="96.4" class="anchored" data-anchor-id="detailed-explanation-4"><span class="header-section-number">96.4</span> Detailed Explanation</h2>
<ol type="1">
<li><strong>BLOSUM62 Matrix as a String:</strong>
<ul>
<li>The BLOSUM62 matrix, a commonly used substitution matrix in bioinformatics, is provided as a multiline string. It contains scores representing how likely it is for each amino acid pair to substitute for each other.</li>
</ul></li>
<li><strong><code>parse_blosum62(matrix_str)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Converts the BLOSUM62 string into a dictionary for easier lookup.</li>
<li><strong>How It Works:</strong>
<ul>
<li>The string is split into lines and then into individual elements.</li>
<li>The first line contains the amino acid headers.</li>
<li>Each subsequent line contains scores for substituting one amino acid with others.</li>
<li>A dictionary is created where each key is a tuple of two amino acids, and the value is the corresponding substitution score.</li>
</ul></li>
</ul></li>
<li><strong><code>parse_fasta(data)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Parses sequences from the FASTA format, which is a standard text-based format for representing sequences.</li>
<li><strong>How It Works:</strong>
<ul>
<li>The function reads the input line by line.</li>
<li>Lines starting with <code>&gt;</code> indicate sequence headers, which are ignored.</li>
<li>Sequence data is collected into a list of sequences.</li>
</ul></li>
</ul></li>
<li><strong><code>match_score(scoring_matrix, a, b)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Retrieves the substitution score for a pair of amino acids from the BLOSUM62 matrix.</li>
<li><strong>How It Works:</strong>
<ul>
<li>It looks up the score for the amino acid pair <code>(a, b)</code> in the dictionary. If the pair is not found, it returns <code>0</code>.</li>
</ul></li>
</ul></li>
<li><strong><code>global_align_with_affine(s, t, scores, gap, gap_e)</code> Function:</strong>
<ul>
<li><strong>Purpose:</strong> Performs global alignment of two sequences using affine gap penalties.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Initialization:</strong> Three matrices (<code>M</code>, <code>X</code>, <code>Y</code>) are used to keep track of the scores for matches, gaps in one sequence, and gaps in the other sequence, respectively. <code>traceM</code>, <code>traceX</code>, and <code>traceY</code> track the path for traceback.</li>
<li><strong>Matrix Filling:</strong> The matrices are filled in a nested loop:
<ul>
<li><code>M[i][j]</code>: Maximum score considering a match or mismatch.</li>
<li><code>X[i][j]</code>: Maximum score considering a gap in sequence <code>t</code>.</li>
<li><code>Y[i][j]</code>: Maximum score considering a gap in sequence <code>s</code>.</li>
</ul></li>
<li><strong>Traceback:</strong> After filling the matrices, the function traces back from the last cell to reconstruct the aligned sequences, inserting gaps where needed.</li>
<li>The traceback ensures that the sequences are aligned optimally according to the scoring matrix and gap penalties.</li>
</ul></li>
</ul></li>
<li><strong>Sample Input and Execution:</strong>
<ul>
<li><strong>Sample Input:</strong> Two sequences (<code>PRTEINS</code> and <code>PRTWPSEIN</code>) are provided in FASTA format.</li>
<li><strong>Execution:</strong>
<ul>
<li>The sequences are parsed from the input.</li>
<li>The BLOSUM62 matrix is parsed.</li>
<li>Global alignment with affine gap penalties is performed using the parsed sequences and matrix.</li>
<li>The alignment result, including the score and the aligned sequences, is printed.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="genome-assembly-with-perfect-coverage-and-repeats" class="level1" data-number="97">
<h1 data-number="97"><span class="header-section-number">97</span> Genome Assembly with Perfect Coverage and Repeats</h1>
<p>Recall that a&nbsp;<a href="https://rosalind.info/glossary/directed-cycle/">directed cycle</a>&nbsp;is a cycle in a&nbsp;<a href="https://rosalind.info/glossary/directed-graph/">directed graph</a>&nbsp;in which the&nbsp;<a href="https://rosalind.info/glossary/head/">head</a>&nbsp;of one edge is equal to the&nbsp;<a href="https://rosalind.info/glossary/tail/">tail</a>&nbsp;of the following edge.</p>
<p>In a de Bruijn graph of&nbsp;k-mers, a circular string&nbsp;s is constructed from a directed cycle&nbsp;<span class="math inline">\(s1→s2→...→si→s1\)</span>&nbsp;is given by&nbsp;<span class="math inline">\(s1+s2[k]+...+s_{i−k}[k]+s_{i−k+1}[k]\)</span>. That is, because the final&nbsp;<span class="math inline">\(k−1\)</span>&nbsp;symbols of&nbsp;<span class="math inline">\(s1\)</span>&nbsp;overlap with the first&nbsp;<span class="math inline">\(k−1\)</span>&nbsp;symbols of&nbsp;<span class="math inline">\(s2\)</span>, we simply tack on the&nbsp;k-th symbol of&nbsp;<span class="math inline">\(s2\)</span>&nbsp;to&nbsp;<span class="math inline">\(s\)</span>, then iterate the process.</p>
<p>For example, the circular string assembled from the cycle “AC”&nbsp;→&nbsp;“CT”&nbsp;→&nbsp;“TA”&nbsp;→&nbsp;“AC” is simply (ACT). Note that this string only has length three because the 2-mers “wrap around” in the string.</p>
<p>If every&nbsp;k-mer in a collection of reads occurs as an edge in a de Bruijn graph cycle the same number of times as it appears in the reads, then we say that the cycle is “complete.”</p>
<p>Given:&nbsp;A list&nbsp;<span class="math inline">\(S_{k+1}\)</span>&nbsp;of error-free DNA&nbsp;(k+1)-mers (<span class="math inline">\(k≤5\)</span>) taken from the same strand of a&nbsp;<a href="https://rosalind.info/glossary/circular-string/">circular chromosome</a>&nbsp;(of length&nbsp;<span class="math inline">\(≤50\)</span>).</p>
<p>Return:&nbsp;All circular strings assembled by complete cycles in the de Bruijn graph&nbsp;<span class="math inline">\(Bk\)</span>&nbsp;of&nbsp;<span class="math inline">\(S_{k+1}\)</span>. The strings may be given in any order, but each one should begin with the first&nbsp;<span class="math inline">\((k+1)\)</span>-mer provided in the input.</p>
<section id="sample-dataset-96" class="level2" data-number="97.1">
<h2 data-number="97.1" class="anchored" data-anchor-id="sample-dataset-96"><span class="header-section-number">97.1</span> Sample Dataset</h2>
<pre><code>CAG
AGT
GTT
TTT
TTG
TGG
GGC
GCG
CGT
GTT
TTC
TCA
CAA
AAT
ATT
TTC
TCA</code></pre>
</section>
<section id="sample-output-97" class="level2" data-number="97.2">
<h2 data-number="97.2" class="anchored" data-anchor-id="sample-output-97"><span class="header-section-number">97.2</span> Sample Output</h2>
<pre><code>CAGTTCAATTTGGCGTT
CAGTTCAATTGGCGTTT
CAGTTTCAATTGGCGTT
CAGTTTGGCGTTCAATT
CAGTTGGCGTTCAATTT
CAGTTGGCGTTTCAATT</code></pre>
</section>
<section id="solution-93" class="level2" data-number="97.3">
<h2 data-number="97.3" class="anchored" data-anchor-id="solution-93"><span class="header-section-number">97.3</span> Solution</h2>
<div class="sourceCode" id="cb295"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>clas DeBruijnGraph:</span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a>    clas Node:</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, kmer):</span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.kmer <span class="op">=</span> kmer</span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.neighbors <span class="op">=</span> []</span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.in_degree <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.out_degree <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, reads):</span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph <span class="op">=</span> {}</span>
<span id="cb295-11"><a href="#cb295-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start_kmer <span class="op">=</span> reads[<span class="dv">0</span>]</span>
<span id="cb295-12"><a href="#cb295-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-13"><a href="#cb295-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> read <span class="kw">in</span> reads:</span>
<span id="cb295-14"><a href="#cb295-14" aria-hidden="true" tabindex="-1"></a>            left_kmer, right_kmer <span class="op">=</span> read[:<span class="op">-</span><span class="dv">1</span>], read[<span class="dv">1</span>:]</span>
<span id="cb295-15"><a href="#cb295-15" aria-hidden="true" tabindex="-1"></a>            left_hash, right_hash <span class="op">=</span> <span class="bu">hash</span>(left_kmer), <span class="bu">hash</span>(right_kmer)</span>
<span id="cb295-16"><a href="#cb295-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-17"><a href="#cb295-17" aria-hidden="true" tabindex="-1"></a>            left_node <span class="op">=</span> <span class="va">self</span>.graph.setdefault(left_hash, <span class="va">self</span>.Node(left_kmer))</span>
<span id="cb295-18"><a href="#cb295-18" aria-hidden="true" tabindex="-1"></a>            right_node <span class="op">=</span> <span class="va">self</span>.graph.setdefault(right_hash, <span class="va">self</span>.Node(right_kmer))</span>
<span id="cb295-19"><a href="#cb295-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-20"><a href="#cb295-20" aria-hidden="true" tabindex="-1"></a>            left_node.neighbors.append(right_node)</span>
<span id="cb295-21"><a href="#cb295-21" aria-hidden="true" tabindex="-1"></a>            left_node.out_degree <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb295-22"><a href="#cb295-22" aria-hidden="true" tabindex="-1"></a>            right_node.in_degree <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb295-23"><a href="#cb295-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-24"><a href="#cb295-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> circular_string(<span class="va">self</span>):</span>
<span id="cb295-25"><a href="#cb295-25" aria-hidden="true" tabindex="-1"></a>        potential_starts <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.graph.values() <span class="cf">if</span> node.out_degree <span class="op">&gt;</span> <span class="dv">1</span>]</span>
<span id="cb295-26"><a href="#cb295-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> potential_starts, <span class="st">"No potential start nodes found!"</span></span>
<span id="cb295-27"><a href="#cb295-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-28"><a href="#cb295-28" aria-hidden="true" tabindex="-1"></a>        contigs <span class="op">=</span> []</span>
<span id="cb295-29"><a href="#cb295-29" aria-hidden="true" tabindex="-1"></a>        strings <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb295-30"><a href="#cb295-30" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.start_kmer) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb295-31"><a href="#cb295-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-32"><a href="#cb295-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> dfs(node, sequence):</span>
<span id="cb295-33"><a href="#cb295-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.out_degree <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb295-34"><a href="#cb295-34" aria-hidden="true" tabindex="-1"></a>                contigs.append(sequence <span class="op">+</span> node.kmer[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb295-35"><a href="#cb295-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb295-36"><a href="#cb295-36" aria-hidden="true" tabindex="-1"></a>                dfs(node.neighbors[<span class="dv">0</span>], sequence <span class="op">+</span> node.kmer[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb295-37"><a href="#cb295-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-38"><a href="#cb295-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> start_node <span class="kw">in</span> potential_starts:</span>
<span id="cb295-39"><a href="#cb295-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> neighbor <span class="kw">in</span> start_node.neighbors:</span>
<span id="cb295-40"><a href="#cb295-40" aria-hidden="true" tabindex="-1"></a>                dfs(neighbor, start_node.kmer)</span>
<span id="cb295-41"><a href="#cb295-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-42"><a href="#cb295-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> find_circular_strings(current_sequence, accumulated_string, used_contigs):</span>
<span id="cb295-43"><a href="#cb295-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(used_contigs) <span class="op">==</span> <span class="bu">len</span>(contigs):</span>
<span id="cb295-44"><a href="#cb295-44" aria-hidden="true" tabindex="-1"></a>                strings.add(accumulated_string)</span>
<span id="cb295-45"><a href="#cb295-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb295-46"><a href="#cb295-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">set</span>(<span class="bu">range</span>(<span class="bu">len</span>(contigs))).difference(used_contigs):</span>
<span id="cb295-47"><a href="#cb295-47" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="kw">not</span> current_sequence.endswith(contigs[idx][:k]):</span>
<span id="cb295-48"><a href="#cb295-48" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb295-49"><a href="#cb295-49" aria-hidden="true" tabindex="-1"></a>                    find_circular_strings(contigs[idx], accumulated_string <span class="op">+</span> contigs[idx][:<span class="op">-</span>k], used_contigs <span class="op">+</span> (idx,))</span>
<span id="cb295-50"><a href="#cb295-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-51"><a href="#cb295-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, contig <span class="kw">in</span> <span class="bu">enumerate</span>(contigs):</span>
<span id="cb295-52"><a href="#cb295-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> contig.startswith(<span class="va">self</span>.start_kmer):</span>
<span id="cb295-53"><a href="#cb295-53" aria-hidden="true" tabindex="-1"></a>                find_circular_strings(contig, contig[:<span class="op">-</span>k], (i,))</span>
<span id="cb295-54"><a href="#cb295-54" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb295-55"><a href="#cb295-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-56"><a href="#cb295-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> strings</span>
<span id="cb295-57"><a href="#cb295-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-58"><a href="#cb295-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-59"><a href="#cb295-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb295-60"><a href="#cb295-60" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb295-61"><a href="#cb295-61" aria-hidden="true" tabindex="-1"></a><span class="st">CAG</span></span>
<span id="cb295-62"><a href="#cb295-62" aria-hidden="true" tabindex="-1"></a><span class="st">AGT</span></span>
<span id="cb295-63"><a href="#cb295-63" aria-hidden="true" tabindex="-1"></a><span class="st">GTT</span></span>
<span id="cb295-64"><a href="#cb295-64" aria-hidden="true" tabindex="-1"></a><span class="st">TTT</span></span>
<span id="cb295-65"><a href="#cb295-65" aria-hidden="true" tabindex="-1"></a><span class="st">TTG</span></span>
<span id="cb295-66"><a href="#cb295-66" aria-hidden="true" tabindex="-1"></a><span class="st">TGG</span></span>
<span id="cb295-67"><a href="#cb295-67" aria-hidden="true" tabindex="-1"></a><span class="st">GGC</span></span>
<span id="cb295-68"><a href="#cb295-68" aria-hidden="true" tabindex="-1"></a><span class="st">GCG</span></span>
<span id="cb295-69"><a href="#cb295-69" aria-hidden="true" tabindex="-1"></a><span class="st">CGT</span></span>
<span id="cb295-70"><a href="#cb295-70" aria-hidden="true" tabindex="-1"></a><span class="st">GTT</span></span>
<span id="cb295-71"><a href="#cb295-71" aria-hidden="true" tabindex="-1"></a><span class="st">TTC</span></span>
<span id="cb295-72"><a href="#cb295-72" aria-hidden="true" tabindex="-1"></a><span class="st">TCA</span></span>
<span id="cb295-73"><a href="#cb295-73" aria-hidden="true" tabindex="-1"></a><span class="st">CAA</span></span>
<span id="cb295-74"><a href="#cb295-74" aria-hidden="true" tabindex="-1"></a><span class="st">AAT</span></span>
<span id="cb295-75"><a href="#cb295-75" aria-hidden="true" tabindex="-1"></a><span class="st">ATT</span></span>
<span id="cb295-76"><a href="#cb295-76" aria-hidden="true" tabindex="-1"></a><span class="st">TTC</span></span>
<span id="cb295-77"><a href="#cb295-77" aria-hidden="true" tabindex="-1"></a><span class="st">TCA</span></span>
<span id="cb295-78"><a href="#cb295-78" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb295-79"><a href="#cb295-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-80"><a href="#cb295-80" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb295-81"><a href="#cb295-81" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> DeBruijnGraph(reads)</span>
<span id="cb295-82"><a href="#cb295-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="op">*</span>graph.circular_string(), sep<span class="op">=</span><span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-47" class="level2" data-number="97.4">
<h2 data-number="97.4" class="anchored" data-anchor-id="explanation-47"><span class="header-section-number">97.4</span> Explanation</h2>
<ol type="1">
<li><p><strong>Graph Construction</strong>: The code constructs a De Bruijn graph using the provided k-mers (reads). Each k-mer’s prefix (all but the last character) and suffix (all but the first character) are treated as nodes in the graph. The graph edges represent transitions from one k-mer to another based on these prefixes and suffixes.</p></li>
<li><p><strong>Node Structure</strong>: Each node in the graph stores its k-mer, its neighbors (other nodes it can connect to), and its in-degree and out-degree (how many edges enter and leave the node).</p></li>
<li><p><strong>Graph Traversal</strong>: The code identifies nodes with more than one outgoing edge (<code>out_degree &gt; 1</code>) as potential starting points for generating circular sequences (possible cyclic paths in the graph).</p></li>
<li><p><strong>Depth-First Search (DFS)</strong>: The code uses DFS to traverse from these potential starting nodes to build “contigs,” which are sequences representing possible paths through the graph.</p></li>
<li><p><strong>Generating Circular Strings</strong>: After building contigs, the code recursively combines these contigs to generate complete circular strings that encompas all the original k-mers.</p></li>
<li><p><strong>Output</strong>: The final set of circular strings that represent possible solutions is printed.</p></li>
</ol>
</section>
</section>
<section id="finding-a-motif-with-modifications" class="level1" data-number="98">
<h1 data-number="98"><span class="header-section-number">98</span> Finding a Motif with Modifications</h1>
<p>Given a string&nbsp;s and a motif&nbsp;tt, an alignment of a substring of&nbsp;s&nbsp;against all of&nbsp;t&nbsp;is called a&nbsp;<a href="https://rosalind.info/glossary/fitting-alignment/">fitting alignment</a>. Our aim is to find a substring&nbsp;<span class="math inline">\(s′\)</span>&nbsp;of&nbsp;s that maximizes an&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>&nbsp;with respect to&nbsp;<span class="math inline">\(t\)</span>.</p>
<p>Note that more than one such substring of&nbsp;<span class="math inline">\(s\)</span>&nbsp;may exist, depending on the particular strings and alignment score used. One candidate for scoring function is the one derived from&nbsp;<a href="https://rosalind.info/glossary/edit-distance/">edit distance</a>; In this problem, we will consider a slightly different alignment score, in which all matched symbols count as +1 and all mismatched symbols (including insertions and deletions) receive a cost of -1. Let’s call this scoring function the&nbsp;<a href="https://rosalind.info/glossary/mismatch-score/">mismatch score</a>.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, where&nbsp;<span class="math inline">\(s\)</span>&nbsp;has length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;represents a motif of length at most 1&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;An optimal fitting alignment score with respect to the mismatch score defined above, followed by an optimal fitting alignment of a substring of&nbsp;s against&nbsp;tt. If multiple such alignments exist, then you may output any one.</p>
<section id="sample-dataset-97" class="level2" data-number="98.1">
<h2 data-number="98.1" class="anchored" data-anchor-id="sample-dataset-97"><span class="header-section-number">98.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_54
GCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC
&gt;Rosalind_46
GCCGTCAGGCTGGTGTCCG</code></pre>
</section>
<section id="sample-output-98" class="level2" data-number="98.2">
<h2 data-number="98.2" class="anchored" data-anchor-id="sample-output-98"><span class="header-section-number">98.2</span> Sample Output</h2>
<pre><code>5
ACCATAAGCCCTACGTG-CCG
GCCGTCAGGC-TG-GTGTCCG</code></pre>
</section>
<section id="solution-94" class="level2" data-number="98.3">
<h2 data-number="98.3" class="anchored" data-anchor-id="solution-94"><span class="header-section-number">98.3</span> Solution</h2>
<div class="sourceCode" id="cb298"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Tuple</span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>GAP_PENALTY <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a>MATCH_SCORE <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a>MISMATCH_PENALTY <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse FASTA format data into a list of sequences."""</span></span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb298-11"><a href="#cb298-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb298-12"><a href="#cb298-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb298-13"><a href="#cb298-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_seq:</span>
<span id="cb298-14"><a href="#cb298-14" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb298-15"><a href="#cb298-15" aria-hidden="true" tabindex="-1"></a>                current_seq <span class="op">=</span> []</span>
<span id="cb298-16"><a href="#cb298-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb298-17"><a href="#cb298-17" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line.strip())</span>
<span id="cb298-18"><a href="#cb298-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_seq:</span>
<span id="cb298-19"><a href="#cb298-19" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb298-20"><a href="#cb298-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb298-21"><a href="#cb298-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-22"><a href="#cb298-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initialize_dp_matrix(m: <span class="bu">int</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb298-23"><a href="#cb298-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Initialize the dynamic programming matrix."""</span></span>
<span id="cb298-24"><a href="#cb298-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb298-25"><a href="#cb298-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-26"><a href="#cb298-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fill_dp_matrix(c: <span class="bu">str</span>, d: <span class="bu">str</span>, dp: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb298-27"><a href="#cb298-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Fill the dynamic programming matrix."""</span></span>
<span id="cb298-28"><a href="#cb298-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(c) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb298-29"><a href="#cb298-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(d) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb298-30"><a href="#cb298-30" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb298-31"><a href="#cb298-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb298-32"><a href="#cb298-32" aria-hidden="true" tabindex="-1"></a>                ans <span class="op">=</span> <span class="bu">max</span>(ans, dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> GAP_PENALTY)</span>
<span id="cb298-33"><a href="#cb298-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb298-34"><a href="#cb298-34" aria-hidden="true" tabindex="-1"></a>                ans <span class="op">=</span> <span class="bu">max</span>(ans, dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> GAP_PENALTY)</span>
<span id="cb298-35"><a href="#cb298-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb298-36"><a href="#cb298-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> c[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> d[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb298-37"><a href="#cb298-37" aria-hidden="true" tabindex="-1"></a>                    ans <span class="op">=</span> <span class="bu">max</span>(ans, dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> MATCH_SCORE)</span>
<span id="cb298-38"><a href="#cb298-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb298-39"><a href="#cb298-39" aria-hidden="true" tabindex="-1"></a>                    ans <span class="op">=</span> <span class="bu">max</span>(ans, dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> MISMATCH_PENALTY)</span>
<span id="cb298-40"><a href="#cb298-40" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> ans</span>
<span id="cb298-41"><a href="#cb298-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-42"><a href="#cb298-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_best_score(dp: List[List[<span class="bu">int</span>]], m: <span class="bu">int</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>, <span class="bu">int</span>, <span class="bu">int</span>]:</span>
<span id="cb298-43"><a href="#cb298-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Find the best score and its position in the DP matrix."""</span></span>
<span id="cb298-44"><a href="#cb298-44" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb298-45"><a href="#cb298-45" aria-hidden="true" tabindex="-1"></a>    bi, bj <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span></span>
<span id="cb298-46"><a href="#cb298-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb298-47"><a href="#cb298-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> score <span class="op">&lt;</span> dp[i][n]:</span>
<span id="cb298-48"><a href="#cb298-48" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> dp[i][n]</span>
<span id="cb298-49"><a href="#cb298-49" aria-hidden="true" tabindex="-1"></a>            bi, bj <span class="op">=</span> i, n</span>
<span id="cb298-50"><a href="#cb298-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(score), bi, bj</span>
<span id="cb298-51"><a href="#cb298-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-52"><a href="#cb298-52" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtrack(c: <span class="bu">str</span>, d: <span class="bu">str</span>, dp: List[List[<span class="bu">int</span>]], bi: <span class="bu">int</span>, bj: <span class="bu">int</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">str</span>, <span class="bu">str</span>]:</span>
<span id="cb298-53"><a href="#cb298-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Backtrack to find the aligned sequences."""</span></span>
<span id="cb298-54"><a href="#cb298-54" aria-hidden="true" tabindex="-1"></a>    s1, s2 <span class="op">=</span> [], []</span>
<span id="cb298-55"><a href="#cb298-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> bj <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb298-56"><a href="#cb298-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bi <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[bi <span class="op">-</span> <span class="dv">1</span>][bj] <span class="op">-</span> GAP_PENALTY <span class="op">==</span> dp[bi][bj]:</span>
<span id="cb298-57"><a href="#cb298-57" aria-hidden="true" tabindex="-1"></a>            s1.append(c[bi <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb298-58"><a href="#cb298-58" aria-hidden="true" tabindex="-1"></a>            s2.append(<span class="st">'-'</span>)</span>
<span id="cb298-59"><a href="#cb298-59" aria-hidden="true" tabindex="-1"></a>            bi <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb298-60"><a href="#cb298-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> bj <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[bi][bj <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> GAP_PENALTY <span class="op">==</span> dp[bi][bj]:</span>
<span id="cb298-61"><a href="#cb298-61" aria-hidden="true" tabindex="-1"></a>            s1.append(<span class="st">'-'</span>)</span>
<span id="cb298-62"><a href="#cb298-62" aria-hidden="true" tabindex="-1"></a>            s2.append(d[bj <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb298-63"><a href="#cb298-63" aria-hidden="true" tabindex="-1"></a>            bj <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb298-64"><a href="#cb298-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb298-65"><a href="#cb298-65" aria-hidden="true" tabindex="-1"></a>            s1.append(c[bi <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb298-66"><a href="#cb298-66" aria-hidden="true" tabindex="-1"></a>            s2.append(d[bj <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb298-67"><a href="#cb298-67" aria-hidden="true" tabindex="-1"></a>            bi <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb298-68"><a href="#cb298-68" aria-hidden="true" tabindex="-1"></a>            bj <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb298-69"><a href="#cb298-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(s1[::<span class="op">-</span><span class="dv">1</span>]), <span class="st">''</span>.join(s2[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb298-70"><a href="#cb298-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-71"><a href="#cb298-71" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb298-72"><a href="#cb298-72" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_54</span></span>
<span id="cb298-73"><a href="#cb298-73" aria-hidden="true" tabindex="-1"></a><span class="st">GCAAACCATAAGCCCTACGTGCCGCCTGTTTAAACTCGCGAACTGAATCTTCTGCTTCACGGTGAAAGTACCACAATGGTATCACACCCCAAGGAAAC</span></span>
<span id="cb298-74"><a href="#cb298-74" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_46</span></span>
<span id="cb298-75"><a href="#cb298-75" aria-hidden="true" tabindex="-1"></a><span class="st">GCCGTCAGGCTGGTGTCCG</span></span>
<span id="cb298-76"><a href="#cb298-76" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb298-77"><a href="#cb298-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-78"><a href="#cb298-78" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb298-79"><a href="#cb298-79" aria-hidden="true" tabindex="-1"></a>c, d <span class="op">=</span> sequences</span>
<span id="cb298-80"><a href="#cb298-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-81"><a href="#cb298-81" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> initialize_dp_matrix(<span class="bu">len</span>(c), <span class="bu">len</span>(d))</span>
<span id="cb298-82"><a href="#cb298-82" aria-hidden="true" tabindex="-1"></a>fill_dp_matrix(c, d, dp)</span>
<span id="cb298-83"><a href="#cb298-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-84"><a href="#cb298-84" aria-hidden="true" tabindex="-1"></a>score, bi, bj <span class="op">=</span> find_best_score(dp, <span class="bu">len</span>(c), <span class="bu">len</span>(d))</span>
<span id="cb298-85"><a href="#cb298-85" aria-hidden="true" tabindex="-1"></a>aligned_c, aligned_d <span class="op">=</span> backtrack(c, d, dp, bi, bj)</span>
<span id="cb298-86"><a href="#cb298-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-87"><a href="#cb298-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(score)</span>
<span id="cb298-88"><a href="#cb298-88" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_c)</span>
<span id="cb298-89"><a href="#cb298-89" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_d)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code performs a sequence alignment between two DNA sequences using a dynamic programming approach. Sequence alignment is a method used in bioinformatics to compare two sequences and determine the best match between them, accounting for matches, mismatches, and gaps.</p>
</section>
<section id="how-the-code-works" class="level2" data-number="98.4">
<h2 data-number="98.4" class="anchored" data-anchor-id="how-the-code-works"><span class="header-section-number">98.4</span> How the Code Works</h2>
<ol type="1">
<li><p><strong>Constants:</strong></p>
<ul>
<li><code>GAP_PENALTY</code>: Penalty for introducing a gap (insertion/deletion) in the sequence alignment.</li>
<li><code>MATCH_SCORE</code>: Score for matching characters between the two sequences.</li>
<li><code>MISMATCH_PENALTY</code>: Penalty for mismatched characters.</li>
</ul></li>
<li><p><strong>Functions:</strong></p>
<ul>
<li><strong><code>parse_fasta(data: str) -&gt; List[str]</code>:</strong>
<ul>
<li><strong>Purpose:</strong> Converts a FASTA format string into a list of sequences.</li>
<li><strong>How It Works:</strong> The function reads the input data, ignoring lines starting with ‘&gt;’ (which are headers), and combines the remaining lines into sequences.</li>
</ul></li>
<li><strong><code>initialize_dp_matrix(m: int, n: int) -&gt; List[List[int]]</code>:</strong>
<ul>
<li><strong>Purpose:</strong> Initializes a matrix for dynamic programming (DP) with dimensions <code>(m+1) x (n+1)</code>, where <code>m</code> and <code>n</code> are the lengths of the two sequences.</li>
<li><strong>How It Works:</strong> Creates a 2D list filled with zeros.</li>
</ul></li>
<li><strong><code>fill_dp_matrix(c: str, d: str, dp: List[List[int]]) -&gt; None</code>:</strong>
<ul>
<li><strong>Purpose:</strong> Fills the DP matrix with scores based on the alignment of sequences <code>c</code> and <code>d</code>.</li>
<li><strong>How It Works:</strong>
<ul>
<li>Iterates over all possible alignments of <code>c</code> and <code>d</code>.</li>
<li>For each position, it calculates the best score considering three possible moves: match/mismatch, insertion, and deletion.</li>
<li>The score is updated based on whether characters match or mismatch, and whether gaps are introduced.</li>
</ul></li>
</ul></li>
<li><strong><code>find_best_score(dp: List[List[int]], m: int, n: int) -&gt; Tuple[int, int, int]</code>:</strong>
<ul>
<li><strong>Purpose:</strong> Finds the best alignment score and its position in the DP matrix.</li>
<li><strong>How It Works:</strong>
<ul>
<li>Scans the last column of the DP matrix to find the highest score and its position. This represents the optimal alignment score.</li>
</ul></li>
</ul></li>
<li><strong><code>backtrack(c: str, d: str, dp: List[List[int]], bi: int, bj: int) -&gt; Tuple[str, str]</code>:</strong>
<ul>
<li><strong>Purpose:</strong> Traces back through the DP matrix to construct the aligned sequences based on the best alignment score.</li>
<li><strong>How It Works:</strong>
<ul>
<li>Starting from the best score position, it determines the path that led to this score, reconstructing the aligned sequences with gaps (<code>-</code>) where necessary.</li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>Execution:</strong></p>
<ul>
<li><strong>Sample Input:</strong> The FASTA input contains two sequences labeled <code>Rosalind_54</code> and <code>Rosalind_46</code>.</li>
<li><strong>Processing:</strong>
<ul>
<li>The sequences are extracted using <code>parse_fasta</code>.</li>
<li>A DP matrix is initialized using <code>initialize_dp_matrix</code>.</li>
<li>The matrix is filled with alignment scores using <code>fill_dp_matrix</code>.</li>
<li>The best alignment score and position are found with <code>find_best_score</code>.</li>
<li>The best alignment itself is reconstructed using <code>backtrack</code>.</li>
</ul></li>
<li><strong>Output:</strong>
<ul>
<li>The alignment score and the two aligned sequences are printed.</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="isolating-symbols-in-alignments" class="level1" data-number="99">
<h1 data-number="99"><span class="header-section-number">99</span> Isolating Symbols in Alignments</h1>
<p>Say that we have two strings&nbsp;s&nbsp;and&nbsp;t&nbsp;of respective lengths&nbsp;<span class="math inline">\(m\)</span>&nbsp;and&nbsp;<span class="math inline">\(n\)</span>&nbsp;and an&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>. Let’s define a matrix&nbsp;MM&nbsp;corresponding to&nbsp;s and&nbsp;t by setting&nbsp;<span class="math inline">\(M_{j,k}\)</span>&nbsp;equal to the maximum score of any alignment that aligns&nbsp;<span class="math inline">\(s[j]\)</span> with&nbsp;<span class="math inline">\(t[k]\)</span>. So each entry in&nbsp;<span class="math inline">\(M\)</span>&nbsp;can be equal to at most the maximum score of any alignment of&nbsp;s and&nbsp;<span class="math inline">\(t\)</span>.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>, each having length at most 1000&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>.</p>
<p>Return:&nbsp;The maximum alignment score of a global alignment of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, followed by the sum of all elements of the matrix&nbsp;<span class="math inline">\(M\)</span>&nbsp;corresponding to&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;that was defined above. Apply the mismatch score introduced in&nbsp;<a href="https://rosalind.info/problems/sims/">“Finding a Motif with Modifications”</a>.</p>
<section id="sample-dataset-98" class="level2" data-number="99.1">
<h2 data-number="99.1" class="anchored" data-anchor-id="sample-dataset-98"><span class="header-section-number">99.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_35
ATAGATA
&gt;Rosalind_5
ACAGGTA</code></pre>
</section>
<section id="sample-output-99" class="level2" data-number="99.2">
<h2 data-number="99.2" class="anchored" data-anchor-id="sample-output-99"><span class="header-section-number">99.2</span> Sample Output</h2>
<pre><code>3
-139</code></pre>
</section>
<section id="solution-95" class="level2" data-number="99.3">
<h2 data-number="99.3" class="anchored" data-anchor-id="solution-95"><span class="header-section-number">99.3</span> Solution</h2>
<div class="sourceCode" id="cb301"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Tuple</span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(data: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parse FASTA format data into a list of sequences."""</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> data.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb301-8"><a href="#cb301-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb301-9"><a href="#cb301-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_seq:</span>
<span id="cb301-10"><a href="#cb301-10" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb301-11"><a href="#cb301-11" aria-hidden="true" tabindex="-1"></a>                current_seq <span class="op">=</span> []</span>
<span id="cb301-12"><a href="#cb301-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb301-13"><a href="#cb301-13" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line.strip())</span>
<span id="cb301-14"><a href="#cb301-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_seq:</span>
<span id="cb301-15"><a href="#cb301-15" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_seq))</span>
<span id="cb301-16"><a href="#cb301-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb301-17"><a href="#cb301-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-18"><a href="#cb301-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initialize_score_matrix(rows: <span class="bu">int</span>, cols: <span class="bu">int</span>) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb301-19"><a href="#cb301-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Initialize the score matrix with gap penalties."""</span></span>
<span id="cb301-20"><a href="#cb301-20" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(cols)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb301-21"><a href="#cb301-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb301-22"><a href="#cb301-22" aria-hidden="true" tabindex="-1"></a>        S[i][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>i</span>
<span id="cb301-23"><a href="#cb301-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb301-24"><a href="#cb301-24" aria-hidden="true" tabindex="-1"></a>        S[<span class="dv">0</span>][j] <span class="op">=</span> <span class="op">-</span>j</span>
<span id="cb301-25"><a href="#cb301-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S</span>
<span id="cb301-26"><a href="#cb301-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-27"><a href="#cb301-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_cell_score(S: List[List[<span class="bu">int</span>]], i: <span class="bu">int</span>, j: <span class="bu">int</span>, s: <span class="bu">str</span>, t: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb301-28"><a href="#cb301-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate the score for a cell in the alignment matrix."""</span></span>
<span id="cb301-29"><a href="#cb301-29" aria-hidden="true" tabindex="-1"></a>    match_score <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> s[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> t[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb301-30"><a href="#cb301-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(</span>
<span id="cb301-31"><a href="#cb301-31" aria-hidden="true" tabindex="-1"></a>        S[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> match_score,</span>
<span id="cb301-32"><a href="#cb301-32" aria-hidden="true" tabindex="-1"></a>        S[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">-</span> <span class="dv">1</span>,</span>
<span id="cb301-33"><a href="#cb301-33" aria-hidden="true" tabindex="-1"></a>        S[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb301-34"><a href="#cb301-34" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb301-35"><a href="#cb301-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-36"><a href="#cb301-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> global_alignment(s: <span class="bu">str</span>, t: <span class="bu">str</span>) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb301-37"><a href="#cb301-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Perform global alignment and return the score matrix."""</span></span>
<span id="cb301-38"><a href="#cb301-38" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(t) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb301-39"><a href="#cb301-39" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> initialize_score_matrix(rows, cols)</span>
<span id="cb301-40"><a href="#cb301-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-41"><a href="#cb301-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb301-42"><a href="#cb301-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb301-43"><a href="#cb301-43" aria-hidden="true" tabindex="-1"></a>            S[i][j] <span class="op">=</span> calculate_cell_score(S, i, j, s, t)</span>
<span id="cb301-44"><a href="#cb301-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-45"><a href="#cb301-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S</span>
<span id="cb301-46"><a href="#cb301-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-47"><a href="#cb301-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> align_to_symbols(s: <span class="bu">str</span>, t: <span class="bu">str</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">int</span>, <span class="bu">int</span>]:</span>
<span id="cb301-48"><a href="#cb301-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute the maximum alignment score and sum of all alignment scores."""</span></span>
<span id="cb301-49"><a href="#cb301-49" aria-hidden="true" tabindex="-1"></a>    prefix_matrix <span class="op">=</span> global_alignment(s, t)</span>
<span id="cb301-50"><a href="#cb301-50" aria-hidden="true" tabindex="-1"></a>    suffix_matrix <span class="op">=</span> global_alignment(s[::<span class="op">-</span><span class="dv">1</span>], t[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb301-51"><a href="#cb301-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-52"><a href="#cb301-52" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb301-53"><a href="#cb301-53" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="op">-</span>(<span class="bu">len</span>(s) <span class="op">+</span> <span class="bu">len</span>(t))</span>
<span id="cb301-54"><a href="#cb301-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-55"><a href="#cb301-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb301-56"><a href="#cb301-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)):</span>
<span id="cb301-57"><a href="#cb301-57" aria-hidden="true" tabindex="-1"></a>            match_score <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> s[i] <span class="op">==</span> t[j] <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb301-58"><a href="#cb301-58" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> prefix_matrix[i][j] <span class="op">+</span> match_score <span class="op">+</span> suffix_matrix[<span class="bu">len</span>(s)<span class="op">-</span><span class="dv">1</span><span class="op">-</span>i][<span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span><span class="op">-</span>j]</span>
<span id="cb301-59"><a href="#cb301-59" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> score</span>
<span id="cb301-60"><a href="#cb301-60" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> <span class="bu">max</span>(best, score)</span>
<span id="cb301-61"><a href="#cb301-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-62"><a href="#cb301-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best, total</span>
<span id="cb301-63"><a href="#cb301-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-64"><a href="#cb301-64" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb301-65"><a href="#cb301-65" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_35</span></span>
<span id="cb301-66"><a href="#cb301-66" aria-hidden="true" tabindex="-1"></a><span class="st">ATAGATA</span></span>
<span id="cb301-67"><a href="#cb301-67" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_5</span></span>
<span id="cb301-68"><a href="#cb301-68" aria-hidden="true" tabindex="-1"></a><span class="st">ACAGGTA</span></span>
<span id="cb301-69"><a href="#cb301-69" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb301-70"><a href="#cb301-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-71"><a href="#cb301-71" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb301-72"><a href="#cb301-72" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(sequences) <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb301-73"><a href="#cb301-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Expected exactly two sequences in the input."</span>)</span>
<span id="cb301-74"><a href="#cb301-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-75"><a href="#cb301-75" aria-hidden="true" tabindex="-1"></a>s, t <span class="op">=</span> sequences</span>
<span id="cb301-76"><a href="#cb301-76" aria-hidden="true" tabindex="-1"></a>best_score, total_score <span class="op">=</span> align_to_symbols(s, t)</span>
<span id="cb301-77"><a href="#cb301-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-78"><a href="#cb301-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>best_score<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb301-79"><a href="#cb301-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>total_score<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="code-breakdown" class="level2" data-number="99.4">
<h2 data-number="99.4" class="anchored" data-anchor-id="code-breakdown"><span class="header-section-number">99.4</span> Code Breakdown</h2>
<ol type="1">
<li><p><strong>Parsing FASTA Format (<code>parse_fasta</code> function):</strong></p>
<ul>
<li><strong>Purpose:</strong> Extracts DNA sequences from a FASTA formatted string.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Input:</strong> A string with lines that include sequences starting with <code>&gt;</code> (sequence headers) and followed by sequence data.</li>
<li><strong>Process:</strong>
<ul>
<li>It reads the input line by line.</li>
<li>When it encounters a line starting with <code>&gt;</code>, it recognizes it as a header and finishes the current sequence.</li>
<li>It collects sequence data lines and joins them into a single sequence string.</li>
<li>It returns a list of sequences.</li>
</ul></li>
</ul></li>
<li><strong>Output:</strong> A list of DNA sequences.</li>
</ul></li>
<li><p><strong>Initializing the Score Matrix (<code>initialize_score_matrix</code> function):</strong></p>
<ul>
<li><strong>Purpose:</strong> Set up a matrix to track alignment scores between two sequences, initializing with gap penalties.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Input:</strong> Number of rows (sequence length + 1) and columns (sequence length + 1).</li>
<li><strong>Process:</strong>
<ul>
<li>Creates a matrix of zeros.</li>
<li>Fills the first row and column with penalties for gaps (negative values), representing the cost of inserting gaps.</li>
</ul></li>
</ul></li>
<li><strong>Output:</strong> A score matrix with initialized gap penalties.</li>
</ul></li>
<li><p><strong>Calculating Cell Scores (<code>calculate_cell_score</code> function):</strong></p>
<ul>
<li><strong>Purpose:</strong> Determine the alignment score for a specific cell in the matrix.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Input:</strong> Current cell indices, the score matrix, and the sequences being aligned.</li>
<li><strong>Process:</strong>
<ul>
<li>Calculates the score for matching or mismatching characters, and the penalty for gaps.</li>
<li>Takes the maximum score among possible scenarios: match/mismatch, gap in one sequence, or gap in the other sequence.</li>
</ul></li>
</ul></li>
<li><strong>Output:</strong> The best score for the current cell.</li>
</ul></li>
<li><p><strong>Global Alignment (<code>global_alignment</code> function):</strong></p>
<ul>
<li><strong>Purpose:</strong> Create and fill a score matrix for global alignment of two sequences.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Input:</strong> Two sequences.</li>
<li><strong>Process:</strong>
<ul>
<li>Initializes the score matrix with gap penalties.</li>
<li>Fills the matrix using <code>calculate_cell_score</code> for each cell.</li>
</ul></li>
</ul></li>
<li><strong>Output:</strong> A filled score matrix representing global alignment scores.</li>
</ul></li>
<li><p><strong>Aligning to Symbols (<code>align_to_symbols</code> function):</strong></p>
<ul>
<li><strong>Purpose:</strong> Calculate the best alignment score and total score sum by considering both the original and reversed sequences.</li>
<li><strong>How It Works:</strong>
<ul>
<li><strong>Input:</strong> Two sequences.</li>
<li><strong>Process:</strong>
<ul>
<li>Computes the alignment score matrices for both the original sequences and their reversed versions.</li>
<li>Calculates scores by combining the prefix (forward alignment) and suffix (reverse alignment) matrices.</li>
<li>Finds the best score and sums all scores from the matrix.</li>
</ul></li>
</ul></li>
<li><strong>Output:</strong> The highest alignment score and the total sum of all scores.</li>
</ul></li>
</ol>
</section>
</section>
<section id="finding-all-similar-motifs" class="level1" data-number="100">
<h1 data-number="100"><span class="header-section-number">100</span> Finding All Similar Motifs</h1>
<p>Given:&nbsp;A positive integer&nbsp;<span class="math inline">\(k\)</span>&nbsp;(<span class="math inline">\(k≤50\)</span>), a&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA string</a>&nbsp;s of length at most 5&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>&nbsp;representing a motif, and a DNA string&nbsp;t of length at most 50 kbp representing a genome.</p>
<p>Return:&nbsp;All substrings&nbsp;<span class="math inline">\(t′\)</span>&nbsp;of&nbsp;<span class="math inline">\(t\)</span>&nbsp;such that the edit distance&nbsp;<span class="math inline">\(dE(s,t′)\)</span> is les than or equal to&nbsp;<span class="math inline">\(k\)</span>. Each substring should be encoded by a pair containing its&nbsp;<a href="https://rosalind.info/glossary/location/">location</a>&nbsp;in&nbsp;<span class="math inline">\(t\)</span>&nbsp;followed by its length.</p>
<section id="sample-dataset-99" class="level2" data-number="100.1">
<h2 data-number="100.1" class="anchored" data-anchor-id="sample-dataset-99"><span class="header-section-number">100.1</span> Sample Dataset</h2>
<pre><code>2
ACGTAG
ACGGATCGGCATCGT</code></pre>
</section>
<section id="sample-output-100" class="level2" data-number="100.2">
<h2 data-number="100.2" class="anchored" data-anchor-id="sample-output-100"><span class="header-section-number">100.2</span> Sample Output</h2>
<pre><code>1 4
1 5
1 6</code></pre>
</section>
<section id="solution-96" class="level2" data-number="100.3">
<h2 data-number="100.3" class="anchored" data-anchor-id="solution-96"><span class="header-section-number">100.3</span> Solution</h2>
<div class="sourceCode" id="cb304"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> multiprocessing <span class="im">as</span> mp</span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_seeds(x, seq, k):</span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true" tabindex="-1"></a>    seed_size <span class="op">=</span> <span class="bu">len</span>(x) <span class="op">//</span> (k <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb304-7"><a href="#cb304-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s1 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(x) <span class="op">-</span> seed_size <span class="op">+</span> <span class="dv">1</span>, seed_size):</span>
<span id="cb304-8"><a href="#cb304-8" aria-hidden="true" tabindex="-1"></a>        px <span class="op">=</span> (s1, s1 <span class="op">+</span> seed_size)</span>
<span id="cb304-9"><a href="#cb304-9" aria-hidden="true" tabindex="-1"></a>        seed <span class="op">=</span> x[px[<span class="dv">0</span>] : px[<span class="dv">1</span>]]</span>
<span id="cb304-10"><a href="#cb304-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> m <span class="kw">in</span> re.finditer(<span class="vs">rf"(?=(</span><span class="sc">{</span>seed<span class="sc">}</span><span class="vs">))"</span>, seq):</span>
<span id="cb304-11"><a href="#cb304-11" aria-hidden="true" tabindex="-1"></a>            ps <span class="op">=</span> (m.span()[<span class="dv">0</span>], m.span()[<span class="dv">0</span>] <span class="op">+</span> seed_size)</span>
<span id="cb304-12"><a href="#cb304-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> (px, ps)</span>
<span id="cb304-13"><a href="#cb304-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-14"><a href="#cb304-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_seed(args):</span>
<span id="cb304-15"><a href="#cb304-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> extend_fwd(i, j, score):</span>
<span id="cb304-16"><a href="#cb304-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i, j, score) <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb304-17"><a href="#cb304-17" aria-hidden="true" tabindex="-1"></a>            seen.update([(i, j, score)])</span>
<span id="cb304-18"><a href="#cb304-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score <span class="op">&lt;=</span> k:</span>
<span id="cb304-19"><a href="#cb304-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">==</span> <span class="bu">len</span>(x) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb304-20"><a href="#cb304-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> i, j, score</span>
<span id="cb304-21"><a href="#cb304-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(x):</span>
<span id="cb304-22"><a href="#cb304-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_fwd(i <span class="op">+</span> <span class="dv">1</span>, j, score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb304-23"><a href="#cb304-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(seq):</span>
<span id="cb304-24"><a href="#cb304-24" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_fwd(i, j <span class="op">+</span> <span class="dv">1</span>, score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb304-25"><a href="#cb304-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(x) <span class="kw">and</span> j <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(seq):</span>
<span id="cb304-26"><a href="#cb304-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_fwd(</span>
<span id="cb304-27"><a href="#cb304-27" aria-hidden="true" tabindex="-1"></a>                        i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">+</span> <span class="dv">1</span>, score <span class="op">+</span> <span class="bu">int</span>(x[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">!=</span> seq[j <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb304-28"><a href="#cb304-28" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb304-29"><a href="#cb304-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-30"><a href="#cb304-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> extend_rev(i, j, score):</span>
<span id="cb304-31"><a href="#cb304-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i, j, score) <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb304-32"><a href="#cb304-32" aria-hidden="true" tabindex="-1"></a>            seen.update([(i, j, score)])</span>
<span id="cb304-33"><a href="#cb304-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score <span class="op">&lt;=</span> k:</span>
<span id="cb304-34"><a href="#cb304-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb304-35"><a href="#cb304-35" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> i, j, score</span>
<span id="cb304-36"><a href="#cb304-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb304-37"><a href="#cb304-37" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_rev(i <span class="op">-</span> <span class="dv">1</span>, j, score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb304-38"><a href="#cb304-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb304-39"><a href="#cb304-39" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_rev(i, j <span class="op">-</span> <span class="dv">1</span>, score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb304-40"><a href="#cb304-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb304-41"><a href="#cb304-41" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">yield</span> <span class="cf">from</span> extend_rev(</span>
<span id="cb304-42"><a href="#cb304-42" aria-hidden="true" tabindex="-1"></a>                        i <span class="op">-</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span>, score <span class="op">+</span> <span class="bu">int</span>(x[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">!=</span> seq[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb304-43"><a href="#cb304-43" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb304-44"><a href="#cb304-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-45"><a href="#cb304-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"."</span>, end<span class="op">=</span><span class="st">""</span>, <span class="bu">file</span><span class="op">=</span>sys.stderr)</span>
<span id="cb304-46"><a href="#cb304-46" aria-hidden="true" tabindex="-1"></a>    sys.stderr.flush()</span>
<span id="cb304-47"><a href="#cb304-47" aria-hidden="true" tabindex="-1"></a>    sys.setrecursionlimit(<span class="dv">10000</span>)</span>
<span id="cb304-48"><a href="#cb304-48" aria-hidden="true" tabindex="-1"></a>    seed, k, x, seq <span class="op">=</span> args</span>
<span id="cb304-49"><a href="#cb304-49" aria-hidden="true" tabindex="-1"></a>    xcoord, seqcoord <span class="op">=</span> seed</span>
<span id="cb304-50"><a href="#cb304-50" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb304-51"><a href="#cb304-51" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb304-52"><a href="#cb304-52" aria-hidden="true" tabindex="-1"></a>    fwds <span class="op">=</span> <span class="bu">list</span>(extend_fwd(xcoord[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>, seqcoord[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb304-53"><a href="#cb304-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> fwds:</span>
<span id="cb304-54"><a href="#cb304-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">set</span>()</span>
<span id="cb304-55"><a href="#cb304-55" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb304-56"><a href="#cb304-56" aria-hidden="true" tabindex="-1"></a>    revs <span class="op">=</span> <span class="bu">list</span>(extend_rev(xcoord[<span class="dv">0</span>], seqcoord[<span class="dv">0</span>], <span class="dv">0</span>))</span>
<span id="cb304-57"><a href="#cb304-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> revs:</span>
<span id="cb304-58"><a href="#cb304-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">set</span>()</span>
<span id="cb304-59"><a href="#cb304-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i0, j0, s0 <span class="kw">in</span> revs:</span>
<span id="cb304-60"><a href="#cb304-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i1, j1, s1 <span class="kw">in</span> fwds:</span>
<span id="cb304-61"><a href="#cb304-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s0 <span class="op">+</span> s1 <span class="op">&lt;=</span> k:</span>
<span id="cb304-62"><a href="#cb304-62" aria-hidden="true" tabindex="-1"></a>                res.add((j0 <span class="op">+</span> <span class="dv">1</span>, j1 <span class="op">-</span> j0 <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb304-63"><a href="#cb304-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res</span>
<span id="cb304-64"><a href="#cb304-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-65"><a href="#cb304-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb304-66"><a href="#cb304-66" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb304-67"><a href="#cb304-67" aria-hidden="true" tabindex="-1"></a><span class="st">1</span></span>
<span id="cb304-68"><a href="#cb304-68" aria-hidden="true" tabindex="-1"></a><span class="st">ACGTAG</span></span>
<span id="cb304-69"><a href="#cb304-69" aria-hidden="true" tabindex="-1"></a><span class="st">GGACGATAGGTAAAGTAGTAGCGACGTAGG</span></span>
<span id="cb304-70"><a href="#cb304-70" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb304-71"><a href="#cb304-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-72"><a href="#cb304-72" aria-hidden="true" tabindex="-1"></a>k, x, seq <span class="op">=</span> sample_input.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb304-73"><a href="#cb304-73" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="bu">int</span>(k)</span>
<span id="cb304-74"><a href="#cb304-74" aria-hidden="true" tabindex="-1"></a>seeds <span class="op">=</span> <span class="bu">list</span>(get_seeds(x, seq, k))</span>
<span id="cb304-75"><a href="#cb304-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"found </span><span class="sc">{</span><span class="bu">len</span>(seeds)<span class="sc">}</span><span class="ss"> seeds"</span>, <span class="bu">file</span><span class="op">=</span>sys.stderr)</span>
<span id="cb304-76"><a href="#cb304-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-77"><a href="#cb304-77" aria-hidden="true" tabindex="-1"></a>pool <span class="op">=</span> mp.Pool(mp.cpu_count())</span>
<span id="cb304-78"><a href="#cb304-78" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> ([seed, k, x, seq] <span class="cf">for</span> seed <span class="kw">in</span> seeds)</span>
<span id="cb304-79"><a href="#cb304-79" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> pool.<span class="bu">map</span>(process_seed, args)</span>
<span id="cb304-80"><a href="#cb304-80" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> <span class="bu">set</span>().union(<span class="op">*</span>res)</span>
<span id="cb304-81"><a href="#cb304-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-82"><a href="#cb304-82" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb304-83"><a href="#cb304-83" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> start, length <span class="kw">in</span> <span class="bu">sorted</span>(<span class="bu">list</span>(res)):</span>
<span id="cb304-84"><a href="#cb304-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>start<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>length<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>해당 문제는 계산량이 많아 파이썬을 사용하는 것이 적절하지 않습니다. 그래도 위 코드를 download dataset 에 적용해 실행한 결과 1 분 45 초 정도가 소요되어 통과할 수 있었습니다.(사용한 CPU: 13th Gen Intel i9-13900F (32) @ 5.3GHz)</p>
</div>
</div>
<p>This Python code is designed to find approximate matches of a short DNA sequence <code>x</code> within a longer DNA sequence <code>seq</code>. It does this by breaking down the problem into smaller “seed” sequences and then extending those seeds to find matches, even if there are a few mismatches allowed (controlled by the parameter <code>k</code>).</p>
</section>
<section id="overview-of-the-code" class="level2" data-number="100.4">
<h2 data-number="100.4" class="anchored" data-anchor-id="overview-of-the-code"><span class="header-section-number">100.4</span> Overview of the Code</h2>
<ol type="1">
<li><strong>Seeding</strong> (<code>get_seeds</code> function):
<ul>
<li>The <code>get_seeds</code> function divides the sequence <code>x</code> into smaller overlapping segments called “seeds.”</li>
<li>For each seed, it searches within the longer sequence <code>seq</code> to find exact matches of the seed.</li>
<li>It returns the positions in both <code>x</code> and <code>seq</code> where these seeds match.</li>
</ul></li>
<li><strong>Extending Seeds</strong> (<code>process_seed</code> function):
<ul>
<li>This function takes a seed and tries to extend it in both directions (forward and backward) to see if a longer match can be found between <code>x</code> and <code>seq</code>, even with up to <code>k</code> mismatches.</li>
<li>Two helper functions, <code>extend_fwd</code> and <code>extend_rev</code>, recursively extend the seed by comparing characters in <code>x</code> and <code>seq</code> while keeping track of mismatches.</li>
<li>The results are stored as starting positions and lengths of the matching segments.</li>
</ul></li>
<li><strong>Parallel Processing</strong>:
<ul>
<li>The script uses multiprocessing to speed up the search by running the seed extension proces in parallel acros multiple CPU cores.</li>
<li>Each seed is processed independently, and the results are combined.</li>
</ul></li>
<li><strong>Result Compilation</strong>:
<ul>
<li>The final matching segments are collected, and the unique results are sorted and printed as the start position and length of each matching segment in <code>seq</code>.</li>
</ul></li>
</ol>
<ul>
<li>The code searches for parts of a short DNA sequence (<code>x</code>) within a longer DNA sequence (<code>seq</code>), allowing for a small number of mismatches (<code>k</code>).</li>
<li>It does this by first finding small exact matches (seeds) and then extending these matches to find longer sequences with few mismatches.</li>
<li>The proces is parallelized to improve performance, especially when dealing with large DNA sequences.</li>
</ul>
</section>
</section>
<section id="overlap-alignment" class="level1" data-number="101">
<h1 data-number="101"><span class="header-section-number">101</span> Overlap Alignment</h1>
<p>An&nbsp;<a href="https://rosalind.info/glossary/overlap-alignment/">overlap alignment</a>&nbsp;between two strings&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;is a local alignment of a&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffix</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;with a&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefix</a>&nbsp;of&nbsp;<span class="math inline">\(t\)</span>. An optimal overlap alignment will therefore maximize an&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>&nbsp;over all such substrings of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>.</p>
<p>The term “overlap alignment” has also been used to describe what Rosalind defines as a&nbsp;<a href="https://rosalind.info/glossary/semiglobal-alignment/">semiglobal alignment</a>. See&nbsp;<a href="https://rosalind.info/problems/smgb/">“Semiglobal Alignment”</a>&nbsp;for details.</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>, each having length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;The score of an optimal overlap alignment of&nbsp;s and&nbsp;tt, followed by an alignment of a suffix&nbsp;<span class="math inline">\(s′\)</span>&nbsp;of&nbsp;s and a prefix&nbsp;<span class="math inline">\(t′\)</span>&nbsp;of&nbsp;t achieving this optimal score. Use an alignment score in which matching symbols count +1, substitutions count -2, and there is a&nbsp;<a href="https://rosalind.info/glossary/linear-gap-penalty/">linear gap penalty</a>&nbsp;of 2. If multiple optimal alignments exist, then you may return any one.</p>
<section id="sample-dataset-100" class="level2" data-number="101.1">
<h2 data-number="101.1" class="anchored" data-anchor-id="sample-dataset-100"><span class="header-section-number">101.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_54
CTAAGGGATTCCGGTAATTAGACAG
&gt;Rosalind_45
ATAGACCATATGTCAGTGACTGTGTAA</code></pre>
</section>
<section id="sample-output-101" class="level2" data-number="101.2">
<h2 data-number="101.2" class="anchored" data-anchor-id="sample-output-101"><span class="header-section-number">101.2</span> Sample Output</h2>
<pre><code>1
ATTAGAC-AG
AT-AGACCAT</code></pre>
</section>
<section id="solution-97" class="level2" data-number="101.3">
<h2 data-number="101.3" class="anchored" data-anchor-id="solution-97"><span class="header-section-number">101.3</span> Solution</h2>
<div class="sourceCode" id="cb307"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> oap(s1, s2, penalty<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> np.empty((<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">=</span> np.empty((<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb307-8"><a href="#cb307-8" aria-hidden="true" tabindex="-1"></a>        score[j][<span class="dv">0</span>] <span class="op">=</span> j <span class="op">*</span> penalty</span>
<span id="cb307-9"><a href="#cb307-9" aria-hidden="true" tabindex="-1"></a>        ptr[j][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb307-10"><a href="#cb307-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb307-11"><a href="#cb307-11" aria-hidden="true" tabindex="-1"></a>        score[<span class="dv">0</span>][i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb307-12"><a href="#cb307-12" aria-hidden="true" tabindex="-1"></a>        ptr[<span class="dv">0</span>][i] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb307-13"><a href="#cb307-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-14"><a href="#cb307-14" aria-hidden="true" tabindex="-1"></a>    score[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb307-15"><a href="#cb307-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s2)):</span>
<span id="cb307-16"><a href="#cb307-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1)):</span>
<span id="cb307-17"><a href="#cb307-17" aria-hidden="true" tabindex="-1"></a>            opt <span class="op">=</span> [</span>
<span id="cb307-18"><a href="#cb307-18" aria-hidden="true" tabindex="-1"></a>                score[j][i] <span class="op">+</span> (<span class="dv">1</span> <span class="cf">if</span> s1[i] <span class="op">==</span> s2[j] <span class="cf">else</span> penalty),</span>
<span id="cb307-19"><a href="#cb307-19" aria-hidden="true" tabindex="-1"></a>                score[j][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">+</span> penalty,</span>
<span id="cb307-20"><a href="#cb307-20" aria-hidden="true" tabindex="-1"></a>                score[j <span class="op">+</span> <span class="dv">1</span>][i] <span class="op">+</span> penalty,</span>
<span id="cb307-21"><a href="#cb307-21" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb307-22"><a href="#cb307-22" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> <span class="bu">max</span>(opt)</span>
<span id="cb307-23"><a href="#cb307-23" aria-hidden="true" tabindex="-1"></a>            score[j <span class="op">+</span> <span class="dv">1</span>][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> best</span>
<span id="cb307-24"><a href="#cb307-24" aria-hidden="true" tabindex="-1"></a>            ptr[j <span class="op">+</span> <span class="dv">1</span>][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> opt.index(best)</span>
<span id="cb307-25"><a href="#cb307-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-26"><a href="#cb307-26" aria-hidden="true" tabindex="-1"></a>    sc <span class="op">=</span> [score[j][<span class="bu">len</span>(s1)] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb307-27"><a href="#cb307-27" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> <span class="bu">max</span>(sc)</span>
<span id="cb307-28"><a href="#cb307-28" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> [j <span class="cf">for</span> j, s <span class="kw">in</span> <span class="bu">enumerate</span>(sc) <span class="cf">if</span> s <span class="op">==</span> max_score][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb307-29"><a href="#cb307-29" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="bu">len</span>(s1)</span>
<span id="cb307-30"><a href="#cb307-30" aria-hidden="true" tabindex="-1"></a>    a1, a2 <span class="op">=</span> <span class="st">""</span>, <span class="st">""</span></span>
<span id="cb307-31"><a href="#cb307-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb307-32"><a href="#cb307-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ptr[j][i] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb307-33"><a href="#cb307-33" aria-hidden="true" tabindex="-1"></a>            a1 <span class="op">+=</span> s1[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb307-34"><a href="#cb307-34" aria-hidden="true" tabindex="-1"></a>            a2 <span class="op">+=</span> s2[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb307-35"><a href="#cb307-35" aria-hidden="true" tabindex="-1"></a>            j, i <span class="op">=</span> j <span class="op">-</span> <span class="dv">1</span>, i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb307-36"><a href="#cb307-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> ptr[j][i] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb307-37"><a href="#cb307-37" aria-hidden="true" tabindex="-1"></a>            a1 <span class="op">+=</span> <span class="st">"-"</span></span>
<span id="cb307-38"><a href="#cb307-38" aria-hidden="true" tabindex="-1"></a>            a2 <span class="op">+=</span> s2[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb307-39"><a href="#cb307-39" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> j <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb307-40"><a href="#cb307-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> ptr[j][i] <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb307-41"><a href="#cb307-41" aria-hidden="true" tabindex="-1"></a>            a1 <span class="op">+=</span> s1[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb307-42"><a href="#cb307-42" aria-hidden="true" tabindex="-1"></a>            a2 <span class="op">+=</span> <span class="st">"-"</span></span>
<span id="cb307-43"><a href="#cb307-43" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb307-44"><a href="#cb307-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-45"><a href="#cb307-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score, a1[::<span class="op">-</span><span class="dv">1</span>], a2[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb307-46"><a href="#cb307-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-47"><a href="#cb307-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_fasta(fasta_string):</span>
<span id="cb307-48"><a href="#cb307-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb307-49"><a href="#cb307-49" aria-hidden="true" tabindex="-1"></a><span class="co">    Parses a FASTA formatted string and returns a list of sequences.</span></span>
<span id="cb307-50"><a href="#cb307-50" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb307-51"><a href="#cb307-51" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> []</span>
<span id="cb307-52"><a href="#cb307-52" aria-hidden="true" tabindex="-1"></a>    current_sequence <span class="op">=</span> []</span>
<span id="cb307-53"><a href="#cb307-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb307-54"><a href="#cb307-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb307-55"><a href="#cb307-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_sequence:</span>
<span id="cb307-56"><a href="#cb307-56" aria-hidden="true" tabindex="-1"></a>                sequences.append(<span class="st">''</span>.join(current_sequence))</span>
<span id="cb307-57"><a href="#cb307-57" aria-hidden="true" tabindex="-1"></a>                current_sequence <span class="op">=</span> []</span>
<span id="cb307-58"><a href="#cb307-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb307-59"><a href="#cb307-59" aria-hidden="true" tabindex="-1"></a>            current_sequence.append(line.strip())</span>
<span id="cb307-60"><a href="#cb307-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_sequence:</span>
<span id="cb307-61"><a href="#cb307-61" aria-hidden="true" tabindex="-1"></a>        sequences.append(<span class="st">''</span>.join(current_sequence))</span>
<span id="cb307-62"><a href="#cb307-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb307-63"><a href="#cb307-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-64"><a href="#cb307-64" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb307-65"><a href="#cb307-65" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_54</span></span>
<span id="cb307-66"><a href="#cb307-66" aria-hidden="true" tabindex="-1"></a><span class="st">CTAAGGGATTCCGGTAATTAGACAG</span></span>
<span id="cb307-67"><a href="#cb307-67" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_45</span></span>
<span id="cb307-68"><a href="#cb307-68" aria-hidden="true" tabindex="-1"></a><span class="st">ATAGACCATATGTCAGTGACTGTGTAA</span></span>
<span id="cb307-69"><a href="#cb307-69" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb307-70"><a href="#cb307-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-71"><a href="#cb307-71" aria-hidden="true" tabindex="-1"></a>s1, s2 <span class="op">=</span> read_fasta(sample_input)</span>
<span id="cb307-72"><a href="#cb307-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="op">*</span>oap(s1, s2, <span class="op">-</span><span class="dv">2</span>), sep<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code implements a semi-global sequence alignment algorithm, also known as overlap alignment. Here’s a brief explanation of how it works:</p>
<ol type="1">
<li>Initialization:
<ul>
<li>Creates two matrices: ‘score’ for alignment scores and ‘ptr’ for backtracking.</li>
<li>Initializes the first row and column of these matrices.</li>
</ul></li>
<li>Filling the matrices:
<ul>
<li>Iterates through both sequences, filling the ‘score’ and ‘ptr’ matrices.</li>
<li>For each cell, calculates three possible scores: match/mismatch, gap in s1, gap in s2.</li>
<li>Chooses the maximum score and stores it along with a pointer to its origin.</li>
</ul></li>
<li>Finding the best alignment:
<ul>
<li>Finds the maximum score in the last column of the ‘score’ matrix.</li>
<li>This allows for free end gaps in s2 (overlap alignment).</li>
</ul></li>
<li>Traceback:
<ul>
<li>Starts from the position of the maximum score.</li>
<li>Follows the pointers back to construct the aligned sequences.</li>
<li>Adds gaps (‘-’) where necessary.</li>
</ul></li>
<li>Result:
<ul>
<li>Returns the maximum alignment score and the two aligned sequences.</li>
</ul></li>
</ol>
<p>The ‘read_fasta’ function parses a FASTA-formatted string into sequences.</p>
<p>Finally, it applies this alignment algorithm to two sequences from the sample input and prints the results.</p>
<p>This algorithm is particularly useful for finding the best overlap between two sequences, allowing for free end gaps in one of the sequences.</p>
</section>
</section>
<section id="quartet-distance" class="level1" data-number="102">
<h1 data-number="102"><span class="header-section-number">102</span> Quartet Distance</h1>
<p>In&nbsp;<a href="https://rosalind.info/problems/cntq/">“Counting Quartets”</a>, we found an expression for&nbsp;<span class="math inline">\(q(T)\)</span>, the number of quartets that can be inferred from an&nbsp;<a href="https://rosalind.info/glossary/unrooted-binary-tree/">unrooted binary tree</a>&nbsp;containing&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa.</p>
<p>If&nbsp;<span class="math inline">\(T1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T2\)</span>&nbsp;are both unrooted binary trees on the same&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa, then we now let&nbsp;<span class="math inline">\(q(T1,T2)\)</span>&nbsp;denote the number of inferred quartets that are common to both trees. The&nbsp;<a href="https://rosalind.info/glossary/quartet-distance/">quartet distance</a>&nbsp;between&nbsp;<span class="math inline">\(T1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T2\)</span>,&nbsp;<span class="math inline">\(dq(T1,T2)\)</span>&nbsp;is the number of quartets that are only inferred from one of the trees. More precisely,&nbsp;<span class="math inline">\(dq(T1,T2)=q(T1)+q(T2)−2q(T1,T2)\)</span>.</p>
<p>Given:&nbsp;A list containing&nbsp;<span class="math inline">\(n\)</span>&nbsp;taxa (<span class="math inline">\(n≤2000\)</span>) and two unrooted binary trees&nbsp;<span class="math inline">\(T1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T2\)</span> on the given taxa. Both&nbsp;<span class="math inline">\(T1\)</span>&nbsp;and&nbsp;<span class="math inline">\(T2\)</span>&nbsp;are given in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>.</p>
<p>Return:&nbsp;The quartet distance&nbsp;<span class="math inline">\(dq(T1,T2)\)</span>.</p>
<section id="sample-dataset-101" class="level2" data-number="102.1">
<h2 data-number="102.1" class="anchored" data-anchor-id="sample-dataset-101"><span class="header-section-number">102.1</span> Sample Dataset</h2>
<pre><code>A B C D E
(A,C,((B,D),E));
(C,(B,D),(A,E));</code></pre>
</section>
<section id="sample-output-102" class="level2" data-number="102.2">
<h2 data-number="102.2" class="anchored" data-anchor-id="sample-output-102"><span class="header-section-number">102.2</span> Sample Output</h2>
<pre><code>4</code></pre>
</section>
<section id="solution-98" class="level2" data-number="102.3">
<h2 data-number="102.3" class="anchored" data-anchor-id="solution-98"><span class="header-section-number">102.3</span> Solution</h2>
<div class="sourceCode" id="cb310"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quartet_distance(taxa, t1, t2):</span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_newick(taxa, tree_str):</span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>        tree <span class="op">=</span> {}</span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>        parent <span class="op">=</span> {}</span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>        node_names <span class="op">=</span> {}</span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a>        new_node_id <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> new_node_id</span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a>        tree[root] <span class="op">=</span> []</span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>        current_node <span class="op">=</span> root</span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> match <span class="kw">in</span> re.finditer(<span class="vs">r"\(|\)|,|;|([^\(\),;]+)"</span>, tree_str):</span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a>            token <span class="op">=</span> match.group()</span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> token <span class="op">==</span> <span class="st">'('</span>:</span>
<span id="cb310-18"><a href="#cb310-18" aria-hidden="true" tabindex="-1"></a>                new_node_id <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb310-19"><a href="#cb310-19" aria-hidden="true" tabindex="-1"></a>                tree[current_node].append(new_node_id)</span>
<span id="cb310-20"><a href="#cb310-20" aria-hidden="true" tabindex="-1"></a>                parent[new_node_id] <span class="op">=</span> current_node</span>
<span id="cb310-21"><a href="#cb310-21" aria-hidden="true" tabindex="-1"></a>                current_node <span class="op">=</span> new_node_id</span>
<span id="cb310-22"><a href="#cb310-22" aria-hidden="true" tabindex="-1"></a>                tree[current_node] <span class="op">=</span> []</span>
<span id="cb310-23"><a href="#cb310-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token <span class="op">==</span> <span class="st">','</span>:</span>
<span id="cb310-24"><a href="#cb310-24" aria-hidden="true" tabindex="-1"></a>                new_node_id <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb310-25"><a href="#cb310-25" aria-hidden="true" tabindex="-1"></a>                tree[parent[current_node]].append(new_node_id)</span>
<span id="cb310-26"><a href="#cb310-26" aria-hidden="true" tabindex="-1"></a>                parent[new_node_id] <span class="op">=</span> parent[current_node]</span>
<span id="cb310-27"><a href="#cb310-27" aria-hidden="true" tabindex="-1"></a>                current_node <span class="op">=</span> new_node_id</span>
<span id="cb310-28"><a href="#cb310-28" aria-hidden="true" tabindex="-1"></a>                tree[current_node] <span class="op">=</span> []</span>
<span id="cb310-29"><a href="#cb310-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token <span class="op">==</span> <span class="st">')'</span>:</span>
<span id="cb310-30"><a href="#cb310-30" aria-hidden="true" tabindex="-1"></a>                current_node <span class="op">=</span> parent[current_node]</span>
<span id="cb310-31"><a href="#cb310-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token <span class="op">==</span> <span class="st">';'</span>:</span>
<span id="cb310-32"><a href="#cb310-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb310-33"><a href="#cb310-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb310-34"><a href="#cb310-34" aria-hidden="true" tabindex="-1"></a>                node_names[current_node] <span class="op">=</span> token</span>
<span id="cb310-35"><a href="#cb310-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb310-36"><a href="#cb310-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tree, parent, node_names</span>
<span id="cb310-37"><a href="#cb310-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-38"><a href="#cb310-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_children(tree, parent, edge_id):</span>
<span id="cb310-39"><a href="#cb310-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> edge_id <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb310-40"><a href="#cb310-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> tree[edge_id]</span>
<span id="cb310-41"><a href="#cb310-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb310-42"><a href="#cb310-42" aria-hidden="true" tabindex="-1"></a>            parent_id <span class="op">=</span> parent[<span class="op">-</span>edge_id]</span>
<span id="cb310-43"><a href="#cb310-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> parent_id <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb310-44"><a href="#cb310-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> [e <span class="cf">for</span> e <span class="kw">in</span> tree[parent_id] <span class="cf">if</span> e <span class="op">!=</span> <span class="op">-</span>edge_id]</span>
<span id="cb310-45"><a href="#cb310-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb310-46"><a href="#cb310-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> [<span class="op">-</span>parent_id] <span class="op">+</span> [e <span class="cf">for</span> e <span class="kw">in</span> tree[parent_id] <span class="cf">if</span> e <span class="op">!=</span> <span class="op">-</span>edge_id]</span>
<span id="cb310-47"><a href="#cb310-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-48"><a href="#cb310-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_shared_leaves(i, j):</span>
<span id="cb310-49"><a href="#cb310-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> shared_leaves[i][j] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb310-50"><a href="#cb310-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> children1[i] <span class="kw">and</span> <span class="kw">not</span> children2[j]:  <span class="co"># Both are leaves</span></span>
<span id="cb310-51"><a href="#cb310-51" aria-hidden="true" tabindex="-1"></a>                shared_leaves[i][j] <span class="op">=</span> <span class="bu">int</span>(leaves1[i] <span class="op">==</span> leaves2[j])</span>
<span id="cb310-52"><a href="#cb310-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="kw">not</span> children1[i]:  <span class="co"># i is a leaf</span></span>
<span id="cb310-53"><a href="#cb310-53" aria-hidden="true" tabindex="-1"></a>                j1, j2 <span class="op">=</span> children2[j]</span>
<span id="cb310-54"><a href="#cb310-54" aria-hidden="true" tabindex="-1"></a>                shared_leaves[i][j] <span class="op">=</span> compute_shared_leaves(i, j1) <span class="op">+</span> compute_shared_leaves(i, j2)</span>
<span id="cb310-55"><a href="#cb310-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="kw">not</span> children2[j]:  <span class="co"># j is a leaf</span></span>
<span id="cb310-56"><a href="#cb310-56" aria-hidden="true" tabindex="-1"></a>                i1, i2 <span class="op">=</span> children1[i]</span>
<span id="cb310-57"><a href="#cb310-57" aria-hidden="true" tabindex="-1"></a>                shared_leaves[i][j] <span class="op">=</span> compute_shared_leaves(i1, j) <span class="op">+</span> compute_shared_leaves(i2, j)</span>
<span id="cb310-58"><a href="#cb310-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:  <span class="co"># Both are internal nodes</span></span>
<span id="cb310-59"><a href="#cb310-59" aria-hidden="true" tabindex="-1"></a>                i1, i2 <span class="op">=</span> children1[i]</span>
<span id="cb310-60"><a href="#cb310-60" aria-hidden="true" tabindex="-1"></a>                j1, j2 <span class="op">=</span> children2[j]</span>
<span id="cb310-61"><a href="#cb310-61" aria-hidden="true" tabindex="-1"></a>                shared_leaves[i][j] <span class="op">=</span> (</span>
<span id="cb310-62"><a href="#cb310-62" aria-hidden="true" tabindex="-1"></a>                    compute_shared_leaves(i1, j1) <span class="op">+</span> compute_shared_leaves(i1, j2) <span class="op">+</span></span>
<span id="cb310-63"><a href="#cb310-63" aria-hidden="true" tabindex="-1"></a>                    compute_shared_leaves(i2, j1) <span class="op">+</span> compute_shared_leaves(i2, j2)</span>
<span id="cb310-64"><a href="#cb310-64" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb310-65"><a href="#cb310-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> shared_leaves[i][j]</span>
<span id="cb310-66"><a href="#cb310-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-67"><a href="#cb310-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_quartet_distances():</span>
<span id="cb310-68"><a href="#cb310-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> all_edges1:</span>
<span id="cb310-69"><a href="#cb310-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> all_edges2:</span>
<span id="cb310-70"><a href="#cb310-70" aria-hidden="true" tabindex="-1"></a>                compute_shared_leaves(i, j)</span>
<span id="cb310-71"><a href="#cb310-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-72"><a href="#cb310-72" aria-hidden="true" tabindex="-1"></a>        total_distance <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb310-73"><a href="#cb310-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c1 <span class="kw">in</span> internal_edges1:</span>
<span id="cb310-74"><a href="#cb310-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c2 <span class="kw">in</span> internal_edges2:</span>
<span id="cb310-75"><a href="#cb310-75" aria-hidden="true" tabindex="-1"></a>                a1, b1 <span class="op">=</span> children1[<span class="op">-</span>c1]</span>
<span id="cb310-76"><a href="#cb310-76" aria-hidden="true" tabindex="-1"></a>                a2, b2 <span class="op">=</span> children2[<span class="op">-</span>c2]</span>
<span id="cb310-77"><a href="#cb310-77" aria-hidden="true" tabindex="-1"></a>                quartet_value <span class="op">=</span> (</span>
<span id="cb310-78"><a href="#cb310-78" aria-hidden="true" tabindex="-1"></a>                    shared_leaves[a1][a2] <span class="op">*</span> shared_leaves[b1][b2] <span class="op">+</span></span>
<span id="cb310-79"><a href="#cb310-79" aria-hidden="true" tabindex="-1"></a>                    shared_leaves[a1][b2] <span class="op">*</span> shared_leaves[b1][a2]</span>
<span id="cb310-80"><a href="#cb310-80" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb310-81"><a href="#cb310-81" aria-hidden="true" tabindex="-1"></a>                total_distance <span class="op">+=</span> quartet_value <span class="op">*</span> (shared_leaves[c1][c2] <span class="op">*</span> (shared_leaves[c1][c2] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb310-82"><a href="#cb310-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-83"><a href="#cb310-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total_distance</span>
<span id="cb310-84"><a href="#cb310-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-85"><a href="#cb310-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse Newick trees</span></span>
<span id="cb310-86"><a href="#cb310-86" aria-hidden="true" tabindex="-1"></a>    tree1, parent1, leaves1 <span class="op">=</span> parse_newick(taxa, t1)</span>
<span id="cb310-87"><a href="#cb310-87" aria-hidden="true" tabindex="-1"></a>    tree2, parent2, leaves2 <span class="op">=</span> parse_newick(taxa, t2)</span>
<span id="cb310-88"><a href="#cb310-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-89"><a href="#cb310-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Number of taxa</span></span>
<span id="cb310-90"><a href="#cb310-90" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(taxa)</span>
<span id="cb310-91"><a href="#cb310-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-92"><a href="#cb310-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get children of each edge</span></span>
<span id="cb310-93"><a href="#cb310-93" aria-hidden="true" tabindex="-1"></a>    children1 <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">5</span>)</span>
<span id="cb310-94"><a href="#cb310-94" aria-hidden="true" tabindex="-1"></a>    children2 <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">5</span>)</span>
<span id="cb310-95"><a href="#cb310-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-96"><a href="#cb310-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">2</span>):</span>
<span id="cb310-97"><a href="#cb310-97" aria-hidden="true" tabindex="-1"></a>        children1[i] <span class="op">=</span> get_children(tree1, parent1, i)</span>
<span id="cb310-98"><a href="#cb310-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> n, <span class="dv">0</span>):</span>
<span id="cb310-99"><a href="#cb310-99" aria-hidden="true" tabindex="-1"></a>        children1[i] <span class="op">=</span> get_children(tree1, parent1, i)</span>
<span id="cb310-100"><a href="#cb310-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-101"><a href="#cb310-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">2</span>):</span>
<span id="cb310-102"><a href="#cb310-102" aria-hidden="true" tabindex="-1"></a>        children2[j] <span class="op">=</span> get_children(tree2, parent2, j)</span>
<span id="cb310-103"><a href="#cb310-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> n, <span class="dv">0</span>):</span>
<span id="cb310-104"><a href="#cb310-104" aria-hidden="true" tabindex="-1"></a>        children2[j] <span class="op">=</span> get_children(tree2, parent2, j)</span>
<span id="cb310-105"><a href="#cb310-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-106"><a href="#cb310-106" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize shared leaves matrix</span></span>
<span id="cb310-107"><a href="#cb310-107" aria-hidden="true" tabindex="-1"></a>    shared_leaves <span class="op">=</span> [[<span class="va">None</span>] <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">5</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">5</span>)]</span>
<span id="cb310-108"><a href="#cb310-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-109"><a href="#cb310-109" aria-hidden="true" tabindex="-1"></a>    <span class="co"># List of all edges and internal edges</span></span>
<span id="cb310-110"><a href="#cb310-110" aria-hidden="true" tabindex="-1"></a>    all_edges1 <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">2</span>)) <span class="op">+</span> [edge <span class="cf">for</span> edge <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> n, <span class="dv">0</span>) <span class="cf">if</span> leaves1.get(<span class="op">-</span>edge) <span class="kw">is</span> <span class="va">None</span>]</span>
<span id="cb310-111"><a href="#cb310-111" aria-hidden="true" tabindex="-1"></a>    all_edges2 <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">2</span>)) <span class="op">+</span> [edge <span class="cf">for</span> edge <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> n, <span class="dv">0</span>) <span class="cf">if</span> leaves2.get(<span class="op">-</span>edge) <span class="kw">is</span> <span class="va">None</span>]</span>
<span id="cb310-112"><a href="#cb310-112" aria-hidden="true" tabindex="-1"></a>    internal_edges1 <span class="op">=</span> [edge <span class="cf">for</span> edge <span class="kw">in</span> all_edges1 <span class="cf">if</span> leaves1.get(edge) <span class="kw">is</span> <span class="va">None</span>]</span>
<span id="cb310-113"><a href="#cb310-113" aria-hidden="true" tabindex="-1"></a>    internal_edges2 <span class="op">=</span> [edge <span class="cf">for</span> edge <span class="kw">in</span> all_edges2 <span class="cf">if</span> leaves2.get(edge) <span class="kw">is</span> <span class="va">None</span>]</span>
<span id="cb310-114"><a href="#cb310-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-115"><a href="#cb310-115" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate quartet distances</span></span>
<span id="cb310-116"><a href="#cb310-116" aria-hidden="true" tabindex="-1"></a>    total_quartets <span class="op">=</span> calculate_quartet_distances()</span>
<span id="cb310-117"><a href="#cb310-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-118"><a href="#cb310-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate and return the quartet distance</span></span>
<span id="cb310-119"><a href="#cb310-119" aria-hidden="true" tabindex="-1"></a>    max_possible_quartets <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> math.comb(n, <span class="dv">4</span>)</span>
<span id="cb310-120"><a href="#cb310-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_possible_quartets <span class="op">-</span> total_quartets</span>
<span id="cb310-121"><a href="#cb310-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-122"><a href="#cb310-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-123"><a href="#cb310-123" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample input</span></span>
<span id="cb310-124"><a href="#cb310-124" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb310-125"><a href="#cb310-125" aria-hidden="true" tabindex="-1"></a><span class="st">A B C D E</span></span>
<span id="cb310-126"><a href="#cb310-126" aria-hidden="true" tabindex="-1"></a><span class="st">(A,C,((B,D),E));</span></span>
<span id="cb310-127"><a href="#cb310-127" aria-hidden="true" tabindex="-1"></a><span class="st">(C,(B,D),(A,E));</span></span>
<span id="cb310-128"><a href="#cb310-128" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb310-129"><a href="#cb310-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-130"><a href="#cb310-130" aria-hidden="true" tabindex="-1"></a>taxa <span class="op">=</span> sample_input[<span class="dv">0</span>].split()</span>
<span id="cb310-131"><a href="#cb310-131" aria-hidden="true" tabindex="-1"></a>nwck1 <span class="op">=</span> sample_input[<span class="dv">1</span>]</span>
<span id="cb310-132"><a href="#cb310-132" aria-hidden="true" tabindex="-1"></a>nwck2 <span class="op">=</span> sample_input[<span class="dv">2</span>]</span>
<span id="cb310-133"><a href="#cb310-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-134"><a href="#cb310-134" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(quartet_distance(taxa, nwck1, nwck2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation-of-how-it-works" class="level2" data-number="102.4">
<h2 data-number="102.4" class="anchored" data-anchor-id="explanation-of-how-it-works"><span class="header-section-number">102.4</span> Explanation of How It Works</h2>
<ol type="1">
<li><strong>Newick Parsing (<code>parse_newick</code>)</strong>:
<ul>
<li>The function <code>parse_newick</code> parses a Newick-formatted tree string and constructs a representation of the tree using a dictionary <code>tree</code>, which maps node IDs to their children. It also maintains a <code>parent</code> dictionary to track parent-child relationships and a <code>name</code> dictionary to map node IDs to taxa names.</li>
<li>This parsed tree allows us to later traverse and compare the structures of the two trees.</li>
</ul></li>
<li><strong>Children Function (<code>get_children</code>)</strong>:
<ul>
<li>The <code>get_children</code> function retrieves the children of a given edge in the tree. If the edge is positive, it directly retrieves children from the tree structure. If the edge is negative, it handles the reversed direction by excluding the edge itself from the parent’s list.</li>
</ul></li>
<li><strong>Shared Leaves Calculation (<code>compute_shared_leaves</code>)</strong>:
<ul>
<li>The <code>compute_shared_leaves</code> function computes the number of shared leaves between two subtrees (one from each tree) by recursively exploring their child nodes. It caches results to avoid redundant calculations, significantly optimizing performance.</li>
</ul></li>
<li><strong>Quartet Calculation (<code>calculate_quartet_distances</code>)</strong>:
<ul>
<li>The <code>calculate_quartet_distances</code> function iterates over all pairs of internal edges from the two trees and calculates the quartet distances. A quartet distance measures the difference in tree structure by comparing the shared leaves for each quartet configuration.</li>
<li>This function sums up these quartet values, representing the differences between the two trees.</li>
</ul></li>
<li><strong>Quartet Distance Calculation</strong>:
<ul>
<li>Finally, the <code>quartet_distance</code> function subtracts the calculated quartet differences from the total possible quartets for the number of taxa (given by <code>math.comb(n, 4)</code>). This provides the quartet distance, a measure of how dissimilar the two trees are in terms of their quartets.</li>
</ul></li>
</ol>
</section>
</section>
<section id="semiglobal-alignment" class="level1" data-number="103">
<h1 data-number="103"><span class="header-section-number">103</span> Semiglobal Alignment</h1>
<p>A&nbsp;<a href="https://rosalind.info/glossary/semiglobal-alignment/">semiglobal alignment</a>&nbsp;of strings&nbsp;s and&nbsp;t is an alignment in which any&nbsp;<a href="https://rosalind.info/glossary/gap/">gaps</a>&nbsp;appearing as&nbsp;<a href="https://rosalind.info/glossary/prefix/">prefixes</a>&nbsp;or&nbsp;<a href="https://rosalind.info/glossary/suffix/">suffixes</a>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;do not contribute to the&nbsp;<a href="https://rosalind.info/glossary/alignment-score/">alignment score</a>.</p>
<p>Semiglobal alignment has sometimes also been called “overlap alignment”. Rosalind defines&nbsp;<a href="https://rosalind.info/glossary/overlap-alignment/">overlap alignment</a>&nbsp;differently (see&nbsp;<a href="https://rosalind.info/problems/oap/">“Overlap Alignment”</a>).</p>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;s and&nbsp;t in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>, each having length at most 10&nbsp;<a href="https://rosalind.info/glossary/kbp/">kbp</a>.</p>
<p>Return:&nbsp;The maximum semiglobal alignment score of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, followed by an alignment of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;achieving this maximum score. Use an alignment score in which matching symbols count +1, substitutions count -1, and there is a&nbsp;<a href="https://rosalind.info/glossary/linear-gap-penalty/">linear gap penalty</a>&nbsp;of 1. If multiple optimal alignments exist, then you may return any one.</p>
<section id="sample-dataset-102" class="level2" data-number="103.1">
<h2 data-number="103.1" class="anchored" data-anchor-id="sample-dataset-102"><span class="header-section-number">103.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_79
CAGCACTTGGATTCTCGG
&gt;Rosalind_98
CAGCGTGG</code></pre>
</section>
<section id="sample-output-103" class="level2" data-number="103.2">
<h2 data-number="103.2" class="anchored" data-anchor-id="sample-output-103"><span class="header-section-number">103.2</span> Sample Output</h2>
<pre><code>4
CAGCA-CTTGGATTCTCGG
---CAGCGTGG--------</code></pre>
</section>
<section id="solution-99" class="level2" data-number="103.3">
<h2 data-number="103.3" class="anchored" data-anchor-id="solution-99"><span class="header-section-number">103.3</span> Solution</h2>
<div class="sourceCode" id="cb313"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> semiglobal_alignment(seq1, seq2):</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a>    seq1 <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> seq1</span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>    seq2 <span class="op">=</span> <span class="st">"-"</span> <span class="op">+</span> seq2</span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>    score_matrix <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2))] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1))]</span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a>    direction_matrix <span class="op">=</span> [[<span class="va">None</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2))] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1))]</span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq1)):</span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(seq2)):</span>
<span id="cb313-10"><a href="#cb313-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-11"><a href="#cb313-11" aria-hidden="true" tabindex="-1"></a>            match_score <span class="op">=</span> score_matrix[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> (<span class="dv">1</span> <span class="cf">if</span> seq1[i] <span class="op">==</span> seq2[j] <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb313-12"><a href="#cb313-12" aria-hidden="true" tabindex="-1"></a>            delete_score <span class="op">=</span> score_matrix[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb313-13"><a href="#cb313-13" aria-hidden="true" tabindex="-1"></a>            insert_score <span class="op">=</span> score_matrix[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb313-14"><a href="#cb313-14" aria-hidden="true" tabindex="-1"></a>            score_matrix[i][j] <span class="op">=</span> <span class="bu">max</span>(match_score, delete_score, insert_score)</span>
<span id="cb313-15"><a href="#cb313-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score_matrix[i][j] <span class="op">==</span> match_score:</span>
<span id="cb313-16"><a href="#cb313-16" aria-hidden="true" tabindex="-1"></a>                direction_matrix[i][j] <span class="op">=</span> <span class="st">"diagonal"</span></span>
<span id="cb313-17"><a href="#cb313-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> score_matrix[i][j] <span class="op">==</span> delete_score:</span>
<span id="cb313-18"><a href="#cb313-18" aria-hidden="true" tabindex="-1"></a>                direction_matrix[i][j] <span class="op">=</span> <span class="st">"up"</span></span>
<span id="cb313-19"><a href="#cb313-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb313-20"><a href="#cb313-20" aria-hidden="true" tabindex="-1"></a>                direction_matrix[i][j] <span class="op">=</span> <span class="st">"left"</span></span>
<span id="cb313-21"><a href="#cb313-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-22"><a href="#cb313-22" aria-hidden="true" tabindex="-1"></a>    last_row_max <span class="op">=</span> <span class="bu">max</span>(<span class="bu">range</span>(<span class="bu">len</span>(seq2)), key<span class="op">=</span><span class="kw">lambda</span> x: score_matrix[<span class="bu">len</span>(seq1) <span class="op">-</span> <span class="dv">1</span>][x])</span>
<span id="cb313-23"><a href="#cb313-23" aria-hidden="true" tabindex="-1"></a>    last_col_max <span class="op">=</span> <span class="bu">max</span>(<span class="bu">range</span>(<span class="bu">len</span>(seq1)), key<span class="op">=</span><span class="kw">lambda</span> x: score_matrix[x][<span class="bu">len</span>(seq2) <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb313-24"><a href="#cb313-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> score_matrix[<span class="bu">len</span>(seq1) <span class="op">-</span> <span class="dv">1</span>][last_row_max] <span class="op">&gt;=</span> score_matrix[last_col_max][<span class="bu">len</span>(seq2) <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb313-25"><a href="#cb313-25" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="bu">len</span>(seq1) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb313-26"><a href="#cb313-26" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> last_row_max</span>
<span id="cb313-27"><a href="#cb313-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb313-28"><a href="#cb313-28" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> last_col_max</span>
<span id="cb313-29"><a href="#cb313-29" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> <span class="bu">len</span>(seq2) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb313-30"><a href="#cb313-30" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> score_matrix[i][j]</span>
<span id="cb313-31"><a href="#cb313-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-32"><a href="#cb313-32" aria-hidden="true" tabindex="-1"></a>    insert_gap <span class="op">=</span> <span class="kw">lambda</span> word, i: word[:i] <span class="op">+</span> <span class="st">'-'</span> <span class="op">+</span> word[i:]</span>
<span id="cb313-33"><a href="#cb313-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-34"><a href="#cb313-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the aligned sequences as the input sequences.</span></span>
<span id="cb313-35"><a href="#cb313-35" aria-hidden="true" tabindex="-1"></a>    aligned_seq1, aligned_seq2 <span class="op">=</span> seq1[<span class="dv">1</span>:], seq2[<span class="dv">1</span>:]</span>
<span id="cb313-36"><a href="#cb313-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-37"><a href="#cb313-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq1) <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i):</span>
<span id="cb313-38"><a href="#cb313-38" aria-hidden="true" tabindex="-1"></a>        aligned_seq2 <span class="op">+=</span> <span class="st">'-'</span></span>
<span id="cb313-39"><a href="#cb313-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(seq2) <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> j):</span>
<span id="cb313-40"><a href="#cb313-40" aria-hidden="true" tabindex="-1"></a>        aligned_seq1 <span class="op">+=</span> <span class="st">'-'</span></span>
<span id="cb313-41"><a href="#cb313-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-42"><a href="#cb313-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">*</span> j <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb313-43"><a href="#cb313-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> direction_matrix[i][j] <span class="op">==</span> <span class="st">"up"</span>:</span>
<span id="cb313-44"><a href="#cb313-44" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb313-45"><a href="#cb313-45" aria-hidden="true" tabindex="-1"></a>            aligned_seq2 <span class="op">=</span> insert_gap(aligned_seq2, j)</span>
<span id="cb313-46"><a href="#cb313-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> direction_matrix[i][j] <span class="op">==</span> <span class="st">"left"</span>:</span>
<span id="cb313-47"><a href="#cb313-47" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb313-48"><a href="#cb313-48" aria-hidden="true" tabindex="-1"></a>            aligned_seq1 <span class="op">=</span> insert_gap(aligned_seq1, i)</span>
<span id="cb313-49"><a href="#cb313-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb313-50"><a href="#cb313-50" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb313-51"><a href="#cb313-51" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb313-52"><a href="#cb313-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-53"><a href="#cb313-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb313-54"><a href="#cb313-54" aria-hidden="true" tabindex="-1"></a>        aligned_seq2 <span class="op">=</span> insert_gap(aligned_seq2, <span class="dv">0</span>)</span>
<span id="cb313-55"><a href="#cb313-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(j):</span>
<span id="cb313-56"><a href="#cb313-56" aria-hidden="true" tabindex="-1"></a>        aligned_seq1 <span class="op">=</span> insert_gap(aligned_seq1, <span class="dv">0</span>)</span>
<span id="cb313-57"><a href="#cb313-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-58"><a href="#cb313-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score, aligned_seq1, aligned_seq2</span>
<span id="cb313-59"><a href="#cb313-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-60"><a href="#cb313-60" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_string):</span>
<span id="cb313-61"><a href="#cb313-61" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb313-62"><a href="#cb313-62" aria-hidden="true" tabindex="-1"></a>    current_label <span class="op">=</span> <span class="va">None</span></span>
<span id="cb313-63"><a href="#cb313-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> fasta_string.strip().split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb313-64"><a href="#cb313-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">'&gt;'</span>):</span>
<span id="cb313-65"><a href="#cb313-65" aria-hidden="true" tabindex="-1"></a>            current_label <span class="op">=</span> line[<span class="dv">1</span>:].strip()</span>
<span id="cb313-66"><a href="#cb313-66" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">=</span> <span class="st">''</span></span>
<span id="cb313-67"><a href="#cb313-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb313-68"><a href="#cb313-68" aria-hidden="true" tabindex="-1"></a>            sequences[current_label] <span class="op">+=</span> line.strip()</span>
<span id="cb313-69"><a href="#cb313-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(sequences.values())</span>
<span id="cb313-70"><a href="#cb313-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-71"><a href="#cb313-71" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb313-72"><a href="#cb313-72" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_79</span></span>
<span id="cb313-73"><a href="#cb313-73" aria-hidden="true" tabindex="-1"></a><span class="st">CAGCACTTGGATTCTCGG</span></span>
<span id="cb313-74"><a href="#cb313-74" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_98</span></span>
<span id="cb313-75"><a href="#cb313-75" aria-hidden="true" tabindex="-1"></a><span class="st">CAGCGTGG</span></span>
<span id="cb313-76"><a href="#cb313-76" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb313-77"><a href="#cb313-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-78"><a href="#cb313-78" aria-hidden="true" tabindex="-1"></a>sequence_A, sequence_B <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb313-79"><a href="#cb313-79" aria-hidden="true" tabindex="-1"></a>final_score, aligned_sequence_A, aligned_sequence_B <span class="op">=</span> semiglobal_alignment(sequence_A, sequence_B)</span>
<span id="cb313-80"><a href="#cb313-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-81"><a href="#cb313-81" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_score)</span>
<span id="cb313-82"><a href="#cb313-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_sequence_A)</span>
<span id="cb313-83"><a href="#cb313-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_sequence_B)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><p>The <code>semiglobal_alignment</code> function implements a semi-global alignment algorithm for two sequences:</p>
<ul>
<li>It adds a gap character “-” at the beginning of both sequences.</li>
<li>It creates two matrices: <code>score_matrix</code> for alignment scores and <code>direction_matrix</code> for backtracking.</li>
</ul></li>
<li><p>The function then fills these matrices:</p>
<ul>
<li>It calculates scores for matches (1), mismatches (-1), and gaps (-1).</li>
<li>It chooses the maximum score among match, deletion, and insertion for each cell.</li>
<li>It records the direction (diagonal, up, or left) in the <code>direction_matrix</code>.</li>
</ul></li>
<li><p>After filling the matrices, it finds the best alignment end point:</p>
<ul>
<li>It checks the maximum score in the last row and last column.</li>
<li>It chooses the higher of these two as the ending point of the alignment.</li>
</ul></li>
<li><p>The function then performs a traceback to construct the aligned sequences:</p>
<ul>
<li>It starts from the best end point and follows the directions in <code>direction_matrix</code>.</li>
<li>It adds gaps to the sequences as needed during the traceback.</li>
</ul></li>
<li><p>Finally, it returns the maximum score and the two aligned sequences.</p></li>
<li><p>The <code>parse_fasta</code> function reads a FASTA-formatted string:</p>
<ul>
<li>It separates the sequences and their labels.</li>
<li>It returns a list of sequences without the labels.</li>
</ul></li>
<li><p>The main part of the code:</p>
<ul>
<li>Defines a sample input in FASTA format.</li>
<li>Parses the input using <code>parse_fasta</code>.</li>
<li>Calls <code>semiglobal_alignment</code> with the parsed sequences.</li>
<li>Prints the final score and the aligned sequences.</li>
</ul></li>
</ol>
</section>
</section>
<section id="local-alignment-with-affine-gap-penalty" class="level1" data-number="104">
<h1 data-number="104"><span class="header-section-number">104</span> Local Alignment with Affine Gap Penalty</h1>
<p>Given:&nbsp;Two&nbsp;<a href="https://rosalind.info/glossary/protein-string/">protein strings</a>&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;(each having length at most 10,000&nbsp;<a href="https://rosalind.info/glossary/amino-acid/">aa</a>).</p>
<p>Return:&nbsp;The maximum local alignment score of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, followed by substrings&nbsp;<span class="math inline">\(r\)</span>&nbsp;and&nbsp;<span class="math inline">\(u\)</span>&nbsp;of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>, respectively, that correspond to the optimal local alignment of&nbsp;<span class="math inline">\(s\)</span>&nbsp;and&nbsp;<span class="math inline">\(t\)</span>. Use:</p>
<ul>
<li>The&nbsp;<a href="https://rosalind.info/glossary/blosum62/">BLOSUM62</a>&nbsp;<a href="https://rosalind.info/glossary/scoring-matrix/">scoring matrix</a>.</li>
<li><a href="https://rosalind.info/glossary/affine-gap-penalty/">Gap opening penalty</a>&nbsp;equal to 11.</li>
<li><a href="https://rosalind.info/glossary/affine-gap-penalty/">Gap extension penalty</a>&nbsp;equal to 1.</li>
</ul>
<p>If multiple solutions exist, then you may output any one.</p>
<section id="sample-dataset-103" class="level2" data-number="104.1">
<h2 data-number="104.1" class="anchored" data-anchor-id="sample-dataset-103"><span class="header-section-number">104.1</span> Sample Dataset</h2>
<pre><code>&gt;Rosalind_8
PLEASANTLY
&gt;Rosalind_18
MEANLY</code></pre>
</section>
<section id="sample-output-104" class="level2" data-number="104.2">
<h2 data-number="104.2" class="anchored" data-anchor-id="sample-output-104"><span class="header-section-number">104.2</span> Sample Output</h2>
<pre><code>12
LEAS
MEAN</code></pre>
</section>
<section id="solution-100" class="level2" data-number="104.3">
<h2 data-number="104.3" class="anchored" data-anchor-id="solution-100"><span class="header-section-number">104.3</span> Solution</h2>
<div class="sourceCode" id="cb316"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a>BLOSUM62 <span class="op">=</span> {</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'F'</span>): <span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'T'</span>): <span class="dv">0</span>,</span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Q'</span>, <span class="st">'Q'</span>): <span class="dv">5</span>, (<span class="st">'N'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Q'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'D'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'H'</span>): <span class="dv">8</span>, (<span class="st">'S'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'H'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'B'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'Y'</span>): <span class="dv">7</span>,</span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'E'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'Z'</span>): <span class="dv">4</span>,</span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'C'</span>, <span class="st">'C'</span>): <span class="dv">9</span>, (<span class="st">'M'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'P'</span>, <span class="st">'P'</span>): <span class="dv">7</span>, (<span class="st">'V'</span>, <span class="st">'I'</span>): <span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-11"><a href="#cb316-11" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'M'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-12"><a href="#cb316-12" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'K'</span>): <span class="dv">5</span>, (<span class="st">'P'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'I'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-13"><a href="#cb316-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-14"><a href="#cb316-14" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'F'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-15"><a href="#cb316-15" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-16"><a href="#cb316-16" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'X'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'K'</span>): <span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-17"><a href="#cb316-17" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'D'</span>, <span class="st">'N'</span>): <span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'K'</span>): <span class="dv">0</span>,</span>
<span id="cb316-18"><a href="#cb316-18" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'X'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'I'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'T'</span>): <span class="dv">0</span>,</span>
<span id="cb316-19"><a href="#cb316-19" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'M'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-20"><a href="#cb316-20" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'S'</span>): <span class="dv">4</span>, (<span class="st">'L'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Q'</span>, <span class="st">'R'</span>): <span class="dv">1</span>,</span>
<span id="cb316-21"><a href="#cb316-21" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'N'</span>, <span class="st">'N'</span>): <span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-22"><a href="#cb316-22" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'S'</span>, <span class="st">'G'</span>): <span class="dv">0</span>, (<span class="st">'L'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-23"><a href="#cb316-23" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'K'</span>): <span class="dv">0</span>, (<span class="st">'Q'</span>, <span class="st">'N'</span>): <span class="dv">0</span>,</span>
<span id="cb316-24"><a href="#cb316-24" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'N'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Y'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-25"><a href="#cb316-25" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'F'</span>): <span class="dv">3</span>, (<span class="st">'C'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'V'</span>, <span class="st">'L'</span>): <span class="dv">1</span>, (<span class="st">'G'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-26"><a href="#cb316-26" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'K'</span>, <span class="st">'R'</span>): <span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'D'</span>): <span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-27"><a href="#cb316-27" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'M'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'C'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-28"><a href="#cb316-28" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'T'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-29"><a href="#cb316-29" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'K'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-30"><a href="#cb316-30" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-31"><a href="#cb316-31" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'V'</span>): <span class="dv">4</span>, (<span class="st">'M'</span>, <span class="st">'I'</span>): <span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb316-32"><a href="#cb316-32" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'M'</span>): <span class="dv">5</span>, (<span class="st">'K'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-33"><a href="#cb316-33" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'D'</span>): <span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Q'</span>, <span class="st">'D'</span>): <span class="dv">0</span>,</span>
<span id="cb316-34"><a href="#cb316-34" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'H'</span>): <span class="dv">0</span>,</span>
<span id="cb316-35"><a href="#cb316-35" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'B'</span>, <span class="st">'H'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'F'</span>): <span class="dv">6</span>, (<span class="st">'X'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-36"><a href="#cb316-36" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'D'</span>): <span class="dv">4</span>, (<span class="st">'D'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'S'</span>): <span class="dv">0</span>,</span>
<span id="cb316-37"><a href="#cb316-37" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'W'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'V'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-38"><a href="#cb316-38" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'W'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'H'</span>, <span class="st">'N'</span>): <span class="dv">1</span>,</span>
<span id="cb316-39"><a href="#cb316-39" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'T'</span>, <span class="st">'T'</span>): <span class="dv">5</span>, (<span class="st">'S'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb316-40"><a href="#cb316-40" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'B'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'L'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'N'</span>): <span class="dv">1</span>,</span>
<span id="cb316-41"><a href="#cb316-41" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'L'</span>): <span class="dv">4</span>, (<span class="st">'Y'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'Q'</span>): <span class="dv">2</span>,</span>
<span id="cb316-42"><a href="#cb316-42" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'S'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-43"><a href="#cb316-43" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'W'</span>): <span class="dv">2</span>, (<span class="st">'E'</span>, <span class="st">'E'</span>): <span class="dv">5</span>,</span>
<span id="cb316-44"><a href="#cb316-44" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'C'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-45"><a href="#cb316-45" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'V'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'V'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-46"><a href="#cb316-46" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'Q'</span>): <span class="dv">1</span>, (<span class="st">'R'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-47"><a href="#cb316-47" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'P'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'I'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'K'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'M'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-48"><a href="#cb316-48" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'W'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'W'</span>, <span class="st">'W'</span>): <span class="dv">11</span>, (<span class="st">'M'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-49"><a href="#cb316-49" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'L'</span>): <span class="dv">2</span>, (<span class="st">'K'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'E'</span>): <span class="dv">4</span>,</span>
<span id="cb316-50"><a href="#cb316-50" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-51"><a href="#cb316-51" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'B'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-52"><a href="#cb316-52" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'Q'</span>): <span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'Z'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-53"><a href="#cb316-53" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'E'</span>): <span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'V'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'F'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'B'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-54"><a href="#cb316-54" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'X'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'D'</span>, <span class="st">'D'</span>): <span class="dv">6</span>, (<span class="st">'W'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Z'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-55"><a href="#cb316-55" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'S'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>, (<span class="st">'W'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'W'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'H'</span>, <span class="st">'Q'</span>): <span class="dv">0</span>,</span>
<span id="cb316-56"><a href="#cb316-56" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'W'</span>, <span class="st">'N'</span>): <span class="op">-</span><span class="dv">4</span>, (<span class="st">'S'</span>, <span class="st">'A'</span>): <span class="dv">1</span>, (<span class="st">'L'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">4</span>,</span>
<span id="cb316-57"><a href="#cb316-57" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'W'</span>, <span class="st">'S'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'S'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'H'</span>, <span class="st">'E'</span>): <span class="dv">0</span>, (<span class="st">'S'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">2</span>,</span>
<span id="cb316-58"><a href="#cb316-58" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'H'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'S'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'L'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Y'</span>, <span class="st">'H'</span>): <span class="dv">2</span>,</span>
<span id="cb316-59"><a href="#cb316-59" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Y'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'G'</span>, <span class="st">'G'</span>): <span class="dv">6</span>,</span>
<span id="cb316-60"><a href="#cb316-60" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'G'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'E'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'Y'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'Y'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-61"><a href="#cb316-61" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'A'</span>, <span class="st">'A'</span>): <span class="dv">4</span>, (<span class="st">'P'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'T'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-62"><a href="#cb316-62" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'V'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'T'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'I'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'Z'</span>, <span class="st">'T'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-63"><a href="#cb316-63" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'C'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'V'</span>, <span class="st">'P'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'P'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'C'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-64"><a href="#cb316-64" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'K'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'I'</span>, <span class="st">'I'</span>): <span class="dv">4</span>, (<span class="st">'P'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'M'</span>, <span class="st">'G'</span>): <span class="op">-</span><span class="dv">3</span>,</span>
<span id="cb316-65"><a href="#cb316-65" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'T'</span>, <span class="st">'S'</span>): <span class="dv">1</span>, (<span class="st">'I'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'P'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">2</span>, (<span class="st">'M'</span>, <span class="st">'K'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-66"><a href="#cb316-66" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'I'</span>, <span class="st">'A'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'P'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'R'</span>, <span class="st">'R'</span>): <span class="dv">5</span>, (<span class="st">'X'</span>, <span class="st">'M'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-67"><a href="#cb316-67" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'L'</span>, <span class="st">'I'</span>): <span class="dv">2</span>, (<span class="st">'X'</span>, <span class="st">'I'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'B'</span>): <span class="dv">1</span>, (<span class="st">'X'</span>, <span class="st">'E'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-68"><a href="#cb316-68" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'Z'</span>, <span class="st">'N'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'A'</span>): <span class="dv">0</span>, (<span class="st">'B'</span>, <span class="st">'R'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'N'</span>): <span class="dv">3</span>,</span>
<span id="cb316-69"><a href="#cb316-69" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'F'</span>, <span class="st">'D'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'X'</span>, <span class="st">'Y'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'Z'</span>, <span class="st">'R'</span>): <span class="dv">0</span>, (<span class="st">'F'</span>, <span class="st">'H'</span>): <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb316-70"><a href="#cb316-70" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'B'</span>, <span class="st">'F'</span>): <span class="op">-</span><span class="dv">3</span>, (<span class="st">'F'</span>, <span class="st">'L'</span>): <span class="dv">0</span>, (<span class="st">'X'</span>, <span class="st">'Q'</span>): <span class="op">-</span><span class="dv">1</span>, (<span class="st">'B'</span>, <span class="st">'B'</span>): <span class="dv">4</span></span>
<span id="cb316-71"><a href="#cb316-71" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb316-72"><a href="#cb316-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-73"><a href="#cb316-73" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> local_alignment_with_affine_gap(str1, str2, gap_open<span class="op">=</span><span class="dv">11</span>, gap_extend<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb316-74"><a href="#cb316-74" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(str1), <span class="bu">len</span>(str2)</span>
<span id="cb316-75"><a href="#cb316-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-76"><a href="#cb316-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize score matrices</span></span>
<span id="cb316-77"><a href="#cb316-77" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb316-78"><a href="#cb316-78" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [[<span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb316-79"><a href="#cb316-79" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> [[<span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb316-80"><a href="#cb316-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-81"><a href="#cb316-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize backtrack matrices</span></span>
<span id="cb316-82"><a href="#cb316-82" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb316-83"><a href="#cb316-83" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-84"><a href="#cb316-84" aria-hidden="true" tabindex="-1"></a>    max_score, max_i, max_j <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb316-85"><a href="#cb316-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-86"><a href="#cb316-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill matrices</span></span>
<span id="cb316-87"><a href="#cb316-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb316-88"><a href="#cb316-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb316-89"><a href="#cb316-89" aria-hidden="true" tabindex="-1"></a>            X[i][j] <span class="op">=</span> <span class="bu">max</span>(X[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> gap_extend, M[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> gap_open <span class="op">-</span> gap_extend)</span>
<span id="cb316-90"><a href="#cb316-90" aria-hidden="true" tabindex="-1"></a>            Y[i][j] <span class="op">=</span> <span class="bu">max</span>(Y[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">-</span> gap_extend, M[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">-</span> gap_open <span class="op">-</span> gap_extend)</span>
<span id="cb316-91"><a href="#cb316-91" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb316-92"><a href="#cb316-92" aria-hidden="true" tabindex="-1"></a>            key <span class="op">=</span> (str1[i<span class="op">-</span><span class="dv">1</span>], str2[j<span class="op">-</span><span class="dv">1</span>]) <span class="cf">if</span> (str1[i<span class="op">-</span><span class="dv">1</span>], str2[j<span class="op">-</span><span class="dv">1</span>]) <span class="kw">in</span> BLOSUM62 <span class="cf">else</span> (str2[j<span class="op">-</span><span class="dv">1</span>], str1[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb316-93"><a href="#cb316-93" aria-hidden="true" tabindex="-1"></a>            match_score <span class="op">=</span> BLOSUM62[key]</span>
<span id="cb316-94"><a href="#cb316-94" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb316-95"><a href="#cb316-95" aria-hidden="true" tabindex="-1"></a>            M[i][j] <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, M[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> match_score, X[i][j], Y[i][j])</span>
<span id="cb316-96"><a href="#cb316-96" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb316-97"><a href="#cb316-97" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> M[i][j] <span class="op">&gt;</span> max_score:</span>
<span id="cb316-98"><a href="#cb316-98" aria-hidden="true" tabindex="-1"></a>                max_score, max_i, max_j <span class="op">=</span> M[i][j], i, j</span>
<span id="cb316-99"><a href="#cb316-99" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb316-100"><a href="#cb316-100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> M[i][j] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb316-101"><a href="#cb316-101" aria-hidden="true" tabindex="-1"></a>                B[i][j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb316-102"><a href="#cb316-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> M[i][j] <span class="op">==</span> M[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> match_score:</span>
<span id="cb316-103"><a href="#cb316-103" aria-hidden="true" tabindex="-1"></a>                B[i][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb316-104"><a href="#cb316-104" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> M[i][j] <span class="op">==</span> X[i][j]:</span>
<span id="cb316-105"><a href="#cb316-105" aria-hidden="true" tabindex="-1"></a>                B[i][j] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb316-106"><a href="#cb316-106" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb316-107"><a href="#cb316-107" aria-hidden="true" tabindex="-1"></a>                B[i][j] <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb316-108"><a href="#cb316-108" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-109"><a href="#cb316-109" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack</span></span>
<span id="cb316-110"><a href="#cb316-110" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> max_i, max_j</span>
<span id="cb316-111"><a href="#cb316-111" aria-hidden="true" tabindex="-1"></a>    aligned_1, aligned_2 <span class="op">=</span> [], []</span>
<span id="cb316-112"><a href="#cb316-112" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-113"><a href="#cb316-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> B[i][j] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb316-114"><a href="#cb316-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> B[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb316-115"><a href="#cb316-115" aria-hidden="true" tabindex="-1"></a>            aligned_1.append(str1[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb316-116"><a href="#cb316-116" aria-hidden="true" tabindex="-1"></a>            aligned_2.append(str2[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb316-117"><a href="#cb316-117" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb316-118"><a href="#cb316-118" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb316-119"><a href="#cb316-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> B[i][j] <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb316-120"><a href="#cb316-120" aria-hidden="true" tabindex="-1"></a>            aligned_1.append(<span class="st">'-'</span>)</span>
<span id="cb316-121"><a href="#cb316-121" aria-hidden="true" tabindex="-1"></a>            aligned_2.append(str2[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb316-122"><a href="#cb316-122" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb316-123"><a href="#cb316-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb316-124"><a href="#cb316-124" aria-hidden="true" tabindex="-1"></a>            aligned_1.append(str1[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb316-125"><a href="#cb316-125" aria-hidden="true" tabindex="-1"></a>            aligned_2.append(<span class="st">'-'</span>)</span>
<span id="cb316-126"><a href="#cb316-126" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb316-127"><a href="#cb316-127" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb316-128"><a href="#cb316-128" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score, <span class="st">''</span>.join(<span class="bu">reversed</span>(aligned_1)), <span class="st">''</span>.join(<span class="bu">reversed</span>(aligned_2))</span>
<span id="cb316-129"><a href="#cb316-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-130"><a href="#cb316-130" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(fasta_str):</span>
<span id="cb316-131"><a href="#cb316-131" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb316-132"><a href="#cb316-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> record <span class="kw">in</span> fasta_str.strip().split(<span class="st">'&gt;'</span>)[<span class="dv">1</span>:]:</span>
<span id="cb316-133"><a href="#cb316-133" aria-hidden="true" tabindex="-1"></a>        lines <span class="op">=</span> record.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>)</span>
<span id="cb316-134"><a href="#cb316-134" aria-hidden="true" tabindex="-1"></a>        sequences[lines[<span class="dv">0</span>]] <span class="op">=</span> <span class="st">''</span>.join(lines[<span class="dv">1</span>:])</span>
<span id="cb316-135"><a href="#cb316-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(sequences.values())</span>
<span id="cb316-136"><a href="#cb316-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-137"><a href="#cb316-137" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb316-138"><a href="#cb316-138" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_8</span></span>
<span id="cb316-139"><a href="#cb316-139" aria-hidden="true" tabindex="-1"></a><span class="st">PLEASANTLY</span></span>
<span id="cb316-140"><a href="#cb316-140" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;Rosalind_18</span></span>
<span id="cb316-141"><a href="#cb316-141" aria-hidden="true" tabindex="-1"></a><span class="st">MEANLY</span></span>
<span id="cb316-142"><a href="#cb316-142" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb316-143"><a href="#cb316-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-144"><a href="#cb316-144" aria-hidden="true" tabindex="-1"></a>stringA, stringB <span class="op">=</span> parse_fasta(sample_input)</span>
<span id="cb316-145"><a href="#cb316-145" aria-hidden="true" tabindex="-1"></a>score, aligned_strA, aligned_strB <span class="op">=</span> local_alignment_with_affine_gap(stringA, stringB)</span>
<span id="cb316-146"><a href="#cb316-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-147"><a href="#cb316-147" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(score)</span>
<span id="cb316-148"><a href="#cb316-148" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_strA.replace(<span class="st">"-"</span>, <span class="st">""</span>))</span>
<span id="cb316-149"><a href="#cb316-149" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(aligned_strB.replace(<span class="st">"-"</span>, <span class="st">""</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><strong>BLOSUM62 Matrix:</strong>
<ul>
<li><code>BLOSUM62</code> is a dictionary containing scores for amino acid substitutions based on the BLOSUM62 matrix. It provides a scoring scheme for amino acid matches and mismatches.</li>
</ul></li>
<li><strong><code>local_alignment_with_affine_gap</code> Function:</strong>
<ul>
<li><strong>Inputs:</strong> <code>str1</code> and <code>str2</code> (the sequences to align), <code>gap_open</code> and <code>gap_extend</code> (penalties for opening and extending gaps).</li>
<li><strong>Initialization:</strong>
<ul>
<li><code>M</code>, <code>X</code>, and <code>Y</code> are matrices used to store scores for alignments and gaps.</li>
<li><code>B</code> is a backtracking matrix to reconstruct the optimal alignment.</li>
</ul></li>
<li><strong>Matrix Filling:</strong>
<ul>
<li>Iterates over each position in the matrices, computing scores based on the BLOSUM62 matrix and gap penalties.</li>
<li>Updates the matrices to reflect the best alignment score at each position.</li>
</ul></li>
<li><strong>Backtracking:</strong>
<ul>
<li>Constructs the optimal local alignment by following the backtracking matrix.</li>
</ul></li>
</ul></li>
<li><strong><code>parse_fasta</code> Function:</strong>
<ul>
<li><strong>Input:</strong> A string in FASTA format containing sequences.</li>
<li><strong>Output:</strong> A list of sequences parsed from the FASTA format.</li>
</ul></li>
<li><strong>Example Usage:</strong>
<ul>
<li><strong><code>sample_input</code>:</strong> A FASTA formatted string with two example sequences.</li>
<li><strong>Execution:</strong>
<ul>
<li>Parses the FASTA string into sequences.</li>
<li>Performs local alignment on these sequences.</li>
<li>Prints the alignment score and the aligned sequences (with gaps removed).</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="identifying-reversing-substitutions" class="level1" data-number="105">
<h1 data-number="105"><span class="header-section-number">105</span> Identifying Reversing Substitutions</h1>
<p>For a&nbsp;<a href="https://rosalind.info/glossary/rooted-tree/">rooted tree</a>&nbsp;<span class="math inline">\(T\)</span>&nbsp;whose internal nodes are labeled with&nbsp;<a href="https://rosalind.info/glossary/genetic-string/">genetic strings</a>, our goal is to identify reversing substitutions in&nbsp;<span class="math inline">\(T\)</span>. Assuming that all the strings of&nbsp;<span class="math inline">\(T\)</span>&nbsp;have the same length, a reversing substitution is defined formally as two&nbsp;<a href="https://rosalind.info/glossary/parent/">parent</a>-<a href="https://rosalind.info/glossary/child/">child</a>&nbsp;string pairs&nbsp;<span class="math inline">\((s,t)\)</span>&nbsp;and&nbsp;<span class="math inline">\((v,w)\)</span>&nbsp;along with a position index&nbsp;<span class="math inline">\(i\)</span>, where:</p>
<ul>
<li>there is a path in&nbsp;<span class="math inline">\(T\)</span>&nbsp;from&nbsp;<span class="math inline">\(s\)</span>&nbsp;down to&nbsp;<span class="math inline">\(w\)</span>;</li>
<li><span class="math inline">\(s[i]=w[i]≠v[i]=t[i\)</span>]; and</li>
<li>if&nbsp;<span class="math inline">\(u\)</span> is on the path connecting&nbsp;<span class="math inline">\(t\)</span>&nbsp;to&nbsp;<span class="math inline">\(v\)</span>, then&nbsp;<span class="math inline">\(t[i]=u[i]\)</span>.</li>
</ul>
<p>In other words, the third condition demands that a reversing substitution must be contiguous: no other substitutions can appear between the initial and reversing substitution.</p>
<p>Given:&nbsp;A&nbsp;<a href="https://rosalind.info/glossary/rooted-binary-tree/">rooted binary tree</a>&nbsp;<span class="math inline">\(T\)</span>&nbsp;with labeled nodes in&nbsp;<a href="https://rosalind.info/glossary/newick-format/">Newick format</a>, followed by a collection of at most 100&nbsp;<a href="https://rosalind.info/glossary/dna-string/">DNA strings</a>&nbsp;in&nbsp;<a href="https://rosalind.info/glossary/fasta-format/">FASTA format</a>&nbsp;whose labels correspond to the labels of&nbsp;<span class="math inline">\(T\)</span>. We will assume that the DNA strings have the same length, which does not exceed 400&nbsp;<a href="https://rosalind.info/glossary/base-pair/">bp</a>).</p>
<p>Return:&nbsp;A list of all reversing substitutions in&nbsp;<span class="math inline">\(T\)</span> (in any order), with each substitution encoded by the following three items:</p>
<ul>
<li>the name of the species in which the symbol is first changed, followed by the name of the species in which it changes back to its original state</li>
<li>the&nbsp;<a href="https://rosalind.info/glossary/position/">position</a>&nbsp;in the string at which the reversing substitution occurs; and</li>
<li>the reversing substitution in the form original_symbol-&gt;substituted_symbol-&gt;reverted_symbol.</li>
</ul>
<section id="sample-dataset-104" class="level2" data-number="105.1">
<h2 data-number="105.1" class="anchored" data-anchor-id="sample-dataset-104"><span class="header-section-number">105.1</span> Sample Dataset</h2>
<pre><code>(((ostrich,cat)rat,mouse)dog,elephant)robot;
&gt;robot
AATTG
&gt;dog
GGGCA
&gt;mouse
AAGAC
&gt;rat
GTTGT
&gt;cat
GAGGC
&gt;ostrich
GTGTC
&gt;elephant
AATTC</code></pre>
</section>
<section id="sample-output-105" class="level2" data-number="105.2">
<h2 data-number="105.2" class="anchored" data-anchor-id="sample-output-105"><span class="header-section-number">105.2</span> Sample Output</h2>
<pre><code>dog mouse 1 A-&gt;G-&gt;A
dog mouse 2 A-&gt;G-&gt;A
rat ostrich 3 G-&gt;T-&gt;G
rat cat 3 G-&gt;T-&gt;G
dog rat 3 T-&gt;G-&gt;T</code></pre>
</section>
<section id="solution-101" class="level2" data-number="105.3">
<h2 data-number="105.3" class="anchored" data-anchor-id="solution-101"><span class="header-section-number">105.3</span> Solution</h2>
<div class="sourceCode" id="cb319"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a>clas Node:</span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, number, parent, name<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.number <span class="op">=</span> number</span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name <span class="kw">or</span> <span class="ss">f"Node_</span><span class="sc">{</span>number<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">(</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>name<span class="sc">}</span><span class="ss">)"</span> <span class="cf">if</span> <span class="va">self</span>.name <span class="op">!=</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">"</span> <span class="cf">else</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb319-10"><a href="#cb319-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-11"><a href="#cb319-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_child(<span class="va">self</span>, child):</span>
<span id="cb319-12"><a href="#cb319-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children.append(child)</span>
<span id="cb319-13"><a href="#cb319-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-14"><a href="#cb319-14" aria-hidden="true" tabindex="-1"></a>clas Newick:</span>
<span id="cb319-15"><a href="#cb319-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb319-16"><a href="#cb319-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> []</span>
<span id="cb319-17"><a href="#cb319-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> []</span>
<span id="cb319-18"><a href="#cb319-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.construct_tree(data)</span>
<span id="cb319-19"><a href="#cb319-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name_index <span class="op">=</span> {node.name: node.number <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes}</span>
<span id="cb319-20"><a href="#cb319-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.inv_name_index <span class="op">=</span> {node.number: node.name <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes}</span>
<span id="cb319-21"><a href="#cb319-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-22"><a href="#cb319-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> construct_tree(<span class="va">self</span>, data):</span>
<span id="cb319-23"><a href="#cb319-23" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> data.replace(<span class="st">','</span>, <span class="st">' '</span>).replace(<span class="st">'('</span>, <span class="st">'( '</span>).replace(<span class="st">')'</span>, <span class="st">' )'</span>).strip(<span class="st">';'</span>).split()</span>
<span id="cb319-24"><a href="#cb319-24" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> [Node(<span class="op">-</span><span class="dv">1</span>, <span class="va">None</span>)]</span>
<span id="cb319-25"><a href="#cb319-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> token <span class="kw">in</span> tokens:</span>
<span id="cb319-26"><a href="#cb319-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> token <span class="op">==</span> <span class="st">'('</span>:</span>
<span id="cb319-27"><a href="#cb319-27" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), stack[<span class="op">-</span><span class="dv">1</span>].number)</span>
<span id="cb319-28"><a href="#cb319-28" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(new_node)</span>
<span id="cb319-29"><a href="#cb319-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.nodes) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb319-30"><a href="#cb319-30" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.nodes[new_node.parent].add_child(new_node.number)</span>
<span id="cb319-31"><a href="#cb319-31" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.edges.append((new_node.parent, new_node.number))</span>
<span id="cb319-32"><a href="#cb319-32" aria-hidden="true" tabindex="-1"></a>                stack.append(new_node)</span>
<span id="cb319-33"><a href="#cb319-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token <span class="op">==</span> <span class="st">')'</span>:</span>
<span id="cb319-34"><a href="#cb319-34" aria-hidden="true" tabindex="-1"></a>                stack.pop()</span>
<span id="cb319-35"><a href="#cb319-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token.startswith(<span class="st">')'</span>):</span>
<span id="cb319-36"><a href="#cb319-36" aria-hidden="true" tabindex="-1"></a>                stack[<span class="op">-</span><span class="dv">1</span>].name <span class="op">=</span> token[<span class="dv">1</span>:]</span>
<span id="cb319-37"><a href="#cb319-37" aria-hidden="true" tabindex="-1"></a>                stack.pop()</span>
<span id="cb319-38"><a href="#cb319-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb319-39"><a href="#cb319-39" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), stack[<span class="op">-</span><span class="dv">1</span>].number, token)</span>
<span id="cb319-40"><a href="#cb319-40" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(new_node)</span>
<span id="cb319-41"><a href="#cb319-41" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[new_node.parent].add_child(new_node.number)</span>
<span id="cb319-42"><a href="#cb319-42" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges.append((new_node.parent, new_node.number))</span>
<span id="cb319-43"><a href="#cb319-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-44"><a href="#cb319-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> traverse(<span class="va">self</span>, node_index<span class="op">=</span><span class="dv">0</span>, order<span class="op">=</span><span class="st">'pre'</span>):</span>
<span id="cb319-45"><a href="#cb319-45" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.nodes[node_index]</span>
<span id="cb319-46"><a href="#cb319-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> order <span class="op">==</span> <span class="st">'pre'</span>:</span>
<span id="cb319-47"><a href="#cb319-47" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> [node]</span>
<span id="cb319-48"><a href="#cb319-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb319-49"><a href="#cb319-49" aria-hidden="true" tabindex="-1"></a>                result.extend(<span class="va">self</span>.traverse(child, order))</span>
<span id="cb319-50"><a href="#cb319-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># post-order</span></span>
<span id="cb319-51"><a href="#cb319-51" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> []</span>
<span id="cb319-52"><a href="#cb319-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb319-53"><a href="#cb319-53" aria-hidden="true" tabindex="-1"></a>                result.extend(<span class="va">self</span>.traverse(child, order))</span>
<span id="cb319-54"><a href="#cb319-54" aria-hidden="true" tabindex="-1"></a>            result.append(node)</span>
<span id="cb319-55"><a href="#cb319-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb319-56"><a href="#cb319-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-57"><a href="#cb319-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> max_depth(<span class="va">self</span>, node):</span>
<span id="cb319-58"><a href="#cb319-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>([<span class="va">self</span>.max_depth(<span class="va">self</span>.nodes[child]) <span class="cf">for</span> child <span class="kw">in</span> node.children], default<span class="op">=-</span><span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb319-59"><a href="#cb319-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-60"><a href="#cb319-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> all_paths(<span class="va">self</span>, node):</span>
<span id="cb319-61"><a href="#cb319-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node.children:</span>
<span id="cb319-62"><a href="#cb319-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb319-63"><a href="#cb319-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-64"><a href="#cb319-64" aria-hidden="true" tabindex="-1"></a>        paths <span class="op">=</span> []</span>
<span id="cb319-65"><a href="#cb319-65" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> [(node, [node.name])]</span>
<span id="cb319-66"><a href="#cb319-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> stack:</span>
<span id="cb319-67"><a href="#cb319-67" aria-hidden="true" tabindex="-1"></a>            current, path <span class="op">=</span> stack.pop()</span>
<span id="cb319-68"><a href="#cb319-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child_idx <span class="kw">in</span> current.children:</span>
<span id="cb319-69"><a href="#cb319-69" aria-hidden="true" tabindex="-1"></a>                child <span class="op">=</span> <span class="va">self</span>.nodes[child_idx]</span>
<span id="cb319-70"><a href="#cb319-70" aria-hidden="true" tabindex="-1"></a>                new_path <span class="op">=</span> path <span class="op">+</span> [child.name]</span>
<span id="cb319-71"><a href="#cb319-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(new_path) <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb319-72"><a href="#cb319-72" aria-hidden="true" tabindex="-1"></a>                    paths.append(new_path)</span>
<span id="cb319-73"><a href="#cb319-73" aria-hidden="true" tabindex="-1"></a>                stack.append((child, new_path))</span>
<span id="cb319-74"><a href="#cb319-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> paths</span>
<span id="cb319-75"><a href="#cb319-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-76"><a href="#cb319-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rsub(<span class="va">self</span>, DNA_strings):</span>
<span id="cb319-77"><a href="#cb319-77" aria-hidden="true" tabindex="-1"></a>        rsub_list <span class="op">=</span> []</span>
<span id="cb319-78"><a href="#cb319-78" aria-hidden="true" tabindex="-1"></a>        pre_order <span class="op">=</span> <span class="va">self</span>.traverse(order<span class="op">=</span><span class="st">'pre'</span>)</span>
<span id="cb319-79"><a href="#cb319-79" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="bu">len</span>(<span class="bu">next</span>(<span class="bu">iter</span>(DNA_strings.values())))</span>
<span id="cb319-80"><a href="#cb319-80" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb319-81"><a href="#cb319-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb319-82"><a href="#cb319-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> node <span class="kw">in</span> pre_order:</span>
<span id="cb319-83"><a href="#cb319-83" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> node.children:</span>
<span id="cb319-84"><a href="#cb319-84" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> path <span class="kw">in</span> <span class="va">self</span>.all_paths(node):</span>
<span id="cb319-85"><a href="#cb319-85" aria-hidden="true" tabindex="-1"></a>                        nucs <span class="op">=</span> [DNA_strings[label][pos] <span class="cf">for</span> label <span class="kw">in</span> path]</span>
<span id="cb319-86"><a href="#cb319-86" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> nucs[<span class="dv">0</span>] <span class="op">==</span> nucs[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> nucs[<span class="dv">1</span>] <span class="kw">and</span> <span class="bu">all</span>(x <span class="op">==</span> nucs[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> nucs[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb319-87"><a href="#cb319-87" aria-hidden="true" tabindex="-1"></a>                            rsub_list.append([path[<span class="dv">1</span>], path[<span class="op">-</span><span class="dv">1</span>], <span class="bu">str</span>(pos <span class="op">+</span> <span class="dv">1</span>), <span class="st">"-&gt;"</span>.join([nucs[<span class="dv">0</span>], nucs[<span class="dv">1</span>], nucs[<span class="op">-</span><span class="dv">1</span>]])])</span>
<span id="cb319-88"><a href="#cb319-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rsub_list</span>
<span id="cb319-89"><a href="#cb319-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-90"><a href="#cb319-90" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(lines):</span>
<span id="cb319-91"><a href="#cb319-91" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb319-92"><a href="#cb319-92" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb319-93"><a href="#cb319-93" aria-hidden="true" tabindex="-1"></a>    current_name <span class="op">=</span> <span class="st">""</span></span>
<span id="cb319-94"><a href="#cb319-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb319-95"><a href="#cb319-95" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb319-96"><a href="#cb319-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb319-97"><a href="#cb319-97" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_name:</span>
<span id="cb319-98"><a href="#cb319-98" aria-hidden="true" tabindex="-1"></a>                sequences[current_name] <span class="op">=</span> <span class="st">""</span>.join(current_seq)</span>
<span id="cb319-99"><a href="#cb319-99" aria-hidden="true" tabindex="-1"></a>            current_name <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb319-100"><a href="#cb319-100" aria-hidden="true" tabindex="-1"></a>            current_seq <span class="op">=</span> []</span>
<span id="cb319-101"><a href="#cb319-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb319-102"><a href="#cb319-102" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line)</span>
<span id="cb319-103"><a href="#cb319-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_name:</span>
<span id="cb319-104"><a href="#cb319-104" aria-hidden="true" tabindex="-1"></a>        sequences[current_name] <span class="op">=</span> <span class="st">""</span>.join(current_seq)</span>
<span id="cb319-105"><a href="#cb319-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span>
<span id="cb319-106"><a href="#cb319-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-107"><a href="#cb319-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-108"><a href="#cb319-108" aria-hidden="true" tabindex="-1"></a>sample_input <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb319-109"><a href="#cb319-109" aria-hidden="true" tabindex="-1"></a><span class="st">(((ostrich,cat)rat,mouse)dog,elephant)robot;</span></span>
<span id="cb319-110"><a href="#cb319-110" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;robot</span></span>
<span id="cb319-111"><a href="#cb319-111" aria-hidden="true" tabindex="-1"></a><span class="st">AATTG</span></span>
<span id="cb319-112"><a href="#cb319-112" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;dog</span></span>
<span id="cb319-113"><a href="#cb319-113" aria-hidden="true" tabindex="-1"></a><span class="st">GGGCA</span></span>
<span id="cb319-114"><a href="#cb319-114" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;mouse</span></span>
<span id="cb319-115"><a href="#cb319-115" aria-hidden="true" tabindex="-1"></a><span class="st">AAGAC</span></span>
<span id="cb319-116"><a href="#cb319-116" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;rat</span></span>
<span id="cb319-117"><a href="#cb319-117" aria-hidden="true" tabindex="-1"></a><span class="st">GTTGT</span></span>
<span id="cb319-118"><a href="#cb319-118" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;cat</span></span>
<span id="cb319-119"><a href="#cb319-119" aria-hidden="true" tabindex="-1"></a><span class="st">GAGGC</span></span>
<span id="cb319-120"><a href="#cb319-120" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;ostrich</span></span>
<span id="cb319-121"><a href="#cb319-121" aria-hidden="true" tabindex="-1"></a><span class="st">GTGTC</span></span>
<span id="cb319-122"><a href="#cb319-122" aria-hidden="true" tabindex="-1"></a><span class="st">&gt;elephant</span></span>
<span id="cb319-123"><a href="#cb319-123" aria-hidden="true" tabindex="-1"></a><span class="st">AATTC</span></span>
<span id="cb319-124"><a href="#cb319-124" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>.strip().split(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb319-125"><a href="#cb319-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-126"><a href="#cb319-126" aria-hidden="true" tabindex="-1"></a>newick <span class="op">=</span> sample_input[<span class="dv">0</span>]</span>
<span id="cb319-127"><a href="#cb319-127" aria-hidden="true" tabindex="-1"></a>DNA_strings <span class="op">=</span> parse_fasta(sample_input[<span class="dv">1</span>:])</span>
<span id="cb319-128"><a href="#cb319-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-129"><a href="#cb319-129" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> Newick(newick)</span>
<span id="cb319-130"><a href="#cb319-130" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tree.rsub(DNA_strings)</span>
<span id="cb319-131"><a href="#cb319-131" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> r <span class="kw">in</span> result:</span>
<span id="cb319-132"><a href="#cb319-132" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" "</span>.join(r))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here’s a refactored version of the provided code with explanations:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a>clas Node:</span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, number, parent, name<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.number <span class="op">=</span> number</span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name <span class="kw">or</span> <span class="ss">f"Node_</span><span class="sc">{</span>number<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb320-9"><a href="#cb320-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">(</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>name<span class="sc">}</span><span class="ss">)"</span> <span class="cf">if</span> <span class="va">self</span>.name <span class="op">!=</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">"</span> <span class="cf">else</span> <span class="ss">f"Node_</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>number<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb320-10"><a href="#cb320-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-11"><a href="#cb320-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_child(<span class="va">self</span>, child):</span>
<span id="cb320-12"><a href="#cb320-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children.append(child)</span>
<span id="cb320-13"><a href="#cb320-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-14"><a href="#cb320-14" aria-hidden="true" tabindex="-1"></a>clas Newick:</span>
<span id="cb320-15"><a href="#cb320-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb320-16"><a href="#cb320-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> []</span>
<span id="cb320-17"><a href="#cb320-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> []</span>
<span id="cb320-18"><a href="#cb320-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.construct_tree(data)</span>
<span id="cb320-19"><a href="#cb320-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name_index <span class="op">=</span> {node.name: node.number <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes}</span>
<span id="cb320-20"><a href="#cb320-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.inv_name_index <span class="op">=</span> {node.number: node.name <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes}</span>
<span id="cb320-21"><a href="#cb320-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-22"><a href="#cb320-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> construct_tree(<span class="va">self</span>, data):</span>
<span id="cb320-23"><a href="#cb320-23" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> data.replace(<span class="st">','</span>, <span class="st">' '</span>).replace(<span class="st">'('</span>, <span class="st">'( '</span>).replace(<span class="st">')'</span>, <span class="st">' )'</span>).strip(<span class="st">';'</span>).split()</span>
<span id="cb320-24"><a href="#cb320-24" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> [Node(<span class="op">-</span><span class="dv">1</span>, <span class="va">None</span>)]</span>
<span id="cb320-25"><a href="#cb320-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> token <span class="kw">in</span> tokens:</span>
<span id="cb320-26"><a href="#cb320-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> token <span class="op">==</span> <span class="st">'('</span>:</span>
<span id="cb320-27"><a href="#cb320-27" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), stack[<span class="op">-</span><span class="dv">1</span>].number)</span>
<span id="cb320-28"><a href="#cb320-28" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(new_node)</span>
<span id="cb320-29"><a href="#cb320-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.nodes) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb320-30"><a href="#cb320-30" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.nodes[new_node.parent].add_child(new_node.number)</span>
<span id="cb320-31"><a href="#cb320-31" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.edges.append((new_node.parent, new_node.number))</span>
<span id="cb320-32"><a href="#cb320-32" aria-hidden="true" tabindex="-1"></a>                stack.append(new_node)</span>
<span id="cb320-33"><a href="#cb320-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token <span class="op">==</span> <span class="st">')'</span>:</span>
<span id="cb320-34"><a href="#cb320-34" aria-hidden="true" tabindex="-1"></a>                stack.pop()</span>
<span id="cb320-35"><a href="#cb320-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> token.startswith(<span class="st">')'</span>):</span>
<span id="cb320-36"><a href="#cb320-36" aria-hidden="true" tabindex="-1"></a>                stack[<span class="op">-</span><span class="dv">1</span>].name <span class="op">=</span> token[<span class="dv">1</span>:]</span>
<span id="cb320-37"><a href="#cb320-37" aria-hidden="true" tabindex="-1"></a>                stack.pop()</span>
<span id="cb320-38"><a href="#cb320-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb320-39"><a href="#cb320-39" aria-hidden="true" tabindex="-1"></a>                new_node <span class="op">=</span> Node(<span class="bu">len</span>(<span class="va">self</span>.nodes), stack[<span class="op">-</span><span class="dv">1</span>].number, token)</span>
<span id="cb320-40"><a href="#cb320-40" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes.append(new_node)</span>
<span id="cb320-41"><a href="#cb320-41" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[new_node.parent].add_child(new_node.number)</span>
<span id="cb320-42"><a href="#cb320-42" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.edges.append((new_node.parent, new_node.number))</span>
<span id="cb320-43"><a href="#cb320-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-44"><a href="#cb320-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> traverse(<span class="va">self</span>, node_index<span class="op">=</span><span class="dv">0</span>, order<span class="op">=</span><span class="st">'pre'</span>):</span>
<span id="cb320-45"><a href="#cb320-45" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.nodes[node_index]</span>
<span id="cb320-46"><a href="#cb320-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> order <span class="op">==</span> <span class="st">'pre'</span>:</span>
<span id="cb320-47"><a href="#cb320-47" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> [node]</span>
<span id="cb320-48"><a href="#cb320-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb320-49"><a href="#cb320-49" aria-hidden="true" tabindex="-1"></a>                result.extend(<span class="va">self</span>.traverse(child, order))</span>
<span id="cb320-50"><a href="#cb320-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># post-order</span></span>
<span id="cb320-51"><a href="#cb320-51" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> []</span>
<span id="cb320-52"><a href="#cb320-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb320-53"><a href="#cb320-53" aria-hidden="true" tabindex="-1"></a>                result.extend(<span class="va">self</span>.traverse(child, order))</span>
<span id="cb320-54"><a href="#cb320-54" aria-hidden="true" tabindex="-1"></a>            result.append(node)</span>
<span id="cb320-55"><a href="#cb320-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb320-56"><a href="#cb320-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-57"><a href="#cb320-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> max_depth(<span class="va">self</span>, node):</span>
<span id="cb320-58"><a href="#cb320-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>([<span class="va">self</span>.max_depth(<span class="va">self</span>.nodes[child]) <span class="cf">for</span> child <span class="kw">in</span> node.children], default<span class="op">=-</span><span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb320-59"><a href="#cb320-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-60"><a href="#cb320-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> all_paths(<span class="va">self</span>, node):</span>
<span id="cb320-61"><a href="#cb320-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node.children:</span>
<span id="cb320-62"><a href="#cb320-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb320-63"><a href="#cb320-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-64"><a href="#cb320-64" aria-hidden="true" tabindex="-1"></a>        paths <span class="op">=</span> []</span>
<span id="cb320-65"><a href="#cb320-65" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> [(node, [node.name])]</span>
<span id="cb320-66"><a href="#cb320-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> stack:</span>
<span id="cb320-67"><a href="#cb320-67" aria-hidden="true" tabindex="-1"></a>            current, path <span class="op">=</span> stack.pop()</span>
<span id="cb320-68"><a href="#cb320-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child_idx <span class="kw">in</span> current.children:</span>
<span id="cb320-69"><a href="#cb320-69" aria-hidden="true" tabindex="-1"></a>                child <span class="op">=</span> <span class="va">self</span>.nodes[child_idx]</span>
<span id="cb320-70"><a href="#cb320-70" aria-hidden="true" tabindex="-1"></a>                new_path <span class="op">=</span> path <span class="op">+</span> [child.name]</span>
<span id="cb320-71"><a href="#cb320-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(new_path) <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb320-72"><a href="#cb320-72" aria-hidden="true" tabindex="-1"></a>                    paths.append(new_path)</span>
<span id="cb320-73"><a href="#cb320-73" aria-hidden="true" tabindex="-1"></a>                stack.append((child, new_path))</span>
<span id="cb320-74"><a href="#cb320-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> paths</span>
<span id="cb320-75"><a href="#cb320-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-76"><a href="#cb320-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rsub(<span class="va">self</span>, DNA_strings):</span>
<span id="cb320-77"><a href="#cb320-77" aria-hidden="true" tabindex="-1"></a>        rsub_list <span class="op">=</span> []</span>
<span id="cb320-78"><a href="#cb320-78" aria-hidden="true" tabindex="-1"></a>        pre_order <span class="op">=</span> <span class="va">self</span>.traverse(order<span class="op">=</span><span class="st">'pre'</span>)</span>
<span id="cb320-79"><a href="#cb320-79" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="bu">len</span>(<span class="bu">next</span>(<span class="bu">iter</span>(DNA_strings.values())))</span>
<span id="cb320-80"><a href="#cb320-80" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb320-81"><a href="#cb320-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb320-82"><a href="#cb320-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> node <span class="kw">in</span> pre_order:</span>
<span id="cb320-83"><a href="#cb320-83" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> node.children:</span>
<span id="cb320-84"><a href="#cb320-84" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> path <span class="kw">in</span> <span class="va">self</span>.all_paths(node):</span>
<span id="cb320-85"><a href="#cb320-85" aria-hidden="true" tabindex="-1"></a>                        nucs <span class="op">=</span> [DNA_strings[label][pos] <span class="cf">for</span> label <span class="kw">in</span> path]</span>
<span id="cb320-86"><a href="#cb320-86" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> nucs[<span class="dv">0</span>] <span class="op">==</span> nucs[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> nucs[<span class="dv">1</span>] <span class="kw">and</span> <span class="bu">all</span>(x <span class="op">==</span> nucs[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> nucs[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb320-87"><a href="#cb320-87" aria-hidden="true" tabindex="-1"></a>                            rsub_list.append([path[<span class="dv">1</span>], path[<span class="op">-</span><span class="dv">1</span>], <span class="bu">str</span>(pos <span class="op">+</span> <span class="dv">1</span>), <span class="st">"-&gt;"</span>.join([nucs[<span class="dv">0</span>], nucs[<span class="dv">1</span>], nucs[<span class="op">-</span><span class="dv">1</span>]])])</span>
<span id="cb320-88"><a href="#cb320-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rsub_list</span>
<span id="cb320-89"><a href="#cb320-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-90"><a href="#cb320-90" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_fasta(lines):</span>
<span id="cb320-91"><a href="#cb320-91" aria-hidden="true" tabindex="-1"></a>    sequences <span class="op">=</span> {}</span>
<span id="cb320-92"><a href="#cb320-92" aria-hidden="true" tabindex="-1"></a>    current_seq <span class="op">=</span> []</span>
<span id="cb320-93"><a href="#cb320-93" aria-hidden="true" tabindex="-1"></a>    current_name <span class="op">=</span> <span class="st">""</span></span>
<span id="cb320-94"><a href="#cb320-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb320-95"><a href="#cb320-95" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb320-96"><a href="#cb320-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line.startswith(<span class="st">"&gt;"</span>):</span>
<span id="cb320-97"><a href="#cb320-97" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_name:</span>
<span id="cb320-98"><a href="#cb320-98" aria-hidden="true" tabindex="-1"></a>                sequences[current_name] <span class="op">=</span> <span class="st">""</span>.join(current_seq)</span>
<span id="cb320-99"><a href="#cb320-99" aria-hidden="true" tabindex="-1"></a>            current_name <span class="op">=</span> line[<span class="dv">1</span>:]</span>
<span id="cb320-100"><a href="#cb320-100" aria-hidden="true" tabindex="-1"></a>            current_seq <span class="op">=</span> []</span>
<span id="cb320-101"><a href="#cb320-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb320-102"><a href="#cb320-102" aria-hidden="true" tabindex="-1"></a>            current_seq.append(line)</span>
<span id="cb320-103"><a href="#cb320-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_name:</span>
<span id="cb320-104"><a href="#cb320-104" aria-hidden="true" tabindex="-1"></a>        sequences[current_name] <span class="op">=</span> <span class="st">""</span>.join(current_seq)</span>
<span id="cb320-105"><a href="#cb320-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sequences</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="classes-and-their-functions" class="level2" data-number="105.4">
<h2 data-number="105.4" class="anchored" data-anchor-id="classes-and-their-functions"><span class="header-section-number">105.4</span> Classes and Their Functions</h2>
<ol type="1">
<li><strong><code>Node</code> Class:</strong>
<ul>
<li>Represents a single node in the tree.</li>
<li>Each node has a unique number, a parent node, a list of children, and a name.</li>
</ul></li>
<li><strong><code>Newick</code> Class:</strong>
<ul>
<li><strong>Purpose:</strong> Parses and builds a tree from a Newick format string.</li>
<li><strong>Key Methods:</strong>
<ul>
<li><strong><code>construct_tree(data)</code>:</strong> Builds the tree structure from the Newick format string.</li>
<li><strong><code>traverse()</code>:</strong> Gets all nodes in a specific order (pre-order or post-order).</li>
<li><strong><code>max_depth(node)</code>:</strong> Finds the maximum depth of the tree from a given node.</li>
<li><strong><code>all_paths(node)</code>:</strong> Lists all paths starting from a node.</li>
<li><strong><code>rsub(DNA_strings)</code>:</strong> Finds specific patterns in the DNA sequences based on the tree.</li>
</ul></li>
</ul></li>
<li><strong><code>parse_fasta(lines)</code>:</strong></li>
</ol>
<ul>
<li>Converts FASTA formatted sequence data into a dictionary. Keys are sequence names, and values are the sequences.</li>
</ul>
</section>
<section id="how-it-works-1" class="level2" data-number="105.5">
<h2 data-number="105.5" class="anchored" data-anchor-id="how-it-works-1"><span class="header-section-number">105.5</span> How It Works</h2>
<ol type="1">
<li><strong>Parse the Tree and Sequences:</strong>
<ul>
<li><strong>Newick Tree:</strong> Convert the Newick format string into a tree structure.</li>
<li><strong>FASTA Sequences:</strong> Read and store DNA sequences.</li>
</ul></li>
<li><strong>Find Patterns:</strong>
<ul>
<li>Use the tree structure and DNA sequences to find and list patterns where:
<ul>
<li>The first and last characters of a pattern are the same.</li>
<li>The middle characters are all the same but different from the first/last character.</li>
</ul></li>
</ul></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/tomorrow-lab\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Proudly served by <a href="https://pages.github.com/">github pages</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This blog is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>