<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Taeyoon Kim">
<meta name="dcterms.date" content="2025-06-15">

<title>Nature Methods 데이터 시각화 컬럼 모음 – tomorrow-lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../.././static/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-4db64599af60036475c97bad6bd17674.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-fd64621b13fe97dabb7154a6833c9727.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-4db64599af60036475c97bad6bd17674.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-47a0f6fb4ac30c434f725a265b04c940.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-d92fb7b19d0bb3decc9536684275f0ea.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-47a0f6fb4ac30c434f725a265b04c940.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-31EWCYNR0V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-31EWCYNR0V', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="google-site-verification" content="z2S1Xqj9hfJiC31aNGCnOA1gYpL_8MoZpPI2avrWMvg">


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Nature Methods 데이터 시각화 컬럼 모음 – tomorrow-lab">
<meta property="og:description" content="The future of scientific discovery lies at the convergence of computational power and biological complexity. Our mission is to provide a platform where enthusiasts, researchers, and professionals can learn about and contribute to the rapidly evolving fields of bioinformatics, computational biology, and systems biology.">
<meta property="og:image" content="https://tomorrow-lab.github.io/posts/md/Tip_dataVisualization.png">
<meta property="og:site_name" content="tomorrow-lab">
<meta property="og:image:height" content="1200">
<meta property="og:image:width" content="1200">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././static/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tomorrow-lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://partrita.github.io"> <i class="bi bi-exclamation-triangle" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/partrita"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<div style="margin-top: 30px; margin-bottom: 20px;">
    <a href="https://substack.com/@tomorrowlab">
        <img alt="Static Badge" src="https://img.shields.io/badge/EHOTTL%40substack_-FF6719?link=https%3A%2F%2Fsubstack.com%2F%40tomorrowlab">
    </a>
    <a href="https://pixi.sh">
        <img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/prefix-dev/pixi/main/assets/badge/v0.json" alt="Pixi Badge">
    </a>
    <!-- <script async src="https://eocampaign1.com/form/2616a818-1ef8-11ef-b372-4587d096212f.js" data-form="2616a818-1ef8-11ef-b372-4587d096212f"></script> -->
</div>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#생물학-데이터-시각화는-필수-도구" id="toc-생물학-데이터-시각화는-필수-도구" class="nav-link active" data-scroll-target="#생물학-데이터-시각화는-필수-도구"><span class="header-section-number">1</span> 생물학 데이터 시각화는 필수 도구</a></li>
  <li><a href="#구성-및-레이아웃" id="toc-구성-및-레이아웃" class="nav-link" data-scroll-target="#구성-및-레이아웃"><span class="header-section-number">2</span> 구성 및 레이아웃</a>
  <ul class="collapse">
  <li><a href="#쉽고-명확한-정보-전달을-위한-디자인" id="toc-쉽고-명확한-정보-전달을-위한-디자인" class="nav-link" data-scroll-target="#쉽고-명확한-정보-전달을-위한-디자인"><span class="header-section-number">2.1</span> 쉽고 명확한 정보 전달을 위한 디자인</a></li>
  <li><a href="#레이아웃-정보-전달을-위한-시각적-정리의-기술" id="toc-레이아웃-정보-전달을-위한-시각적-정리의-기술" class="nav-link" data-scroll-target="#레이아웃-정보-전달을-위한-시각적-정리의-기술"><span class="header-section-number">2.2</span> 레이아웃: 정보 전달을 위한 시각적 정리의 기술</a></li>
  <li><a href="#게슈탈트-이론" id="toc-게슈탈트-이론" class="nav-link" data-scroll-target="#게슈탈트-이론"><span class="header-section-number">2.3</span> 게슈탈트 이론</a>
  <ul class="collapse">
  <li><a href="#유사성-원리" id="toc-유사성-원리" class="nav-link" data-scroll-target="#유사성-원리"><span class="header-section-number">2.3.1</span> 유사성 원리</a></li>
  <li><a href="#근접성-원리" id="toc-근접성-원리" class="nav-link" data-scroll-target="#근접성-원리"><span class="header-section-number">2.3.2</span> 근접성 원리</a></li>
  <li><a href="#연결성-및-폐쇄성-원리" id="toc-연결성-및-폐쇄성-원리" class="nav-link" data-scroll-target="#연결성-및-폐쇄성-원리"><span class="header-section-number">2.3.3</span> 연결성 및 폐쇄성 원리</a></li>
  <li><a href="#시각적-완성-원리" id="toc-시각적-완성-원리" class="nav-link" data-scroll-target="#시각적-완성-원리"><span class="header-section-number">2.3.4</span> 시각적 완성 원리</a></li>
  <li><a href="#연속성-원리" id="toc-연속성-원리" class="nav-link" data-scroll-target="#연속성-원리"><span class="header-section-number">2.3.5</span> 연속성 원리</a></li>
  </ul></li>
  <li><a href="#여백negative-space-디자인의-숨겨진-힘" id="toc-여백negative-space-디자인의-숨겨진-힘" class="nav-link" data-scroll-target="#여백negative-space-디자인의-숨겨진-힘"><span class="header-section-number">2.4</span> 여백(Negative Space): 디자인의 숨겨진 힘</a>
  <ul class="collapse">
  <li><a href="#여백의-중요성" id="toc-여백의-중요성" class="nav-link" data-scroll-target="#여백의-중요성"><span class="header-section-number">2.4.1</span> 여백의 중요성</a></li>
  <li><a href="#효과적인-여백-넣기" id="toc-효과적인-여백-넣기" class="nav-link" data-scroll-target="#효과적인-여백-넣기"><span class="header-section-number">2.4.2</span> 효과적인 여백 넣기</a></li>
  <li><a href="#여백으로-시선-집중시키기" id="toc-여백으로-시선-집중시키기" class="nav-link" data-scroll-target="#여백으로-시선-집중시키기"><span class="header-section-number">2.4.3</span> 여백으로 시선 집중시키기</a></li>
  </ul></li>
  <li><a href="#중요한-부분-강조하기" id="toc-중요한-부분-강조하기" class="nav-link" data-scroll-target="#중요한-부분-강조하기"><span class="header-section-number">2.5</span> 중요한 부분 강조하기</a>
  <ul class="collapse">
  <li><a href="#의도치-않은-두드러짐의-위험성" id="toc-의도치-않은-두드러짐의-위험성" class="nav-link" data-scroll-target="#의도치-않은-두드러짐의-위험성"><span class="header-section-number">2.5.1</span> 의도치 않은 두드러짐의 위험성</a></li>
  <li><a href="#효과적인-글쓰기-원칙을-그림-디자인에-적용하기" id="toc-효과적인-글쓰기-원칙을-그림-디자인에-적용하기" class="nav-link" data-scroll-target="#효과적인-글쓰기-원칙을-그림-디자인에-적용하기"><span class="header-section-number">2.5.2</span> 효과적인 글쓰기 원칙을 그림 디자인에 적용하기</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Nature Methods 데이터 시각화 컬럼 모음</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Tip</div>
    <div class="quarto-category">Productivity</div>
    <div class="quarto-category">Visualization</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Taeyoon Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 15, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">June 17, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Tip_dataVisualization.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="Tip_dataVisualization.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></a></p>
</figure>
</div>
<p>Bang Wong, Martin Krzywinski, Nils Gehlenborg, Cydney Nielsen, Noam Shoresh, Rikke Schmidt Kjaergaard, Erica Savig, Alberto Cairo이 Nature Methods에 데이터 시각화에 대한 컬럼을 35편 썼습니다. 이글은 이런 자료들을 더 쉽게 찾아볼 수 있도록 한곳에 모아 정리한 것으로 많은 분들이 데이터 시각화를 하는데 도움이 되길 바랍니다.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="생물학-데이터-시각화는-필수-도구" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 생물학 데이터 시각화는 필수 도구</h1>
<p>오늘날 생물학 연구에서는 방대한 양의 데이터가 쏟아져 나오고 있으며 데이터를 효과적으로 탐색하고 소통하기 위해 데이터 시각화가 필수적입니다. 데이터 시각화의 궁극적인 목표는 복잡한 데이터를 사람들이 쉽고 명확하게 이해하고 설명할 수 있도록 돕는 것입니다. 모든 생물학적 데이터에 시각화가 필요한 것은 아닙니다. 하지만 다음과 같은 경우 데이터 시각화는 강력한 이점을 갖습니다.</p>
<ul>
<li>패턴 탐색: 데이터의 규칙성을 아직 모를 때 시각화는 패턴을 찾아내는 데 효과적입니다.</li>
<li>알고리즘 보완: 자동화된 계산으로는 파악하기 어려운 데이터의 세부 사항(예: 유전체학의 구조적 변이)을 시각적으로 명확하게 이해할 수 있도록 돕습니다.</li>
</ul>
<p>결론적으로 잘 디자인된 데이터 시각화는 복잡한 인지적 평가를 직관적인 지각적 이해로 바꿔주기 때문에 데이터를 이해하는 데 강력한 도움이 됩니다. 특히 방대한 데이터가 생산되는 현대 생물학 연구에서 시각화는 매우 중요한 역할을 합니다.</p>
</section>
<section id="구성-및-레이아웃" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 구성 및 레이아웃</h1>
<section id="쉽고-명확한-정보-전달을-위한-디자인" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="쉽고-명확한-정보-전달을-위한-디자인"><span class="header-section-number">2.1</span> 쉽고 명확한 정보 전달을 위한 디자인</h2>
<p>디자인의 가장 중요한 원칙은 유용성과 기능입니다. 잘 만들어진 물건이 쓰기 쉬운 것처럼 여러분의 그래프와 포스터도 보고 이해하기 쉬워야 합니다. 훌륭한 디자인은 그 물건이 어떤 기능을 하는지 명확한 단서를 주는 것입니다. 예를 들어, 지하철 노선도는 도시의 한 곳에서 다른 곳으로 이동하는 방법을 찾는 데 매우 효율적인 도구입니다. 만약 기차 정보를 단순히 정류장과 연결 표로만 제공한다면, 두 지점 사이의 가장 빠른 길을 찾는 것은 훨씬 더 어려울 겁니다.</p>
<p>따라서 그래프를 디자인할 때는 정보를 표현하는 체계적인 방법을 사용 하는 것이 중요합니다. 다른 종류의 정보를 명확하게 구분해 독자들이 발표 내용을 쉽게 이해할 수 있게 해야합니다.</p>
<p>또한 탄탄한 디자인 아이디어 개념과 뛰어난 기술 실행 능력이 좋은 결과물을 만드는 데 필요합니다. 디자인은 탐색적인 과정이므로 머릿속의 아이디어를 현실로 만들고 필요에 따라 그래픽 요소를 다듬을 수 있는 능력이 필요합니다. 그러니 그래픽 소프트웨어를 능숙하게 다룰 수 있도록 시간을 투자하세요.</p>
</section>
<section id="레이아웃-정보-전달을-위한-시각적-정리의-기술" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="레이아웃-정보-전달을-위한-시각적-정리의-기술"><span class="header-section-number">2.2</span> 레이아웃: 정보 전달을 위한 시각적 정리의 기술</h2>
<p>레이아웃은 발표 자료를 명확하게 만들기 위해 글과 그림을 페이지에 보기 좋게 배치하는 작업입니다. 그래픽 디자인에서는 모든 시각적인 정보를 전달하는 데 레이아웃이 가장 기본이 됩니다. 내용을 잘 정리하면 복잡한 정보도 독자들이 쉽게 따라갈 수 있지만 자료가 뒤죽박죽이면 독자들을 헷갈리게 합니다.</p>
<p>많은 예술가들은 ’황금 비율’이라는 특별한 수학적 관계를 사용합니다. 황금 비율은 어떤 선을 두 부분으로 나눴을 때, 전체 길이와 긴 부분의 비율이 긴 부분과 짧은 부분의 비율과 같아지는 것을 말합니다(대략 13:8 비율). 또한 황금 비율과 관련이 있는 ’피보나치 수열’은 그래픽 디자인에 많은 영향을 줍니다.(예 1, 2, 3, 5, 8, 13 등). 피보나치 숫자는 사용해 글꼴 크기나 책 페이지 레이아웃을 결정에 자주 사용되기 때문이죠.</p>
<p>황금 비율을 실제로 활용하는 방법은 우리가 만드는 슬라이드와 포스터에 조화로운 비율을 적용하는 것입니다. 이는 단순히 예술적인 이유뿐만이 아닙니다. 페이지에 요소를 어디에 배치하느냐에 따라 의미를 전달할 수 있기 때문입니다. 황금 비율을 간단하게 적용한 것이 바로 ‘삼등분할 법칙’입니다. 이 법칙은 페이지를 가로세로로 3등분 하여 총 9개의 구획을 만들고, 이 선을 따라 또는 선이 교차하는 지점(이른바 ’파워 포인트’)에 중요한 요소를 배치하면 시각적으로 더 눈에 띄게 됩니다. 시선 추적 연구에 따르면 사람들은 이미지를 볼 때 이러한 선으로 표시된 영역에 시선이 더 오래 머무는 경향이 있다고 합니다.</p>
<p>’그리드’를 사용하여 레이아웃을 잡으면 내용의 크기나 배치를 대충 짐작하지 않아도 되므로 디자인 과정을 훨씬 쉽게 만들 수 있습니다. 작업을 시작하기 전에 파워포인트나 어도비 일러스트레이터 같은 프로그램에서 미리 안내선(가이드)을 전략적으로 배치해보세요. 그리드는 내용을 고정시켜 디자인 전체에 안정감을 주고, 슬라이드 간의 일관성을 만들어 독자들이 다음에 나올 내용이 어디쯤에 나타날지 예상할 수 있도록 돕습니다.</p>
<p>레이아웃은 단순히 그리드 선을 그리는 것이 아니라 독자의 시선이 어떤 경로로 움직이기를 원하는지 계획하는 과정입니다. 이는 내용의 중요도를 파악하여 무엇을 먼저 읽고 무엇을 나중에 읽을지 명확하게 보여주는 것입니다.</p>
<p>우리는 모든 자료에 똑같은 시각적 내용으로 가득 찬 슬라이드와 포스터를 종종 보게 됩니다. 이런 경우 어디서부터 읽어야 할지 알기 어렵습니다. 전설적인 그래픽 디자이너 폴 랜드는 “대비가 없으면 죽은 것이나 마찬가지다”라고 말했습니다. 이처럼 레이아웃은 그래픽 디자인의 기본이자 정보 이해에 큰 영향을 줍니다.</p>
</section>
<section id="게슈탈트-이론" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="게슈탈트-이론"><span class="header-section-number">2.3</span> 게슈탈트 이론</h2>
<p>게슈탈트 이론은 사람들이 시각 정보를 어떻게 인식하고 정리하는지를 설명하기 위해 1920년대에 제안된 심리학 이론입니다. 독일어로 ‘형태’ 또는 ’형식’을 뜻하는 ’게슈탈트’는 우리가 개별적인 시각적 요소들을 모아 하나의 ’통합된 전체’로 인식하는 방식을 설명합니다.</p>
<p>게슈탈트는 부분과 전체의 상호작용을 강조합니다. 게슈탈트 심리학의 창시자 중 한 명인 쿠르트 코프카는 “전체는 부분의 합과는 다르다”고 말했습니다. 단순히 각 부분의 합을 넘어서는 새로운 의미가 창출된다는 점입니다. 이 이론의 핵심 개념은 그룹화입니다. 우리는 비슷하게 보이거나, 가까이 배치되거나, 선으로 연결되거나, 공통된 공간 안에 둘러싸인 객체들을 함께 속한 것으로 인식하는 경향이 있습니다. 이는 정보에 대한 맥락을 구축하는 강력한 방법입니다.</p>
<section id="유사성-원리" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="유사성-원리"><span class="header-section-number">2.3.1</span> 유사성 원리</h3>
<p>유사성 원리는 우리가 시각적으로 비슷한 요소들을 한 그룹으로 묶어 인식하는 경향을 설명합니다. 즉, 색상, 크기, 모양 등이 비슷한 것들은 서로 관련이 있다고 생각하는 것이죠. 이 원리는 데이터 시각화에서 범주를 구분할 때 흔히 사용됩니다. 또한, 글꼴, 글꼴 크기, 방향, 여백과 같은 그래픽 처리 방식을 반복적으로 사용하여 문서 내의 요소들이 서로 더 관련 있어 보이도록 디자인할 수 있습니다.</p>
</section>
<section id="근접성-원리" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="근접성-원리"><span class="header-section-number">2.3.2</span> 근접성 원리</h3>
<p>근접성 원리는 서로 가까이 배치된 객체들을 한 그룹으로 인식하는 경향을 말합니다. 이 원리는 그림 패널을 배열할 때 유용하게 적용됩니다. 예를 들어, 여러 개의 패널이 균일하게 떨어져 있을 때는 무엇을 기준으로 분석해야 할지 모호할 수 있습니다. 하지만 비교해야 할 패널들을 가깝게 배치하여 그룹화하면, 독자는 자연스럽게 그 관계를 파악하게 됩니다. 반대로, 패널을 순서대로 읽도록 유도하고 싶다면 한 줄로 배열하는 것이 효과적입니다.</p>
</section>
<section id="연결성-및-폐쇄성-원리" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="연결성-및-폐쇄성-원리"><span class="header-section-number">2.3.3</span> 연결성 및 폐쇄성 원리</h3>
<p>연결성 원리는 선이나 다른 시각적 연결 고리로 이어진 객체들을 통합된 그룹으로 인식하는 경향입니다. 유사성이나 근접성으로 묶인 객체들이 느슨한 연합으로 보이는 반면, 선으로 연결하면 연결성 원리에 의해 객체들을 훨씬 더 강하게 연관되게 보입니다.</p>
<p>폐쇄성 원리는 공통된 영역 안에 요소들이 둘러싸여 있을 때 하나의 그룹으로 인식하는 경향을 말합니다. 이 원리는 유사성, 근접성, 심지어 연결성보다도 강력하게 객체들을 통합된 전체로 묶어줍니다.</p>
</section>
<section id="시각적-완성-원리" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="시각적-완성-원리"><span class="header-section-number">2.3.4</span> 시각적 완성 원리</h3>
<p>시각적 완성(Visual Completion), 또는 시각적 보간(interpolation)은 실제로 존재하지 않는 윤곽선을 보게 되는 흥미로운 착시 현상을 만듭니다. 우리는 가능한 보이는 것에서 패턴을 찾으려는 경향이 있습니다. 따라서 우리는 프레젠테이션을 어지럽히는 불필요한 선, 상자, 글머리 기호 및 기타 그래픽 요소를 생략하여 깔끔하고 효과적인 디자인을 해야합니다.</p>
</section>
<section id="연속성-원리" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="연속성-원리"><span class="header-section-number">2.3.5</span> 연속성 원리</h3>
<p>우리 눈은 작은 정렬 불일치에도 매우 민감합니다. 이것을 연속성(Continuity) 원리라고 합니다. 따라서 시각적 요소를 가이드에 맞춰 정렬하는 것이 보는 사람이 패턴을 식별하는 데 도움이 됩니다. 그래서 정렬 가이드를 사용하여 구성된 그림은 깔끔하고 전문적으로 보이게 됩니다.</p>
</section>
</section>
<section id="여백negative-space-디자인의-숨겨진-힘" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="여백negative-space-디자인의-숨겨진-힘"><span class="header-section-number">2.4</span> 여백(Negative Space): 디자인의 숨겨진 힘</h2>
<p>여백(Negative Space)은 페이지의 여백뿐만 아니라 텍스트 블록, 이미지 사이의 간격등을 의미 합니다. 여백은 제목, 글, 그림만큼이나 디자인에 중요한 부분으로 디자인 요소들에게 숨 쉴 공간을 줄 뿐만 아니라 시각적 매력과 효과를 극적으로 향상시킬 수 있습니다.</p>
<section id="여백의-중요성" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="여백의-중요성"><span class="header-section-number">2.4.1</span> 여백의 중요성</h3>
<p>과학자의 발표 자료는 대개 내용으로 빽빽하게 채워져 있습니다. 일부 사람은 여백이 불필요하다고 여기거나 심지어 페이지가 가득 채워지지 않는다고 불평하기도 합니다. 그러나 내용이 빽빽한 없는 슬라이드와 포스터는 여백이 불규칙하기 때문에 이해하기 어렵습니다.</p>
</section>
<section id="효과적인-여백-넣기" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="효과적인-여백-넣기"><span class="header-section-number">2.4.2</span> 효과적인 여백 넣기</h3>
<p>이미지와 텍스트를 글자 그대로 또는 시각적으로 추상화된 ‘상자’ 안에 넣어서 레이아웃을 만드세요. 그러면 양의 공간과 음의 공간의 분포가 명확해집니다. 일반적인 팁을 주자면 섹션을 구분할 때 더 넓은 간격을 사용하고 섹션 내의 항목을 분리 할때는 더 얇은 간격을 사용하는 것입니다. 그리고 텍스트의 경우 글자 사이의 간격, 줄의 길이, 줄 사이의 간격을 조절해 추상화된 상자에 맞춥니다. 이런 방식의 여백은 독자에게 콘텐츠의 계층과 구성을 전달할 수 있습니다.</p>
</section>
<section id="여백으로-시선-집중시키기" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="여백으로-시선-집중시키기"><span class="header-section-number">2.4.3</span> 여백으로 시선 집중시키기</h3>
<p>여백은 독자의 주의를 끄는 가장 효과적인 방법 중 하나입니다. 강조하고 싶은 콘텐츠를 상대적으로 더 많은 여백으로 둘러싸 보세요. 페이지의 해당 부분으로 시선을 이끌 것입니다.</p>
</section>
</section>
<section id="중요한-부분-강조하기" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="중요한-부분-강조하기"><span class="header-section-number">2.5</span> 중요한 부분 강조하기</h2>
<p>두드러짐(Salience)은 객체를 주변 환경과 차별화시키는 속성입니다. 특히 슬라이드 프레젠테이션과 같은 시각 자료에서는 두드러짐과 정보의 관련성(relevance)이 일치하는지 확인하는 것이 필수적입니다. 청중이 내용을 동시에 듣고 읽는 상황이므로 정보 전달의 효율성이 무엇보다 중요하기 때문이죠.</p>
<p>예를 들어, 표의 특정 행이나 열에 색깔을 입히면 선택된 자료에 시선이 집중될 것입니다. 표 형식의 정보는 일반적으로 균일하게 보이기 때문에, 가장 중요한 것이 무엇인지 명확히 하는 것이 도움이 됩니다. 그래프에도 데이터의 특정 부분을 강조 구분을 하면 청중이 발표 내용과 시각 자료를 더 잘 이해하도록 돕는 방법이 될 수 있습니다.</p>
<section id="의도치-않은-두드러짐의-위험성" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="의도치-않은-두드러짐의-위험성"><span class="header-section-number">2.5.1</span> 의도치 않은 두드러짐의 위험성</h3>
<p>반대로 부주의하게 두드러짐을 남용하면 오히려 독자에게 잘못된 메세지를 줄 수 있습니다. 예를 들어 움직이는 이미지(예: 회전하는 3차원 단백질 구조)을 넣을 때는 주의해야 합니다. 왜냐하면 움직이는 이미지가 독자의 주의를 전부 집중시켜 다른 콘텐츠를 보지 못하게 합니다. 따라서 파워포인트 애니메이션은 신중하게 사용해야 하며, 움직이는 요소는 반드시 슬라이드의 주요 메시지를 뒷받침하는 콘텐츠여야 합니다.</p>
<p>동일한 콘텐츠도 어떻게 제시되느냐에 따라 이해도에 극적인 영향을 줍니다. 항상 화면에서 잠시 물러서서 무엇이 가장 두드러지는지 파악하려고 하세요. 그리고 가장 시각적으로 두드러지는 정보는 당신의 핵심 메시지여야 합니다.</p>
</section>
<section id="효과적인-글쓰기-원칙을-그림-디자인에-적용하기" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="효과적인-글쓰기-원칙을-그림-디자인에-적용하기"><span class="header-section-number">2.5.2</span> 효과적인 글쓰기 원칙을 그림 디자인에 적용하기</h3>
<p>효과적인 글쓰기 원칙을 그림 디자인에 적용하면 어려움을 극복하고 체계적인 방식으로 시각 자료를 만들 수 있습니다. 마치 글의 단어 하나하나를 다듬듯이, 그림의 각 부분도 평가하고 최적화되야 합니다.</p>
<p>핵심 원칙:</p>
<ul>
<li><p>명확성과 간결성: 복잡하고 이해하기 어려운 문장처럼 혼란스럽고 과도하게 꾸며진 그림(‘차트 잡동사니’)은 피해야 합니다. 번쩍이는 질감, 그라데이션, 불필요한 형태의 증식은 데이터를 해석하기 어렵게 만들고, 특정 부분을 강조하는 것을 방해하며 빈약한 데이터를 결코 구제할 수 없습니다.</p></li>
<li><p>평행 구조와 시각적 강조: 관련 아이디어를 시각적으로 강화하려면 ’평행 구조’를 사용하세요. 즉, 유사한 아이디어를 비슷한 시각적 형태로 표현하여 정보 간의 관계를 명확히 보여주세요. 중첩, 범주 계층, 중요성을 직관적으로 나타내는 모양과 색상을 선택하는 것이 중요합니다.</p></li>
</ul>
<hr>
<p><em>내용을 계속 추가하는 중입니다.</em></p>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>https://blogs.nature.com/methagora/2013/07/data-visualization-points-of-view.html<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomorrow-lab\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      if (authorPrefersDark) {
          [baseTheme, altTheme] = [altTheme, baseTheme];
      }
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "partrita/giscus";
    script.dataset.repoId = "R_kgDONvsa2g";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDONvsa2s4CmWd7";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Proudly served by <a href="https://pages.github.com/">github pages</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This blog is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>